<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>linux 通过系统函数设置系统时间</title>
    <url>/2019/11/03/linux-%E9%80%9A%E8%BF%87%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h5 id="一、描述："><a href="#一、描述：" class="headerlink" title="一、描述："></a>一、描述：</h5><p>通过settimeofday()函数来设置系统时间，这个函数设置的精度可以精确到微秒。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">int settimeofday(const struct timeval *tv , const struct timezone *tz);</span><br><span class="line"></span><br><span class="line">struct timeval &#123;</span><br><span class="line">    time_t      tv_sec;     /* seconds */</span><br><span class="line">    suseconds_t tv_usec;    /* microseconds */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct timezone &#123;</span><br><span class="line">    int tz_minuteswest;     /* minutes west of Greenwich */</span><br><span class="line">    int tz_dsttime;         /* type of DST correction */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tz参数为时区，时区结构中tz_dsttime在linux中不支持，应该置为0，通常将参数tz设置为NULL，表示使用当前系统的时区。该函数是glib中的，但在mingw中没有实现。</p>
</blockquote>
<a id="more"></a>

<h5 id="二、代码演示："><a href="#二、代码演示：" class="headerlink" title="二、代码演示："></a>二、代码演示：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/time.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int SetSystemTime(char *dt)</span><br><span class="line">&#123;</span><br><span class="line">    struct tm rtc_time;</span><br><span class="line">    struct tm _tm;</span><br><span class="line">    struct timeval tv;</span><br><span class="line">    time_t timep;</span><br><span class="line">    sscanf(dt, &quot;%d-%d-%d %d:%d:%d&quot;, &amp;rtc_time.tm_year,</span><br><span class="line">		&amp;rtc_time.tm_mon, &amp;rtc_time.tm_mday,&amp;rtc_time.tm_hour,</span><br><span class="line">        &amp;rtc_time.tm_min, &amp;rtc_time.tm_sec);</span><br><span class="line">    _tm.tm_sec = rtc_time.tm_sec;</span><br><span class="line">    _tm.tm_min = rtc_time.tm_min;</span><br><span class="line">    _tm.tm_hour = rtc_time.tm_hour;</span><br><span class="line">    _tm.tm_mday = rtc_time.tm_mday;</span><br><span class="line">    _tm.tm_mon = rtc_time.tm_mon - 1;</span><br><span class="line">    _tm.tm_year = rtc_time.tm_year - 1900;</span><br><span class="line"> </span><br><span class="line">    timep = mktime(&amp;_tm);</span><br><span class="line">    tv.tv_sec = timep;</span><br><span class="line">    tv.tv_usec = 0;</span><br><span class="line">    // if(settimeofday (&amp;tv, (struct timezone *) 0) &lt; 0)</span><br><span class="line">	if(settimeofday (&amp;tv, NULL) &lt; 0)	</span><br><span class="line">    &#123;</span><br><span class="line">		printf(&quot;Set system datatime error!\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	printf(&quot;现在的时间是:&quot;);</span><br><span class="line">	fflush(stdout);</span><br><span class="line">	system(&quot;date&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  SetSystemTime(&quot;2019-11-03 16:30:30&quot;);//2019-11-01 21:19:05  </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="三、效果如下："><a href="#三、效果如下：" class="headerlink" title="三、效果如下："></a>三、效果如下：</h5><p><img src="/2019/11/03/linux-%E9%80%9A%E8%BF%87%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/1.jpg" alt="1"><br>注意：</p>
<ol>
<li>调用settimeofday函数时必须要在root权限下执行。</li>
<li>设置时间之前最好把虚拟机网络断开。</li>
</ol>
]]></content>
      <categories>
        <category>系统函数&amp;库函数</category>
      </categories>
      <tags>
        <tag>系统时间</tag>
      </tags>
  </entry>
  <entry>
    <title>cURL-01_基本概念与了解</title>
    <url>/2019/11/03/cURL-01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<h5 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h5><p>cURL（Client URL Library Functions）is a command line tool for transfering data with URL syntax（使用 URL 语法传输数据的命令行工具），即客户端向服务器请求资源的工具。</p>
<p><img src="/2019/11/03/cURL-01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BA%86%E8%A7%A3/1.png" alt="1"></p>
<a id="more"></a>

<p>curl库是C语言封装的一个强大的库，使用curl比封装socket更加方便。</p>
<p>cURL 最初的设计初衷是使用不同的协议（比如 FTP、HTTP、SCP 等）在端点之间移动文件。它最初是一个命令行实用工具，但现在也是一个绑定了 30 多种语言的库。因此，现在不仅可以通过 shell 使用 cURL，您还可以构建合并了这个重要功能的应用程序。libcurl 库也是可以移植的，支持 Linux®、IBM®AIX®操作系统、BSD、Solaris 以及许多其他 UNIX®变体。</p>
<p>cURL是一个命令行工具和库，实现了各种客户端协议。它支持 12 种以上的协议，包括 FTP、HTTP、Telnet 以及其他安全变体。许多平台上都能找到 cURL，包括 Linux、AIX、BSD 和 Solaris，它支持 30 多种语言。</p>
<p>PycURL是 libcurl API 之上的一个薄层，PycURL 速度非常快。使用 PycURL，您可以使用 libcurl 库开发 Python 应用程序。</p>
<p>关于cURL,<a href="https://curl.haxx.se/" target="_blank" rel="noopener">这里</a>有更详细的介绍。</p>
<h5 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h5><p>1.网页资源（例如编写网页爬虫）</p>
<p>2.WebService 数据接口资源（比如动态获取接口数据，比如天气、号码归属地等）</p>
<p>3.FTP 服务器里的文件资源（下载 FTP 服务器里面的文件）</p>
<p>4.其他资源（所有网络上的资源都可以使用 cURL 访问和下载到）</p>
<h5 id="三、延伸"><a href="#三、延伸" class="headerlink" title="三、延伸"></a>三、延伸</h5><p>开发 HTTP 和 FTP 之类依赖于应用层协议的应用程序并不复杂，但也不简单。进一步讲，这不是应用程序的重点，因为大部分情况下，协议之上的内容才是真正重要的内容。因此，libcurl 引起了许多人的兴趣，因为它的重点是应用程序而不是开发的各个方面。注意，很少有应用程序开发自己的 TCP/IP 堆栈，所以老话重提：尽可能重用以最小化开发安排并提高应用程序的可靠性。</p>
<h6 id="关于Web-协议"><a href="#关于Web-协议" class="headerlink" title="关于Web 协议"></a>关于Web 协议</h6><p>如今构建应用程序已与过去大不相同。现在的应用程序需要能够通过网络或 Internet 进行通讯（提供人类可用的网络 API 或接口），还要能支持用户脚本化以提高灵活性。现代应用程序通常使用 HTTP 公开 Web 接口，并通过 Simple Mail Transport Protocol (SMTP) 提供警告通知。这些协议允许您将 Web 浏览器指向设备以获得配置或状态信息，并从设备或常用的电子邮件客户端接收标准电子邮件（分别通过 HTTP 和 SMTP）。</p>
<p>这些 Web 服务通常构建在网络堆栈的套接字层上（见图 1）。套接字层实现一个最先出现在 Berkeley Software Distribution (BSD) 操作系统上的 API，并提取底层传输和网络层协议的详细信息。</p>
<p>图 1. 网络堆栈和 libcurl</p>
<p><img src="/2019/11/03/cURL-01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BA%86%E8%A7%A3/2.gif" alt="2"></p>
<p>Web 服务发生在客户端和服务器之间的协议对话中。在 HTTP 上下文中，服务器是终端设备，客户端是位于端点上的浏览器。对于 SMTP，服务器是邮件网关或端点用户，客户端是终端设备。在某些情况下，协议对话发生在两个步骤（请求和响应）中，但另一些情况下，需要协商和通讯的通信量更多。这种协商可能增加了大量复杂性，这可以通过 API 进行抽象，比如 libcurl。</p>
]]></content>
      <categories>
        <category>cURL</category>
      </categories>
      <tags>
        <tag>cURL</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机VMware与Windows主机共享文件介绍</title>
    <url>/2019/11/03/%E8%99%9A%E6%8B%9F%E6%9C%BAVMware%E4%B8%8EWindows%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h5 id="一、设置共享文件夹功能"><a href="#一、设置共享文件夹功能" class="headerlink" title="一、设置共享文件夹功能"></a>一、设置共享文件夹功能</h5><p>虚拟机VMware提供了在宿主机与虚拟机系统之间交换文件的共享文件夹（Shared Folder）功能。不管虚拟机操作系统是Linux还是Windows都可用。你可以通过设置（ Settings）&gt;共享文件夹（Shared Folder）来设置。但是此功能选项必须要安装虚拟机工具（VMware Tools），否则如下所示，否则该功能选项不可用。</p>
<p><img src="/2019/11/03/%E8%99%9A%E6%8B%9F%E6%9C%BAVMware%E4%B8%8EWindows%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/1.jpg" alt="1"></p>
<a id="more"></a>
<h5 id="二、安装虚拟机工具步骤如下所示："><a href="#二、安装虚拟机工具步骤如下所示：" class="headerlink" title="二、安装虚拟机工具步骤如下所示："></a>二、安装虚拟机工具步骤如下所示：</h5><h6 id="1-在对应虚拟机的设置选项（Settings-下，为虚拟机光驱指定虚拟机系统的镜像文件。"><a href="#1-在对应虚拟机的设置选项（Settings-下，为虚拟机光驱指定虚拟机系统的镜像文件。" class="headerlink" title="1. 在对应虚拟机的设置选项（Settings)下，为虚拟机光驱指定虚拟机系统的镜像文件。"></a>1. 在对应虚拟机的设置选项（Settings)下，为虚拟机光驱指定虚拟机系统的镜像文件。</h6><p>注意：在执行下面步骤前，必须确保虚拟机的电源开启、虚拟机系统正在运行。</p>
<p><img src="/2019/11/03/%E8%99%9A%E6%8B%9F%E6%9C%BAVMware%E4%B8%8EWindows%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/2.png" alt="2"></p>
<h6 id="2-在VM下选择”Install-VMware-Tools”"><a href="#2-在VM下选择”Install-VMware-Tools”" class="headerlink" title="2. 在VM下选择”Install VMware Tools”."></a>2. 在VM下选择”Install VMware Tools”.</h6><p><img src="/2019/11/03/%E8%99%9A%E6%8B%9F%E6%9C%BAVMware%E4%B8%8EWindows%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/3.png" alt="3"></p>
<ol start="3">
<li>然后安装虚拟机组件工具，详细步骤如下所示：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@DB-Server ~]# cd /mnt</span><br><span class="line">[root@DB-Server mnt]# mkdir cdrom</span><br><span class="line">[root@DB-Server mnt]# mount /dev/cdrom  /mnt/cdrom</span><br><span class="line">[root@DB-Server mnt]# cd /mnt/cdrom</span><br><span class="line">[root@DB-Server cdrom]# cp  VMwareTools-8.8.2-590212.tar.gz /tmp</span><br><span class="line">[root@DB-Server cdrom]#tar xz</span><br><span class="line">[root@DB-Server tmp]# ls</span><br><span class="line">gconfd-root     orbit-root           VMwareTools-8.8.2-590212.tar.gz</span><br><span class="line">keyring-qO15Cg  ssh-EWUeHQ4064       vmware-tools-distrib</span><br><span class="line">mapping-root    virtual-root.9mZzaq</span><br><span class="line">[root@DB-Server tmp]# cd vmware-tools-distrib/</span><br><span class="line">[root@DB-Server vmware-tools-distrib]# ls</span><br><span class="line">bin  doc  etc  FILES  INSTALL  installer  lib  vmware-install.pl</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[root@DB-Server vmware-tools-distrib]# ./vmware-install.pl </span><br><span class="line">A previous installation of VMware Tools has been detected.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">之后直接安装即可。</span><br></pre></td></tr></table></figure>
安装完成后重启虚拟机</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title>Source Insight 使用技巧整理</title>
    <url>/2019/11/03/Source-Insight-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h4 id="通用设置"><a href="#通用设置" class="headerlink" title="通用设置"></a>通用设置</h4><p>Options - File Type Options:</p>
<ul>
<li>显示行号：勾选Show line mumbers</li>
<li>选中自动高亮：勾选Hightlight references to selected sysmbol</li>
<li>转换tab成空格：勾选Expand tabs to spaces，设置Tab width：4<br><img src="/2019/11/03/Source-Insight-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/1.png" alt="1"></li>
</ul>
<a id="more"></a>
<p><strong>高亮选中符号：</strong><br>F8</p>
<p><strong>代码折叠：</strong><br>View –&gt; Show Outlining </p>
<p><strong>代码默认字体大小：</strong><br>Ctrl + 滑动鼠标滑轮，可以增大缩小代码字体大小</p>
<blockquote>
<p>对所有代码文件字体都生效，步骤如：<br>Preferences –&gt; File Type Options -&gt; Screen Font<br>Preferences –&gt; Languages –&gt; File Types –&gt; Screen Font</p>
</blockquote>
<p><strong>只为主界面导入配色方案（不是全局，全局在Options-&gt;Load Configuration..）</strong></p>
<ol>
<li>Options –&gt; Style properties -&gt; Load</li>
<li>背景色修改： Options –&gt; Preferences –&gt;  Colors –&gt; Window Background </li>
<li>字体修改：在需要修改的词处点击，选择style Properties 会自动对应到需要修改的词语类型，然后直接修改颜色即可。</li>
</ol>
<p><strong>替换：</strong><br>Ctrl + h<br><strong>查找：</strong><br>Ctrl + f<br><strong>全局查找：</strong><br>Ctrl + /<br><strong>向上搜索</strong><br>Ctrl + F3<br><strong>向下搜索</strong><br>Ctrl + F4<br><strong>跳转到行：</strong><br>F5<br><strong>跳转到定义：</strong><br>Ctrl + 鼠标左键</p>
<h4 id="显示中文乱码"><a href="#显示中文乱码" class="headerlink" title="显示中文乱码"></a>显示中文乱码</h4><p>File - Reload As Encoding - GB2312</p>
<p><img src="/2019/11/03/Source-Insight-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/2.png" alt="2"></p>
<h4 id="添加注释快捷键"><a href="#添加注释快捷键" class="headerlink" title="添加注释快捷键"></a>添加注释快捷键</h4><blockquote>
<p>添加一些配置文件宏，比如：注释掉代码：单行注释、多行注释，将选中内容注释掉；在一行代码的前、后添加注释性文字等。</p>
</blockquote>
<h5 id="操作步骤："><a href="#操作步骤：" class="headerlink" title="操作步骤："></a>操作步骤：</h5><p>打开Projcet-&gt;Open project，选择base，可以看到utils.em文件，将下列宏添加到该文件中，并在其他工程里加入该文件，在上面介绍的快捷键添加方式里找到该宏并自定义快捷键。</p>
<h5 id="单行、多行注释："><a href="#单行、多行注释：" class="headerlink" title="单行、多行注释："></a>单行、多行注释：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">macro MultiLineComment()  </span><br><span class="line">&#123;  </span><br><span class="line">    hwnd = GetCurrentWnd()  </span><br><span class="line">    selection = GetWndSel(hwnd)  </span><br><span class="line">    LnFirst = GetWndSelLnFirst(hwnd)      //取首行行号  </span><br><span class="line">    LnLast = GetWndSelLnLast(hwnd)      //取末行行号  </span><br><span class="line">    hbuf = GetCurrentBuf()  </span><br><span class="line">   </span><br><span class="line">    if(GetBufLine(hbuf, 0) == &quot;//magic-number:tph85666031&quot;)&#123;  </span><br><span class="line">        stop  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    Ln = Lnfirst  </span><br><span class="line">    buf = GetBufLine(hbuf, Ln)  </span><br><span class="line">    len = strlen(buf)  </span><br><span class="line">   </span><br><span class="line">    while(Ln &lt;= Lnlast) &#123;  </span><br><span class="line">        buf = GetBufLine(hbuf, Ln)  //取Ln对应的行  </span><br><span class="line">        if(buf == &quot;&quot;)&#123;                    //跳过空行  </span><br><span class="line">            Ln = Ln + 1  </span><br><span class="line">            continue  </span><br><span class="line">        &#125;  </span><br><span class="line">   </span><br><span class="line">        if(StrMid(buf, 0, 1) == &quot;/&quot;) &#123;       //需要取消注释,防止只有单字符的行  </span><br><span class="line">            if(StrMid(buf, 1, 2) == &quot;/&quot;)&#123;  </span><br><span class="line">                PutBufLine(hbuf, Ln, StrMid(buf, 2, Strlen(buf)))  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">   </span><br><span class="line">        if(StrMid(buf,0,1) != &quot;/&quot;)&#123;          //需要添加注释  </span><br><span class="line">            PutBufLine(hbuf, Ln, Cat(&quot;//&quot;, buf))  </span><br><span class="line">        &#125;  </span><br><span class="line">        Ln = Ln + 1  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    SetWndSel(hwnd, selection)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上面的代码保存到utils.em文件，打开source insight，将该文件添加到工程中，然后在Options-&gt;Key Assignments中你就可以看到这个宏了，宏的名字是MultiLineComments，然后我们为它分配快捷键“Ctrl + /”，然后就可以了。</p>
<p>添加“#ifdef 0”和“#endif”的宏代码，定义快捷键为Ctrl+/+Shift：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">macro AddMacroComment()  </span><br><span class="line">&#123;  </span><br><span class="line">    hwnd=GetCurrentWnd()  </span><br><span class="line">    sel=GetWndSel(hwnd)  </span><br><span class="line">    lnFirst=GetWndSelLnFirst(hwnd)  </span><br><span class="line">    lnLast=GetWndSelLnLast(hwnd)  </span><br><span class="line">    hbuf=GetCurrentBuf()  </span><br><span class="line">   </span><br><span class="line">    if(LnFirst == 0) &#123;  </span><br><span class="line">            szIfStart = &quot;&quot;  </span><br><span class="line">    &#125;else&#123;  </span><br><span class="line">            szIfStart = GetBufLine(hbuf, LnFirst-1)  </span><br><span class="line">    &#125;  </span><br><span class="line">    szIfEnd = GetBufLine(hbuf, lnLast+1)  </span><br><span class="line">    if(szIfStart == &quot;#if 0&quot; &amp;&amp; szIfEnd == &quot;#endif&quot;) &#123;  </span><br><span class="line">            DelBufLine(hbuf, lnLast+1)  </span><br><span class="line">            DelBufLine(hbuf, lnFirst-1)  </span><br><span class="line">            sel.lnFirst = sel.lnFirst – 1  </span><br><span class="line">            sel.lnLast = sel.lnLast – 1  </span><br><span class="line">    &#125;else&#123;  </span><br><span class="line">            InsBufLine(hbuf, lnFirst, &quot;#if 0&quot;)  </span><br><span class="line">            InsBufLine(hbuf, lnLast+2, &quot;#endif&quot;)  </span><br><span class="line">            sel.lnFirst = sel.lnFirst + 1  </span><br><span class="line">            sel.lnLast = sel.lnLast + 1  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    SetWndSel( hwnd, sel )  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>操作和上面类似</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Source Insight</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu配置NFS及其挂载设备</title>
    <url>/2019/11/02/Ubuntu%E9%85%8D%E7%BD%AENFS%E5%8F%8A%E5%85%B6%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87/</url>
    <content><![CDATA[<h5 id="在Ubuntu系统中安装NFS"><a href="#在Ubuntu系统中安装NFS" class="headerlink" title="在Ubuntu系统中安装NFS"></a>在Ubuntu系统中安装NFS</h5><p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nfs-kernel-server</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同时会有两个软件包nfs-common和portmap被安装上，如果没有安装成功多安装几次。</p>
</blockquote>
<a id="more"></a>

<h5 id="在Ubuntu系统中的-mnt下建立共享项目nfs-shared"><a href="#在Ubuntu系统中的-mnt下建立共享项目nfs-shared" class="headerlink" title="在Ubuntu系统中的/mnt下建立共享项目nfs_shared"></a>在Ubuntu系统中的/mnt下建立共享项目nfs_shared</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mkdir nfs_shared </span><br><span class="line"># chmod 777 -R nfs_shared/</span><br></pre></td></tr></table></figure>
<p>保证使用者都能够读、写、执行。如图</p>
<p><img src="/2019/11/02/Ubuntu%E9%85%8D%E7%BD%AENFS%E5%8F%8A%E5%85%B6%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87/1.png" alt="1"></p>
<h5 id="在Ubuntu系统中修改NFS配置文件"><a href="#在Ubuntu系统中修改NFS配置文件" class="headerlink" title="在Ubuntu系统中修改NFS配置文件"></a>在Ubuntu系统中修改NFS配置文件</h5><p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/exports</span><br></pre></td></tr></table></figure>
<p>在exports最后一行添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/mnt/nfs_shared 192.168.0.*(rw,sync,no_root_squash,no_subtree_check)</span><br><span class="line">其中，</span><br><span class="line">/mnt/nfs_shared  ---要共享的目录</span><br><span class="line">192.168.0.*---允许访问的网段，也可以是ip地址、主机名（能够被服务器解析）、</span><br><span class="line">     *（所有人都能访问）</span><br><span class="line">(rw,sync,no_root_squash,no_subtree_check)---</span><br><span class="line">rw:读/写权限</span><br><span class="line">sync:数据同步写入内存和硬盘</span><br><span class="line">no_root_squash:服务器允许远程系统以root特权存取该目录</span><br><span class="line">no_subtree_check:关闭子树检查</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/02/Ubuntu%E9%85%8D%E7%BD%AENFS%E5%8F%8A%E5%85%B6%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87/2.png" alt="2"></p>
<h5 id="在Ubuntu系统中启动服务"><a href="#在Ubuntu系统中启动服务" class="headerlink" title="在Ubuntu系统中启动服务"></a>在Ubuntu系统中启动服务</h5><p>依次执行下列命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service rpcbind restart</span><br><span class="line">sudo service rpcbind restart</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/02/Ubuntu%E9%85%8D%E7%BD%AENFS%E5%8F%8A%E5%85%B6%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87/3.png" alt="3"></p>
<h5 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h5><h6 id="测试Ubuntu-nfs"><a href="#测试Ubuntu-nfs" class="headerlink" title="测试Ubuntu nfs"></a>测试Ubuntu nfs</h6><p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$showmount -e</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/02/Ubuntu%E9%85%8D%E7%BD%AENFS%E5%8F%8A%E5%85%B6%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87/4.png" alt="4"></p>
<h6 id="设备挂载"><a href="#设备挂载" class="headerlink" title="设备挂载"></a>设备挂载</h6><p>在《Hi3519AV100 SDK 安装及升级使用说明.pdf》中4.2 使用 NFS 文件系统进行开发可以看到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -t nfs -o nolock -o tcp -o rsize=32768,wsize=32768 xx.xx.xx.xx:/your-nfs-path /mnt</span><br></pre></td></tr></table></figure>

<p>改为：（在设备中挂载）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -t nfs -o nolock -o tcp -o rsize=32768,wsize=32768 192.168.0.180:/mnt/</span><br></pre></td></tr></table></figure>
<p>之后就可以在设备的/mnt下面查看Ubuntu/mnt/nfs_shared的文件了。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>nfs</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/02/%E7%AE%80%E5%8D%95%E7%9A%84rtsp%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>这里C表示rtsp客户端,S表示rtsp服务端。 </p>
</blockquote>
<h6 id="C-gt-发送流媒体数据前的准备"><a href="#C-gt-发送流媒体数据前的准备" class="headerlink" title="C-&gt;:发送流媒体数据前的准备"></a>C-&gt;:发送流媒体数据前的准备</h6><ul>
<li>C-&gt;S:OPTION request  //询问S有哪些方法可用 </li>
<li>S-&gt;C:OPTION response //S回应信息中包括提供的所有可用方法 </li>
</ul>
<ul>
<li>C-&gt;S:DESCRIBE request //要求得到S提供的媒体初始化描述信息 </li>
<li>S-&gt;C:DESCRIBE response //S回应媒体初始化描述信息，主要是sdp </li>
</ul>
<ul>
<li>C-&gt;S:SETUP request //设置会话的属性，以及传输模式，提醒S建立会话 </li>
<li>S-&gt;C:SETUP response //S建立会话，返回会话标识符，以及会话相关信息 </li>
</ul>
<ul>
<li>C-&gt;S:PLAY request //C请求播放 </li>
<li>S-&gt;C:PLAY response //S回应该请求的信息 </li>
</ul>
<h6 id="S-gt-C-发送流媒体数据"><a href="#S-gt-C-发送流媒体数据" class="headerlink" title="S-&gt;C:发送流媒体数据"></a>S-&gt;C:发送流媒体数据</h6><ul>
<li>C-&gt;S:TEARDOWN request //C请求关闭会话 </li>
<li>S-&gt;C:TEARDOWN response //S回应该请求</li>
</ul>
]]></content>
      <categories>
        <category>流媒体</category>
      </categories>
  </entry>
</search>
