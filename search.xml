<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>cURL-03-cURL的几种语言支持</title>
    <url>/2019/11/03/cURL-03-cURL%E7%9A%84%E5%87%A0%E7%A7%8D%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81/</url>
    <content><![CDATA[<h5 id="一、基于-C-的-HTTP-客户端"><a href="#一、基于-C-的-HTTP-客户端" class="headerlink" title="一、基于 C 的 HTTP 客户端"></a>一、基于 C 的 HTTP 客户端</h5><p>C API 在 libcurl 功能上提供了两个 API。easy 接口是一个简单的同步 API（意味着当您使用请求调用 libcurl 时，将能够满足您的请求，直到完成或发生错误）。多接口可以进一步控制 libcurl，您的应用程序可以执行多个同步传输，并控制 libcurl 何时何地移动数据。</p>
<p>该示例使用 easy 接口。该 API 还能控制数据移动过程（使用回调），但正如其名称所示，使用起来非常简单。下面请看HTTP 的 C 语言示例,使用 libcurl easy 接口的 C HTTP 客户端。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">#include &lt;string.h&gt; </span><br><span class="line">#include &lt;curl/curl.h&gt; </span><br><span class="line"> </span><br><span class="line">#define MAX_BUF     65536 </span><br><span class="line"> </span><br><span class="line">char wr_buf[MAX_BUF+1]; </span><br><span class="line">int  wr_index; </span><br><span class="line"> </span><br><span class="line">/* </span><br><span class="line">* Write data callback function (called within the context of </span><br><span class="line">* curl_easy_perform. </span><br><span class="line">*/ </span><br><span class="line">size_t write_data( void *buffer, size_t size, size_t nmemb, void *userp ) </span><br><span class="line">&#123; </span><br><span class="line"> int segsize = size * nmemb; </span><br><span class="line"> </span><br><span class="line"> /* Check to see if this data exceeds the size of our buffer. If so, </span><br><span class="line">  * set the user-defined context value and return 0 to indicate a </span><br><span class="line">  * problem to curl. </span><br><span class="line">  */ </span><br><span class="line"> if ( wr_index + segsize &gt; MAX_BUF ) &#123; </span><br><span class="line">   *(int *)userp = 1; </span><br><span class="line">   return 0; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> /* Copy the data from the curl buffer into our buffer */ </span><br><span class="line"> memcpy( (void *)&amp;wr_buf[wr_index], buffer, (size_t)segsize ); </span><br><span class="line"> </span><br><span class="line"> /* Update the write index */ </span><br><span class="line"> wr_index += segsize; </span><br><span class="line"> </span><br><span class="line"> /* Null terminate the buffer */ </span><br><span class="line"> wr_buf[wr_index] = 0; </span><br><span class="line"> </span><br><span class="line"> /* Return the number of bytes received, indicating to curl that all is okay */ </span><br><span class="line"> return segsize; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/* </span><br><span class="line">* Simple curl application to read the index.html file from a Web site. </span><br><span class="line">*/ </span><br><span class="line">int main( void ) </span><br><span class="line">&#123; </span><br><span class="line"> CURL *curl; </span><br><span class="line"> CURLcode ret; </span><br><span class="line"> int  wr_error; </span><br><span class="line"> </span><br><span class="line"> wr_error = 0; </span><br><span class="line"> wr_index = 0; </span><br><span class="line"> </span><br><span class="line"> /* First step, init curl */ </span><br><span class="line"> curl = curl_easy_init(); </span><br><span class="line"> if (!curl) &#123; </span><br><span class="line">   printf(&quot;couldn&apos;t init curl\n&quot;); </span><br><span class="line">   return 0; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> /* Tell curl the URL of the file we&apos;re going to retrieve */ </span><br><span class="line"> curl_easy_setopt( curl, CURLOPT_URL, &quot;www.exampledomain.com&quot; ); </span><br><span class="line"> </span><br><span class="line"> /* Tell curl that we&apos;ll receive data to the function write_data, and </span><br><span class="line">  * also provide it with a context pointer for our error return. </span><br><span class="line">  */ </span><br><span class="line"> curl_easy_setopt( curl, CURLOPT_WRITEDATA, (void *)&amp;wr_error ); </span><br><span class="line"> curl_easy_setopt( curl, CURLOPT_WRITEFUNCTION, write_data ); </span><br><span class="line"> </span><br><span class="line"> /* Allow curl to perform the action */ </span><br><span class="line"> ret = curl_easy_perform( curl ); </span><br><span class="line"> </span><br><span class="line"> printf( &quot;ret = %d (write_error = %d)\n&quot;, ret, wr_error ); </span><br><span class="line"> </span><br><span class="line"> /* Emit the page if curl indicates that no errors occurred */ </span><br><span class="line"> if ( ret == 0 ) printf( &quot;%s\n&quot;, wr_buf ); </span><br><span class="line"> </span><br><span class="line"> curl_easy_cleanup( curl ); </span><br><span class="line"> </span><br><span class="line"> return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最上方是必需的 include文件，包括 cURL 根文件。接下来，定义了两个用于传输的变量。第一个变量是 wr_buf，表示将在其中写入传入数据的缓冲区。wr_index表示缓冲区的当前写入索引。</p>
<p>转到 main函数，该函数使用 easy API 进行设置。所有 cURL 调用都通过维护特定请求状态的句柄进行操作。这称为 CURL指针引用。本例还创建一个特殊的返回码，称为 CURLcode。在使用任何 libcurl 函数之前，您需要调用 curl_easy_init获取 CURL句柄。接下来，注意 curl_easy_setopt调用的数量。它们为特定的操作配置句柄。对于这些调用，您提供句柄、命令和选项。首先，本例使用 CURLOPT_URL指定要获取的 URL。然后，它使用 CURL_WRITEDATA提供一个上下文变量（在本例中，它是内部的 write 错误变量）。最后，它使用 CURLOPT_WRITEFUNCTION指定数据可用时应该调用的函数。在启动 API 之后，API 将使用它读取的数据多次调用该函数。</p>
<p>要开始传输，调用 curl_easy_perform。它的工作是根据之前的配置执行传输。调用该函数时，在完成传输或发生错误之前该函数不会返回。main的最后一步是提交返回状态，提交页面读取，最后使用 curl_easy_cleanup清除（当使用句柄执行完操作后）。</p>
<p>现在看看 write_data函数。该函数是针对特定操作收到数据时调用的回调。注意，当您从网站读取数据时，将写入该数据（write_data）。将向回调提供一个缓冲区（包含可用数据）、成员数量和大小（缓冲中可用数据总量）、上下文指针。第一个任务是确保缓冲区（wr_buf）的空间足以写入数据。如果不够，它将设置上下文指针并返回 0，表示出现问题。否则，它将 cURL 缓冲区的数据复制到您的缓冲区，并增加索引，指向要写入的下一个位置。本例还终止字符串，稍后可以对其使用 printf。最后，它返回 libcurl 操作的字节数量。这将告诉 libcurl 数据被提取，它也可以丢弃该数据。这就是从网站将文件读取到内存的相对简单的方法。</p>
<h5 id="二、基于-Python-的-HTTP-客户端"><a href="#二、基于-Python-的-HTTP-客户端" class="headerlink" title="二、基于 Python 的 HTTP 客户端"></a>二、基于 Python 的 HTTP 客户端</h5><p>Python 是一种非常有用的面向对象的脚本语言，在原型化和构建生产软件方面非常突出。示例假设您较熟悉 Python，但使用不多，因此不要期望过高。</p>
<p>这个简单的 Python HTTP 客户端使用 pycurl，如下：</p>
<p>使用 libcurl 的 pycurl接口的 Python HTTP 客户端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys </span><br><span class="line">import pycurl </span><br><span class="line"> </span><br><span class="line">wr_buf = &apos;&apos;</span><br><span class="line"> </span><br><span class="line">def write_data( buf ): </span><br><span class="line">    global wr_buf </span><br><span class="line">    wr_buf += buf </span><br><span class="line"> </span><br><span class="line">def main(): </span><br><span class="line">    c = pycurl.Curl() </span><br><span class="line">    c.setopt( pycurl.URL, &apos;http://www.exampledomain.com&apos; ) </span><br><span class="line">    c.setopt( pycurl.WRITEFUNCTION, write_data ) </span><br><span class="line"> </span><br><span class="line">    c.perform() </span><br><span class="line"> </span><br><span class="line">    c.close() </span><br><span class="line"> </span><br><span class="line">main() </span><br><span class="line">sys.stdout.write(wr_buf)</span><br></pre></td></tr></table></figure>

<p>这比 C 语言版本简单的多。它首先导入必需的模块（用于标准系统的 sys和 pycurl模块）。接下来，它定义 write 缓冲区（wr_buf）。像 C 程序中一样，声明一个 write_data函数。注意，该函数只有一个参数：从 HTTP 服务器中读取的数据缓冲区。我将该缓冲区连接到全局 write 缓冲区。main函数首先创建一个 Curl句柄，然后使用 setopt方法为传输定义 URL和 WRITEFUNCTION。它调用 perform方法启动传输并关闭句柄。最后，它调用 main函数，并将 write 缓冲区提交到 stdout。注意，在这种情况下，不需要错误上下文指针，因为使用了 Python 字符串连接，这就是说您不会使用大小固定的字符串。</p>
]]></content>
      <categories>
        <category>cURL</category>
      </categories>
      <tags>
        <tag>cURL</tag>
      </tags>
  </entry>
  <entry>
    <title>cURL-02_在命令行中使用cURL</title>
    <url>/2019/11/03/cURL-02-%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E4%BD%BF%E7%94%A8cURL/</url>
    <content><![CDATA[<h4 id="一、获取和安装-cURL-libcurl"><a href="#一、获取和安装-cURL-libcurl" class="headerlink" title="一、获取和安装 cURL/libcurl"></a>一、获取和安装 cURL/libcurl</h4><p>获取和安装 libcurl 非常简单，取决于您所运行的 Linux 发行版。如果运行的是 Ubuntu，您可以使用 apt-get轻松安装这些包。以下行演示了如何为 libcurl 安装 libcurl 和 Python 绑定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install libcurl3</span><br><span class="line">$ sudo apt-get install python-pycurl</span><br></pre></td></tr></table></figure>
<blockquote>
<p>apt-get实用工具确保该过程满足所有的依赖关系。</p>
</blockquote>
<a id="more"></a>

<h4 id="二、相对简单的用法"><a href="#二、相对简单的用法" class="headerlink" title="二、相对简单的用法"></a>二、相对简单的用法</h4><h5 id="1-从百度的网页服务器上获得该网站的主页："><a href="#1-从百度的网页服务器上获得该网站的主页：" class="headerlink" title="1. 从百度的网页服务器上获得该网站的主页："></a>1. 从百度的网页服务器上获得该网站的主页：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl http://www.baidu.com/</span><br></pre></td></tr></table></figure>
<p>如果要把这个网页保存下来，可以使用<code>-o</code>参数，这就相当于使用wget命令了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -o [文件名] www.baidu.com</span><br></pre></td></tr></table></figure>


<h5 id="2-自动跳转"><a href="#2-自动跳转" class="headerlink" title="2. 自动跳转"></a>2. 自动跳转</h5><p>有的网址是自动跳转的。使用<code>-L</code>参数，curl就会跳转到新的网址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -L www.baidu.com</span><br></pre></td></tr></table></figure>

<p>输入上面的命令，结果就自动跳转为<a href="http://www.baidu.com。" target="_blank" rel="noopener">www.baidu.com。</a></p>
<h5 id="3-显示头信息"><a href="#3-显示头信息" class="headerlink" title="3. 显示头信息"></a>3. 显示头信息</h5><p><code>-i</code>参数可以显示http response的头信息，连同网页代码一起。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -i www.baidu.com</span><br></pre></td></tr></table></figure>
<p><code>-I</code>参数则是只显示http response的头信息。</p>
<h5 id="4-显示通信过程"><a href="#4-显示通信过程" class="headerlink" title="4. 显示通信过程"></a>4. 显示通信过程</h5><p><code>-v</code>参数可以显示一次http通信的整个过程，包括端口连接和http request头信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -v www.baidu.com</span><br></pre></td></tr></table></figure>

<p>如果你觉得上面的信息还不够，那么下面的命令可以查看更详细的通信过程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl --trace output.txt www.baidu.com</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl --trace-ascii output.txt www.baidu.com</span><br></pre></td></tr></table></figure>
<p>运行后，请打开output.txt文件查看。</p>
<h5 id="5-发送表单信息"><a href="#5-发送表单信息" class="headerlink" title="5. 发送表单信息"></a>5. 发送表单信息</h5><p>发送表单信息有GET和POST两种方法。GET方法相对简单，只要把数据附在网址后面就行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl example.com/form.cgi?data=xxx</span><br></pre></td></tr></table></figure>
<p>POST方法必须把数据和网址分开，curl就要用到–data参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -X POST --data &quot;data=xxx&quot; example.com/form.cgi</span><br></pre></td></tr></table></figure>
<p>如果你的数据没有经过表单编码，还可以让curl为你编码，参数是<code>--data-urlencode</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -X POST--data-urlencode &quot;date=April 1&quot; example.com/form.cgi</span><br></pre></td></tr></table></figure>

<h5 id="6-HTTP动词"><a href="#6-HTTP动词" class="headerlink" title="6. HTTP动词"></a>6. HTTP动词</h5><p>curl默认的HTTP动词是GET，使用<code>-X</code>参数可以支持其他动词。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -X POST www.example.com</span><br><span class="line">$ curl -X DELETE www.example.com</span><br></pre></td></tr></table></figure>

<h5 id="7-文件上传"><a href="#7-文件上传" class="headerlink" title="7. 文件上传"></a>7. 文件上传</h5><p>假定文件上传的表单是下面这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form method=&quot;POST&quot; enctype=&apos;multipart/form-data&apos; action=&quot;upload.cgi&quot;&gt;</span><br><span class="line">&lt;input type=file name=upload&gt;</span><br><span class="line">&lt;input type=submit name=press value=&quot;OK&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>你可以用curl这样上传文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl --form upload=@localfilename --form press=OK [URL]</span><br></pre></td></tr></table></figure>

<h5 id="8-Referer字段"><a href="#8-Referer字段" class="headerlink" title="8. Referer字段"></a>8. Referer字段</h5><p>有时你需要在http request头信息中，提供一个referer字段，表示你是从哪里跳转过来的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl --referer http://www.example.com http://www.example.com</span><br></pre></td></tr></table></figure>

<h5 id="9-User-Agent字段"><a href="#9-User-Agent字段" class="headerlink" title="9. User Agent字段"></a>9. User Agent字段</h5><p>这个字段是用来表示客户端的设备信息。服务器有时会根据这个字段，针对不同设备，返回不同格式的网页，比如手机版和桌面版。</p>
<p>iPhone4的User Agent是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_0 like Mac OS X; en-us) AppleWebKit/532.9 (KHTML, like Gecko) Version/4.0.5 Mobile/8A293 Safari/6531.22.7</span><br></pre></td></tr></table></figure>
<p>curl可以这样模拟：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl --user-agent &quot;[User Agent]&quot; [URL]</span><br></pre></td></tr></table></figure>

<h5 id="10-cookie"><a href="#10-cookie" class="headerlink" title="10. cookie"></a>10. cookie</h5><p>使用<code>--cookie</code>参数，可以让curl发送cookie。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl --cookie &quot;name=xxx&quot; www.example.com</span><br></pre></td></tr></table></figure>
<p>至于具体的cookie的值，可以从http response头信息的<code>Set-Cookie</code>字段中得到。</p>
<p><code>-c cookie-file</code>可以保存服务器返回的cookie到文件，<code>-b cookie-file</code>可以使用这个文件作为cookie信息，进行后续的请求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -c cookies http://example.com</span><br><span class="line">$ curl -b cookies http://example.com</span><br></pre></td></tr></table></figure>

<h5 id="11-增加头信息"><a href="#11-增加头信息" class="headerlink" title="11. 增加头信息"></a>11. 增加头信息</h5><p>有时需要在http request之中，自行增加一个头信息。<code>--header</code>参数就可以起到这个作用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl --header &quot;Content-Type:application/json&quot; http://example.com</span><br></pre></td></tr></table></figure>
<h5 id="12-HTTP认证"><a href="#12-HTTP认证" class="headerlink" title="12. HTTP认证"></a>12. HTTP认证</h5><p>有些网域需要HTTP认证，这时curl需要用到<code>--user</code>参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl --user name:password example.com</span><br></pre></td></tr></table></figure>




<h5 id="13-cURL还有很多命令行操作，这里就不作陈诉了。"><a href="#13-cURL还有很多命令行操作，这里就不作陈诉了。" class="headerlink" title="13. cURL还有很多命令行操作，这里就不作陈诉了。"></a>13. cURL还有很多命令行操作，这里就不作陈诉了。</h5>]]></content>
      <categories>
        <category>cURL</category>
      </categories>
      <tags>
        <tag>cURL</tag>
      </tags>
  </entry>
  <entry>
    <title>sscanf()函数使用详解</title>
    <url>/2019/11/03/sscanf-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="一、描述："><a href="#一、描述：" class="headerlink" title="一、描述："></a>一、描述：</h4><p>sscanf通常被用来解析并转换字符串，其格式定义灵活多变，可以实现很强大的字符串解析功能。</p>
<p>sscanf的原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int sscanf(const char *str, const char *format, ...);</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>str:待解析的字符串;</p>
<p>format:字符串格式描述;</p>
<p>其后是一序列数目不定的指针参数，存储解析后的数据.</p>
<h4 id="二、示例用法："><a href="#二、示例用法：" class="headerlink" title="二、示例用法："></a>二、示例用法：</h4><h5 id="sscanf的基本用法"><a href="#sscanf的基本用法" class="headerlink" title="sscanf的基本用法"></a>sscanf的基本用法</h5><h6 id="整形数转换"><a href="#整形数转换" class="headerlink" title="整形数转换"></a>整形数转换</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int year, month, day;</span><br><span class="line"></span><br><span class="line">int converted = sscanf(&quot;20191103&quot;, &quot;%04d%02d%02d&quot;, &amp;year, &amp;month, &amp;day);</span><br><span class="line">printf(&quot;converted=%d, year=%d, month=%d, day=%d/n&quot;, converted, year, month, day);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">converted=3, year=2019, month=11, day=03</span><br></pre></td></tr></table></figure>

<p>“%04d%02d%02d”是用来解析字符串的格式，%表示格式转换的开始，d表示转换为一个整数，04作为d的修饰，表示这是一个长度为4位的整数，不足4位时以0补齐。</p>
<p>例子返回结果等于3，表示有3个数据成功转换，转换成功数目同时取决于被解析的字符串以及其转换格式，如果我们把例子中的格式改为”%04d%02d”，那么sscanf将只返回2，day的数值不会被sscanf更改。</p>
<h6 id="浮点数转换"><a href="#浮点数转换" class="headerlink" title="浮点数转换"></a>浮点数转换</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double longitude, latitude;</span><br><span class="line">int converted = sscanf(&quot;113.123456789 31.123456789&quot;, &quot;%lf %lf&quot;, &amp;longitude, &amp;latitude);</span><br><span class="line">printf(&quot;converted=%d, longitude=%.9lf, latitude=%lf/n&quot;, converted, longitude, latitude);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">converted=2, longitude=113.123456789, latitude=31.123457</span><br></pre></td></tr></table></figure>
<p>sscanf的格式字符串中，f表示这是一个浮点数，其修饰词l表示这是一个double的浮点数。</p>
<h5 id="sscanf的高级用法"><a href="#sscanf的高级用法" class="headerlink" title="sscanf的高级用法"></a>sscanf的高级用法</h5><h6 id="数字-字符串"><a href="#数字-字符串" class="headerlink" title="数字+字符串"></a>数字+字符串</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char str[32] = &quot;&quot;;</span><br><span class="line">sscanf(&quot;123456abcdedf&quot;, &quot;%31[0-9]&quot;, str);</span><br><span class="line">printf(&quot;str=%s/n&quot;, str);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str=123456</span><br></pre></td></tr></table></figure>
<p>上面的格式中，[0-9]表示这是一个仅包含0-9这几个字符的字符串，==前面使用数字31修饰词表示这个字符串缓冲区的最大长度(这也是sscanf最为人诟病的地方，很容易出现缓冲区溢出错误，实际上sscanf是可以避免出现缓冲区溢出的，只要在书写任何字符串解析的格式时，注意加上其缓冲区尺寸的限制)。==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char str[32] = &quot;&quot;;</span><br><span class="line">sscanf(&quot;123456abcdedf&quot;, &quot;%31[0-9a-z]&quot;, str);</span><br><span class="line">printf(&quot;str=%s/n&quot;, str);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str=123456abcdedf</span><br></pre></td></tr></table></figure>
<p>在格式[]中增加了a-z的描述。</p>
<h6 id="使用-示例："><a href="#使用-示例：" class="headerlink" title="使用^示例："></a>使用^示例：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char str[32] = &quot;&quot;;</span><br><span class="line">sscanf(&quot;123456abcdedf&quot;, &quot;%31[^a-z]&quot;, str);</span><br><span class="line">printf(&quot;str=%s/n&quot;, str);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str=123456</span><br></pre></td></tr></table></figure>
<p>在[]中增加^表示相反的意思，上面的[^a-z]表示一个不包含任何a-z之间的字符串。</p>
<h6 id="使用-的例子："><a href="#使用-的例子：" class="headerlink" title="使用*的例子："></a>使用*的例子：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char str[32] = &quot;&quot;;</span><br><span class="line">int ret = sscanf(&quot;123456abcdedf&quot;, &quot;%*[0-9]%31[a-z]&quot;, str);</span><br><span class="line">printf(&quot;ret=%d, str=%s/n&quot;,ret, str);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ret=1, str=abcdedf</span><br></pre></td></tr></table></figure>
<p>加上*修饰表示一个被忽略的数据，同时也不需要为它准备空间存放解析结果。如上面的例子中，我们就只使用了str一个参数存放%31[a-z]的解析结果，而sscanf也只返回1，表示只解析了一个数据。</p>
<p>掌握了[], ^, *如何使用后，我们会发现sscanf原来是一个如此强大的工具，很多我们原先认为必须使用正则表达式的地方，很可能使用sscanf就可以实现。</p>
]]></content>
      <categories>
        <category>系统函数&amp;库函数</category>
      </categories>
      <tags>
        <tag>字符串操作</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 通过系统函数设置系统时间</title>
    <url>/2019/11/03/linux-%E9%80%9A%E8%BF%87%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h5 id="一、描述："><a href="#一、描述：" class="headerlink" title="一、描述："></a>一、描述：</h5><p>通过settimeofday()函数来设置系统时间，这个函数设置的精度可以精确到微秒。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">int settimeofday(const struct timeval *tv , const struct timezone *tz);</span><br><span class="line"></span><br><span class="line">struct timeval &#123;</span><br><span class="line">    time_t      tv_sec;     /* seconds */</span><br><span class="line">    suseconds_t tv_usec;    /* microseconds */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct timezone &#123;</span><br><span class="line">    int tz_minuteswest;     /* minutes west of Greenwich */</span><br><span class="line">    int tz_dsttime;         /* type of DST correction */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tz参数为时区，时区结构中tz_dsttime在linux中不支持，应该置为0，通常将参数tz设置为NULL，表示使用当前系统的时区。该函数是glib中的，但在mingw中没有实现。</p>
</blockquote>
<a id="more"></a>

<h5 id="二、代码演示："><a href="#二、代码演示：" class="headerlink" title="二、代码演示："></a>二、代码演示：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/time.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int SetSystemTime(char *dt)</span><br><span class="line">&#123;</span><br><span class="line">    struct tm rtc_time;</span><br><span class="line">    struct tm _tm;</span><br><span class="line">    struct timeval tv;</span><br><span class="line">    time_t timep;</span><br><span class="line">    sscanf(dt, &quot;%d-%d-%d %d:%d:%d&quot;, &amp;rtc_time.tm_year,</span><br><span class="line">		&amp;rtc_time.tm_mon, &amp;rtc_time.tm_mday,&amp;rtc_time.tm_hour,</span><br><span class="line">        &amp;rtc_time.tm_min, &amp;rtc_time.tm_sec);</span><br><span class="line">    _tm.tm_sec = rtc_time.tm_sec;</span><br><span class="line">    _tm.tm_min = rtc_time.tm_min;</span><br><span class="line">    _tm.tm_hour = rtc_time.tm_hour;</span><br><span class="line">    _tm.tm_mday = rtc_time.tm_mday;</span><br><span class="line">    _tm.tm_mon = rtc_time.tm_mon - 1;</span><br><span class="line">    _tm.tm_year = rtc_time.tm_year - 1900;</span><br><span class="line"> </span><br><span class="line">    timep = mktime(&amp;_tm);</span><br><span class="line">    tv.tv_sec = timep;</span><br><span class="line">    tv.tv_usec = 0;</span><br><span class="line">    // if(settimeofday (&amp;tv, (struct timezone *) 0) &lt; 0)</span><br><span class="line">	if(settimeofday (&amp;tv, NULL) &lt; 0)	</span><br><span class="line">    &#123;</span><br><span class="line">		printf(&quot;Set system datatime error!\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	printf(&quot;现在的时间是:&quot;);</span><br><span class="line">	fflush(stdout);</span><br><span class="line">	system(&quot;date&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  SetSystemTime(&quot;2019-11-03 16:30:30&quot;);//2019-11-01 21:19:05  </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="三、效果如下："><a href="#三、效果如下：" class="headerlink" title="三、效果如下："></a>三、效果如下：</h5><p><img src="/2019/11/03/linux-%E9%80%9A%E8%BF%87%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/1.jpg" alt="1"><br>注意：</p>
<ol>
<li>调用settimeofday函数时必须要在root权限下执行。</li>
<li>设置时间之前最好把虚拟机网络断开。</li>
</ol>
]]></content>
      <categories>
        <category>系统函数&amp;库函数</category>
      </categories>
      <tags>
        <tag>系统时间</tag>
      </tags>
  </entry>
  <entry>
    <title>cURL-01_基本概念与了解</title>
    <url>/2019/11/03/cURL-01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<h5 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h5><p>cURL（Client URL Library Functions）is a command line tool for transfering data with URL syntax（使用 URL 语法传输数据的命令行工具），即客户端向服务器请求资源的工具。</p>
<p><img src="/2019/11/03/cURL-01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BA%86%E8%A7%A3/1.png" alt="1"></p>
<a id="more"></a>

<p>curl库是C语言封装的一个强大的库，使用curl比封装socket更加方便。</p>
<p>cURL 最初的设计初衷是使用不同的协议（比如 FTP、HTTP、SCP 等）在端点之间移动文件。它最初是一个命令行实用工具，但现在也是一个绑定了 30 多种语言的库。因此，现在不仅可以通过 shell 使用 cURL，您还可以构建合并了这个重要功能的应用程序。libcurl 库也是可以移植的，支持 Linux®、IBM®AIX®操作系统、BSD、Solaris 以及许多其他 UNIX®变体。</p>
<p>cURL是一个命令行工具和库，实现了各种客户端协议。它支持 12 种以上的协议，包括 FTP、HTTP、Telnet 以及其他安全变体。许多平台上都能找到 cURL，包括 Linux、AIX、BSD 和 Solaris，它支持 30 多种语言。</p>
<p>PycURL是 libcurl API 之上的一个薄层，PycURL 速度非常快。使用 PycURL，您可以使用 libcurl 库开发 Python 应用程序。</p>
<p>关于cURL,<a href="https://curl.haxx.se/" target="_blank" rel="noopener">这里</a>有更详细的介绍。</p>
<h5 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h5><p>1.网页资源（例如编写网页爬虫）</p>
<p>2.WebService 数据接口资源（比如动态获取接口数据，比如天气、号码归属地等）</p>
<p>3.FTP 服务器里的文件资源（下载 FTP 服务器里面的文件）</p>
<p>4.其他资源（所有网络上的资源都可以使用 cURL 访问和下载到）</p>
<h5 id="三、延伸-为什么要用cURL"><a href="#三、延伸-为什么要用cURL" class="headerlink" title="三、延伸(为什么要用cURL)"></a>三、延伸(为什么要用cURL)</h5><p>开发 HTTP 和 FTP 之类依赖于应用层协议的应用程序并不复杂，但也不简单。进一步讲，这不是应用程序的重点，因为大部分情况下，协议之上的内容才是真正重要的内容。因此，libcurl 引起了许多人的兴趣，因为它的重点是应用程序而不是开发的各个方面。注意，很少有应用程序开发自己的 TCP/IP 堆栈，所以老话重提：尽可能重用以最小化开发安排并提高应用程序的可靠性。</p>
<h6 id="关于Web-协议"><a href="#关于Web-协议" class="headerlink" title="关于Web 协议"></a>关于Web 协议</h6><p>如今构建应用程序已与过去大不相同。现在的应用程序需要能够通过网络或 Internet 进行通讯（提供人类可用的网络 API 或接口），还要能支持用户脚本化以提高灵活性。现代应用程序通常使用 HTTP 公开 Web 接口，并通过 Simple Mail Transport Protocol (SMTP) 提供警告通知。这些协议允许您将 Web 浏览器指向设备以获得配置或状态信息，并从设备或常用的电子邮件客户端接收标准电子邮件（分别通过 HTTP 和 SMTP）。</p>
<p>这些 Web 服务通常构建在网络堆栈的套接字层上（见图 1）。套接字层实现一个最先出现在 Berkeley Software Distribution (BSD) 操作系统上的 API，并提取底层传输和网络层协议的详细信息。</p>
<p>图 1. 网络堆栈和 libcurl</p>
<p><img src="/2019/11/03/cURL-01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BA%86%E8%A7%A3/2.gif" alt="2"></p>
<p>Web 服务发生在客户端和服务器之间的协议对话中。在 HTTP 上下文中，服务器是终端设备，客户端是位于端点上的浏览器。对于 SMTP，服务器是邮件网关或端点用户，客户端是终端设备。在某些情况下，协议对话发生在两个步骤（请求和响应）中，但另一些情况下，需要协商和通讯的通信量更多。这种协商可能增加了大量复杂性，这可以通过 API 进行抽象，比如 libcurl。</p>
]]></content>
      <categories>
        <category>cURL</category>
      </categories>
      <tags>
        <tag>cURL</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机VMware与Windows主机共享文件介绍</title>
    <url>/2019/11/03/%E8%99%9A%E6%8B%9F%E6%9C%BAVMware%E4%B8%8EWindows%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h5 id="一、设置共享文件夹功能"><a href="#一、设置共享文件夹功能" class="headerlink" title="一、设置共享文件夹功能"></a>一、设置共享文件夹功能</h5><p>虚拟机VMware提供了在宿主机与虚拟机系统之间交换文件的共享文件夹（Shared Folder）功能。不管虚拟机操作系统是Linux还是Windows都可用。你可以通过设置（ Settings）&gt;共享文件夹（Shared Folder）来设置。但是此功能选项必须要安装虚拟机工具（VMware Tools），否则如下所示，否则该功能选项不可用。</p>
<p><img src="/2019/11/03/%E8%99%9A%E6%8B%9F%E6%9C%BAVMware%E4%B8%8EWindows%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/1.jpg" alt="1"></p>
<a id="more"></a>
<h5 id="二、安装虚拟机工具步骤如下所示："><a href="#二、安装虚拟机工具步骤如下所示：" class="headerlink" title="二、安装虚拟机工具步骤如下所示："></a>二、安装虚拟机工具步骤如下所示：</h5><h6 id="1-在对应虚拟机的设置选项（Settings-下，为虚拟机光驱指定虚拟机系统的镜像文件。"><a href="#1-在对应虚拟机的设置选项（Settings-下，为虚拟机光驱指定虚拟机系统的镜像文件。" class="headerlink" title="1. 在对应虚拟机的设置选项（Settings)下，为虚拟机光驱指定虚拟机系统的镜像文件。"></a>1. 在对应虚拟机的设置选项（Settings)下，为虚拟机光驱指定虚拟机系统的镜像文件。</h6><p>注意：在执行下面步骤前，必须确保虚拟机的电源开启、虚拟机系统正在运行。</p>
<p><img src="/2019/11/03/%E8%99%9A%E6%8B%9F%E6%9C%BAVMware%E4%B8%8EWindows%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/2.png" alt="2"></p>
<h6 id="2-在VM下选择”Install-VMware-Tools”"><a href="#2-在VM下选择”Install-VMware-Tools”" class="headerlink" title="2. 在VM下选择”Install VMware Tools”."></a>2. 在VM下选择”Install VMware Tools”.</h6><p><img src="/2019/11/03/%E8%99%9A%E6%8B%9F%E6%9C%BAVMware%E4%B8%8EWindows%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/3.png" alt="3"></p>
<ol start="3">
<li>然后安装虚拟机组件工具，详细步骤如下所示：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@DB-Server ~]# cd /mnt</span><br><span class="line">[root@DB-Server mnt]# mkdir cdrom</span><br><span class="line">[root@DB-Server mnt]# mount /dev/cdrom  /mnt/cdrom</span><br><span class="line">[root@DB-Server mnt]# cd /mnt/cdrom</span><br><span class="line">[root@DB-Server cdrom]# cp  VMwareTools-8.8.2-590212.tar.gz /tmp</span><br><span class="line">[root@DB-Server cdrom]#tar xz</span><br><span class="line">[root@DB-Server tmp]# ls</span><br><span class="line">gconfd-root     orbit-root           VMwareTools-8.8.2-590212.tar.gz</span><br><span class="line">keyring-qO15Cg  ssh-EWUeHQ4064       vmware-tools-distrib</span><br><span class="line">mapping-root    virtual-root.9mZzaq</span><br><span class="line">[root@DB-Server tmp]# cd vmware-tools-distrib/</span><br><span class="line">[root@DB-Server vmware-tools-distrib]# ls</span><br><span class="line">bin  doc  etc  FILES  INSTALL  installer  lib  vmware-install.pl</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[root@DB-Server vmware-tools-distrib]# ./vmware-install.pl </span><br><span class="line">A previous installation of VMware Tools has been detected.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">之后直接安装即可。</span><br></pre></td></tr></table></figure>
安装完成后重启虚拟机</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title>Source Insight 使用技巧整理</title>
    <url>/2019/11/03/Source-Insight-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h4 id="通用设置"><a href="#通用设置" class="headerlink" title="通用设置"></a>通用设置</h4><p>Options - File Type Options:</p>
<ul>
<li>显示行号：勾选Show line mumbers</li>
<li>选中自动高亮：勾选Hightlight references to selected sysmbol</li>
<li>转换tab成空格：勾选Expand tabs to spaces，设置Tab width：4<br><img src="/2019/11/03/Source-Insight-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/1.png" alt="1"></li>
</ul>
<a id="more"></a>
<p><strong>高亮选中符号：</strong><br>F8</p>
<p><strong>代码折叠：</strong><br>View –&gt; Show Outlining </p>
<p><strong>代码默认字体大小：</strong><br>Ctrl + 滑动鼠标滑轮，可以增大缩小代码字体大小</p>
<blockquote>
<p>对所有代码文件字体都生效，步骤如：<br>Preferences –&gt; File Type Options -&gt; Screen Font<br>Preferences –&gt; Languages –&gt; File Types –&gt; Screen Font</p>
</blockquote>
<p><strong>只为主界面导入配色方案（不是全局，全局在Options-&gt;Load Configuration..）</strong></p>
<ol>
<li>Options –&gt; Style properties -&gt; Load</li>
<li>背景色修改： Options –&gt; Preferences –&gt;  Colors –&gt; Window Background </li>
<li>字体修改：在需要修改的词处点击，选择style Properties 会自动对应到需要修改的词语类型，然后直接修改颜色即可。</li>
</ol>
<p><strong>替换：</strong><br>Ctrl + h<br><strong>查找：</strong><br>Ctrl + f<br><strong>全局查找：</strong><br>Ctrl + /<br><strong>向上搜索</strong><br>Ctrl + F3<br><strong>向下搜索</strong><br>Ctrl + F4<br><strong>跳转到行：</strong><br>F5<br><strong>跳转到定义：</strong><br>Ctrl + 鼠标左键</p>
<h4 id="显示中文乱码"><a href="#显示中文乱码" class="headerlink" title="显示中文乱码"></a>显示中文乱码</h4><p>File - Reload As Encoding - GB2312</p>
<p><img src="/2019/11/03/Source-Insight-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/2.png" alt="2"></p>
<h4 id="添加注释快捷键"><a href="#添加注释快捷键" class="headerlink" title="添加注释快捷键"></a>添加注释快捷键</h4><blockquote>
<p>添加一些配置文件宏，比如：注释掉代码：单行注释、多行注释，将选中内容注释掉；在一行代码的前、后添加注释性文字等。</p>
</blockquote>
<h5 id="操作步骤："><a href="#操作步骤：" class="headerlink" title="操作步骤："></a>操作步骤：</h5><p>打开Projcet-&gt;Open project，选择base，可以看到utils.em文件，将下列宏添加到该文件中，并在其他工程里加入该文件，在上面介绍的快捷键添加方式里找到该宏并自定义快捷键。</p>
<h5 id="单行、多行注释："><a href="#单行、多行注释：" class="headerlink" title="单行、多行注释："></a>单行、多行注释：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">macro MultiLineComment()  </span><br><span class="line">&#123;  </span><br><span class="line">    hwnd = GetCurrentWnd()  </span><br><span class="line">    selection = GetWndSel(hwnd)  </span><br><span class="line">    LnFirst = GetWndSelLnFirst(hwnd)      //取首行行号  </span><br><span class="line">    LnLast = GetWndSelLnLast(hwnd)      //取末行行号  </span><br><span class="line">    hbuf = GetCurrentBuf()  </span><br><span class="line">   </span><br><span class="line">    if(GetBufLine(hbuf, 0) == &quot;//magic-number:tph85666031&quot;)&#123;  </span><br><span class="line">        stop  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    Ln = Lnfirst  </span><br><span class="line">    buf = GetBufLine(hbuf, Ln)  </span><br><span class="line">    len = strlen(buf)  </span><br><span class="line">   </span><br><span class="line">    while(Ln &lt;= Lnlast) &#123;  </span><br><span class="line">        buf = GetBufLine(hbuf, Ln)  //取Ln对应的行  </span><br><span class="line">        if(buf == &quot;&quot;)&#123;                    //跳过空行  </span><br><span class="line">            Ln = Ln + 1  </span><br><span class="line">            continue  </span><br><span class="line">        &#125;  </span><br><span class="line">   </span><br><span class="line">        if(StrMid(buf, 0, 1) == &quot;/&quot;) &#123;       //需要取消注释,防止只有单字符的行  </span><br><span class="line">            if(StrMid(buf, 1, 2) == &quot;/&quot;)&#123;  </span><br><span class="line">                PutBufLine(hbuf, Ln, StrMid(buf, 2, Strlen(buf)))  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">   </span><br><span class="line">        if(StrMid(buf,0,1) != &quot;/&quot;)&#123;          //需要添加注释  </span><br><span class="line">            PutBufLine(hbuf, Ln, Cat(&quot;//&quot;, buf))  </span><br><span class="line">        &#125;  </span><br><span class="line">        Ln = Ln + 1  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    SetWndSel(hwnd, selection)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上面的代码保存到utils.em文件，打开source insight，将该文件添加到工程中，然后在Options-&gt;Key Assignments中你就可以看到这个宏了，宏的名字是MultiLineComments，然后我们为它分配快捷键“Ctrl + /”，然后就可以了。</p>
<p>添加“#ifdef 0”和“#endif”的宏代码，定义快捷键为Ctrl+/+Shift：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">macro AddMacroComment()  </span><br><span class="line">&#123;  </span><br><span class="line">    hwnd=GetCurrentWnd()  </span><br><span class="line">    sel=GetWndSel(hwnd)  </span><br><span class="line">    lnFirst=GetWndSelLnFirst(hwnd)  </span><br><span class="line">    lnLast=GetWndSelLnLast(hwnd)  </span><br><span class="line">    hbuf=GetCurrentBuf()  </span><br><span class="line">   </span><br><span class="line">    if(LnFirst == 0) &#123;  </span><br><span class="line">            szIfStart = &quot;&quot;  </span><br><span class="line">    &#125;else&#123;  </span><br><span class="line">            szIfStart = GetBufLine(hbuf, LnFirst-1)  </span><br><span class="line">    &#125;  </span><br><span class="line">    szIfEnd = GetBufLine(hbuf, lnLast+1)  </span><br><span class="line">    if(szIfStart == &quot;#if 0&quot; &amp;&amp; szIfEnd == &quot;#endif&quot;) &#123;  </span><br><span class="line">            DelBufLine(hbuf, lnLast+1)  </span><br><span class="line">            DelBufLine(hbuf, lnFirst-1)  </span><br><span class="line">            sel.lnFirst = sel.lnFirst – 1  </span><br><span class="line">            sel.lnLast = sel.lnLast – 1  </span><br><span class="line">    &#125;else&#123;  </span><br><span class="line">            InsBufLine(hbuf, lnFirst, &quot;#if 0&quot;)  </span><br><span class="line">            InsBufLine(hbuf, lnLast+2, &quot;#endif&quot;)  </span><br><span class="line">            sel.lnFirst = sel.lnFirst + 1  </span><br><span class="line">            sel.lnLast = sel.lnLast + 1  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    SetWndSel( hwnd, sel )  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>操作和上面类似</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Source Insight</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu配置NFS及其挂载设备</title>
    <url>/2019/11/02/Ubuntu%E9%85%8D%E7%BD%AENFS%E5%8F%8A%E5%85%B6%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87/</url>
    <content><![CDATA[<h5 id="在Ubuntu系统中安装NFS"><a href="#在Ubuntu系统中安装NFS" class="headerlink" title="在Ubuntu系统中安装NFS"></a>在Ubuntu系统中安装NFS</h5><p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nfs-kernel-server</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同时会有两个软件包nfs-common和portmap被安装上，如果没有安装成功多安装几次。</p>
</blockquote>
<a id="more"></a>

<h5 id="在Ubuntu系统中的-mnt下建立共享项目nfs-shared"><a href="#在Ubuntu系统中的-mnt下建立共享项目nfs-shared" class="headerlink" title="在Ubuntu系统中的/mnt下建立共享项目nfs_shared"></a>在Ubuntu系统中的/mnt下建立共享项目nfs_shared</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mkdir nfs_shared </span><br><span class="line"># chmod 777 -R nfs_shared/</span><br></pre></td></tr></table></figure>
<p>保证使用者都能够读、写、执行。如图</p>
<p><img src="/2019/11/02/Ubuntu%E9%85%8D%E7%BD%AENFS%E5%8F%8A%E5%85%B6%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87/1.png" alt="1"></p>
<h5 id="在Ubuntu系统中修改NFS配置文件"><a href="#在Ubuntu系统中修改NFS配置文件" class="headerlink" title="在Ubuntu系统中修改NFS配置文件"></a>在Ubuntu系统中修改NFS配置文件</h5><p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/exports</span><br></pre></td></tr></table></figure>
<p>在exports最后一行添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/mnt/nfs_shared 192.168.0.*(rw,sync,no_root_squash,no_subtree_check)</span><br><span class="line">其中，</span><br><span class="line">/mnt/nfs_shared  ---要共享的目录</span><br><span class="line">192.168.0.*---允许访问的网段，也可以是ip地址、主机名（能够被服务器解析）、</span><br><span class="line">     *（所有人都能访问）</span><br><span class="line">(rw,sync,no_root_squash,no_subtree_check)---</span><br><span class="line">rw:读/写权限</span><br><span class="line">sync:数据同步写入内存和硬盘</span><br><span class="line">no_root_squash:服务器允许远程系统以root特权存取该目录</span><br><span class="line">no_subtree_check:关闭子树检查</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/02/Ubuntu%E9%85%8D%E7%BD%AENFS%E5%8F%8A%E5%85%B6%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87/2.png" alt="2"></p>
<h5 id="在Ubuntu系统中启动服务"><a href="#在Ubuntu系统中启动服务" class="headerlink" title="在Ubuntu系统中启动服务"></a>在Ubuntu系统中启动服务</h5><p>依次执行下列命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service rpcbind restart</span><br><span class="line">sudo service rpcbind restart</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/02/Ubuntu%E9%85%8D%E7%BD%AENFS%E5%8F%8A%E5%85%B6%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87/3.png" alt="3"></p>
<h5 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h5><h6 id="测试Ubuntu-nfs"><a href="#测试Ubuntu-nfs" class="headerlink" title="测试Ubuntu nfs"></a>测试Ubuntu nfs</h6><p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$showmount -e</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/02/Ubuntu%E9%85%8D%E7%BD%AENFS%E5%8F%8A%E5%85%B6%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87/4.png" alt="4"></p>
<h6 id="设备挂载"><a href="#设备挂载" class="headerlink" title="设备挂载"></a>设备挂载</h6><p>在《Hi3519AV100 SDK 安装及升级使用说明.pdf》中4.2 使用 NFS 文件系统进行开发可以看到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -t nfs -o nolock -o tcp -o rsize=32768,wsize=32768 xx.xx.xx.xx:/your-nfs-path /mnt</span><br></pre></td></tr></table></figure>

<p>改为：（在设备中挂载）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -t nfs -o nolock -o tcp -o rsize=32768,wsize=32768 192.168.0.180:/mnt/</span><br></pre></td></tr></table></figure>
<p>之后就可以在设备的/mnt下面查看Ubuntu/mnt/nfs_shared的文件了。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>nfs</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/02/%E7%AE%80%E5%8D%95%E7%9A%84rtsp%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>这里C表示rtsp客户端,S表示rtsp服务端。 </p>
</blockquote>
<h6 id="C-gt-发送流媒体数据前的准备"><a href="#C-gt-发送流媒体数据前的准备" class="headerlink" title="C-&gt;:发送流媒体数据前的准备"></a>C-&gt;:发送流媒体数据前的准备</h6><ul>
<li>C-&gt;S:OPTION request  //询问S有哪些方法可用 </li>
<li>S-&gt;C:OPTION response //S回应信息中包括提供的所有可用方法 </li>
</ul>
<ul>
<li>C-&gt;S:DESCRIBE request //要求得到S提供的媒体初始化描述信息 </li>
<li>S-&gt;C:DESCRIBE response //S回应媒体初始化描述信息，主要是sdp </li>
</ul>
<ul>
<li>C-&gt;S:SETUP request //设置会话的属性，以及传输模式，提醒S建立会话 </li>
<li>S-&gt;C:SETUP response //S建立会话，返回会话标识符，以及会话相关信息 </li>
</ul>
<ul>
<li>C-&gt;S:PLAY request //C请求播放 </li>
<li>S-&gt;C:PLAY response //S回应该请求的信息 </li>
</ul>
<h6 id="S-gt-C-发送流媒体数据"><a href="#S-gt-C-发送流媒体数据" class="headerlink" title="S-&gt;C:发送流媒体数据"></a>S-&gt;C:发送流媒体数据</h6><ul>
<li>C-&gt;S:TEARDOWN request //C请求关闭会话 </li>
<li>S-&gt;C:TEARDOWN response //S回应该请求</li>
</ul>
]]></content>
      <categories>
        <category>流媒体</category>
      </categories>
  </entry>
</search>
