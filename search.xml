<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git-03_gitlab的应用场景</title>
    <url>/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<blockquote>
<p>前面简单介绍了Web端gitlab的配置与准备工作，这里主要介绍gitlab的一些应用场景。</p>
</blockquote>
<p>以Linux为例，Windows平台和linux一样。<br>前面(2.2.1点击按钮“New project”建立项目)在建立一个新的project的时候出现Command line instructions,下面几乎所有的操作都是围绕着这几条命令。</p>
<a id="more"></a>

<h5 id="Command-line-instructions"><a href="#Command-line-instructions" class="headerlink" title="Command line instructions"></a>Command line instructions</h5><h6 id="Git-global-setup"><a href="#Git-global-setup" class="headerlink" title="Git global setup"></a>Git global setup</h6><p>在第一次使用时需要对Git进行设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;yhh&quot;</span><br><span class="line">git config --global user.email &quot;yihuihong@example.cn&quot;</span><br></pre></td></tr></table></figure>


<h6 id="Create-a-new-repository"><a href="#Create-a-new-repository" class="headerlink" title="Create a new repository"></a>Create a new repository</h6><p>从远程库中克隆一个空的project下来，然后创建新的文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@example.wicp.vip:example_firmware/test.git</span><br><span class="line">cd test</span><br><span class="line">touch README.md</span><br><span class="line">git add README.md	        //1.将代码从工作区中添加到版本库暂存区中去</span><br><span class="line">git commit -m &quot;add README&quot;  //2.把暂存区的所有修改提交到master分支上去</span><br><span class="line">git push -u origin master   //3.把分master支上代码push到远程仓库中去</span><br></pre></td></tr></table></figure>

<h6 id="Existing-folder"><a href="#Existing-folder" class="headerlink" title="Existing folder"></a>Existing folder</h6><p>我们一般用的是这个命令，将现有工程代码push到远程库中去。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd existing_folder</span><br><span class="line">git init //创建版本库，后面会有详细介绍（只有第一次操作即可，后面不用操作）</span><br><span class="line"></span><br><span class="line">关联仓库（两种push代码方式）</span><br><span class="line">git remote add origin http://example.wicp.vip/example_firmware/test.git /*走http协议（只有第一次操作即可，后面不用操作）*/</span><br><span class="line">git remote add origin git@192.168.0.xx:example_firmware/plug-in_framework.git /*走SSH协议 （只有第一次操作即可，后面不用操作）*/</span><br><span class="line"></span><br><span class="line">git add .                      //1.将代码从工作区中添加到版本库暂存区中去</span><br><span class="line">git commit -m &quot;Initial commit&quot; //2.把暂存区的所有修改提交到master分支上去</span><br><span class="line">git push -u origin master      //3.把分master支上代码push到远程仓库中去</span><br></pre></td></tr></table></figure>

<h6 id="Existing-Git-repository"><a href="#Existing-Git-repository" class="headerlink" title="Existing Git repository"></a>Existing Git repository</h6><p>没做研究（略）</p>
<h5 id="1-创建版本库"><a href="#1-创建版本库" class="headerlink" title="1.    创建版本库"></a>1.    创建版本库</h5><p>在linux平台相应项目工作目录中执行：git init 之后对应的工作目录中就会生成一个.git文件。这个是用来跟踪库管理版本库的，以后千万不要把这个删除了，不然之前的所有git记录都会被破坏掉。<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/1.png" alt="1"><br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/2.png" alt="2"></p>
<h5 id="2-关联仓库"><a href="#2-关联仓库" class="headerlink" title="2.  关联仓库"></a>2.  关联仓库</h5><p>将本地仓库和远程仓库进行关联，之后才能把内容添加到远程仓库中去。</p>
<h6 id="SSH方式"><a href="#SSH方式" class="headerlink" title="SSH方式"></a>SSH方式</h6><pre><code>git remote add origin git@192.168.0.xx:example_firmware/plug-in_framework.git  </code></pre><h6 id="HTTP方式"><a href="#HTTP方式" class="headerlink" title="HTTP方式"></a>HTTP方式</h6><pre><code>git remote add origin http://example.wicp.vip/example_firmware/test.git</code></pre><h5 id="3-代码管理"><a href="#3-代码管理" class="headerlink" title="3.    代码管理"></a>3.    代码管理</h5><p>代码管理，常用的几个命令，其实就是三板斧。</p>
<h6 id="3-1查看代码状态"><a href="#3-1查看代码状态" class="headerlink" title="3.1查看代码状态"></a>3.1查看代码状态</h6><p>执行命令：</p>
<pre><code>git status</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/3.png" alt="3"></p>
<h6 id="3-2-添加代码到版本库"><a href="#3-2-添加代码到版本库" class="headerlink" title="3.2    添加代码到版本库"></a>3.2    添加代码到版本库</h6><p>执行命令：</p>
<pre><code>git add .</code></pre><h6 id="3-3-将代码添加分支"><a href="#3-3-将代码添加分支" class="headerlink" title="3.3    将代码添加分支"></a>3.3    将代码添加分支</h6><p>执行命令：</p>
<pre><code>git commit -m “初次提交”</code></pre><p>（太多了就不上图了）</p>
<h6 id="3-4-将分支代码提交到远程库"><a href="#3-4-将分支代码提交到远程库" class="headerlink" title="3.4    将分支代码提交到远程库"></a>3.4    将分支代码提交到远程库</h6><p>执行命令：</p>
<pre><code>git push -u origin master(第一次执行命令需要加上-u，后面就不需要)</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/4.png" alt="4"></p>
<h5 id="4-版本回退"><a href="#4-版本回退" class="headerlink" title="4.    版本回退"></a>4.    版本回退</h5><p>我们这工作中，经常想知道我们在版本库中提交了多少版本，执行命令：</p>
<pre><code>git log</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/5.png" alt="5"></p>
<p>或者命令：</p>
<pre><code>git log --pretty=onelin</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/6.png" alt="6"><br>其中commit 4b10e619d0b82c574a34b2266ca40ad13b7d5622，是每一个版本的id 通过SHA1计算出来的。</p>
<p>或者命令：</p>
<pre><code>git reflog</code></pre><h6 id="4-1-代码回退到上一个版本"><a href="#4-1-代码回退到上一个版本" class="headerlink" title="4.1 代码回退到上一个版本"></a>4.1 代码回退到上一个版本</h6><p>执行命令：</p>
<pre><code>git reset --hard HEAD^</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/7.png" alt="7"><br>其中HEAD是当前版本的指针，^ 表示上一个版本，^^表示上上一个版本。</p>
<h6 id="4-2-代码回退指定版本"><a href="#4-2-代码回退指定版本" class="headerlink" title="4.2 代码回退指定版本"></a>4.2 代码回退指定版本</h6><p>指令命令：</p>
<pre><code>git reset --hard 57d3f9aa669dc646697064a97810b842a50fe1bc</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/8.png" alt="8"></p>
<h6 id="4-3-代码回退最新版本"><a href="#4-3-代码回退最新版本" class="headerlink" title="4.3 代码回退最新版本"></a>4.3 代码回退最新版本</h6><p>第一步，执行命令：</p>
<pre><code>git reflog //找到所有版本的 commit id</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/9.png" alt="9"></p>
<p>第二步，执行命令：</p>
<pre><code>git reset --hard 4b10e61</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/10.png" alt="10"></p>
<h5 id="5-多个分支"><a href="#5-多个分支" class="headerlink" title="5.    多个分支"></a>5.    多个分支</h5><p>平时开发，我们一般是master分支留作发布版本，dev分支做测试开发。</p>
<h6 id="5-1-建立新分支"><a href="#5-1-建立新分支" class="headerlink" title="5.1 建立新分支"></a>5.1 建立新分支</h6><p>执行一个命令：</p>
<pre><code>git checkout -b dev</code></pre><p>这个命令可分解为两步：git branch dev和git checkout dev</p>
<p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/11.png" alt="11"></p>
<blockquote>
<p>注意：切换dev分支时，需要将master分支中的代码 commit 到版本库中去，否则切换不成功，或者原有的代码将不保存。</p>
</blockquote>
<h6 id="5-2-查看分支"><a href="#5-2-查看分支" class="headerlink" title="5.2 查看分支"></a>5.2 查看分支</h6><p>执行命令：</p>
<pre><code>git branch</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/12.png" alt="12"><br>表示现在可以在dev分支上进行开发了，图中绿色字体。    </p>
<h6 id="5-3-合并分支"><a href="#5-3-合并分支" class="headerlink" title="5.3 合并分支"></a>5.3 合并分支</h6><p>在dev分支上修改代码并提交到版本库中去，然后进入master分支上去执行命令：</p>
<pre><code>git merge dev</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/13.png" alt="13"></p>
<h6 id="5-4-删除分支"><a href="#5-4-删除分支" class="headerlink" title="5.4 删除分支"></a>5.4 删除分支</h6><p>执行命令：</p>
<pre><code>git branch -d dev</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/14.png" alt="14"></p>
<h6 id="5-5-合并分支的冲突"><a href="#5-5-合并分支的冲突" class="headerlink" title="5.5 合并分支的冲突"></a>5.5 合并分支的冲突</h6><p>所谓的冲突，就是多个分支之间不同步，一般我们在修改master分支代码之前，先pull一下代码，不然就会出现下面这种冲突的情况，出现这种情况，我们就需要把git合并失败的文件手动编辑为我们希望的内容，再提交。</p>
<p>第一步：创建并修改一个分支，然后提交。如下：<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/15.png" alt="15"></p>
<p>第二步：切换到master分支，并修改master分支，之后合并dev1分支。<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/16.png" alt="16"><br>可以看到有合并冲突，同时查看readme.txt<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/17.png" alt="17"><br>这种情况就是冲突，必须需要手动解决冲突后再提交。删除readme.txt不需要的部分然后再commit上去即可。<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/18.png" alt="18"><br>执行命令：</p>
<pre><code>git log --graph --pretty=oneline --abbrev-commit</code></pre><p>可以查看分子合并的情况，如图。</p>
<p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/19.png" alt="19"></p>
<h6 id="5-6-多人协作"><a href="#5-6-多人协作" class="headerlink" title="5.6 多人协作"></a>5.6 多人协作</h6><p>多人协作时，大家都会往master和dev分支上推送各自的修改。假设你是A，同时有一个人B在另一台电脑（注意要把SSH Key添加到GitLab）或者同一台电脑的另一个目录下克隆。</p>
<p>执行命令：</p>
<pre><code>git clone git@192.168.0.xx:xxx_firmware/test.git</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/20.png" alt="20"></p>
<p>默认情况下就是master分支，如下：git branch<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/21.png" alt="21"></p>
<p>此时B会在dev分支上开发并push代码<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/22.png" alt="22"></p>
<p>然后A也做了修改，同时将代码push到dev分支上去，如下<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/23.png" alt="23"></p>
<p>上面显示推送失败，因为B在最新的提交和A的提交有冲突，解决方法就是先将远程库的代码拉取下来，看下图。</p>
<p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/24.png" alt="24"><br>注意：在拉取代码失败的时候，需要指定本地的dev分支和远程库的origin/dev分支的关联。同时查看本地readme.txt分支修改情况，可以发现<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/25.png" alt="25"></p>
<p>这个时候和5.6合并分支的冲突一样。解决之后再提交，最后在push。<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/26.png" alt="26"></p>
<h5 id="6-标签设定与版本号"><a href="#6-标签设定与版本号" class="headerlink" title="6.    标签设定与版本号"></a>6.    标签设定与版本号</h5><p>Gitlab没push一个版本代码都有一个commit id，我们根据这些commit id 可以给他们打上一个标签，这写标签可以是一个版本号。</p>
<h6 id="6-1-默认标签"><a href="#6-1-默认标签" class="headerlink" title="6.1 默认标签"></a>6.1 默认标签</h6><p>默认标签是打在最新提交的commit上的如下：<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/27.png" alt="27"></p>
<h6 id="6-2-指定commit-id-上打标签"><a href="#6-2-指定commit-id-上打标签" class="headerlink" title="6.2    指定commit id 上打标签"></a>6.2    指定commit id 上打标签</h6><p>第一步：</p>
<pre><code>git log --pretty=oneline --abbrev-commit</code></pre><p>找到所有master分支上提交版本commit id</p>
<p>第二步：</p>
<pre><code>git tag v0.9 8c1b181 </code></pre><p>指定commit 打标签</p>
<h6 id="6-3-查看具体标签具体信息"><a href="#6-3-查看具体标签具体信息" class="headerlink" title="6.3    查看具体标签具体信息"></a>6.3    查看具体标签具体信息</h6><p>执行命令：</p>
<pre><code>git show v0.9</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/28.png" alt="28"></p>
<h6 id="6-4-推送标签"><a href="#6-4-推送标签" class="headerlink" title="6.4    推送标签"></a>6.4    推送标签</h6><p>推送某一个标签：</p>
<pre><code>git push origin v1.0</code></pre><p>推送所有标签：</p>
<pre><code>git push origin –tags</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/29.png" alt="29"></p>
<p>此时观察Web端：<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/30.png" alt="30"><br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/31.png" alt="31"><br>这个就是标签。</p>
<h6 id="6-5-删除标签"><a href="#6-5-删除标签" class="headerlink" title="6.5    删除标签"></a>6.5    删除标签</h6><p>若标签只存在本地，直接执行命令：</p>
<pre><code>git tag -d v1.0</code></pre><p>若标签已经推送到远程，要删除远程标签需要<br>第一步，先删除本地标签：</p>
<pre><code>git tag -d v1.0</code></pre><p>第二步，再删除远程的标签：</p>
<pre><code>git push origin :refs/tags/v1.0</code></pre>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言-shell命令方式&函数方式执行汇总</title>
    <url>/2020/01/10/C%E8%AF%AD%E8%A8%80-shell%E5%91%BD%E4%BB%A4%E6%96%B9%E5%BC%8F-%E5%87%BD%E6%95%B0%E6%96%B9%E5%BC%8F%E6%89%A7%E8%A1%8C%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h5 id="一、调用system执行shell命令"><a href="#一、调用system执行shell命令" class="headerlink" title="一、调用system执行shell命令"></a>一、调用system执行shell命令</h5><p><strong>编译验证过的源码码</strong>：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">#define FILE_PATH_HISI_TAR &quot;/mnt/hgfs/VMWARE/curl/app/temp/&quot;</span><br><span class="line">#define FILE_PATH_HISI_TAR_AFTER &quot;/mnt/hgfs/VMWARE/curl/app/temp/root/&quot;	</span><br><span class="line">#define FILE_PATH_MD5 &quot;/mnt/hgfs/VMWARE/test/12-shell_cmd_func/&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int shell_system(char *pcmd)</span><br><span class="line">&#123;</span><br><span class="line">	pid_t status;</span><br><span class="line">	</span><br><span class="line">	printf(&quot;execute cmd:%s\n&quot;,pcmd);</span><br><span class="line">	status = system(pcmd);</span><br><span class="line">	if (-1 == status)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;system error!&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">    &#125;</span><br><span class="line">	if(WIFEXITED(status) != 0)//正常退出</span><br><span class="line">	&#123;</span><br><span class="line">		if(WEXITSTATUS(status) == 0)//操作正确</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;run command success\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;run error\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else//异常退出</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;exit error is %d\n&quot;, WEXITSTATUS(status));</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">	char shell_cmd_ls[128];</span><br><span class="line">	char shell_cmd_tar[128];</span><br><span class="line">	char shell_cmd_md5[128];</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	sprintf(shell_cmd_ls,&quot;ls -al&quot;);</span><br><span class="line">	if(0 != shell_system(shell_cmd_ls))</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;System call failed!\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">/* 	</span><br><span class="line">	//解压文件</span><br><span class="line">	sprintf(shell_cmd_tar,&quot;tar zxvf %s%s -C %s&quot;,FILE_PATH_HISI_TAR,&quot;hisi_app.tar.gz&quot;,FILE_PATH_HISI_TAR_AFTER);</span><br><span class="line">	if(0 != shell_system(shell_cmd_tar))</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;System call failed!\n&quot;);</span><br><span class="line">	&#125;	</span><br><span class="line">	</span><br><span class="line">	//拷贝文件</span><br><span class="line">	//删除文件</span><br><span class="line">	//统计文件</span><br><span class="line">	//改变文件权限</span><br><span class="line">	//计算md5值</span><br><span class="line">	sprintf(shell_cmd_md5,&quot;md5sum %s%s&quot;,FILE_PATH_MD5,&quot;chmod.c&quot;);</span><br><span class="line">	if(0 != shell_system(shell_cmd_md5))</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;System call failed!\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="二、调用popen执行shell命令"><a href="#二、调用popen执行shell命令" class="headerlink" title="二、调用popen执行shell命令"></a>二、调用popen执行shell命令</h5><p><strong>编译验证过的源码码</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">#define FILE_PATH_HISI_TAR &quot;/mnt/hgfs/VMWARE/curl/app/temp/&quot;</span><br><span class="line">#define FILE_PATH_HISI_TAR_AFTER &quot;/mnt/hgfs/VMWARE/curl/app/temp/root/&quot;	</span><br><span class="line">#define FILE_PATH_MD5 &quot;/mnt/hgfs/VMWARE/test/12-shell_cmd_func/&quot;</span><br><span class="line"></span><br><span class="line">int shell_popen(char *pbuf,char *pfile_path)</span><br><span class="line">&#123;</span><br><span class="line">	char cmd_buf[64];</span><br><span class="line">	FILE* fp = NULL;</span><br><span class="line">	sprintf(cmd_buf,&quot;md5sum %s&quot;,pfile_path);</span><br><span class="line">	fp = popen(cmd_buf, &quot;r&quot;);</span><br><span class="line">	if(NULL == fp)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(&quot;popen&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	while(fgets(pbuf, 1024, fp) != NULL);</span><br><span class="line"></span><br><span class="line">	pclose(fp);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void) </span><br><span class="line">&#123;</span><br><span class="line">	char buf[128] = &#123;0&#125;;</span><br><span class="line">	char file_path[128];</span><br><span class="line">	</span><br><span class="line">	//ls -al</span><br><span class="line">	//拷贝文件</span><br><span class="line">	//删除文件</span><br><span class="line">	//统计文件</span><br><span class="line">	//改变文件权限</span><br><span class="line">	//解压文件</span><br><span class="line">	//计算md5值</span><br><span class="line">	sprintf(file_path,&quot;%s/%s&quot;,FILE_PATH_MD5,&quot;chmod.c&quot;);</span><br><span class="line">	if(0 == shell_popen(buf,file_path))</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;MD5:%s\n&quot;, buf);</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		printf(&quot;get MD5&apos;s value is failed!\n&quot;);</span><br><span class="line">	&#125;	</span><br><span class="line">	memset(buf, 0x0, sizeof(buf));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以前用shell命令通过管道或者系统方式执行一条命令，这样会在线程里面开启新的进程，从而会造成代码出现不可控的状态。<br>管道或者system会返回出各种状态值，这些状态值是不可控。</p>
<h5 id="三、函数方式删除文件"><a href="#三、函数方式删除文件" class="headerlink" title="三、函数方式删除文件"></a>三、函数方式删除文件</h5><p><strong>编译验证过的源码码</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef _DELETE_FILE</span><br><span class="line">#define _DELETE_FILE</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;limits.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line"></span><br><span class="line">//判断是否为目录</span><br><span class="line">bool is_dir(const char *path)</span><br><span class="line">&#123;</span><br><span class="line">    struct stat statbuf;</span><br><span class="line">    if(lstat(path, &amp;statbuf) ==0)//lstat返回文件的信息，文件信息存放在stat结构中</span><br><span class="line">    &#123;</span><br><span class="line">        return S_ISDIR(statbuf.st_mode) != 0;//S_ISDIR宏，判断文件类型是否为目录</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//判断是否为常规文件</span><br><span class="line">bool is_file(const char *path)</span><br><span class="line">&#123;</span><br><span class="line">    struct stat statbuf;</span><br><span class="line">    if(lstat(path, &amp;statbuf) ==0)</span><br><span class="line">        return S_ISREG(statbuf.st_mode) != 0;//判断文件是否为常规文件</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//判断是否是特殊目录</span><br><span class="line">bool is_special_dir(const char *path)</span><br><span class="line">&#123;</span><br><span class="line">    return strcmp(path, &quot;.&quot;) == 0 || strcmp(path, &quot;..&quot;) == 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//生成完整的文件路径</span><br><span class="line">void get_file_path(const char *path, const char *file_name,  char *file_path)</span><br><span class="line">&#123;</span><br><span class="line">    strcpy(file_path, path);</span><br><span class="line">    if(file_path[strlen(path) - 1] != &apos;/&apos;)</span><br><span class="line">        strcat(file_path, &quot;/&quot;);</span><br><span class="line">    strcat(file_path, file_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void delete_file(const char *path)</span><br><span class="line">&#123;</span><br><span class="line">    DIR *dir;</span><br><span class="line">    struct dirent *dir_info;</span><br><span class="line">    char file_path[PATH_MAX];</span><br><span class="line">    if(is_file(path))</span><br><span class="line">    &#123;</span><br><span class="line">        remove(path);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(is_dir(path))</span><br><span class="line">    &#123;</span><br><span class="line">        if((dir = opendir(path)) == NULL)</span><br><span class="line">            return;</span><br><span class="line">        while((dir_info = readdir(dir)) != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            get_file_path(path, dir_info-&gt;d_name, file_path);</span><br><span class="line">            if(is_special_dir(dir_info-&gt;d_name))</span><br><span class="line">                continue;</span><br><span class="line">            delete_file(file_path);</span><br><span class="line">            rmdir(file_path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;argv[1]=%s\n&quot;,argv[1]);</span><br><span class="line">    delete_file(argv[1]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<h5 id="四、函数方式统计某个目录下的文件个数"><a href="#四、函数方式统计某个目录下的文件个数" class="headerlink" title="四、函数方式统计某个目录下的文件个数"></a>四、函数方式统计某个目录下的文件个数</h5><p><strong>编译验证过的源码码</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define MAX 1024</span><br><span class="line">/*</span><br><span class="line">返回值,返回该文件夹中的文件个数</span><br><span class="line">参数ppathfile,所求文件夹目录的路径</span><br><span class="line">*/</span><br><span class="line">int get_file_count(char *ppathfile)</span><br><span class="line">&#123;</span><br><span class="line">	DIR *dir;</span><br><span class="line">	struct dirent * ptr;</span><br><span class="line">	int total = 0;</span><br><span class="line">	char path[MAX];</span><br><span class="line">	dir = opendir(ppathfile); /* 打开目录*/</span><br><span class="line">	if(dir == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(&quot;fail to open dir&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	errno = 0;</span><br><span class="line">	while((ptr = readdir(dir)) != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		//顺序读取每一个目录项；</span><br><span class="line">		//跳过“..”和“.”两个目录</span><br><span class="line">		if(strcmp(ptr-&gt;d_name,&quot;.&quot;) == 0 || strcmp(ptr-&gt;d_name,&quot;..&quot;) == 0)</span><br><span class="line">		&#123;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		//printf(&quot;%s%s\n&quot;,ppathfile,ptr-&gt;d_name);</span><br><span class="line">		//如果是目录，则递归调用 get_file_count函数</span><br><span class="line">		if(ptr-&gt;d_type == DT_DIR)</span><br><span class="line">		&#123;</span><br><span class="line">			sprintf(path,&quot;%s%s/&quot;,ppathfile,ptr-&gt;d_name);</span><br><span class="line">			//printf(&quot;%s\n&quot;,path);</span><br><span class="line">			</span><br><span class="line">			total += get_file_count(path);</span><br><span class="line">		&#125;</span><br><span class="line">		if(ptr-&gt;d_type == DT_REG)</span><br><span class="line">		&#123;</span><br><span class="line">			total++;</span><br><span class="line">			printf(&quot;%s%s\n&quot;,ppathfile,ptr-&gt;d_name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	if(errno != 0)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;fail to read dir&quot;); //失败则输出提示信息</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	closedir(dir);</span><br><span class="line">	return total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int total;</span><br><span class="line">	if(argc != 2)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;wrong usage\n&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	total = get_file_count(argv[1]);</span><br><span class="line">	printf(&quot;%s have %d files\n&quot;,argv[1],total);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h5 id="五、函数方式改变文件权限"><a href="#五、函数方式改变文件权限" class="headerlink" title="五、函数方式改变文件权限"></a>五、函数方式改变文件权限</h5><p><strong>编译验证过的源码码</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    chmod(&quot;/home/yhh/123&quot;, S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IWGRP|S_IXGRP|S_IROTH|S_IWOTH|S_IXOTH);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#if 0</span><br><span class="line">函数说明：</span><br><span class="line">chmod()会依参数mode 权限来更改参数path 指定文件的权限</span><br><span class="line"></span><br><span class="line">参数 mode 有下列数种组合：</span><br><span class="line">S_ISUID 04000 文件的 (set user-id on execution)位</span><br><span class="line">S_ISGID 02000 文件的 (set group-id on execution)位</span><br><span class="line">S_ISVTX 01000 文件的sticky 位</span><br><span class="line">S_IRUSR (S_IREAD) 00400 文件所有者具可读取权限</span><br><span class="line">S_IWUSR (S_IWRITE)00200 文件所有者具可写入权限</span><br><span class="line">S_IXUSR (S_IEXEC) 00100 文件所有者具可执行权限</span><br><span class="line">S_IRGRP 00040 用户组具可读取权限</span><br><span class="line">S_IWGRP 00020 用户组具可写入权限</span><br><span class="line">S_IXGRP 00010 用户组具可执行权限</span><br><span class="line">S_IROTH 00004 其他用户具可读取权限</span><br><span class="line">S_IWOTH 00002 其他用户具可写入权限</span><br><span class="line">S_IXOTH 00001 其他用户具可执行权限</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>



<h5 id="六、函数方式计算文件的md5值"><a href="#六、函数方式计算文件的md5值" class="headerlink" title="六、函数方式计算文件的md5值"></a>六、函数方式计算文件的md5值</h5><p><strong>编译验证过的源码码</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned int count[2];  </span><br><span class="line">    unsigned int state[4];  </span><br><span class="line">    unsigned char buffer[64];     </span><br><span class="line">&#125;MD5_CTX;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define F(x,y,z) ((x &amp; y) | (~x &amp; z))  </span><br><span class="line">#define G(x,y,z) ((x &amp; z) | (y &amp; ~z))  </span><br><span class="line">#define H(x,y,z) (x^y^z)  </span><br><span class="line">#define I(x,y,z) (y ^ (x | ~z))  </span><br><span class="line">#define ROTATE_LEFT(x,n) ((x &lt;&lt; n) | (x &gt;&gt; (32-n)))  </span><br><span class="line">#define FF(a,b,c,d,x,s,ac) \</span><br><span class="line">&#123; \</span><br><span class="line">    a += F(b,c,d) + x + ac; \</span><br><span class="line">    a = ROTATE_LEFT(a,s); \</span><br><span class="line">    a += b; \</span><br><span class="line">&#125;  </span><br><span class="line">#define GG(a,b,c,d,x,s,ac) \</span><br><span class="line">&#123; \</span><br><span class="line">    a += G(b,c,d) + x + ac; \</span><br><span class="line">    a = ROTATE_LEFT(a,s); \</span><br><span class="line">    a += b; \</span><br><span class="line">&#125;  </span><br><span class="line">#define HH(a,b,c,d,x,s,ac) \</span><br><span class="line">&#123; \</span><br><span class="line">    a += H(b,c,d) + x + ac; \</span><br><span class="line">    a = ROTATE_LEFT(a,s); \</span><br><span class="line">    a += b; \</span><br><span class="line">&#125;  </span><br><span class="line">#define II(a,b,c,d,x,s,ac) \</span><br><span class="line">&#123; \</span><br><span class="line">    a += I(b,c,d) + x + ac; \</span><br><span class="line">    a = ROTATE_LEFT(a,s); \</span><br><span class="line">    a += b; \</span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line">unsigned char PADDING[]=&#123;</span><br><span class="line">	0x80,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  </span><br><span class="line">	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  </span><br><span class="line">	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  </span><br><span class="line">	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">void MD5Encode(unsigned char *output,unsigned int *input,unsigned int len)  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned int i = 0,j = 0;  </span><br><span class="line">    while(j &lt; len)  </span><br><span class="line">    &#123;  </span><br><span class="line">        output[j] = input[i] &amp; 0xFF;    </span><br><span class="line">        output[j+1] = (input[i] &gt;&gt; 8) &amp; 0xFF;  </span><br><span class="line">        output[j+2] = (input[i] &gt;&gt; 16) &amp; 0xFF;  </span><br><span class="line">        output[j+3] = (input[i] &gt;&gt; 24) &amp; 0xFF;  </span><br><span class="line">        i++;  </span><br><span class="line">        j+=4;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">void MD5Decode(unsigned int *output,unsigned char *input,unsigned int len)  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned int i = 0,j = 0;  </span><br><span class="line">    while(j &lt; len)  </span><br><span class="line">    &#123;  </span><br><span class="line">        output[i] = (input[j]) |  </span><br><span class="line">            (input[j+1] &lt;&lt; 8) |  </span><br><span class="line">            (input[j+2] &lt;&lt; 16) |  </span><br><span class="line">            (input[j+3] &lt;&lt; 24);  </span><br><span class="line">        i++;  </span><br><span class="line">        j+=4;   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">void MD5Transform(unsigned int state[4],unsigned char block[64])  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned int a = state[0];  </span><br><span class="line">    unsigned int b = state[1];  </span><br><span class="line">    unsigned int c = state[2];  </span><br><span class="line">    unsigned int d = state[3];  </span><br><span class="line">    unsigned int x[64];  </span><br><span class="line">    MD5Decode(x,block,64);  </span><br><span class="line">    FF(a, b, c, d, x[ 0], 7, 0xd76aa478);   </span><br><span class="line">    FF(d, a, b, c, x[ 1], 12, 0xe8c7b756);   </span><br><span class="line">    FF(c, d, a, b, x[ 2], 17, 0x242070db);   </span><br><span class="line">    FF(b, c, d, a, x[ 3], 22, 0xc1bdceee);   </span><br><span class="line">    FF(a, b, c, d, x[ 4], 7, 0xf57c0faf);   </span><br><span class="line">    FF(d, a, b, c, x[ 5], 12, 0x4787c62a);   </span><br><span class="line">    FF(c, d, a, b, x[ 6], 17, 0xa8304613);   </span><br><span class="line">    FF(b, c, d, a, x[ 7], 22, 0xfd469501);   </span><br><span class="line">    FF(a, b, c, d, x[ 8], 7, 0x698098d8);   </span><br><span class="line">    FF(d, a, b, c, x[ 9], 12, 0x8b44f7af);   </span><br><span class="line">    FF(c, d, a, b, x[10], 17, 0xffff5bb1);   </span><br><span class="line">    FF(b, c, d, a, x[11], 22, 0x895cd7be);   </span><br><span class="line">    FF(a, b, c, d, x[12], 7, 0x6b901122);   </span><br><span class="line">    FF(d, a, b, c, x[13], 12, 0xfd987193);   </span><br><span class="line">    FF(c, d, a, b, x[14], 17, 0xa679438e);   </span><br><span class="line">    FF(b, c, d, a, x[15], 22, 0x49b40821);   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    GG(a, b, c, d, x[ 1], 5, 0xf61e2562);   </span><br><span class="line">    GG(d, a, b, c, x[ 6], 9, 0xc040b340);   </span><br><span class="line">    GG(c, d, a, b, x[11], 14, 0x265e5a51);   </span><br><span class="line">    GG(b, c, d, a, x[ 0], 20, 0xe9b6c7aa);   </span><br><span class="line">    GG(a, b, c, d, x[ 5], 5, 0xd62f105d);   </span><br><span class="line">    GG(d, a, b, c, x[10], 9,  0x2441453);   </span><br><span class="line">    GG(c, d, a, b, x[15], 14, 0xd8a1e681);   </span><br><span class="line">    GG(b, c, d, a, x[ 4], 20, 0xe7d3fbc8);   </span><br><span class="line">    GG(a, b, c, d, x[ 9], 5, 0x21e1cde6);   </span><br><span class="line">    GG(d, a, b, c, x[14], 9, 0xc33707d6);   </span><br><span class="line">    GG(c, d, a, b, x[ 3], 14, 0xf4d50d87);   </span><br><span class="line">    GG(b, c, d, a, x[ 8], 20, 0x455a14ed);   </span><br><span class="line">    GG(a, b, c, d, x[13], 5, 0xa9e3e905);   </span><br><span class="line">    GG(d, a, b, c, x[ 2], 9, 0xfcefa3f8);   </span><br><span class="line">    GG(c, d, a, b, x[ 7], 14, 0x676f02d9);   </span><br><span class="line">    GG(b, c, d, a, x[12], 20, 0x8d2a4c8a);   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    HH(a, b, c, d, x[ 5], 4, 0xfffa3942);   </span><br><span class="line">    HH(d, a, b, c, x[ 8], 11, 0x8771f681);   </span><br><span class="line">    HH(c, d, a, b, x[11], 16, 0x6d9d6122);   </span><br><span class="line">    HH(b, c, d, a, x[14], 23, 0xfde5380c);   </span><br><span class="line">    HH(a, b, c, d, x[ 1], 4, 0xa4beea44);   </span><br><span class="line">    HH(d, a, b, c, x[ 4], 11, 0x4bdecfa9);   </span><br><span class="line">    HH(c, d, a, b, x[ 7], 16, 0xf6bb4b60);   </span><br><span class="line">    HH(b, c, d, a, x[10], 23, 0xbebfbc70);   </span><br><span class="line">    HH(a, b, c, d, x[13], 4, 0x289b7ec6);   </span><br><span class="line">    HH(d, a, b, c, x[ 0], 11, 0xeaa127fa);   </span><br><span class="line">    HH(c, d, a, b, x[ 3], 16, 0xd4ef3085);   </span><br><span class="line">    HH(b, c, d, a, x[ 6], 23,  0x4881d05);   </span><br><span class="line">    HH(a, b, c, d, x[ 9], 4, 0xd9d4d039);   </span><br><span class="line">    HH(d, a, b, c, x[12], 11, 0xe6db99e5);   </span><br><span class="line">    HH(c, d, a, b, x[15], 16, 0x1fa27cf8);   </span><br><span class="line">    HH(b, c, d, a, x[ 2], 23, 0xc4ac5665);   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    II(a, b, c, d, x[ 0], 6, 0xf4292244);   </span><br><span class="line">    II(d, a, b, c, x[ 7], 10, 0x432aff97);   </span><br><span class="line">    II(c, d, a, b, x[14], 15, 0xab9423a7);   </span><br><span class="line">    II(b, c, d, a, x[ 5], 21, 0xfc93a039);   </span><br><span class="line">    II(a, b, c, d, x[12], 6, 0x655b59c3);   </span><br><span class="line">    II(d, a, b, c, x[ 3], 10, 0x8f0ccc92);   </span><br><span class="line">    II(c, d, a, b, x[10], 15, 0xffeff47d);   </span><br><span class="line">    II(b, c, d, a, x[ 1], 21, 0x85845dd1);   </span><br><span class="line">    II(a, b, c, d, x[ 8], 6, 0x6fa87e4f);   </span><br><span class="line">    II(d, a, b, c, x[15], 10, 0xfe2ce6e0);   </span><br><span class="line">    II(c, d, a, b, x[ 6], 15, 0xa3014314);   </span><br><span class="line">    II(b, c, d, a, x[13], 21, 0x4e0811a1);   </span><br><span class="line">    II(a, b, c, d, x[ 4], 6, 0xf7537e82);   </span><br><span class="line">    II(d, a, b, c, x[11], 10, 0xbd3af235);   </span><br><span class="line">    II(c, d, a, b, x[ 2], 15, 0x2ad7d2bb);   </span><br><span class="line">    II(b, c, d, a, x[ 9], 21, 0xeb86d391);   </span><br><span class="line">    state[0] += a;  </span><br><span class="line">    state[1] += b;  </span><br><span class="line">    state[2] += c;  </span><br><span class="line">    state[3] += d;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">void MD5Init(MD5_CTX *context)  </span><br><span class="line">&#123;  </span><br><span class="line">    context-&gt;count[0] = 0;  </span><br><span class="line">    context-&gt;count[1] = 0;  </span><br><span class="line">    context-&gt;state[0] = 0x67452301;  </span><br><span class="line">    context-&gt;state[1] = 0xEFCDAB89;  </span><br><span class="line">    context-&gt;state[2] = 0x98BADCFE;  </span><br><span class="line">    context-&gt;state[3] = 0x10325476;  </span><br><span class="line">&#125;  </span><br><span class="line">void MD5Update(MD5_CTX *context,unsigned char *input,unsigned int inputlen)  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned int i = 0,index = 0,partlen = 0;  </span><br><span class="line">    index = (context-&gt;count[0] &gt;&gt; 3) &amp; 0x3F;  </span><br><span class="line">    partlen = 64 - index;  </span><br><span class="line">    context-&gt;count[0] += inputlen &lt;&lt; 3;  </span><br><span class="line">    if(context-&gt;count[0] &lt; (inputlen &lt;&lt; 3))  </span><br><span class="line">        context-&gt;count[1]++;  </span><br><span class="line">    context-&gt;count[1] += inputlen &gt;&gt; 29;  </span><br><span class="line"></span><br><span class="line">    if(inputlen &gt;= partlen)  </span><br><span class="line">    &#123;  </span><br><span class="line">        memcpy(&amp;context-&gt;buffer[index],input,partlen);  </span><br><span class="line">        MD5Transform(context-&gt;state,context-&gt;buffer);  </span><br><span class="line">        for(i = partlen;i+64 &lt;= inputlen;i+=64)  </span><br><span class="line">            MD5Transform(context-&gt;state,&amp;input[i]);  </span><br><span class="line">        index = 0;          </span><br><span class="line">    &#125;    </span><br><span class="line">    else  </span><br><span class="line">    &#123;  </span><br><span class="line">        i = 0;  </span><br><span class="line">    &#125;  </span><br><span class="line">    memcpy(&amp;context-&gt;buffer[index],&amp;input[i],inputlen-i);  </span><br><span class="line">&#125;  </span><br><span class="line">void MD5Final(MD5_CTX *context,unsigned char digest[16])  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned int index = 0,padlen = 0;  </span><br><span class="line">    unsigned char bits[8];  </span><br><span class="line">    index = (context-&gt;count[0] &gt;&gt; 3) &amp; 0x3F;  </span><br><span class="line">    padlen = (index &lt; 56)?(56-index):(120-index);  </span><br><span class="line">    MD5Encode(bits,context-&gt;count,8);  </span><br><span class="line">    MD5Update(context,PADDING,padlen);  </span><br><span class="line">    MD5Update(context,bits,8);  </span><br><span class="line">    MD5Encode(digest,context-&gt;state,16);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* md5函数测试 */</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	FILE *fp = fopen(&quot;chmod.c&quot;, &quot;r&quot;);</span><br><span class="line">    struct stat st;</span><br><span class="line">    unsigned char digest[16] = &#123;0&#125;;</span><br><span class="line">    MD5_CTX context;</span><br><span class="line">    int i = 0;</span><br><span class="line"></span><br><span class="line">    MD5Init(&amp;context);</span><br><span class="line">	if(0 == stat(&quot;chmod.c&quot;, &amp;st))//获取文件信息</span><br><span class="line">    &#123;</span><br><span class="line">		/* 计算文件MD5 */	</span><br><span class="line">		char *data = NULL;</span><br><span class="line">		int ret = 0;</span><br><span class="line"></span><br><span class="line">		if(!fp)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(&quot;fopen&quot;);</span><br><span class="line">			exit(-1);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		data = malloc(st.st_size);</span><br><span class="line">		if(!data)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(&quot;malloc&quot;);</span><br><span class="line">			exit(-1);</span><br><span class="line">		&#125;</span><br><span class="line">		ret = fread(data, 1, st.st_size, fp);</span><br><span class="line">		if(ret != st.st_size)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(&quot;fread&quot;);</span><br><span class="line">			exit(-1);</span><br><span class="line">		&#125; </span><br><span class="line">		MD5Update(&amp;context, data, st.st_size);</span><br><span class="line">		fclose(fp);</span><br><span class="line">		free(data);		</span><br><span class="line">    &#125;</span><br><span class="line">    MD5Final(&amp;context, digest);</span><br><span class="line"></span><br><span class="line">    /* 打印MD5值 */</span><br><span class="line">    printf(&quot;md5: &quot;);</span><br><span class="line">    for(i = 0; i &lt; 16; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%02x&quot;, digest[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="七、函数方式查看磁盘空间"><a href="#七、函数方式查看磁盘空间" class="headerlink" title="七、函数方式查看磁盘空间"></a>七、函数方式查看磁盘空间</h5><p><strong>编译验证过的源码码</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/statfs.h&gt;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">void get_system_available(unsigned long long *pavailable)</span><br><span class="line">&#123;</span><br><span class="line">	struct statfs diskInfo;</span><br><span class="line">	</span><br><span class="line">	statfs(&quot;/&quot;, &amp;diskInfo);</span><br><span class="line">	unsigned long long blocksize = diskInfo.f_bsize;	//每个block里包含的字节数</span><br><span class="line">	unsigned long long totalsize = blocksize * diskInfo.f_blocks; 	//总的字节数，f_blocks为block的数目</span><br><span class="line">	printf(&quot;Total_size = %llu B = %llu KB = %llu MB = %llu GB\n&quot;, totalsize, totalsize&gt;&gt;10, totalsize&gt;&gt;20, totalsize&gt;&gt;30);</span><br><span class="line">	</span><br><span class="line">	unsigned long long freeDisk = diskInfo.f_bfree * blocksize;	//剩余空间的大小</span><br><span class="line">	*pavailable = diskInfo.f_bavail * blocksize; 	//可用空间大小</span><br><span class="line">	printf(&quot;Disk_free = %llu MB = %llu GB\n&quot;, freeDisk&gt;&gt;20, freeDisk&gt;&gt;30);</span><br><span class="line">	//printf(&quot;Disk_available = %llu MB = %llu GB\n&quot;, availableDisk&gt;&gt;20, availableDisk&gt;&gt;30);</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;	</span><br><span class="line">	unsigned long long available;</span><br><span class="line">	get_system_available(&amp;available);</span><br><span class="line">	printf(&quot;Disk_available = %llu MB = %llu GB\n&quot;, available&gt;&gt;20, available&gt;&gt;30);</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>system</tag>
        <tag>popen</tag>
        <tag>remove</tag>
        <tag>dirent</tag>
        <tag>chmod</tag>
        <tag>MD5</tag>
        <tag>statfs</tag>
      </tags>
  </entry>
  <entry>
    <title>Git-02_gitlab的配置与准备工作</title>
    <url>/2020/01/01/Git-02-gitlab%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/</url>
    <content><![CDATA[<blockquote>
<p>前面简单介绍了Web端gitlab的一些基本信息，这里主要介绍gitlab 一些配置和准备工作。</p>
</blockquote>
<h5 id="1-修改密码和邮箱"><a href="#1-修改密码和邮箱" class="headerlink" title="1.修改密码和邮箱"></a>1.修改密码和邮箱</h5><p>略</p>
<h5 id="2-配置SSH-Keys"><a href="#2-配置SSH-Keys" class="headerlink" title="2.配置SSH Keys"></a>2.配置SSH Keys</h5><p>前面Web端介绍时提到了SSH Keys的设置（见web端界面2.12账户设置）。<br>在往前我们建立一个新项目的时候也看到了一个SSH协议（见Web界面2.2.1点击按钮“New project”建立一个新项目，那里还有一个http协议，http协议不需要配置，但是push代码比较慢）。<br>都有提到关于SSH，这是因为我们git仓库和Gitlab仓库之间是通过SSH加密的，所以需要进行相应的配置。</p>
<a id="more"></a>

<h6 id="第1步：创建SSH-Key"><a href="#第1步：创建SSH-Key" class="headerlink" title="第1步：创建SSH Key"></a>第1步：创建SSH Key</h6><p>在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：<br>ssh-keygen -t rsa -C <a href="mailto:email@example.com" target="_blank" rel="noopener">email@example.com</a><br>之后一路回车，使用默认值，就可以获得一个Key值。一切顺利可以在用户主目录下面找到.ssh文件夹，可以看到里面有两个文件id_rsa和id_rsa.pub。其中id_rsa是私钥，id_rsa.pub是公钥。</p>
<p>如图：<br><img src="/2020/01/01/Git-02-gitlab%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/1.png" alt="1"></p>
<h6 id="第2步：登陆GitLab，打开账户设置，“SSH-Keys”页面："><a href="#第2步：登陆GitLab，打开账户设置，“SSH-Keys”页面：" class="headerlink" title="第2步：登陆GitLab，打开账户设置，“SSH Keys”页面："></a>第2步：登陆GitLab，打开账户设置，“SSH Keys”页面：</h6><p><img src="/2020/01/01/Git-02-gitlab%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/2.png" alt="2"></p>
<p><img src="/2020/01/01/Git-02-gitlab%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/3.png" alt="3"><br>这样就成功添加了。<br>其实在前面创建项目的时候提示这个，就表示要添加SSH Keys了。<br><img src="/2020/01/01/Git-02-gitlab%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/4.png" alt="4"></p>
<h5 id="3-安装Git"><a href="#3-安装Git" class="headerlink" title="3.安装Git"></a>3.安装Git</h5><p>Windows端需要下载一个git 客户端工具GitHubDesktopSetup.exe，这里主要是以Linux为主。<br>执行命令：</p>
<pre><code>sudo apt install git</code></pre><p>然后直接安装即可。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>Git-01_gitlab的Web端界面</title>
    <url>/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<h4 id="一、gitlab的登录"><a href="#一、gitlab的登录" class="headerlink" title="一、gitlab的登录"></a>一、gitlab的登录</h4><p>Web网页输入：<a href="http://xxx.wicp.vip/" target="_blank" rel="noopener">http://xxx.wicp.vip/</a> 进入gitlab登录界面，输入账号密码之后，选择 standard登录，进入Web页面。不同权限的人进入的界面是不一样的。<br>如下：<br><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/1.png" alt="1"></p>
<a id="more"></a>

<h4 id="二、gitlab-Web端的介绍"><a href="#二、gitlab-Web端的介绍" class="headerlink" title="二、gitlab Web端的介绍"></a>二、gitlab Web端的介绍</h4><p>点击Web端菜单栏上标签按钮，可以进入不同的功能任务主窗口。</p>
<h5 id="2-1-gitlab-一个logo标志-，进入或者恢复初始界面。"><a href="#2-1-gitlab-一个logo标志-，进入或者恢复初始界面。" class="headerlink" title="2.1 gitlab(一个logo标志)，进入或者恢复初始界面。"></a>2.1 gitlab(一个logo标志)，进入或者恢复初始界面。</h5><h5 id="2-2-Project，根据下拉列表或者Project标签页中的Tab列表选择同类型的项目。如下图"><a href="#2-2-Project，根据下拉列表或者Project标签页中的Tab列表选择同类型的项目。如下图" class="headerlink" title="2.2 Project，根据下拉列表或者Project标签页中的Tab列表选择同类型的项目。如下图"></a>2.2 Project，根据下拉列表或者Project标签页中的Tab列表选择同类型的项目。如下图</h5><p><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/2.png" alt="2"><br><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/3.png" alt="3"></p>
<h6 id="2-2-1点击按钮“New-project”建立项目"><a href="#2-2-1点击按钮“New-project”建立项目" class="headerlink" title="2.2.1点击按钮“New project”建立项目"></a>2.2.1点击按钮“New project”建立项目</h6><p><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/4.png" alt="4"><br>可以看到主窗口中有三个待选标签页：Blank project、Create from template、 Import project分别表示不同project的创建方式，一般我们用第一种。</p>
<p>根据项目Group的下拉菜单，选择beacom_firmware开发小组，输入项目名名称test，添加项目描述信息。</p>
<p>最后选择Visibility Level 的权限(可以选上README文件，最后会生成一个README文件)，点击按钮“Create project”就在这个开发小组中可以建立一个项目了。<br>如下图：<br><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/5.png" alt="5"></p>
<p>注意: </p>
<ol>
<li>点击按钮“clone”弹出一个对话框，上面有关于SSH和HTTP方式的链接，后续会有介绍。</li>
<li>每建立一个project 都会有这样一个命令：Command line instructions，这个是让我我们上传代码的命令，后面所有的操作基本上都是围绕这几步来，一般我们用这个命令：Create a new repository，后续会有介绍。</li>
</ol>
<h6 id="2-2-2回到刚才的Project-gt-Your-project-页面中可以看到新建的子项目xxx-firmware-test，以后开发就可以从这里进入"><a href="#2-2-2回到刚才的Project-gt-Your-project-页面中可以看到新建的子项目xxx-firmware-test，以后开发就可以从这里进入" class="headerlink" title="2.2.2回到刚才的Project-&gt;Your project 页面中可以看到新建的子项目xxx_firmware/test，以后开发就可以从这里进入"></a>2.2.2回到刚才的Project-&gt;Your project 页面中可以看到新建的子项目xxx_firmware/test，以后开发就可以从这里进入</h6><h5 id="2-3-Group-根据顶级菜单的下拉列表或者是子菜单的Tab列表都可以进如到不同的开发小组中去。"><a href="#2-3-Group-根据顶级菜单的下拉列表或者是子菜单的Tab列表都可以进如到不同的开发小组中去。" class="headerlink" title="2.3 Group,根据顶级菜单的下拉列表或者是子菜单的Tab列表都可以进如到不同的开发小组中去。"></a>2.3 Group,根据顶级菜单的下拉列表或者是子菜单的Tab列表都可以进如到不同的开发小组中去。</h5><p>以XXX_firmware开发小组为例，可以看到左边的的功能菜单上有：<br><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/6.png" alt="6"></p>
<h6 id="2-3-1-Owerview"><a href="#2-3-1-Owerview" class="headerlink" title="2.3.1 Owerview"></a>2.3.1 Owerview</h6><p>是一些项目细节或者是开发人员的活跃记录，如上图和下图所示。<br><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/7.png" alt="7"></p>
<h6 id="2-3-2-Issues"><a href="#2-3-2-Issues" class="headerlink" title="2.3.2 Issues"></a>2.3.2 Issues</h6><p>在这里这个项目组成员可以提交一些问题，大家相互交流，项目开发进度等等，代码发布版本都可以在这里做记录，这里没做研究。</p>
<h6 id="2-3-3-Merge-Requests"><a href="#2-3-3-Merge-Requests" class="headerlink" title="2.3.3 Merge Requests"></a>2.3.3 Merge Requests</h6><p>主要是别人提交代码请求合并的记录</p>
<h6 id="2-3-4-Kubernetes"><a href="#2-3-4-Kubernetes" class="headerlink" title="2.3.4 Kubernetes"></a>2.3.4 Kubernetes</h6><p>略</p>
<h6 id="2-3-5-Members"><a href="#2-3-5-Members" class="headerlink" title="2.3.5 Members"></a>2.3.5 Members</h6><p>这里有开发人员的相关信息，包括各级权限。</p>
<h5 id="2-4-Activity"><a href="#2-4-Activity" class="headerlink" title="2.4 Activity"></a>2.4 Activity</h5><p>不同人员各种代码提交、活跃记录都在上面。</p>
<h5 id="2-5-Milestones"><a href="#2-5-Milestones" class="headerlink" title="2.5 Milestones"></a>2.5 Milestones</h5><p>同2.3.2Issues中的milestones,就是项目开发达到某一个程度，比如可以发布的一个版本。（后面给代码打标签设置版本号还会提到如：git tag v1.0）</p>
<h5 id="2-6-Snippet"><a href="#2-6-Snippet" class="headerlink" title="2.6 Snippet"></a>2.6 Snippet</h5><p>个人的一些工作中的Idea启发,都可以记录在这里，有权限设置，相当于个人blog。</p>
<h5 id="2-7-“-”"><a href="#2-7-“-”" class="headerlink" title="2.7 “+”"></a>2.7 “+”</h5><p>根据下拉列表看到New Project、New group、New snippet，这个前面都有相关介绍。</p>
<h5 id="2-8-Issues"><a href="#2-8-Issues" class="headerlink" title="2.8 Issues"></a>2.8 Issues</h5><p>同2.3.2 Issues</p>
<h5 id="2-9-Merge-Requests"><a href="#2-9-Merge-Requests" class="headerlink" title="2.9 Merge Requests"></a>2.9 Merge Requests</h5><p>同2.3.3 Merge Requests</p>
<h5 id="2-9-Todos"><a href="#2-9-Todos" class="headerlink" title="2.9 Todos"></a>2.9 Todos</h5><p>接下来要做的事情，同2.3.2 Issues</p>
<h5 id="2-10？"><a href="#2-10？" class="headerlink" title="2.10？"></a>2.10？</h5><p>一款工具不能少的，常见帮助信息。</p>
<h5 id="2-11-账户设置"><a href="#2-11-账户设置" class="headerlink" title="2.11 账户设置"></a>2.11 账户设置</h5><p>选择账户中下拉列表Setings进入账户设置。如下图</p>
<p><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/8.png" alt="8"></p>
<p>这里主要是一些个人信息的设置，比如修改账户密码、邮箱等。还有一个重要的操作修改添加SSH Keys后面会有介绍。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>工程设计-软件升级之设备端版本号管理(3)</title>
    <url>/2019/12/29/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E8%BD%AF%E4%BB%B6%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%AE%BE%E5%A4%87%E7%AB%AF%E7%89%88%E6%9C%AC%E5%8F%B7%E7%AE%A1%E7%90%86-3/</url>
    <content><![CDATA[<blockquote>
<p>关于版本号管控需要满足以空间分支为主导,用时间变更作定位,方便bug查找修改。</p>
</blockquote>
<p>1.需要满足设备的向上兼容,通过版本号的变更迭代可以实现。形如：3.000.0001</p>
<p>2.需要满足事物存在的3要素：</p>
<ul>
<li><p>时间(就是设备发货时间,也是设备的初始版本号,例如3.000.0001到3.000.0002的变更，就是一个时间变迁的过程)</p>
</li>
<li><p>地点(就是设备发货地点,同时对应代码库的分支)</p>
</li>
<li><p>设备(设备是必须存在的)</p>
</li>
</ul>
<a id="more"></a>

<p>每往一个地方发送设备,设备端代码通过git库建立一个分支,之后这个分支代码就主要是这个地方设备运行代码,方便以后bug查找,但不会对这个分支代码进行修改。<br>初始版本,以发往四川的为例：sichuan-3.000.0001</p>
<p>3.我们的程序不断的在master分支上进行更新迭代。</p>
<p>4.关于升级,会出现两种情况。(其它各种情况都离不开这两种情况)</p>
<p>4.1 一种情况就是某一个地方的设备出现了bug被人发现了,这个时候必须要对这个地方的设备进行升级,此时修改master分支测试验证通过<br>将master分支代码克隆到这个地方分支上去,代码的版本号变更由sichuan-3.000.0001到sichuan-3.000.0002的变更。</p>
<p>4.2 此时master分支,对4.1中bug进行修复并验证通过,同时我们也解决了一个其它的代码bug或者实现了一个功能,代码测试验证通过之后,感觉可以升级了,<br>这就是第二种情况升级(第二种升级又是系列情况升级)。<br>但并不是所有的设备都能升级,所以将master分支代码克隆到能够升级的地方分支上去。(时刻谨记地点分支代码不是用来修改的,是用来定位查找bug的)<br>形如：</p>
<pre><code>sichuan-3.000.0002到sichuan-3.001.0000的升级
tieling-3.000.0001到tieling-3.001.0000的升级
xian-3.000.00001  到xian-3.000.00001不升级</code></pre><p>5.所以从上面可以看出：sichuan-3.000.00000,从右往左起,<br>第1段是bug&amp;功能的升级<br>第2段是代码进行系列的升级<br>第3段前半部分是地方名称,后半部分是产品换代升级</p>
<p>6.代码的升级虽然是在服务器端升级的,但其实还是由设备端提供代码进行升级的。<br>所以每发一批设备,设备端都要给服务器端一个版本号：地点+一串号码,用来放入软件升级代码中去。</p>
<p>每次发出去之前,肯定要经过相应的一系列测试,这些测试必然包括版本升级测试。<br>(关于软件升级版本号必然是以if else if的方式不端的扩张的,因为它是未知的。)</p>
<p>7.软件升级代码以后要集中到运行程序中去,这样软件升级代码自身也会不断的迭代更新。</p>
<blockquote>
<p>注：此只为自己的一些不成熟的想法，真正版本号管理需要领导们自己决定。</p>
</blockquote>
]]></content>
      <categories>
        <category>工程设计</category>
      </categories>
  </entry>
  <entry>
    <title>系统函数&库函数-Linux中的popen函数和system函数(转)</title>
    <url>/2019/12/22/%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0-%E5%BA%93%E5%87%BD%E6%95%B0-Linux%E4%B8%AD%E7%9A%84popen%E5%87%BD%E6%95%B0%E5%92%8Csystem%E5%87%BD%E6%95%B0-%E8%BD%AC/</url>
    <content><![CDATA[<blockquote>
<p>说在前面，在实际编程中尽量减少使用system函数。</p>
</blockquote>
<h5 id="int-system-const-char-command"><a href="#int-system-const-char-command" class="headerlink" title="int system(const char *command);"></a>int system(const char *command);</h5><h6 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h6><p>system()通过调用/bin/sh -c命令执行命令中指定的命令，并在命令完成后返回。在执行该命令期间，SIGCHLD将被阻塞，并且SIGINT和SIGQUIT将被忽略。</p>
<a id="more"></a>

<h6 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h6><p>实际上system调用了三个函数：fork()、exec()、waitpid()。因此有三种返回值：</p>
<ol>
<li>fork()失败或者waitpid()返回除了EINTR之外的出错，则system返回-1.而且errno中设置了错误类型值。</li>
<li>如果exec失败（表示不能执行shell），则其返回值如同shell执行了exit（127）一样</li>
<li>如果三个函数都执行成功，并且system的返回值是shell的终止状态，其格式已在已在waitpid中说明。</li>
</ol>
<h6 id="system的实现："><a href="#system的实现：" class="headerlink" title="system的实现："></a>system的实现：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int system(const char * cmdstring)  </span><br><span class="line">&#123;   </span><br><span class="line">  pid_t pid;   </span><br><span class="line">  int status;   </span><br><span class="line">  if(cmdstring == NULL)  </span><br><span class="line">    &#123;   </span><br><span class="line">      return (1);   </span><br><span class="line">    &#125;   </span><br><span class="line">  if((pid = fork())&lt;0)  </span><br><span class="line">    &#123;   </span><br><span class="line">      status = -1;   </span><br><span class="line">    &#125;   </span><br><span class="line">  else if(pid = 0)  </span><br><span class="line">    &#123;  </span><br><span class="line">       execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-c&quot;, cmdstring, (char *)0); -exit(127); //子进程正常执行则不会执行此语句 &#125;   </span><br><span class="line">  else  </span><br><span class="line">    &#123;   </span><br><span class="line">       while(waitpid(pid, &amp;status, 0) &lt; 0)  </span><br><span class="line">    &#123;  </span><br><span class="line">  if(errno != EINTER)&#123; status = -1; break;   </span><br><span class="line">    &#125;   </span><br><span class="line">   &#125;  </span><br><span class="line">  &#125;   </span><br><span class="line">  return status;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="简单的使用："><a href="#简单的使用：" class="headerlink" title="简单的使用："></a>简单的使用：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int status = 0;</span><br><span class="line">  status = system(&quot;ls -a&quot;);</span><br><span class="line">  if(-1 == status)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(&quot;system&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  if(WIFEXITED(status) != 0)  //正常退出</span><br><span class="line">  &#123;</span><br><span class="line">    if(WEXITSTATUS(status) == 0)  //操作正确</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;run command success\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;run error\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else      //异常退出</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;exit error is %d\n&quot;, WEXITSTATUS(status));</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码我们可以看到，system在使用时的一个弊端，由于返回值太多，要安全的使用它就要进行许多步的出错处理。</p>
<p>所以，不太建议使用system。</p>
<h6 id="使用system需要注意："><a href="#使用system需要注意：" class="headerlink" title="使用system需要注意："></a>使用system需要注意：</h6><p>1.建议system()函数只用来执行shell命令，因为一般来讲，system()返回值不是0就说明出错了； </p>
<p>2.监控一下system()函数的执行完毕后的errno值，争取出错时给出更多有用信息； </p>
<h5 id="建议使用popen函数取代system"><a href="#建议使用popen函数取代system" class="headerlink" title="建议使用popen函数取代system();"></a>建议使用popen函数取代system();</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FILE *popen(const char *command, const char *type);</span><br><span class="line">int pclose(FILE *stream);返回值： command的终止状态， 出错返回-1</span><br></pre></td></tr></table></figure>

<h6 id="popen-函数较于system-函数的优势在于使用简单，popen-函数只返回两个值："><a href="#popen-函数较于system-函数的优势在于使用简单，popen-函数只返回两个值：" class="headerlink" title="popen()函数较于system()函数的优势在于使用简单，popen()函数只返回两个值："></a>popen()函数较于system()函数的优势在于使用简单，popen()函数只返回两个值：</h6><p>成功返回子进程的status，使用WIFEXITED相关宏就可以取得command的返回结果；</p>
<p>失败返回-1，我们可以使用perro()函数或strerror()函数得到有用的错误信息。</p>
<p>popen先执行fork，然后调用exec以执行command并返回一个标准I/O文件指针。如果type是“r”，则文件指针链接到command的标准输出。如果type是“w”,则文件指针链接到command的标准输入。将popen和fopen进行类比，方便记忆其最后一个参数及其作用，如果type是“r”，则返回文件指针是刻度的，如果type是是“w”，则是可写的。</p>
<p><img src="/2019/12/22/%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0-%E5%BA%93%E5%87%BD%E6%95%B0-Linux%E4%B8%AD%E7%9A%84popen%E5%87%BD%E6%95%B0%E5%92%8Csystem%E5%87%BD%E6%95%B0-%E8%BD%AC/1.png" alt="1"></p>
<p>简单使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  FILE* fp = NULL;</span><br><span class="line">  char buf[1024] = &#123;0&#125;;</span><br><span class="line">  fp = popen(&quot;ls -a&quot;, &quot;r&quot;);</span><br><span class="line">  if(NULL == fp)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(&quot;popen&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  while(fgets(buf, 1024, fp) != NULL)</span><br><span class="line">  &#123;</span><br><span class="line">   fprintf(stdout, &quot;%s&quot;, buf); </span><br><span class="line">  &#125;</span><br><span class="line">  pclose(fp);</span><br><span class="line"> </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，popen绝不应该由设置用户ID或设置组ID程序调用。当它执行命令</p>
<p>popen等同于execl(“/bin/sh”, “sh”, “-c”, command ,NULL);</p>
<p>它在从调用者继承的环境中执行shell，并由shell解释执行command。一个心怀不轨的用户可以操纵这种环境，使得shell能以设置ID文件模式所授予的提升了的权限以及非预期的方式执行命令。</p>
<p>popen特别适用于构造简单的过滤程序，它变换运行命令的输入或输出。</p>
<p>当命令希望构建自己的管道线时就是这种情形。</p>
<blockquote>
<p>借楼发个问题：在多次调用system和popen（中间没有做delay处理）后，再次调用是直接fp返回空或system返回无此目录或文件。</p>
</blockquote>
]]></content>
      <categories>
        <category>系统函数&amp;库函数</category>
      </categories>
      <tags>
        <tag>system</tag>
        <tag>popen</tag>
      </tags>
  </entry>
  <entry>
    <title>系统函数&库函数-popen 的使用方法及场景(转)</title>
    <url>/2019/12/22/%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0-%E5%BA%93%E5%87%BD%E6%95%B0-popen-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%8F%8A%E5%9C%BA%E6%99%AF-%E8%BD%AC/</url>
    <content><![CDATA[<h5 id="1-Popen的应用场景"><a href="#1-Popen的应用场景" class="headerlink" title="1.Popen的应用场景"></a>1.Popen的应用场景</h5><p>popen应用于执行shell命令，并读取此命令的返值，或者与执行的命令进行交互。</p>
<a id="more"></a>

<h5 id="2-Popen的实现"><a href="#2-Popen的实现" class="headerlink" title="2.Popen的实现"></a>2.Popen的实现</h5><p>popen()函数通过创建一个管道，调用fork()产生一个子进程，执行一个shell以运行命令来开启一个进程。可以通过这个管道执行标准输入输出操作。这个管道必须由pclose()函数关闭，必须由pclose()函数关闭，必须由pclose()函数关闭，而不是fclose()函数（若使用fclose则会产生僵尸进程）。pclose()函数关闭标准I/O流，等待命令执行结束，然后返回shell的终止状态。如果shell不能被执行，则pclose()返回的终止状态与shell已执行exit一样。</p>
<p>type参数只能是读或者写中的一种，得到的返回值（标准I/O流）也具有和type相应的只读或只写类型。如果type是”r”则文件指针连接到command的标准输出；如果type是”w”则文件指针连接到command的标准输入。</p>
<p>command参数是一个指向以NULL结束的shell命令字符串的指针。这行命令将被传到bin/sh并使用-c标志，shell将执行这个命令。</p>
<p>popen()的返回值是个标准I/O流，必须由pclose来终止。前面提到这个流是单向的（只能用于读或写）。向这个流写内容相当于写入该命令的标准输入，命令的标准输出和调用popen()的进程相同；与之相反的，从流中读数据相当于读取命令的标准输出，命令的标准输入和调用popen()的进程相同。</p>
<p><strong>返回值</strong></p>
<p>如果调用fork()或pipe()失败，或者不能分配内存将返回NULL，否则返回标准I/O流。popen()没有为内存分配失败设置errno值。如果调用fork()或pipe()时出现错误，errno被设为相应的错误类型。如果type参数不合法，errno将返回EINVAL。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FILE *popen(const char *command, const char *type);</span><br><span class="line">int pclose(FILE *stream);</span><br></pre></td></tr></table></figure>



<h5 id="3-Pclose操作"><a href="#3-Pclose操作" class="headerlink" title="3.Pclose操作"></a>3.Pclose操作</h5><p>Pclose()函数会闭标准i/0流，等待子进程结束，然后返回shell终止状态。如果不执行，则pclose()返回终止状态就是shell的exit状态。</p>
<p><strong>源码附上：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* Copyright (C) 2004       Manuel Novoa III    &lt;mjn3@codepoet.org&gt;</span><br><span class="line"> * Copyright (C) 2000-2006 Erik Andersen &lt;andersen@uclibc.org&gt;</span><br><span class="line"> *</span><br><span class="line"> * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.</span><br><span class="line"> *</span><br><span class="line"> * Dedicated to Toni.  See uClibc/DEDICATION.mjn3 for details.</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/* Jan 1, 2004</span><br><span class="line"> *</span><br><span class="line"> * Rewrite popen for SUSv3 compliance.</span><br><span class="line"> *   Added a list of popen()&apos;d to store pids and use waitpid() in pclose().</span><br><span class="line"> *   Loop on waitpid() failure due to EINTR as required.</span><br><span class="line"> *   Close parent&apos;s popen()&apos;d FILEs in the &#123;v&#125;fork()&apos;d child.</span><br><span class="line"> *   Fix failure exit code for failed execve().</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;bits/uClibc_mutex.h&gt;</span><br><span class="line"> </span><br><span class="line">#ifdef __UCLIBC_MJN3_ONLY__</span><br><span class="line">#warning &quot;hmm... susv3 says Pipe streams are byte-oriented.&quot;</span><br><span class="line">#endif /* __UCLIBC_MJN3_ONLY__ */</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/* uClinux-2.0 has vfork, but Linux 2.0 doesn&apos;t */</span><br><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line">#if ! defined __NR_vfork</span><br><span class="line"># define vfork fork</span><br><span class="line"># define VFORK_LOCK		((void) 0)</span><br><span class="line"># define VFORK_UNLOCK		((void) 0)</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">#ifndef VFORK_LOCK</span><br><span class="line">__UCLIBC_MUTEX_STATIC(mylock, PTHREAD_MUTEX_INITIALIZER);</span><br><span class="line"># define VFORK_LOCK		__UCLIBC_MUTEX_LOCK(mylock)</span><br><span class="line"># define VFORK_UNLOCK		__UCLIBC_MUTEX_UNLOCK(mylock)</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">struct popen_list_item &#123;</span><br><span class="line">	struct popen_list_item *next;</span><br><span class="line">	FILE *f;</span><br><span class="line">	pid_t pid;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">static struct popen_list_item *popen_list /* = NULL (bss initialized) */;</span><br><span class="line"> </span><br><span class="line">FILE *popen(const char *command, const char *modes)</span><br><span class="line">&#123;</span><br><span class="line">	FILE *fp;</span><br><span class="line">	struct popen_list_item *pi;</span><br><span class="line">	struct popen_list_item *po;</span><br><span class="line">	int pipe_fd[2];</span><br><span class="line">	int parent_fd;</span><br><span class="line">	int child_fd;</span><br><span class="line">	int child_writing;			/* Doubles as the desired child fildes. */</span><br><span class="line">	pid_t pid;</span><br><span class="line"> </span><br><span class="line">	child_writing = 0;			/* Assume child is writing. */</span><br><span class="line">	if (modes[0] != &apos;w&apos;) &#123;		/* Parent not writing... */</span><br><span class="line">		++child_writing;		/* so child must be writing. */</span><br><span class="line">		if (modes[0] != &apos;r&apos;) &#123;	/* Oops!  Parent not reading either! */</span><br><span class="line">			__set_errno(EINVAL);</span><br><span class="line">			goto RET_NULL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	if (!(pi = malloc(sizeof(struct popen_list_item)))) &#123;</span><br><span class="line">		goto RET_NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	// 打开一个pipe，管道是单向。故数据流只能单向流动。</span><br><span class="line">	if (pipe(pipe_fd)) &#123;</span><br><span class="line">		goto FREE_PI;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	//下面两个描述符就是管道的两端的描述，一个为读一个为写。</span><br><span class="line">	child_fd = pipe_fd[child_writing]; </span><br><span class="line">	parent_fd = pipe_fd[1-child_writing]; </span><br><span class="line">	//fdopen就是打开一个描述，fd相同模式或者字集的方式打开。意思就是把一个已找打开的流与一个文件描述符相关联，且</span><br><span class="line">	//这个文件描述是唯一的，这样也就可以保证这个函数接口的可重入性。如果设计的不可重入性，也就没必要再做一次fdopen了。</span><br><span class="line">	if (!(fp = fdopen(parent_fd, modes))) &#123;</span><br><span class="line">		close(parent_fd);</span><br><span class="line">		close(child_fd);</span><br><span class="line">		goto FREE_PI;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	VFORK_LOCK;</span><br><span class="line">	//再这里创建一个子进程，然后执行 shell命令。这里最重的两步就是用pipe的两个描述替换标准输入或者输出。</span><br><span class="line">	if ((pid = vfork()) == 0) &#123;	/* Child of vfork... */</span><br><span class="line">		close(parent_fd);</span><br><span class="line">		if (child_fd != child_writing) &#123;</span><br><span class="line">			dup2(child_fd, child_writing); //用child_fd来代替标准输入或输出。</span><br><span class="line">			close(child_fd);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		/* SUSv3 requires that any previously popen()&apos;d streams in the</span><br><span class="line">		 * parent shall be closed in the child. */</span><br><span class="line">		//关闭不必要的资源。</span><br><span class="line">		for (po = popen_list ; po ; po = po-&gt;next) &#123;</span><br><span class="line">			close(po-&gt;f-&gt;__filedes);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		//执行exec shell,这个时候标准输入/输出就变为pipe管道的一端了。</span><br><span class="line">		//这里只能实现单向的功能。要么读要么写。</span><br><span class="line">		execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-c&quot;, command, (char *)0);</span><br><span class="line"> </span><br><span class="line">		/* SUSv3 mandates an exit code of 127 for the child if the</span><br><span class="line">		 * command interpreter can not be invoked. */</span><br><span class="line">		_exit(127);</span><br><span class="line">	&#125;</span><br><span class="line">	VFORK_UNLOCK;</span><br><span class="line"> </span><br><span class="line">	/* We need to close the child filedes whether vfork failed or</span><br><span class="line">	 * it succeeded and we&apos;re in the parent. */</span><br><span class="line">	close(child_fd);</span><br><span class="line">	//将当前的信息保存到全局链表。为了是pclose可以找到对的子进程与通信文件描述。</span><br><span class="line">	if (pid &gt; 0) &#123;				/* Parent of vfork... */</span><br><span class="line">		pi-&gt;pid = pid;</span><br><span class="line">		pi-&gt;f = fp;</span><br><span class="line">		VFORK_LOCK;</span><br><span class="line">		pi-&gt;next = popen_list;</span><br><span class="line">		popen_list = pi;</span><br><span class="line">		VFORK_UNLOCK;</span><br><span class="line"> </span><br><span class="line">		return fp;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	/* If we get here, vfork failed. */</span><br><span class="line">	fclose(fp);					/* Will close parent_fd. */</span><br><span class="line"> </span><br><span class="line"> FREE_PI:</span><br><span class="line">	free(pi);</span><br><span class="line"> </span><br><span class="line"> RET_NULL:</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#warning is pclose correct wrt the new mutex semantics?</span><br><span class="line"> </span><br><span class="line">int pclose(FILE *stream)</span><br><span class="line">&#123;</span><br><span class="line">	struct popen_list_item *p;</span><br><span class="line">	int stat;</span><br><span class="line">	pid_t pid;</span><br><span class="line"> </span><br><span class="line">	/* First, find the list entry corresponding to stream and remove it</span><br><span class="line">	 * from the list.  Set p to the list item (NULL if not found). */</span><br><span class="line">	VFORK_LOCK;</span><br><span class="line">	if ((p = popen_list) != NULL) &#123;</span><br><span class="line">		if (p-&gt;f == stream) &#123;// 找到stream对应的popen结点。</span><br><span class="line">			popen_list = p-&gt;next;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			struct popen_list_item *t;</span><br><span class="line">			do &#123;</span><br><span class="line">				t = p;</span><br><span class="line">				if (!(p = t-&gt;next)) &#123;</span><br><span class="line">					__set_errno(EINVAL); /* Not required by SUSv3. */</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				if (p-&gt;f == stream) &#123;</span><br><span class="line">					t-&gt;next = p-&gt;next;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; while (1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	VFORK_UNLOCK;</span><br><span class="line"> </span><br><span class="line">	if (p) &#123;</span><br><span class="line">		pid = p-&gt;pid;			/* Save the pid we need */</span><br><span class="line">		free(p);				/* and free the list item. */</span><br><span class="line"> </span><br><span class="line">		fclose(stream);	/* The SUSv3 example code ignores the return. */</span><br><span class="line"> </span><br><span class="line">		/* SUSv3 specificly requires that pclose not return before the child</span><br><span class="line">		 * terminates, in order to disallow pclose from returning on EINTR. */</span><br><span class="line">		do &#123;</span><br><span class="line">			if (waitpid(pid, &amp;stat, 0) &gt;= 0) &#123; //等待子进程返回。获取返回值。</span><br><span class="line">				return stat;</span><br><span class="line">			&#125;</span><br><span class="line">			if (errno != EINTR) &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; while (1);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>举例附上：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	FILE *fp = NULL;</span><br><span class="line">	char buf[1024] = &quot;&quot;;</span><br><span class="line"> </span><br><span class="line">	fp = popen(&quot;ls -al&quot;, &quot;r&quot;);</span><br><span class="line">	if(fp == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(&quot;popen error\n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	while(fgets(buf, sizeof(buf), fp) != 0)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%s\n&quot;, buf);</span><br><span class="line">		memset(buf, 0x0, sizeof(buf));</span><br><span class="line">	&#125;</span><br><span class="line">	pclose(fp);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>系统函数&amp;库函数</category>
      </categories>
      <tags>
        <tag>popen</tag>
      </tags>
  </entry>
  <entry>
    <title>工程设计-软件升级之设备端版本号管理(2)</title>
    <url>/2019/12/22/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E8%BD%AF%E4%BB%B6%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%AE%BE%E5%A4%87%E7%AB%AF%E7%89%88%E6%9C%AC%E5%8F%B7%E7%AE%A1%E7%90%86-2/</url>
    <content><![CDATA[<blockquote>
<p>关于版本号管理，之前升级都是在嵌入式设备中移植一个微型服务器，然后通过web端进行升级。现在是设备作为客户端向http发送版本号，http发送下载指令，设备端再想ftp服务器请求下载文件。所以思维方式要转换一下。<br>并且预期忘版本号的管理符合git库版本管理规则。</p>
</blockquote>
<a id="more"></a>

<h5 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h5><p>服务器只有一个，而设备却有很多种，且分布在全国各地，各个地方情况不一样。<br>有的地方因为设备或者其它原因，软件不需要更新。<br>有的设备因为硬件与软件兼容性问题，只能升级特定的版本。<br>所以远程升级必须需要满足下面两种情况。</p>
<h5 id="二、远程升级满足下面两种情况"><a href="#二、远程升级满足下面两种情况" class="headerlink" title="二、远程升级满足下面两种情况"></a>二、远程升级满足下面两种情况</h5><h6 id="2-1-后台服务器的手动升级-暴力升级"><a href="#2-1-后台服务器的手动升级-暴力升级" class="headerlink" title="2.1 后台服务器的手动升级(暴力升级)"></a>2.1 后台服务器的手动升级(暴力升级)</h6><h6 id="2-2-设备端的自动升级"><a href="#2-2-设备端的自动升级" class="headerlink" title="2.2 设备端的自动升级"></a>2.2 设备端的自动升级</h6><p>参考：<img src="/2019/12/22/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E8%BD%AF%E4%BB%B6%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%AE%BE%E5%A4%87%E7%AB%AF%E7%89%88%E6%9C%AC%E5%8F%B7%E7%AE%A1%E7%90%86-2/1.png" alt="1"></p>
<h5 id="三、关于版本号管控"><a href="#三、关于版本号管控" class="headerlink" title="三、关于版本号管控"></a>三、关于版本号管控</h5><p>版本号管控或称三段式管控，形如：3.000.00000，3.100.10000,以10进制字符串的方式体现出来。（关于版本号的管控也可以按照设备发送的地方进行管控。按照时间来进行版本号回退管理，按照空间(发货地点)来进行分支进退管理。）</p>
<p>注意：16进制数据和字符串型数据容易混淆</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HISI_APP:3.01.0001 </span><br><span class="line">16进制方式：(0x03 0x2e 0x00 0x01 0x2e 0x00 0x00 0x00 0x01) </span><br><span class="line">字符串方式：(0x33 0x2e 0x30 0x31 0x2e 0x30 0x30 0x30 0x31)</span><br></pre></td></tr></table></figure>



<h6 id="3-1-第3段—-00001，子功能升级-amp-BUG的修改（软件对应子功能添加-amp-BUG的修改的升级）"><a href="#3-1-第3段—-00001，子功能升级-amp-BUG的修改（软件对应子功能添加-amp-BUG的修改的升级）" class="headerlink" title="3.1 第3段—-00001，子功能升级&amp;BUG的修改（软件对应子功能添加&amp;BUG的修改的升级）"></a>3.1 第3段—-00001，子功能升级&amp;BUG的修改（软件对应子功能添加&amp;BUG的修改的升级）</h6><p>从文本文件中读取的’.’后面的第一位，为1表示该不可以升级，为0表示该段程序可以升级。</p>
<p>之后的4位，表示版本号的范围：0000-9999。</p>
<p>关于兼容性：修改bug有9999种版本完全够用，可能还没有达到这么多，就进入了系列升级。</p>
<h6 id="3-2-第2段—-001，产品系列的升级（软件对应硬件方面的升级）"><a href="#3-2-第2段—-001，产品系列的升级（软件对应硬件方面的升级）" class="headerlink" title="3.2 第2段—-001，产品系列的升级（软件对应硬件方面的升级）"></a>3.2 第2段—-001，产品系列的升级（软件对应硬件方面的升级）</h6><p>从文本文件中读取的’.’后面的第一位，为1表示该不可以升级，为0表示该段程序可以升级。</p>
<p>之后的2位，表示版本号的范围：00-99</p>
<p>关于兼容性：修改bug有99种版本完全够用，可能还没有达到这么多，就进入了换代升级</p>
<h6 id="3-3-第1段—-3，产品的换代升级（软件对应产品发布方面的升级）"><a href="#3-3-第1段—-3，产品的换代升级（软件对应产品发布方面的升级）" class="headerlink" title="3.3 第1段—-3，产品的换代升级（软件对应产品发布方面的升级）"></a>3.3 第1段—-3，产品的换代升级（软件对应产品发布方面的升级）</h6>]]></content>
      <categories>
        <category>工程设计</category>
      </categories>
      <tags>
        <tag>FTP</tag>
        <tag>流程图</tag>
        <tag>http</tag>
        <tag>版本号</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言-函数返回局部变量的几种方式</title>
    <url>/2019/12/15/C%E8%AF%AD%E8%A8%80-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>一般的来说，函数是可以返回局部变量的。</p>
<p>局部变量的作用域只在函数内部，在函数返回后，局部变量的内存已经释放了。</p>
<p>因此，如果函数返回的是局部变量的值，不涉及地址，程序不会出错。</p>
<p>但是如果返回的是局部变量的地址(指针)的话，程序运行后会出错。</p>
<p>因为函数只是把指针复制后返回了，但是指针指向的内容已经被释放了，这样指针指向的内容就是不可预料的内容，调用就会出错。</p>
<p>准确的来说，函数不能通过返回指向栈内存的指针(注意这里指的是栈，返回指向堆内存的指针是可以的)。</p>
<a id="more"></a>

<p>下面以函数返回局部变量的指针举几个典型的例子来说明：</p>
<h5 id="1-字符串常量’hello-world’，存放在只读数据段"><a href="#1-字符串常量’hello-world’，存放在只读数据段" class="headerlink" title="1. 字符串常量’hello world’，存放在只读数据段"></a>1. 字符串常量’hello world’，存放在只读数据段</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;   </span><br><span class="line">char *returnStr()   </span><br><span class="line">&#123;   </span><br><span class="line">    char *p=&quot;hello world!&quot;;   </span><br><span class="line">    return p;   </span><br><span class="line">&#125;   </span><br><span class="line">int main()   </span><br><span class="line">&#123;   </span><br><span class="line">    char *str;   </span><br><span class="line">    str=returnStr();   </span><br><span class="line">    printf(&quot;%s\n&quot;, str);   </span><br><span class="line">    return 0;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个没有任何问题，因为”hello world!”是一个字符串常量，存放在只读数据段，把该字符串常量存放的只读数据段的首地址赋值给了指针，所以returnStr函数退出时，该该字符串常量所在内存不会被回收，故能够通过指针顺利无误的访问。</p>
<h5 id="2-局部变量’hello-world’存放在栈中"><a href="#2-局部变量’hello-world’存放在栈中" class="headerlink" title="2. 局部变量’hello world’存放在栈中"></a>2. 局部变量’hello world’存放在栈中</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;   </span><br><span class="line"></span><br><span class="line">char *returnStr()   </span><br><span class="line">&#123;   </span><br><span class="line">    char p[]=&quot;hello world!&quot;;   </span><br><span class="line">    return p;   </span><br><span class="line">&#125;   </span><br><span class="line">int main()   </span><br><span class="line">&#123;   </span><br><span class="line">    char *str;   </span><br><span class="line">    str=returnStr();   </span><br><span class="line">    printf(&quot;%s\n&quot;, str);   </span><br><span class="line">    return 0;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“hello world!”是局部变量存放在栈中。当returnStr函数退出时，栈要清空，局部变量的内存也被清空了，所以这时的函数返回的是一个已被释放的内存地址，所以有可能打印出来的是乱码。 </p>
<h5 id="3-局部变量（实参与型参）、地址（指针）栈（指向内存的释放）、静态变量地址（指针）的生存周期"><a href="#3-局部变量（实参与型参）、地址（指针）栈（指向内存的释放）、静态变量地址（指针）的生存周期" class="headerlink" title="3. 局部变量（实参与型参）、地址（指针）栈（指向内存的释放）、静态变量地址（指针）的生存周期"></a>3. 局部变量（实参与型参）、地址（指针）栈（指向内存的释放）、静态变量地址（指针）的生存周期</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int func()  </span><br><span class="line">&#123;  </span><br><span class="line">      int a;  </span><br><span class="line">      ....  </span><br><span class="line">      return a;    //允许  </span><br><span class="line">&#125;                     </span><br><span class="line">  </span><br><span class="line">int * func()  </span><br><span class="line">&#123;  </span><br><span class="line">      int a;  </span><br><span class="line">      ....  </span><br><span class="line">      return &amp;a;    //无意义，不应该这样做  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>局部变量也分局部自动变量和局部静态变量，由于a返回的是值，因此返回一个局部变量是可以的，无论自动还是静态，因为这时候返回的是这个局部变量的值。</p>
<p>但不应该返回指向局部自动变量的指针，因为函数调用结束后该局部自动变量<br>被抛弃，这个指针指向一个不再存在的对象，是无意义的。</p>
<p>但可以返回指向局部静态变量的指针，因为静态变量的生存期从定义起到程序结束。</p>
<h5 id="4-如果函数的返回值非要是一个局部变量的地址，那么该局部变量一定要申明为static类型。"><a href="#4-如果函数的返回值非要是一个局部变量的地址，那么该局部变量一定要申明为static类型。" class="headerlink" title="4. 如果函数的返回值非要是一个局部变量的地址，那么该局部变量一定要申明为static类型。"></a>4. 如果函数的返回值非要是一个局部变量的地址，那么该局部变量一定要申明为static类型。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;   </span><br><span class="line">char *returnStr()   </span><br><span class="line">&#123;   </span><br><span class="line">    static char p[]=&quot;hello world!&quot;;   </span><br><span class="line">    return p;   </span><br><span class="line">&#125;   </span><br><span class="line">int main()   </span><br><span class="line">&#123;   </span><br><span class="line">    char *str;   </span><br><span class="line">    str=returnStr();   </span><br><span class="line">    printf(&quot;%s\n&quot;, str);   </span><br><span class="line">  </span><br><span class="line">    return 0;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-数组是不能作为函数的返回值的，原因是编译器把数组名认为是局部变量（数组）的地址。返回一个数组一般用返回指向这个数组的指针代替，而且这个指针不能指向一个自动数组，因为函数结束后自动数组被抛弃，但可以返回一个指向静态局部数组的指针，因为静态存储期是从对象定义到程序结束的。"><a href="#5-数组是不能作为函数的返回值的，原因是编译器把数组名认为是局部变量（数组）的地址。返回一个数组一般用返回指向这个数组的指针代替，而且这个指针不能指向一个自动数组，因为函数结束后自动数组被抛弃，但可以返回一个指向静态局部数组的指针，因为静态存储期是从对象定义到程序结束的。" class="headerlink" title="5. 数组是不能作为函数的返回值的，原因是编译器把数组名认为是局部变量（数组）的地址。返回一个数组一般用返回指向这个数组的指针代替，而且这个指针不能指向一个自动数组，因为函数结束后自动数组被抛弃，但可以返回一个指向静态局部数组的指针，因为静态存储期是从对象定义到程序结束的。"></a>5. 数组是不能作为函数的返回值的，原因是编译器把数组名认为是局部变量（数组）的地址。返回一个数组一般用返回指向这个数组的指针代替，而且这个指针不能指向一个自动数组，因为函数结束后自动数组被抛弃，但可以返回一个指向静态局部数组的指针，因为静态存储期是从对象定义到程序结束的。</h5><p>如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int* func( void )  </span><br><span class="line">&#123;  </span><br><span class="line">    static int a[10];  </span><br><span class="line">    ........  </span><br><span class="line">    return a;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="6-返回指向堆内存的指针是可以的"><a href="#6-返回指向堆内存的指针是可以的" class="headerlink" title="6. 返回指向堆内存的指针是可以的"></a>6. 返回指向堆内存的指针是可以的</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char *GetMemory3(int num)  </span><br><span class="line">&#123;  </span><br><span class="line">    char *p = (char *)malloc(sizeof(char) * num);  </span><br><span class="line">    return p;  </span><br><span class="line">&#125;  </span><br><span class="line">void Test3(void)  </span><br><span class="line">&#123;  </span><br><span class="line">    char *str = NULL;  </span><br><span class="line">    str = GetMemory3(100);  </span><br><span class="line">    strcpy(str, &quot;hello&quot;);  </span><br><span class="line">    cout&lt;&lt; str &lt;&lt; endl;  </span><br><span class="line">    free(str);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序在运行的时候用 malloc 申请任意多少的内存,程序员自己负责在何时用 free释放内存。动态内存的生存期由程序员自己决定,使用非常灵活。</p>
<h5 id="7-通过局部变量在另一个函数去取值-传一个地址，用指针变量来接收，用指针来指向一个值"><a href="#7-通过局部变量在另一个函数去取值-传一个地址，用指针变量来接收，用指针来指向一个值" class="headerlink" title="7. 通过局部变量在另一个函数去取值(传一个地址，用指针变量来接收，用指针来指向一个值)"></a>7. 通过局部变量在另一个函数去取值(传一个地址，用指针变量来接收，用指针来指向一个值)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void get_value(int* Temp)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;2:0x%x\n&quot;,Temp);</span><br><span class="line">    *Temp = 6;</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    int temp;</span><br><span class="line">    printf(&quot;1:0x%x\n&quot;,&amp;temp);</span><br><span class="line">    </span><br><span class="line">    get_value(&amp;temp);</span><br><span class="line">    printf(&quot;3:%d\n&quot;,temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8-通过局部变量数组在另一个函数去取值-传一个地址，用指针变量来接收，用指针来指向一个值"><a href="#8-通过局部变量数组在另一个函数去取值-传一个地址，用指针变量来接收，用指针来指向一个值" class="headerlink" title="8. 通过局部变量数组在另一个函数去取值(传一个地址，用指针变量来接收，用指针来指向一个值)"></a>8. 通过局部变量数组在另一个函数去取值(传一个地址，用指针变量来接收，用指针来指向一个值)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void get_value(char * ptemp)</span><br><span class="line">&#123;</span><br><span class="line">	char i;</span><br><span class="line">    printf(&quot;2:0x%x\n&quot;,ptemp);</span><br><span class="line">    ptemp = &quot;hello world!&quot;;//这样不行，字符串常量放在只读数据段，和主函数中的temp局部数据区域有冲突</span><br><span class="line">	</span><br><span class="line">	printf(&quot;3:%s\n&quot;,ptemp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char temp[13]=&#123;0&#125;;</span><br><span class="line">    printf(&quot;1:0x%x\n&quot;,temp);</span><br><span class="line">    </span><br><span class="line">    get_value(temp);</span><br><span class="line">	</span><br><span class="line">    printf(&quot;4:%s\n&quot;,temp);</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/2019/12/15/C%E8%AF%AD%E8%A8%80-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/1.png" alt="1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void get_value(char * ptemp)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;2:0x%x\n&quot;,ptemp);</span><br><span class="line">    for(char i=0;i&lt;13;i++)//这样可以，temp和ptemp都在栈函数数据区域中，main函数调用get_value，get_value会先释放，但是temp申请的内存空间，此时并没有释放，所以可以拿到值。</span><br><span class="line">	&#123;</span><br><span class="line">		ptemp[i] = &apos;h&apos;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	printf(&quot;3:%s\n&quot;,ptemp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char temp[13]=&#123;0&#125;;</span><br><span class="line">    printf(&quot;1:0x%x\n&quot;,temp);</span><br><span class="line">    </span><br><span class="line">    get_value(temp);</span><br><span class="line">	</span><br><span class="line">    printf(&quot;4:%s\n&quot;,temp);</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/2019/12/15/C%E8%AF%AD%E8%A8%80-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/2.png" alt="2"></p>
<h5 id="9-通过结构体类型的局部变量数组在另一个函数去取值-传一个结构体变量的地址，用指针变量来接收，用指针来指向一个值"><a href="#9-通过结构体类型的局部变量数组在另一个函数去取值-传一个结构体变量的地址，用指针变量来接收，用指针来指向一个值" class="headerlink" title="9. 通过结构体类型的局部变量数组在另一个函数去取值(传一个结构体变量的地址，用指针变量来接收，用指针来指向一个值)"></a>9. 通过结构体类型的局部变量数组在另一个函数去取值(传一个结构体变量的地址，用指针变量来接收，用指针来指向一个值)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">	char hisi_app[9];</span><br><span class="line">	char sys_lib[9];</span><br><span class="line">	char mb_mcu[9];</span><br><span class="line">	char mcu_4g[9];</span><br><span class="line">	char mcu_1256[9];</span><br><span class="line">	char device[7];</span><br><span class="line">&#125;file_ver_t;</span><br><span class="line"></span><br><span class="line">void read_file_version(file_ver_t *pfile_ver)</span><br><span class="line">&#123;</span><br><span class="line">	memset(pfile_ver-&gt;hisi_app,0,9);</span><br><span class="line">	memcpy(pfile_ver-&gt;hisi_app,&quot;3.01.0001&quot;,9);</span><br><span class="line">	printf(&quot;%s\n&quot;, pfile_ver-&gt;hisi_app);	</span><br><span class="line">	memcpy(pfile_ver-&gt;sys_lib,&quot;3.01.0001&quot;,9);</span><br><span class="line">	printf(&quot;%s\n&quot;, pfile_ver-&gt;sys_lib);	</span><br><span class="line">	memcpy(pfile_ver-&gt;mb_mcu,&quot;3.01.0001&quot;,9);</span><br><span class="line">	printf(&quot;%s\n&quot;, pfile_ver-&gt;mb_mcu);</span><br><span class="line">	memcpy(pfile_ver-&gt;mcu_4g,&quot;3.01.0001&quot;,9);</span><br><span class="line">	printf(&quot;%s\n&quot;, pfile_ver-&gt;mcu_4g);</span><br><span class="line">	memcpy(pfile_ver-&gt;mcu_1256,&quot;3.01.0001&quot;,9);</span><br><span class="line">	printf(&quot;%s\n&quot;, pfile_ver-&gt;mcu_1256);</span><br><span class="line">	memcpy(pfile_ver-&gt;device,&quot;1.00.00&quot;,7);</span><br><span class="line">	printf(&quot;%s\n&quot;, pfile_ver-&gt;device);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	file_ver_t file_ver;</span><br><span class="line">	read_file_version(&amp;file_ver);</span><br><span class="line">	</span><br><span class="line">	printf(&quot;%s\n&quot;, file_ver.hisi_app);</span><br><span class="line">	printf(&quot;%s\n&quot;, file_ver.sys_lib);</span><br><span class="line">	printf(&quot;%s\n&quot;, file_ver.mb_mcu);</span><br><span class="line">	printf(&quot;%s\n&quot;, file_ver.mcu_4g);</span><br><span class="line">	printf(&quot;%s\n&quot;, file_ver.mcu_1256);</span><br><span class="line">	printf(&quot;%s\n&quot;, file_ver.device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/2019/12/15/C%E8%AF%AD%E8%A8%80-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/3.png" alt="3"></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>生存周期</tag>
        <tag>内存分配</tag>
        <tag>局部变量</tag>
        <tag>数组取值</tag>
      </tags>
  </entry>
  <entry>
    <title>问题-notepadd++  ANSI编码与UTF-8编码</title>
    <url>/2019/12/15/%E9%97%AE%E9%A2%98-notepadd-ANSI%E7%BC%96%E7%A0%81%E4%B8%8EUTF-8%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<p>之前有一种见鬼的感觉，主要表现在写脚本上（写脚本主要是因为空格的原因），写程序倒是不会出现。结果导致脚本执行不成功。</p>
<a id="more"></a>

<p>使用UTF-8编码</p>
<p><img src="/2019/12/15/%E9%97%AE%E9%A2%98-notepadd-ANSI%E7%BC%96%E7%A0%81%E4%B8%8EUTF-8%E7%BC%96%E7%A0%81/1.png" alt="1"></p>
<p>使用ANSI编码</p>
<p><img src="/2019/12/15/%E9%97%AE%E9%A2%98-notepadd-ANSI%E7%BC%96%E7%A0%81%E4%B8%8EUTF-8%E7%BC%96%E7%A0%81/2.png" alt="2"></p>
<p>这种情况要记住，以后不要在这上面浪费时间了。</p>
]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>notepadd</tag>
        <tag>UTF-8</tag>
        <tag>ANSI</tag>
      </tags>
  </entry>
  <entry>
    <title>工程设计-html boa cgi上传文件</title>
    <url>/2019/12/15/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-html-boa-cgi%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>暂略</p>
]]></content>
      <categories>
        <category>工程设计</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>boa</tag>
        <tag>cgi</tag>
      </tags>
  </entry>
  <entry>
    <title>工程设计-软件升级之设备端FTP文件上传与下载(1)</title>
    <url>/2019/12/14/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E8%BD%AF%E4%BB%B6%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%AE%BE%E5%A4%87%E7%AB%AFFTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD-1/</url>
    <content><![CDATA[<h4 id="主要目的"><a href="#主要目的" class="headerlink" title="主要目的"></a>主要目的</h4><h5 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h5><h6 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h6><p>av_streamer input_streamer output_app</p>
<a id="more"></a>

<h6 id="系统库"><a href="#系统库" class="headerlink" title="系统库"></a>系统库</h6><p>libapp_para.so<br>libntptime.so<br>libsys_commom.so<br>libsys_serial.so<br>libdevsdk.so<br>librtmp_push.so<br>libsys_httppro.so<br>libdhclient.so<br>librtsp.so<br>libsys_media.so<br>libnnie_ai.so<br>libsys_base.so<br>libsys_mp4_storage.so</p>
<h6 id="MCU程序"><a href="#MCU程序" class="headerlink" title="MCU程序"></a>MCU程序</h6><p>和上面类似（略）</p>
<h5 id="上传日志"><a href="#上传日志" class="headerlink" title="上传日志"></a>上传日志</h5><p>程序运行记录（略）</p>
<h4 id="第一阶段-正常环境下"><a href="#第一阶段-正常环境下" class="headerlink" title="第一阶段-正常环境下"></a>第一阶段-正常环境下</h4><p>还是直接看图比较直观。<br><img src="/2019/12/14/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E8%BD%AF%E4%BB%B6%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%AE%BE%E5%A4%87%E7%AB%AFFTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD-1/1.png" alt="1"></p>
<h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p><a href="https://github.com/faihung/cURL" target="_blank" rel="noopener">参考代码</a></p>
]]></content>
      <categories>
        <category>工程设计</category>
      </categories>
      <tags>
        <tag>cURL</tag>
        <tag>FTP</tag>
        <tag>流程图</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>cURL-09_使用curl库进行http通信(转)</title>
    <url>/2019/12/12/cURL-09-%E4%BD%BF%E7%94%A8curl%E5%BA%93%E8%BF%9B%E8%A1%8Chttp%E9%80%9A%E4%BF%A1-%E8%BD%AC/</url>
    <content><![CDATA[<h5 id="一、LibCurl基本编程框架"><a href="#一、LibCurl基本编程框架" class="headerlink" title="一、LibCurl基本编程框架"></a>一、LibCurl基本编程框架</h5><p>关于libcurl，<a href="https://www.faihung.net/2019/11/03/cURL-01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BA%86%E8%A7%A3/">前面已经有了很多介绍</a>，这里就不详西描述了。</p>
<p>在基于LibCurl的程序里，主要采用callback function （回调函数）的形式完成传输任务，用户在启动传输前设置好各类参数和回调函数，当满足条件时libcurl将调用用户的回调函数实现特定功能。</p>
<a id="more"></a>

<p>下面是利用libcurl完成传输任务的流程：</p>
<ol>
<li>调用curl_global_init()初始化libcurl</li>
<li>调用curl_easy_init()函数得到 easy interface 型指针</li>
<li>调用curl_easy_setopt()设置传输选项</li>
<li>根据curl_easy_setopt()设置的传输选项，实现回调函数以完成用户特定任务</li>
<li>调用curl_easy_perform()函数完成传输任务</li>
<li>调用curl_easy_cleanup()释放内存</li>
</ol>
<p>在整过过程中设置curl_easy_setopt()参数是最关键的，几乎所有的libcurl程序都要使用它。</p>
<h5 id="二、一些基本的函数"><a href="#二、一些基本的函数" class="headerlink" title="二、一些基本的函数"></a>二、一些基本的函数</h5><h6 id="1-CURLcode-curl-global-init-long-flags"><a href="#1-CURLcode-curl-global-init-long-flags" class="headerlink" title="1.CURLcode curl_global_init(long flags);"></a>1.CURLcode curl_global_init(long flags);</h6><p>描述：<br>这个函数只能用一次。(其实在调用curl_global_cleanup 函数后仍然可再用)<br>如果这个函数在curl_easy_init函数调用时还没调用，它将由libcurl库自动调用，所以多线程下最好主动调用该函数以防止在线程中curl_easy_init时多次调用。</p>
<p>注意：虽然libcurl是线程安全的，但curl_global_init是不能保证线程安全的，所以不要在每个线程中都调用curl_global_init，应该将该函数的调用放在主线程中。</p>
<p>参数：flags</p>
<pre><code>CURL_GLOBAL_ALL             //初始化所有的可能的调用。
CURL_GLOBAL_SSL             //初始化支持安全套接字层。
CURL_GLOBAL_WIN32           //初始化win32套接字库。
CURL_GLOBAL_NOTHING         //没有额外的初始化。</code></pre><h6 id="2-void-curl-global-cleanup-void"><a href="#2-void-curl-global-cleanup-void" class="headerlink" title="2 void curl_global_cleanup(void);"></a>2 void curl_global_cleanup(void);</h6><p>描述：在结束libcurl使用的时候，用来对curl_global_cleanup做的工作清理。类似于close的函数。</p>
<p>注意：虽然libcurl是线程安全的，但curl_global_cleanup是不能保证线程安全的，所以不要在每个线程中都调用curl_global_init，应该将该函数的调用放在主线程中。</p>
<h6 id="3-char-curl-version"><a href="#3-char-curl-version" class="headerlink" title="3 char *curl_version( );"></a>3 char *curl_version( );</h6><p>描述: 打印当前libcurl库的版本。</p>
<h6 id="4-CURL-curl-easy-init"><a href="#4-CURL-curl-easy-init" class="headerlink" title="4 CURL *curl_easy_init( );"></a>4 CURL *curl_easy_init( );</h6><p>描述:<br>curl_easy_init用来初始化一个CURL的指针(有些像返回FILE类型的指针一样). 相应的在调用结束时要用curl_easy_cleanup函数清理.<br>一般curl_easy_init意味着一个会话的开始. 它会返回一个easy_handle(CURL*对象), 一般都用在easy系列的函数中.</p>
<h6 id="5-void-curl-easy-cleanup-CURL-handle"><a href="#5-void-curl-easy-cleanup-CURL-handle" class="headerlink" title="5 void curl_easy_cleanup(CURL *handle);"></a>5 void curl_easy_cleanup(CURL *handle);</h6><p>描述:<br>这个调用用来结束一个会话，curl_easy_init配合着用。</p>
<p>参数:<br>CURL类型的指针.</p>
<h6 id="6-CURLcode-curl-easy-setopt-CURL-handle-CURLoption-option-parameter"><a href="#6-CURLcode-curl-easy-setopt-CURL-handle-CURLoption-option-parameter" class="headerlink" title="6 CURLcode curl_easy_setopt(CURL *handle, CURLoption option, parameter);"></a>6 CURLcode curl_easy_setopt(CURL *handle, CURLoption option, parameter);</h6><p>描述: 这个函数最重要了.几乎所有的curl程序都要频繁的使用它.它告诉curl库.程序将有如何的行为. 比如要查看一个网页的html代码等.(这个函数有些像ioctl函数)参数:</p>
<ol>
<li>CURL类型的指针。</li>
<li>各种CURLoption类型的选项.(都在curl.h库里有定义,man也可以查看到)</li>
<li>parameter 这个参数既可以是个函数的指针,也可以是某个对象的指针,也可以是个long型的变量.它用什么这取决于第二个参数。<br>CURLoption 这个参数的取值很多.具体的可以查看man手册。</li>
</ol>
<h6 id="7-CURLcode-curl-easy-perform-CURL-handle"><a href="#7-CURLcode-curl-easy-perform-CURL-handle" class="headerlink" title="7 CURLcode curl_easy_perform(CURL *handle);"></a>7 CURLcode curl_easy_perform(CURL *handle);</h6><p>描述:这个函数在初始化CURL类型的指针 以及curl_easy_setopt完成后调用.就像字面的意思所说perform就像是个舞台，让我们设置的<br>option 运作起来.</p>
<p>参数:<br>CURL类型的指针。</p>
<h5 id="三、curl-easy-setopt函数部分选项介绍"><a href="#三、curl-easy-setopt函数部分选项介绍" class="headerlink" title="三、curl_easy_setopt函数部分选项介绍"></a>三、curl_easy_setopt函数部分选项介绍</h5><p>本节主要介绍curl_easy_setopt中跟http相关的参数。该函数是curl中非常重要的函数，curl所有设置都是在该函数中完成的，该函数的设置选项众多，注意本节的阐述的只是部分常见选项。</p>
<h6 id="1-CURLOPT-URL"><a href="#1-CURLOPT-URL" class="headerlink" title="1.CURLOPT_URL"></a>1.CURLOPT_URL</h6><p>设置访问URL</p>
<h6 id="2-CURLOPT-WRITEFUNCTION，CURLOPT-WRITEDATA"><a href="#2-CURLOPT-WRITEFUNCTION，CURLOPT-WRITEDATA" class="headerlink" title="2.CURLOPT_WRITEFUNCTION，CURLOPT_WRITEDATA"></a>2.CURLOPT_WRITEFUNCTION，CURLOPT_WRITEDATA</h6><p>回调函数原型为：</p>
<pre><code>size_t function( void *ptr, size_t size, size_t nmemb, void *stream);</code></pre><p>函数将在libcurl接收到数据后被调用，因此函数多做数据保存的功能，如处理下载文件。</p>
<p>CURLOPT_WRITEDATA 用于表明CURLOPT_WRITEFUNCTION函数中的stream指针的来源。<br>如果你没有通过CURLOPT_WRITEFUNCTION属性给easy handle设置回调函数，libcurl会提供一个默认的回调函数，它只是简单的将接收到的数据打印到标准输出。你也可以通过 CURLOPT_WRITEDATA属性给默认回调函数传递一个已经打开的文件指针，用于将数据输出到文件里。</p>
<h6 id="3-CURLOPT-HEADERFUNCTION，CURLOPT-HEADERDATA"><a href="#3-CURLOPT-HEADERFUNCTION，CURLOPT-HEADERDATA" class="headerlink" title="3.CURLOPT_HEADERFUNCTION，CURLOPT_HEADERDATA"></a>3.CURLOPT_HEADERFUNCTION，CURLOPT_HEADERDATA</h6><p>回调函数原型为 </p>
<pre><code>size_t function( void *ptr, size_t size,size_t nmemb, void *stream);</code></pre><p>libcurl一旦接收到http 头部数据后将调用该函数。CURLOPT_WRITEDATA 传递指针给libcurl，该指针表明CURLOPT_HEADERFUNCTION函数的stream指针的来源。</p>
<h6 id="4-CURLOPT-READFUNCTION-CURLOPT-READDATA"><a href="#4-CURLOPT-READFUNCTION-CURLOPT-READDATA" class="headerlink" title="4.CURLOPT_READFUNCTION CURLOPT_READDATA"></a>4.CURLOPT_READFUNCTION CURLOPT_READDATA</h6><p>libCurl需要读取数据传递给远程主机时将调用CURLOPT_READFUNCTION指定的函数，函数原型是：</p>
<pre><code>size_t function(void *ptr, size_t size, size_t nmemb,void *stream)；</code></pre><p>CURLOPT_READDATA 表明CURLOPT_READFUNCTION函数原型中的stream指针来源。</p>
<h6 id="5-CURLOPT-NOPROGRESS，CURLOPT-PROGRESSFUNCTION，CURLOPT-PROGRESSDATA"><a href="#5-CURLOPT-NOPROGRESS，CURLOPT-PROGRESSFUNCTION，CURLOPT-PROGRESSDATA" class="headerlink" title="5.CURLOPT_NOPROGRESS，CURLOPT_PROGRESSFUNCTION，CURLOPT_PROGRESSDATA"></a>5.CURLOPT_NOPROGRESS，CURLOPT_PROGRESSFUNCTION，CURLOPT_PROGRESSDATA</h6><p>跟数据传输进度相关的参数。CURLOPT_PROGRESSFUNCTION指定的函数正常情况下每秒被libcurl调用一次，为了使CURLOPT_PROGRESSFUNCTION被调用，CURLOPT_NOPROGRESS必须被设置为false，CURLOPT_PROGRESSDATA指定的参数将作为CURLOPT_PROGRESSFUNCTION指定函数的第一个参数</p>
<h6 id="6-CURLOPT-TIMEOUT，CURLOPT-CONNECTIONTIMEOUT"><a href="#6-CURLOPT-TIMEOUT，CURLOPT-CONNECTIONTIMEOUT" class="headerlink" title="6.CURLOPT_TIMEOUT，CURLOPT_CONNECTIONTIMEOUT"></a>6.CURLOPT_TIMEOUT，CURLOPT_CONNECTIONTIMEOUT</h6><p>CURLOPT_TIMEOUT 由于设置传输时间，CURLOPT_CONNECTIONTIMEOUT 设置连接等待时间</p>
<h6 id="7-CURLOPT-FOLLOWLOCATION"><a href="#7-CURLOPT-FOLLOWLOCATION" class="headerlink" title="7.CURLOPT_FOLLOWLOCATION"></a>7.CURLOPT_FOLLOWLOCATION</h6><p>设置重定位URL</p>
<h6 id="8-CURLOPT-RANGE-CURLOPT-RESUME-FROM"><a href="#8-CURLOPT-RANGE-CURLOPT-RESUME-FROM" class="headerlink" title="8.CURLOPT_RANGE: CURLOPT_RESUME_FROM:"></a>8.CURLOPT_RANGE: CURLOPT_RESUME_FROM:</h6><p>断点续传相关设置。CURLOPT_RANGE 指定char *参数传递给libcurl，用于指明http域的RANGE头域，</p>
<p>例如：</p>
<pre><code>表示头500个字节：bytes=0-499
表示第二个500字节：bytes=500-999
表示最后500个字节：bytes=-500
表示500字节以后的范围：bytes=500-
第一个和最后一个字节：bytes=0-0,-1
同时指定几个范围：bytes=500-600,601-999</code></pre><p>CURLOPT_RESUME_FROM 传递一个long参数给libcurl，指定你希望开始传递的偏移量。</p>
<h5 id="四、curl-easy-perform-函数说明（error-状态码）"><a href="#四、curl-easy-perform-函数说明（error-状态码）" class="headerlink" title="四、curl_easy_perform 函数说明（error 状态码）"></a>四、curl_easy_perform 函数说明（error 状态码）</h5><p>该函数是完成curl_easy_setopt指定的所有选项，本节重点介绍curl_easy_perform的返回值。返回0意味一切ok，非0代表错误发生。主要错误码说明：</p>
<pre><code>1.CURLE_OK
任务完成一切都好
2.CURLE_UNSUPPORTED_PROTOCOL
不支持的协议，由URL的头部指定
3.CURLE_COULDNT_CONNECT
不能连接到remote 主机或者代理
4.CURLE_REMOTE_ACCESS_DENIED
访问被拒绝
5.CURLE_HTTP_RETURNED_ERROR
Http返回错误
6.CURLE_READ_ERROR
读本地文件错误</code></pre><p>要获取详细的错误描述字符串，可以通过</p>
<pre><code>const char *curl_easy_strerror(CURLcode errornum ) </code></pre><p>这个函数取得。    </p>
<h5 id="五、libcurl使用的HTTP消息头"><a href="#五、libcurl使用的HTTP消息头" class="headerlink" title="五、libcurl使用的HTTP消息头"></a>五、libcurl使用的HTTP消息头</h5><p>当使用libcurl发送http请求时，它会自动添加一些http头。我们可以通过CURLOPT_HTTPHEADER属性手动替换、添加或删除相应 的HTTP消息头。</p>
<pre><code>Host
http1.1（大部分http1.0)版本都要求客户端请求提供这个信息头。
Pragma
&quot;no-cache&quot;。表示不要缓冲数据。
Accept
&quot;*/*&quot;。表示允许接收任何类型的数据。
Expect
以POST的方式向HTTP服务器提交请求时，libcurl会设置该消息头为&quot;100-continue&quot;，它要求服务器在正式处理该请求之前，返回一 个&quot;OK&quot;消息。如果POST的数据很小，libcurl可能不会设置该消息头。</code></pre><p><strong>自定义选项</strong></p>
<p>当前越来越多的协议都构建在HTTP协议之上（如：soap），这主要归功于HTTP的可靠性，以及被广泛使用的代理支持（可以穿透大部分防火墙）。 这些协议的使用方式与传统HTTP可能有很大的不同。对此，libcurl作了很好的支持。</p>
<p>自定义请求方式(CustomRequest)，<br>HTTP支持GET, HEAD或者POST提交请求。可以设置CURLOPT_CUSTOMREQUEST来设置自定义的请求方式，libcurl默认以GET方式提交请求：</p>
<pre><code>curl_easy_setopt(easy_handle, CURLOPT_CUSTOMREQUEST, &quot;MYOWNREQUEST&quot;);</code></pre><p><strong>修改消息头</strong></p>
<p>HTTP协议提供了消息头，请求消息头用于告诉服务器如何处理请求；响应消息头则告诉浏览器如何处理接收到的数据。在libcurl中，你可以自由的添加这些消息头：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct curl_slist *headers=NULL; /* init to NULL is important */</span><br><span class="line">headers = curl_slist_append(headers, &quot;Hey-server-hey: how are you?&quot;);</span><br><span class="line">headers = curl_slist_append(headers, &quot;X-silly-content: yes&quot;);</span><br><span class="line">/* pass our list of custom made headers */</span><br><span class="line">curl_easy_setopt(easyhandle, CURLOPT_HTTPHEADER, headers);</span><br><span class="line">curl_easy_perform(easyhandle); /* transfer http */</span><br><span class="line">curl_slist_free_all(headers); /* free the header list */</span><br></pre></td></tr></table></figure>

<p>对于已经存在的消息头，可以重新设置它的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">headers = curl_slist_append(headers, &quot;Accept: Agent-007&quot;); </span><br><span class="line">headers = curl_slist_append(headers, &quot;Host: munged.host.line&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>删除消息头</strong></p>
<p>对于一个已经存在的消息头，设置它的内容为空，libcurl在发送请求时就不会同时提交该消息头：</p>
<pre><code>headers = curl_slist_append(headers, &quot;Accept:&quot;);</code></pre><h5 id="六、获取http应答头信息"><a href="#六、获取http应答头信息" class="headerlink" title="六、获取http应答头信息"></a>六、获取http应答头信息</h5><p>发出http请求后，服务器会返回应答头信息和应答数据，如果仅仅是打印应答头的所有内容，则直接可以通过curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, 打印函数)的方式来完成，这里需要获取的是应答头中特定的信息，比如应答码、cookies列表等，则需要通过下面这个函数：</p>
<pre><code>CURLcode curl_easy_getinfo(CURL *curl, CURLINFO info, ... );</code></pre><p>info参数就是我们需要获取的内容，下面是一些参数值:</p>
<pre><code>1.CURLINFO_RESPONSE_CODE 获取应答码
2.CURLINFO_HEADER_SIZE 头大小
3.CURLINFO_COOKIELIST cookies列表</code></pre><p>除了获取应答信息外，这个函数还能获取curl的一些内部信息，如请求时间、连接时间等等。</p>
<p>更多的参数可以参考API文档。</p>
<h5 id="七、多线程问题"><a href="#七、多线程问题" class="headerlink" title="七、多线程问题"></a>七、多线程问题</h5><p>首先一个基本原则就是：绝对不应该在线程之间共享同一个libcurl handle(CURL *对象)，不管是easy handle还是multi handle（本文只介绍easy_handle）。一个线程每次只能使用一个handle。</p>
<p>libcurl是线程安全的，但有两点例外：信号(signals)和SSL/TLS handler。 信号用于超时失效名字解析(timing out name resolves)。libcurl依赖其他的库来支持SSL/STL，所以用多线程的方式访问HTTPS或FTPS的URL时，应该满足这些库对多线程 操作的一些要求。</p>
<p>NSS: 宣称是多线程安全的。</p>
<h5 id="八、什么时候libcurl无法正常工作"><a href="#八、什么时候libcurl无法正常工作" class="headerlink" title="八、什么时候libcurl无法正常工作"></a>八、什么时候libcurl无法正常工作</h5><p>传输失败总是有原因的。你可能错误的设置了一些libcurl的属性或者没有正确的理解某些属性的含义，或者是远程主机返回一些无法被正确解析的内容。</p>
<p>这里有一个<strong>黄金法则</strong>来处理这些问题：</p>
<p>将CURLOPT_VERBOSE属性设置为1，libcurl会输出通信过程中的一些细节。如果使用的是http协议，请求头/响应头也会被输出。将CURLOPT_HEADER设为1，这些头信息将出现在消息的内容中。</p>
<p>当然不可否认的是，libcurl还存在bug。</p>
<p>如果你对相关的协议了解越多，在使用libcurl时，就越不容易犯错。</p>
<h5 id="九、关于密码"><a href="#九、关于密码" class="headerlink" title="九、关于密码"></a>九、关于密码</h5><p>客户端向服务器发送请求时，许多协议都要求提供用户名与密码。libcurl提供了多种方式来设置它们。</p>
<p>一些协议支持在URL中直接指定用户名和密码，类似于：<br>protocol://user:<a href="mailto:password@example.com" target="_blank" rel="noopener">password@example.com</a>/path/。libcurl能正确的识别这种URL中的用户名与密码并执行相应的操作。如果你提供的用户名和密码中有特殊字符，首先应该对其进行URL编码。</p>
<p>也可以通过CURLOPT_USERPWD属性来设置用户名与密码。参数是格式如<br>“user:password ”的字符串：</p>
<pre><code>curl_easy_setopt(easy_handle, CURLOPT_USERPWD, &quot;user_name:password&quot;);</code></pre><p>有时候在访问代理服务器的时候，可能时时要求提供用户名和密码进行用户身份验证。这种情况下，libcurl提供了另一个属性CURLOPT_PROXYUSERPWD：</p>
<pre><code>curl_easy_setopt(easy_handle, CURLOPT_PROXYUSERPWD, &quot;user_name:password&quot;);</code></pre><p>在UNIX平台下，访问FTP的用户名和密码可能会被保存在$HOME/.netrc文件中。libcurl支持直接从这个文件中获取用户名与密码：  </p>
<pre><code>curl_easy_setopt(easy_handle, CURLOPT_NETRC, 1L);    </code></pre><p>在使用SSL时，可能需要提供一个私钥用于数据安全传输，通过CURLOPT_KEYPASSWD来设置私钥：</p>
<pre><code>curl_easy_setopt(easy_handle, CURLOPT_KEYPASSWD, &quot;keypassword&quot;);</code></pre><h5 id="十、HTTP验证"><a href="#十、HTTP验证" class="headerlink" title="十、HTTP验证"></a>十、HTTP验证</h5><p>在使用HTTP协议时，客户端有很多种方式向服务器提供验证信息。默认的HTTP验证方法是”Basic”，它将用户名与密码以明文的方式、经Base64编码后保存在HTTP请求头中，发往服务器。当然这不太安全。</p>
<p>当前版本的libcurl支持的验证方法有：basic, Digest, NTLM, Negotiate, GSS-Negotiate and SPNEGO。（译者感叹：搞Web这么多年，尽然不知道这些Http的验证方式，实在惭愧。）可以通过CURLOPT_HTTPAUTH属性来设置具体 的验证方式：</p>
<pre><code>curl_easy_setopt(easy_handle, CURLOPT_HTTPAUTH, CURLAUTH_DIGEST);</code></pre><p>向代理服务器发送验证信息时，可以通过CURLOPT_PROXYAUTH设置验证方式：</p>
<pre><code>curl_easy_setopt(easy_handle, CURLOPT_PROXYAUTH, CURLAUTH_NTLM);</code></pre><p>也可以同时设置多种验证方式（通过按位与）， 使用’CURLAUTH_ANY’将允许libcurl可以选择任何它所支持的验证方式。通过CURLOPT_HTTPAUTH或 CURLOPT_PROXYAUTH属性设置的多种验证方式，libcurl会在运行时选择一种它认为是最好的方式与服务器通信：</p>
<pre><code>curl_easy_setopt(easy_handle, CURLOPT_HTTPAUTH,  CURLAUTH_DIGEST|CURLAUTH_BASIC);
// curl_easy_setopt(easy_handle, CURLOPT_HTTPAUTH,  CURLAUTH_ANY);</code></pre><h5 id="十一、代码示例"><a href="#十一、代码示例" class="headerlink" title="十一、代码示例"></a>十一、代码示例</h5><h6 id="1-基本的http-GET-POST操作"><a href="#1-基本的http-GET-POST操作" class="headerlink" title="1.基本的http GET/POST操作"></a>1.基本的http GET/POST操作</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line"></span><br><span class="line">bool getUrl(char *filename)</span><br><span class="line">&#123;</span><br><span class="line">    CURL *curl;</span><br><span class="line">    CURLcode res;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    if ((fp = fopen(filename, &quot;w&quot;)) == NULL)  //返回结果用文件存储</span><br><span class="line">        return false;</span><br><span class="line">    struct curl_slist *headers = NULL;</span><br><span class="line">    headers = curl_slist_append(headers, &quot;Accept: Agent-007&quot;);</span><br><span class="line">    curl = curl_easy_init();    //初始化</span><br><span class="line">    if (curl)</span><br><span class="line">    &#123;</span><br><span class="line">        //curl_easy_setopt(curl, CURLOPT_PROXY, &quot;10.99.60.201:8080&quot;);//代理</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);//改协议头</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_URL,&quot;http://www.baidu.com&quot;);</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp); //将返回的http头输出到fp指向的文件</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_HEADERDATA, fp); //将返回的html主体数据输出到fp指向的文件</span><br><span class="line">        res = curl_easy_perform(curl);   // 执行</span><br><span class="line">        if (res != 0) &#123;</span><br><span class="line"></span><br><span class="line">            curl_slist_free_all(headers);</span><br><span class="line">            curl_easy_cleanup(curl);</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool postUrl(char *filename)</span><br><span class="line">&#123;</span><br><span class="line">    CURL *curl;</span><br><span class="line">    CURLcode res;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    if ((fp = fopen(filename, &quot;w&quot;)) == NULL)</span><br><span class="line">        return false;</span><br><span class="line">    curl = curl_easy_init();</span><br><span class="line">    if (curl)</span><br><span class="line">    &#123;</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_COOKIEFILE, &quot;/mnt/hgfs/VMWARE/test/10-http/temp/cookie.txt&quot;); // 指定cookie文件</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, &quot;&amp;logintype=uid&amp;u=xieyan&amp;psw=xxx86&quot;);    // 指定post内容</span><br><span class="line">        //curl_easy_setopt(curl, CURLOPT_PROXY, &quot;10.99.60.201:8080&quot;);</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_URL, &quot; http://mail.sina.com.cn/cgi-bin/login.cgi &quot;);   // 指定url</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);</span><br><span class="line">        res = curl_easy_perform(curl);</span><br><span class="line">        curl_easy_cleanup(curl);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    getUrl(&quot;/mnt/hgfs/VMWARE/test/10-http/temp/get.html&quot;);</span><br><span class="line">    postUrl(&quot;/mnt/hgfs/VMWARE/test/10-http/temp/post.html&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行命令：</p>
<pre><code>gcc  get_post.c  -o get_post –lcurl
./ get_post</code></pre><p>得到结果：<br>略</p>
<h6 id="2-获取html网页"><a href="#2-获取html网页" class="headerlink" title="2. 获取html网页"></a>2. 获取html网页</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    CURL *curl;             //定义CURL类型的指针</span><br><span class="line">    CURLcode res;           //定义CURLcode类型的变量，保存返回状态码</span><br><span class="line">    if(argc!=2)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Usage : file &lt;url&gt;;\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    curl = curl_easy_init();        //初始化一个CURL类型的指针</span><br><span class="line">    if(curl!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        //设置curl选项. 其中CURLOPT_URL是让用户指 定url. argv[1]中存放的命令行传进来的网址</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_URL, argv[1]);        </span><br><span class="line">        //调用curl_easy_perform 执行我们的设置.并进行相关的操作. 在这 里只在屏幕上显示出来.</span><br><span class="line">        res = curl_easy_perform(curl);</span><br><span class="line">        //清除curl操作.</span><br><span class="line">        curl_easy_cleanup(curl);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行命令：</p>
<pre><code>gcc  get_http.c  -o get_http –lcurl
./get_http www.baidu.com</code></pre><h6 id="3-网页下载保存实例"><a href="#3-网页下载保存实例" class="headerlink" title="3. 网页下载保存实例"></a>3. 网页下载保存实例</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 采用CURLOPT_WRITEFUNCTION 实现网页下载保存功能</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;;</span><br><span class="line"> </span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line">#include &lt;curl/types.h&gt;</span><br><span class="line">#include &lt;curl/easy.h&gt;</span><br><span class="line"> </span><br><span class="line">FILE *fp;  //定义FILE类型指针</span><br><span class="line">//这个函数是为了符合CURLOPT_WRITEFUNCTION而构造的</span><br><span class="line">//完成数据保存功能</span><br><span class="line">size_t write_data(void *ptr, size_t size, size_t nmemb, void *stream)  </span><br><span class="line">&#123;</span><br><span class="line">    int written = fwrite(ptr, size, nmemb, (FILE *)fp);</span><br><span class="line">    return written;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    CURL *curl;</span><br><span class="line"> </span><br><span class="line">    curl_global_init(CURL_GLOBAL_ALL);  </span><br><span class="line">    curl=curl_easy_init();</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL, argv[1]);  </span><br><span class="line"> </span><br><span class="line">    if((fp=fopen(argv[2],&quot;w&quot;))==NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        curl_easy_cleanup(curl);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    ////CURLOPT_WRITEFUNCTION 将后继的动作交给write_data函数处理</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);  </span><br><span class="line">    curl_easy_perform(curl);</span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行命令：</p>
<pre><code>gcc  save_http.c  -o save_http –lcurl
./ save_http www.baidu.com
/tmp/baidu</code></pre><h6 id="4-进度条实例显示文件下载进度"><a href="#4-进度条实例显示文件下载进度" class="headerlink" title="4.进度条实例显示文件下载进度"></a>4.进度条实例显示文件下载进度</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 采用CURLOPT_NOPROGRESS， CURLOPT_PROGRESSFUNCTION    CURLOPT_PROGRESSDATA 实现文件传输进度提示功能</span><br><span class="line">//函数采用了gtk库，故编译时需指定gtk库</span><br><span class="line">//函数启动专门的线程用于显示gtk 进度条bar</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;gtk/gtk.h&gt;</span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line">#include &lt;curl/types.h&gt; /* new for v7 */</span><br><span class="line">#include &lt;curl/easy.h&gt; /* new for v7 */</span><br><span class="line"> </span><br><span class="line">GtkWidget *Bar;</span><br><span class="line">////这个函数是为了符合CURLOPT_WRITEFUNCTION而构造的</span><br><span class="line">//完成数据保存功能</span><br><span class="line">size_t my_write_func(void *ptr, size_t size, size_t nmemb, FILE *stream)</span><br><span class="line">&#123;</span><br><span class="line">  return fwrite(ptr, size, nmemb, stream);</span><br><span class="line">&#125;</span><br><span class="line">//这个函数是为了符合CURLOPT_READFUNCTION而构造的</span><br><span class="line">//数据上传时使用</span><br><span class="line">size_t my_read_func(void *ptr, size_t size, size_t nmemb, FILE *stream)</span><br><span class="line">&#123;</span><br><span class="line">  return fread(ptr, size, nmemb, stream);</span><br><span class="line">&#125;</span><br><span class="line">//这个函数是为了符合CURLOPT_PROGRESSFUNCTION而构造的</span><br><span class="line">//显示文件传输进度，t代表文件大小，d代表传 输已经完成部分</span><br><span class="line">int my_progress_func(GtkWidget *bar,</span><br><span class="line">                     double t, /* dltotal */</span><br><span class="line">                     double d, /* dlnow */</span><br><span class="line">                     double ultotal,</span><br><span class="line">                     double ulnow)</span><br><span class="line">&#123;</span><br><span class="line">/*  printf(&quot;%d / %d (%g %%)\n&quot;, d, t, d*100.0/t);*/</span><br><span class="line">  gdk_threads_enter();</span><br><span class="line">  gtk_progress_set_value(GTK_PROGRESS(bar), d*100.0/t);</span><br><span class="line">  gdk_threads_leave();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void *my_thread(void *ptr)</span><br><span class="line">&#123;</span><br><span class="line">  CURL *curl;</span><br><span class="line">  CURLcode res;</span><br><span class="line">  FILE *outfile;</span><br><span class="line">  gchar *url = ptr;</span><br><span class="line"> </span><br><span class="line">  curl = curl_easy_init();</span><br><span class="line">  if(curl)</span><br><span class="line">  &#123;</span><br><span class="line">    outfile = fopen(&quot;test.curl&quot;, &quot;w&quot;);</span><br><span class="line"> </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL, url);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEDATA, outfile);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, my_write_func);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_READFUNCTION, my_read_func);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 0L);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_PROGRESSFUNCTION, my_progress_func);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_PROGRESSDATA, Bar);</span><br><span class="line"> </span><br><span class="line">    res = curl_easy_perform(curl);</span><br><span class="line"> </span><br><span class="line">    fclose(outfile);</span><br><span class="line">    /* always cleanup */</span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">  GtkWidget *Window, *Frame, *Frame2;</span><br><span class="line">  GtkAdjustment *adj;</span><br><span class="line"> </span><br><span class="line">  /* Must initialize libcurl before any threads are started */</span><br><span class="line">  curl_global_init(CURL_GLOBAL_ALL);</span><br><span class="line"> </span><br><span class="line">  /* Init thread */</span><br><span class="line">  g_thread_init(NULL);</span><br><span class="line"> </span><br><span class="line">  gtk_init(&amp;argc, &amp;argv);</span><br><span class="line">  Window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</span><br><span class="line">  Frame = gtk_frame_new(NULL);</span><br><span class="line">  gtk_frame_set_shadow_type(GTK_FRAME(Frame), GTK_SHADOW_OUT);</span><br><span class="line">  gtk_container_add(GTK_CONTAINER(Window), Frame);</span><br><span class="line">  Frame2 = gtk_frame_new(NULL);</span><br><span class="line">  gtk_frame_set_shadow_type(GTK_FRAME(Frame2), GTK_SHADOW_IN);</span><br><span class="line">  gtk_container_add(GTK_CONTAINER(Frame), Frame2);</span><br><span class="line">  gtk_container_set_border_width(GTK_CONTAINER(Frame2), 5);</span><br><span class="line">  adj = (GtkAdjustment*)gtk_adjustment_new(0, 0, 100, 0, 0, 0);</span><br><span class="line">  Bar = gtk_progress_bar_new_with_adjustment(adj);</span><br><span class="line">  gtk_container_add(GTK_CONTAINER(Frame2), Bar);</span><br><span class="line">  gtk_widget_show_all(Window);</span><br><span class="line"> </span><br><span class="line">  if (!g_thread_create(&amp;my_thread, argv[1], FALSE, NULL) != 0)</span><br><span class="line">    g_warning(&quot;can&apos;t create the thread&quot;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  gdk_threads_enter();</span><br><span class="line">  gtk_main();</span><br><span class="line">  gdk_threads_leave();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行命令：</p>
<pre><code>export PKG_CONFIG_PATH=/usr/lib/pkgconfig/
gcc progress.c –o progress ` pkg-config --libs –cflags gtk+-2..0` -lcurl –lgthread-2.0
./ progress  http://software.sky-union.cn/index.asp</code></pre><h6 id="5-断点续传实例"><a href="#5-断点续传实例" class="headerlink" title="5.断点续传实例"></a>5.断点续传实例</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//采用CURLOPT_RESUME_FROM_LARGE 实现文件断点续传功能</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line"> </span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line">//这个函数为CURLOPT_HEADERFUNCTION参数构造</span><br><span class="line">/* 从http头部获取文件size*/</span><br><span class="line">size_t getcontentlengthfunc(void *ptr, size_t size, size_t nmemb, void *stream) &#123;</span><br><span class="line">       int r;</span><br><span class="line">       long len = 0;</span><br><span class="line"> </span><br><span class="line">       /* _snscanf() is Win32 specific */</span><br><span class="line">       // r = _snscanf(ptr, size * nmemb, &quot;Content-Length: %ld\n&quot;, &amp;len);</span><br><span class="line"> r = sscanf(ptr, &quot;Content-Length: %ld\n&quot;, &amp;len);</span><br><span class="line">       if (r) /* Microsoft: we don&apos;t read the specs */</span><br><span class="line">              *((long *) stream) = len;</span><br><span class="line"> </span><br><span class="line">       return size * nmemb;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* 保存下载文件 */</span><br><span class="line">size_t wirtefunc(void *ptr, size_t size, size_t nmemb, void *stream)</span><br><span class="line">&#123;</span><br><span class="line">        return fwrite(ptr, size, nmemb, stream);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/*读取上传文件 */</span><br><span class="line">size_t readfunc(void *ptr, size_t size, size_t nmemb, void *stream)</span><br><span class="line">&#123;</span><br><span class="line">       FILE *f = stream;</span><br><span class="line">       size_t n;</span><br><span class="line"> </span><br><span class="line">       if (ferror(f))</span><br><span class="line">              return CURL_READFUNC_ABORT;</span><br><span class="line"> </span><br><span class="line">       n = fread(ptr, size, nmemb, f) * size;</span><br><span class="line"> </span><br><span class="line">       return n;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 下载 或者上传文件函数</span><br><span class="line">int download(CURL *curlhandle, const char * remotepath, const char * localpath,</span><br><span class="line">           long timeout, long tries)</span><br><span class="line">&#123;</span><br><span class="line">       FILE *f;</span><br><span class="line">       curl_off_t local_file_len = -1 ;</span><br><span class="line">       long filesize =0 ;</span><br><span class="line">       </span><br><span class="line">       CURLcode r = CURLE_GOT_NOTHING;</span><br><span class="line">       int c;</span><br><span class="line">  struct stat file_info;</span><br><span class="line">  int use_resume = 0;</span><br><span class="line">  /* 得到本地文件大小 */</span><br><span class="line">  //if(access(localpath,F_OK) ==0)</span><br><span class="line">  </span><br><span class="line">    if(stat(localpath, &amp;file_info) == 0) </span><br><span class="line">     &#123;</span><br><span class="line">        local_file_len =  file_info.st_size;</span><br><span class="line">        use_resume  = 1;</span><br><span class="line">      &#125;</span><br><span class="line">  //采用追加方式打开文件，便于实现文件断点续传工作</span><br><span class="line">       f = fopen(localpath, &quot;ab+&quot;); </span><br><span class="line">       if (f == NULL) &#123;</span><br><span class="line">              perror(NULL);</span><br><span class="line">              return 0;</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">       //curl_easy_setopt(curlhandle, CURLOPT_UPLOAD, 1L);</span><br><span class="line"> </span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_URL, remotepath);</span><br><span class="line"> </span><br><span class="line">              curl_easy_setopt(curlhandle, CURLOPT_CONNECTTIMEOUT, timeout);  // 设置连接超时，单位秒</span><br><span class="line">       //设置http 头部处理函数</span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_HEADERFUNCTION, getcontentlengthfunc);</span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_HEADERDATA, &amp;filesize);</span><br><span class="line"> // 设置文件续传的位置给libcurl</span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_RESUME_FROM_LARGE, use_resume?local_file_len:0);</span><br><span class="line"> </span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_WRITEDATA, f);</span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_WRITEFUNCTION, wirtefunc);</span><br><span class="line"> </span><br><span class="line">       //curl_easy_setopt(curlhandle, CURLOPT_READFUNCTION, readfunc);</span><br><span class="line">       //curl_easy_setopt(curlhandle, CURLOPT_READDATA, f);</span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_NOPROGRESS, 1L);</span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_VERBOSE, 1L);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  r = curl_easy_perform(curlhandle);</span><br><span class="line">       </span><br><span class="line"> </span><br><span class="line">       fclose(f);</span><br><span class="line"> </span><br><span class="line">       if (r == CURLE_OK)</span><br><span class="line"></span><br><span class="line">              return 1;</span><br><span class="line">       else &#123;</span><br><span class="line">              fprintf(stderr, &quot;%s\n&quot;, curl_easy_strerror(r));</span><br><span class="line">              return 0;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int c, char **argv) &#123;</span><br><span class="line">       CURL *curlhandle = NULL;</span><br><span class="line"> </span><br><span class="line">       curl_global_init(CURL_GLOBAL_ALL);</span><br><span class="line">       curlhandle = curl_easy_init();</span><br><span class="line"> </span><br><span class="line">       //download(curlhandle, &quot;ftp://user:pass@host/path/file&quot;, &quot;C:\\file&quot;, 0, 3);</span><br><span class="line">  download(curlhandle , &quot;http://software.sky-union.cn/index.asp&quot;,&quot;/mnt/hgfs/VMWARE/test/10-http/temp/index.asp&quot;,1,3);</span><br><span class="line">       curl_easy_cleanup(curlhandle);</span><br><span class="line">       curl_global_cleanup();</span><br><span class="line"> </span><br><span class="line">       return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行命令：</p>
<pre><code>gcc  resume.c  -o resume –lcurl
./ resume  </code></pre>]]></content>
      <categories>
        <category>cURL</category>
      </categories>
      <tags>
        <tag>cURL</tag>
      </tags>
  </entry>
  <entry>
    <title>cURL-08_ARM交叉编译</title>
    <url>/2019/12/12/cURL-08-ARM%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p><a href="https://www.faihung.net/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/">前面</a>提到过libcurl在Ubuntu环境下的编译安装，本章主要是嵌入式环境下的ARM交叉编译</p>
<p>执行<a href="https://www.faihung.net/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/">前面</a>的操作之后，进行arm的交叉编译</p>
<pre><code>./configure --host=arm-himix200-linux CC=arm-himix200-linux-gcc CXX=arm-himix200-linux-g++ </code></pre><a id="more"></a>


<p>交叉编译，说实话整了好几个小时没怎么明白，不知道为什么不行。</p>
<p>但是，我把原有工程的的cURL模块拆分出来，修改了Makefile之后，可以交叉编译可以在设备中运行。</p>
<p>目前关于cURL的交叉编译就告一段落，之后有时间在研究编译。</p>
]]></content>
      <categories>
        <category>cURL</category>
      </categories>
      <tags>
        <tag>cURL</tag>
      </tags>
  </entry>
  <entry>
    <title>cURL-07_Linux下使用libcurl实现FTP文件上传下载功能</title>
    <url>/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<blockquote>
<p>Linux下使用libcurl实现FTP单个文件或者压缩包上传下载功能</p>
</blockquote>
<a id="more"></a>

<h5 id="一、关于FTP"><a href="#一、关于FTP" class="headerlink" title="一、关于FTP"></a>一、关于FTP</h5><p>参考：<br><a href="https://www.faihung.net/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/">在WIN10上搭建Ftp服务器</a></p>
<h5 id="二、FTP上传"><a href="#二、FTP上传" class="headerlink" title="二、FTP上传"></a>二、FTP上传</h5><p>该FTP上传代码为官网上的<a href="https://curl.haxx.se/libcurl/c/example.html" target="_blank" rel="noopener">demo</a>例程代码，若要为己所用，只需将宏定义修改并准备一个要上传的文件即可。当然，该函数只能上传一个文件或者压缩包至FTP服务器，若要上传多个文件，可以在此例程上进行修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#ifdef WIN32</span><br><span class="line">#include &lt;io.h&gt;</span><br><span class="line">#else</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define LOCAL_FILE      &quot;/mnt/hgfs/VMWARE/test/8-curl/1206.rar&quot; //要上传的文件</span><br><span class="line">#define UPLOAD_FILE_AS  &quot;while-uploading.txt&quot;</span><br><span class="line">#define REMOTE_URL      &quot;ftp://192.168.31.175/&quot;  UPLOAD_FILE_AS //FTP服务器地址</span><br><span class="line">#define RENAME_FILE_TO  &quot;1206.rar&quot;//最终写入到这个文件名中</span><br><span class="line"></span><br><span class="line">static size_t read_callback(void *ptr, size_t size, size_t nmemb, void *stream)</span><br><span class="line">&#123;</span><br><span class="line">  curl_off_t nread;</span><br><span class="line"></span><br><span class="line">  size_t retcode = fread(ptr, size, nmemb, stream);</span><br><span class="line"></span><br><span class="line">  nread = (curl_off_t)retcode;</span><br><span class="line"></span><br><span class="line">  fprintf(stderr, &quot; We read %&quot; CURL_FORMAT_CURL_OFF_T</span><br><span class="line">          &quot; bytes from file\n&quot;, nread);</span><br><span class="line">  return retcode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">  CURL *curl;</span><br><span class="line">  CURLcode res;</span><br><span class="line">  FILE *hd_src;</span><br><span class="line">  struct stat file_info;</span><br><span class="line">  curl_off_t fsize;</span><br><span class="line"></span><br><span class="line">  struct curl_slist *headerlist = NULL;</span><br><span class="line">  static const char buf_1 [] = &quot;RNFR &quot; UPLOAD_FILE_AS;</span><br><span class="line">  static const char buf_2 [] = &quot;RNTO &quot; RENAME_FILE_TO;</span><br><span class="line"></span><br><span class="line">  /* 获得上传文件的大小 */ </span><br><span class="line">  if(stat(LOCAL_FILE, &amp;file_info)) &#123;</span><br><span class="line">    printf(&quot;Couldn&apos;t open &apos;%s&apos;: %s\n&quot;, LOCAL_FILE, strerror(errno));</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  fsize = (curl_off_t)file_info.st_size;</span><br><span class="line"></span><br><span class="line">  printf(&quot;Local file size: %&quot; CURL_FORMAT_CURL_OFF_T &quot; bytes.\n&quot;, fsize);</span><br><span class="line"></span><br><span class="line">  /* 获得FILE类型变量 */ </span><br><span class="line">  hd_src = fopen(LOCAL_FILE, &quot;rb&quot;);</span><br><span class="line"></span><br><span class="line">  /* 初始化 */ </span><br><span class="line">  curl_global_init(CURL_GLOBAL_ALL);</span><br><span class="line"></span><br><span class="line">  /* 获得curl操作符 */ </span><br><span class="line">  curl = curl_easy_init();</span><br><span class="line">  if(curl) &#123;</span><br><span class="line">    /*建立一个传递给libcurl的命令列表 */ </span><br><span class="line">    headerlist = curl_slist_append(headerlist, buf_1);</span><br><span class="line">    headerlist = curl_slist_append(headerlist, buf_2);</span><br><span class="line"></span><br><span class="line">    /* 使用curl提供的Read功能 */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_READFUNCTION, read_callback);</span><br><span class="line"></span><br><span class="line">    /* 上传使能 */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_UPLOAD, 1L);</span><br><span class="line"></span><br><span class="line">    /* 设置特定目标 */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL, REMOTE_URL);</span><br><span class="line"></span><br><span class="line">    /* 传递最后一个FTP命令以在传输后运行 */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_POSTQUOTE, headerlist);</span><br><span class="line"></span><br><span class="line">    /*指定上传文件 */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_READDATA, hd_src);</span><br><span class="line"></span><br><span class="line">    /*设置要上传的文件的大小（可选） */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_INFILESIZE_LARGE,</span><br><span class="line">                     (curl_off_t)fsize);</span><br><span class="line"></span><br><span class="line">    /* 运行 */ </span><br><span class="line">    res = curl_easy_perform(curl);</span><br><span class="line">    /* 容错处理 */ </span><br><span class="line">    if(res != CURLE_OK)</span><br><span class="line">      fprintf(stderr, &quot;curl_easy_perform() failed: %s\n&quot;,</span><br><span class="line">              curl_easy_strerror(res));</span><br><span class="line"></span><br><span class="line">    /* 清除FTP命令列表 */ </span><br><span class="line">    curl_slist_free_all(headerlist);</span><br><span class="line"></span><br><span class="line">    /*释放所有curl资源 */ </span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(hd_src); /*关闭本地文件 */ </span><br><span class="line"></span><br><span class="line">  /*释放所有curl资源 */ </span><br><span class="line">  curl_global_cleanup();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保存代码，文件名命名为“ftpupload.c”，并在/mnt/hgfs/VMWARE/test/8-curl文件夹中准备“1206.rar”文件（即代码中指定的要上传的文件名），使用gcc编译，编译指令：</p>
<pre><code>gcc -o ftpupload ftpupload.c -lcurl</code></pre><p>执行结果：</p>
<p><img src="/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/1.png" alt="1"></p>
<p>上传前的代码：</p>
<p><img src="/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/2.png" alt="2"></p>
<p>上传到FTP服务器之后：</p>
<p><img src="/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/3.png" alt="3"></p>
<p>至此，上传功能完成。</p>
<h5 id="三、FTP下载"><a href="#三、FTP下载" class="headerlink" title="三、FTP下载"></a>三、FTP下载</h5><p>同样，该FTP下载代码为官网上的<a href="https://curl.haxx.se/libcurl/c/example.html" target="_blank" rel="noopener">demo</a>例程代码，若要为己所用，只需将宏定义修改并指定一个要下载的文件即可。当然，该函数只能下载一个文件或者压缩包至FTP客户端，若要下载多个文件，可以在此例程上进行修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line"></span><br><span class="line">struct FtpFile &#123;</span><br><span class="line">  const char *filename;</span><br><span class="line">  FILE *stream;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static size_t my_fwrite(void *buffer, size_t size, size_t nmemb, void *stream)</span><br><span class="line">&#123;</span><br><span class="line">  struct FtpFile *out = (struct FtpFile *)stream;</span><br><span class="line">  if(out &amp;&amp; !out-&gt;stream) &#123;</span><br><span class="line">    /* 打开文件以进行写操作 */ </span><br><span class="line">    out-&gt;stream = fopen(out-&gt;filename, &quot;wb&quot;);</span><br><span class="line">    if(!out-&gt;stream)</span><br><span class="line">      return -1; /* failure, can&apos;t open file to write */ </span><br><span class="line">  &#125;</span><br><span class="line">  return fwrite(buffer, size, nmemb, out-&gt;stream);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">  CURL *curl;</span><br><span class="line">  CURLcode res;</span><br><span class="line">  struct FtpFile ftpfile = &#123;</span><br><span class="line">    &quot;/mnt/hgfs/VMWARE/test/8-curl/1208.rar&quot;, /* 若FTP下载成功，名命下载后的文件为&quot;curl.txt&quot; */ </span><br><span class="line">    NULL</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  curl_global_init(CURL_GLOBAL_DEFAULT);</span><br><span class="line"></span><br><span class="line">  curl = curl_easy_init();</span><br><span class="line">  if(curl) &#123;</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL,</span><br><span class="line">                     &quot;ftp://192.168.31.175/1208.rar&quot;);//下载指定的文件</span><br><span class="line">    /* 定义回调函数，以便在需要写入数据时进行调用 */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, my_fwrite);</span><br><span class="line">    /*设置一个指向我们的结构的指针传递给回调函数*/ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;ftpfile);</span><br><span class="line"></span><br><span class="line">    /* 打开完整的协议/调试输出*/ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);</span><br><span class="line"></span><br><span class="line">    res = curl_easy_perform(curl);</span><br><span class="line"></span><br><span class="line">    /* 释放所有curl资源*/ </span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line"></span><br><span class="line">    if(CURLE_OK != res) &#123;</span><br><span class="line">      /*容错处理 */ </span><br><span class="line">      fprintf(stderr, &quot;curl told us %d\n&quot;, res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(ftpfile.stream)</span><br><span class="line">    fclose(ftpfile.stream); /* 关闭本地文件 */ </span><br><span class="line"> /*释放所有curl资源*/</span><br><span class="line">  curl_global_cleanup();</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用gcc编译，编译指令：</p>
<pre><code>gcc -o ftpDown ftpDown.c -lcurl</code></pre><p>执行结果：</p>
<p><img src="/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/4.png" alt="4"></p>
<p>下载之前，放在FTP服务器中时：</p>
<p><img src="/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/5.png" alt="5"></p>
<p>下载之后，放在本地文件中中时：</p>
<p><img src="/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/6.png" alt="6"></p>
]]></content>
      <categories>
        <category>cURL</category>
      </categories>
      <tags>
        <tag>cURL</tag>
      </tags>
  </entry>
  <entry>
    <title>cURL-06_cURL和libcurl的安装的安装途径</title>
    <url>/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/</url>
    <content><![CDATA[<p>cURL的安装一般有三种方式:<a href="https://ec.haxx.se/" target="_blank" rel="noopener">https://ec.haxx.se/</a></p>
<a id="more"></a>

<h5 id="一、ubuntu16-04-安装curl，一般用于命令行工具操作"><a href="#一、ubuntu16-04-安装curl，一般用于命令行工具操作" class="headerlink" title="一、ubuntu16.04 安装curl，一般用于命令行工具操作"></a>一、ubuntu16.04 安装curl，一般用于命令行工具操作</h5><h6 id="1-直接安装"><a href="#1-直接安装" class="headerlink" title="1. 直接安装"></a>1. 直接安装</h6><pre><code>sudo apt install curl</code></pre><h6 id="2-或者是下载软件压缩包安装-Ubuntu下安装cURL库用于libcurl开发"><a href="#2-或者是下载软件压缩包安装-Ubuntu下安装cURL库用于libcurl开发" class="headerlink" title="2. 或者是下载软件压缩包安装-Ubuntu下安装cURL库用于libcurl开发"></a>2. 或者是下载软件压缩包安装-Ubuntu下安装cURL库用于libcurl开发</h6><p>2.1 下载curl包（可以在这个网站上找最新的版本 <a href="http://curl.haxx.se/download/）" target="_blank" rel="noopener">http://curl.haxx.se/download/）</a></p>
<p><img src="/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/1.png" alt="1"></p>
<pre><code>wget https://curl.haxx.se/download/curl-7.55.1.tar.gz</code></pre><p>2.2 解压</p>
<pre><code>tar -xzvf  curl-7.55.1.tar.gz</code></pre><p>2.3 覆盖安装</p>
<pre><code>stemp 1 cd curl-7.55.1
stemp 2 ./configure
stemp 3 make
stemp 4 make install</code></pre><p>2.4 使用 curl –version 检查是否更新成功</p>
<p><img src="/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/2.png" alt="2"></p>
<h5 id="二、ubuntu16-04-安装libcurl-主要用于ubuntu中应用程序开发-curl和libcurl的区别"><a href="#二、ubuntu16-04-安装libcurl-主要用于ubuntu中应用程序开发-curl和libcurl的区别" class="headerlink" title="二、ubuntu16.04 安装libcurl,主要用于ubuntu中应用程序开发(curl和libcurl的区别)"></a>二、ubuntu16.04 安装libcurl,主要用于ubuntu中应用程序开发(curl和libcurl的区别)</h5><pre><code>sudo apt install libcurl4-openssl-dev</code></pre><p>可以看到-ubuntu系统中/usr/include/curl中的头文件,此操作可以作为Ubuntu虚拟程序中的&lt;curl/curl.h&gt;,一般作为Ubuntu平台模拟程序使用。</p>
<p>库文件：/usr/lib/x86_64-linux-gnu/libcurl.so.4</p>
<h5 id="三、linux下编译安装libcurl"><a href="#三、linux下编译安装libcurl" class="headerlink" title="三、linux下编译安装libcurl"></a>三、linux下编译安装libcurl</h5><h6 id="1-直接下载"><a href="#1-直接下载" class="headerlink" title="1. 直接下载"></a>1. 直接下载</h6><pre><code>git clone https://github.com/curl/curl.git </code></pre><h6 id="2-tar解压后，进入curl工程目录输入指令：-buidconf，产生configure脚本"><a href="#2-tar解压后，进入curl工程目录输入指令：-buidconf，产生configure脚本" class="headerlink" title="2.tar解压后，进入curl工程目录输入指令：./buidconf，产生configure脚本"></a>2.tar解压后，进入curl工程目录输入指令：./buidconf，产生configure脚本</h6><p>之后和第一条步骤类似</p>
]]></content>
      <categories>
        <category>cURL</category>
      </categories>
      <tags>
        <tag>cURL</tag>
      </tags>
  </entry>
  <entry>
    <title>cURL-05_curl和libcurl的区别简介(转)</title>
    <url>/2019/12/08/cURL-05-curl%E5%92%8Clibcurl%E7%9A%84%E5%8C%BA%E5%88%AB%E7%AE%80%E4%BB%8B-%E8%BD%AC/</url>
    <content><![CDATA[<h5 id="curl简介"><a href="#curl简介" class="headerlink" title="curl简介"></a>curl简介</h5><p>curl是利用URL语法在命令行方式下工作的开源文件传输工具。<br>它支持很多协议：DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP。</p>
<p>curl同样支持SSL证书,HTTP POST, HTTP PUT,FTP上传，基于表单的HTTP上传，代理(proxies)、cookies、用户名/密码认证(Basic, Digest, NTLM等)、下载文件断点续传，上载文件断点续传(file transfer resume)，http代理服务器管道（proxy tunneling)以及其他特性。</p>
<p>curl是瑞典curl组织开发的,curl的官网是<a href="http://curl.haxx.se/,可以从官网获取它的源代码和相关说明。" target="_blank" rel="noopener">http://curl.haxx.se/,可以从官网获取它的源代码和相关说明。</a></p>
<a id="more"></a>

<h5 id="libcurl简介"><a href="#libcurl简介" class="headerlink" title="libcurl简介"></a>libcurl简介</h5><p>libcurl为一个免费开源的，客户端url传输库，支持DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP等协议。</p>
<p>同curl一样，libcurl也支持SSL证书,HTTP POST, HTTP PUT,FTP上传，基于表单的HTTP上传，代理(proxies)、cookies、用户名/密码认证(Basic, Digest, NTLM等)、下载文件断点续传，上载文件断点续传(file transfer resume)，http代理服务器管道（proxy tunneling)等。</p>
<p>libcurl是高度可移植的，可以工作在不同的平台上，支持Windows，Unix，Linux等。</p>
<p>libcurl是免费的，线程安全的，IPV6兼容的，同时它还有很多其它非常丰富的特性。libcurl已经被很多知名的大企业以及应用程序所采用。</p>
<h5 id="curl与libcurl对比"><a href="#curl与libcurl对比" class="headerlink" title="curl与libcurl对比"></a>curl与libcurl对比</h5><h6 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h6><p>curl和libcurl都可以利用多种多样的协议来传输文件，包括HTTP, HTTPS, FTP, FTPS, GOPHER, LDAP, DICT, TELNET and FILE等。</p>
<h6 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h6><ul>
<li>curl是命令行工具，可以通过shell或脚本来运行curl。curl底层所使用的库是libcurl。</li>
<li>libcurl是一个库，通常与别的程序绑定在一起使用，如命令行工具curl就是封装了libcurl库。所以我们也可以在你自己的程序或项目中使用libcurl以获得类似CURL的强大功能。接下来将要介绍的PHP扩展就是对curl的一个封装。</li>
</ul>
<h5 id="几个名词"><a href="#几个名词" class="headerlink" title="几个名词"></a>几个名词</h5><h6 id="“curl”的不同意思"><a href="#“curl”的不同意思" class="headerlink" title="“curl”的不同意思"></a>“curl”的不同意思</h6><p>1.curl指的是curl命令行工具，可以从命令行或者脚本或者批处理文件中运行curl。curl创建于1998年，并且提供了100多个选项去控制它。</p>
<p>2.cURL是一个软件项目的名字。该软件项目包含了上面所说的curl和libcurl，并且都是开源的。</p>
<p>3.cURL通常用作PHP中libcurl扩展的名字。这个扩展确保了PHP程序员在程序中可以访问libcurl库所提供的功能。</p>
<h6 id="curl—命令行工具"><a href="#curl—命令行工具" class="headerlink" title="curl—命令行工具"></a>curl—命令行工具</h6><ol>
<li>命令行工具，可以从shell或者脚本中运行该工具。</li>
<li>提供了130多种不同的“flags”</li>
<li>通常被用来模拟浏览器的行为</li>
<li>跨平台</li>
</ol>
<h6 id="libcurl—库"><a href="#libcurl—库" class="headerlink" title="libcurl—库"></a>libcurl—库</h6><ol>
<li>用作其他程序的开发库</li>
<li>可以与许多语言想结合，如PHP、C++</li>
<li>跨平台</li>
<li>提供了多种不同的使用它的APIs</li>
</ol>
<h5 id="PHP中使用curl和libcurl"><a href="#PHP中使用curl和libcurl" class="headerlink" title="PHP中使用curl和libcurl"></a>PHP中使用curl和libcurl</h5><h6 id="PHP中使用curl"><a href="#PHP中使用curl" class="headerlink" title="PHP中使用curl"></a>PHP中使用curl</h6><p>在PHP中使用curl非常简单，只要调用PHP中几个执行系统命令的相关函数即可。<br>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$baidu=shell_exec(&quot;/usr/bin/curl -L http://www.baidu.com&quot;); </span><br><span class="line">var_dump($baidu);</span><br></pre></td></tr></table></figure>
<h6 id="PHP中使用libcurl"><a href="#PHP中使用libcurl" class="headerlink" title="PHP中使用libcurl"></a>PHP中使用libcurl</h6><p>在PHP中使用libcurl，也就是我们通常所说的PHP中的“curl”。这部分的内容会在以后的文章中给出，这里只写出一个示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// FTP this script to a server</span><br><span class="line">$fp = fopen(__FILE__, &quot;r&quot;);</span><br><span class="line">$url = &quot;ftp://username:password@mydomain.com:21/path/to/newfile.php&quot;;</span><br><span class="line">$ch = curl_init();   </span><br><span class="line">curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);</span><br><span class="line">curl_setopt($ch, CURLOPT_UPLOAD, 1);</span><br><span class="line">curl_setopt($ch, CURLOPT_INFILE, $fp);</span><br><span class="line">curl_setopt($ch, CURLOPT_FTPASCII, 1);</span><br><span class="line">curl_setopt($ch, CURLOPT_INFILESIZE, filesize(__FILE__));</span><br><span class="line">$result = curl_exec($ch);</span><br><span class="line">curl_close($ch);</span><br></pre></td></tr></table></figure>

<h5 id="使用curl还是libcurl？"><a href="#使用curl还是libcurl？" class="headerlink" title="使用curl还是libcurl？"></a>使用curl还是libcurl？</h5><p>使用curl还是libcurl这个需要根据具体的情况而定。例如，当有一个定时脚本在远程服务器的文件改变时发送邮件或者当前PHP环境不支持libcurl时，我们应该使用curl。否则，我们使用libcurl即可。</p>
]]></content>
      <categories>
        <category>cURL</category>
      </categories>
      <tags>
        <tag>cURL</tag>
      </tags>
  </entry>
  <entry>
    <title>工具-虚拟机的桥接模式和NAT模式的区别</title>
    <url>/2019/12/08/%E5%B7%A5%E5%85%B7-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E5%92%8CNAT%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h5 id="1-桥接模式"><a href="#1-桥接模式" class="headerlink" title="1.桥接模式"></a>1.桥接模式</h5><p>通过使用物理机的网卡，有自己的IP地址，就像在电脑上虚拟出来另一台主机，它可以访问网内任何一台主机，需要手工为其配置IP地址、子网掩码、需要和宿主机器处于同一个网段，这样虚拟机才能和宿主机器进行通信。同时，由于这个虚拟系统是局域网中的一个独立主机系统，就可以手工配置他的TCP\IP信息，实现通过局域网的网关或路由进行互联网访问。</p>
<a id="more"></a>

<p><strong>弊端:</strong></p>
<ol>
<li><p>Ip地址可能会发生变化 192.150.1.100/192.168.1.101</p>
</li>
<li><p>如果这时传递文件时需要依靠交换机/路由器</p>
</li>
</ol>
<p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E5%92%8CNAT%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/1.png" alt="1"></p>
<h5 id="2-NAT模式"><a href="#2-NAT模式" class="headerlink" title="2.NAT模式"></a>2.NAT模式</h5><p>使用NAT模式，就是让虚拟系统借助NAT（网络地址的转换功能），通过宿主机器所在的网络来访问公网，也就是说使用NAT模式可以实现在虚拟系统里访问互联网，NAT模式下的虚拟系统的TCP/IP配置是由VMnet8（NAT）虚拟网络的DHCP服务器提供的，无法进行手工修改，因此虚拟系统也就无法和本局域网中的其他真是主机进行通讯。采用NAT模式的虚拟机的有点就是，想要接入互联网十分方便，只要宿主机能访问到互联网即可。</p>
<p><strong>特点:</strong></p>
<ol>
<li><p>NAT模式时,只能由真实的计算机连接虚拟网络空间,其他的计算机由于网络不在一个网段内,则不能通信.</p>
</li>
<li><p>NAT模式时,IP地址一般都是固定不变的.所以无论在哪里.Ip都能直接连接.</p>
</li>
</ol>
<p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E5%92%8CNAT%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/2.png" alt="2"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>VMware</tag>
        <tag>网络配置</tag>
      </tags>
  </entry>
  <entry>
    <title>工具-如何配置Windows、虚拟机、开发板的网络</title>
    <url>/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>烧录软件和方便调试先要保证电脑windos操作系统、虚拟机linuxr操作系统<br>和开发板三者之间相互Ping通，要做到这些其实很简单：</p>
<a id="more"></a>
<h5 id="1-打开windows网络和共享中心更改适配器设置"><a href="#1-打开windows网络和共享中心更改适配器设置" class="headerlink" title="1. 打开windows网络和共享中心更改适配器设置"></a>1. 打开windows网络和共享中心更改适配器设置</h5><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/1.png" alt="1"></p>
<h5 id="2-打开这三个的属性，把VMware-Bridge-Protocol都勾上，如图"><a href="#2-打开这三个的属性，把VMware-Bridge-Protocol都勾上，如图" class="headerlink" title="2. 打开这三个的属性，把VMware Bridge Protocol都勾上，如图"></a>2. 打开这三个的属性，把VMware Bridge Protocol都勾上，如图</h5><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/2.png" alt="2"></p>
<h5 id="3-打开本地连接的属性再打开IPV4的属性选择使用手动IP如下图所示"><a href="#3-打开本地连接的属性再打开IPV4的属性选择使用手动IP如下图所示" class="headerlink" title="3. 打开本地连接的属性再打开IPV4的属性选择使用手动IP如下图所示"></a>3. 打开本地连接的属性再打开IPV4的属性选择使用手动IP如下图所示</h5><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/3.png" alt="3"></p>
<h5 id="4-点击VMware的虚拟机-gt-设置-网络选择桥接如下图所示"><a href="#4-点击VMware的虚拟机-gt-设置-网络选择桥接如下图所示" class="headerlink" title="4. 点击VMware的虚拟机-&gt; 设置 网络选择桥接如下图所示"></a>4. 点击VMware的虚拟机-&gt; 设置 网络选择桥接如下图所示</h5><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/4.png" alt="4"></p>
<p>网络选择桥接如下图所示</p>
<p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/5.png" alt="5"></p>
<h5 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h5><h6 id="5-1-点击VMware的编辑-gt-虚拟网络编辑器"><a href="#5-1-点击VMware的编辑-gt-虚拟网络编辑器" class="headerlink" title="5.1 点击VMware的编辑-&gt;虚拟网络编辑器"></a>5.1 点击VMware的编辑-&gt;虚拟网络编辑器</h6><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/6.png" alt="6"></p>
<h6 id="5-2-点击更改设置"><a href="#5-2-点击更改设置" class="headerlink" title="5.2 点击更改设置"></a>5.2 点击更改设置</h6><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/7.png" alt="7"></p>
<h6 id="5-3-点击桥接模式，选择自己要桥接的网卡-网卡要记得选对"><a href="#5-3-点击桥接模式，选择自己要桥接的网卡-网卡要记得选对" class="headerlink" title="5.3 点击桥接模式，选择自己要桥接的网卡(网卡要记得选对)"></a>5.3 点击桥接模式，选择自己要桥接的网卡(网卡要记得选对)</h6><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/8.png" alt="8"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>VMware</tag>
        <tag>网络配置</tag>
      </tags>
  </entry>
  <entry>
    <title>工具-在WIN10上搭建Ftp服务器（转）</title>
    <url>/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>在windows10上面搭建你的FTP服务器，     正在学服务器这门课程，刚好学到搭建Ftp服务器。所以就在自己电脑上也搭建了一个Ftp服务器。我的电脑是win10的，所以本教程也是在win10上面搭建Ftp服务器。希望能帮到有需要的同学！</p>
</blockquote>
<a id="more"></a>

<h5 id="一、在windows10中搭建Ftp服务器主要用的是IIS管理器管理控制台"><a href="#一、在windows10中搭建Ftp服务器主要用的是IIS管理器管理控制台" class="headerlink" title="一、在windows10中搭建Ftp服务器主要用的是IIS管理器管理控制台"></a>一、在windows10中搭建Ftp服务器主要用的是IIS管理器管理控制台</h5><h6 id="1-在控制面板里面打开程序功能里面的FTP服务器和web管理工具"><a href="#1-在控制面板里面打开程序功能里面的FTP服务器和web管理工具" class="headerlink" title="1. 在控制面板里面打开程序功能里面的FTP服务器和web管理工具"></a>1. 在控制面板里面打开程序功能里面的FTP服务器和web管理工具</h6><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/1.png" alt="1"></p>
<h5 id="二、打开IIS管理器平台，不知道在哪打开的可以直接搜索IIS打开"><a href="#二、打开IIS管理器平台，不知道在哪打开的可以直接搜索IIS打开" class="headerlink" title="二、打开IIS管理器平台，不知道在哪打开的可以直接搜索IIS打开"></a>二、打开IIS管理器平台，不知道在哪打开的可以直接搜索IIS打开</h5><h6 id="1-在网站那里右键“添加FTP站点”"><a href="#1-在网站那里右键“添加FTP站点”" class="headerlink" title="1.在网站那里右键“添加FTP站点”"></a>1.在网站那里右键“添加FTP站点”</h6><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/2.png" alt="2"></p>
<h6 id="2-输入你的站点名称和物理路径"><a href="#2-输入你的站点名称和物理路径" class="headerlink" title="2. 输入你的站点名称和物理路径"></a>2. 输入你的站点名称和物理路径</h6><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/3.png" alt="3"></p>
<h6 id="3-下一步绑定你的FTP服务器地址，这里的端口使用默认的21号端口。IP地址是你本机的IP地址"><a href="#3-下一步绑定你的FTP服务器地址，这里的端口使用默认的21号端口。IP地址是你本机的IP地址" class="headerlink" title="3. 下一步绑定你的FTP服务器地址，这里的端口使用默认的21号端口。IP地址是你本机的IP地址"></a>3. 下一步绑定你的FTP服务器地址，这里的端口使用默认的21号端口。IP地址是你本机的IP地址</h6><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/4.png" alt="4"></p>
<h6 id="4-下一步，根据需要设置身份验证和授权信息"><a href="#4-下一步，根据需要设置身份验证和授权信息" class="headerlink" title="4. 下一步，根据需要设置身份验证和授权信息"></a>4. 下一步，根据需要设置身份验证和授权信息</h6><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/5.png" alt="5"></p>
<p>点击完成FTP服务器就搭建好了。</p>
<h5 id="三、测试你的ftp服务器"><a href="#三、测试你的ftp服务器" class="headerlink" title="三、测试你的ftp服务器"></a>三、测试你的ftp服务器</h5><p>在浏览器上输入ftp://<strong>.</strong>.<strong>.</strong>（填你自己的ftp地址）。你就可以看到你ftp目录里面的东西了，浏览器打开的效果是这样子的</p>
<p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/6.png" alt="6"></p>
<h5 id="四、有小伙伴私信我，服务器搭建好了，自己可以访问，但是别人访问不了，以下我总结了以下解决方法，希望对你们有效"><a href="#四、有小伙伴私信我，服务器搭建好了，自己可以访问，但是别人访问不了，以下我总结了以下解决方法，希望对你们有效" class="headerlink" title="四、有小伙伴私信我，服务器搭建好了，自己可以访问，但是别人访问不了，以下我总结了以下解决方法，希望对你们有效"></a>四、有小伙伴私信我，服务器搭建好了，自己可以访问，但是别人访问不了，以下我总结了以下解决方法，希望对你们有效</h5><h6 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h6><p>把防火墙关掉、一般别人访问不了都是防火墙限制了，直接把防火墙关掉这是最快的解决方法</p>
<h6 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h6><p>如果你想把防火墙开着呢，那应该怎么做？</p>
<p>打开防火墙设置，选择允许的应用，把ftp服务器勾选上、然后再点击允许其它应用</p>
<p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/7.png" alt="7"></p>
<p>选择C:\Windows\System32目录下面的svchost.exe这个软件</p>
<p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/8.png" alt="8"></p>
<p>把这个应该添加到防火墙允许的应用里面</p>
<p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/9.png" alt="9"></p>
<p>做完以上步骤再试一下，别人就可以在你开启防火墙的状态依旧可以访问你的ftp服务器了</p>
<p>但是有的小伙伴还是不能访问，那应该怎么办呢？继续以下步骤（如果进行完以上步骤可以访问就不用进行下面的操作）</p>
<p>依旧是打开防火墙设置，然后选择高级设置</p>
<p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/10.png" alt="10"></p>
<p>在出站规则里面选择和frp相关的规则，点击右边的启用规则就可以了</p>
<p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/11.png" alt="11"></p>
<p>启用之后规则左边就会被打上勾了</p>
<p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/12.png" alt="12"></p>
<p>基本上我目前遇到小伙伴私信的问题都可以通过以上的方法解决，如果还是不行的话，记得私信我，我们再一起研究研究，然后把解决方法再加上。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>FTP</tag>
      </tags>
  </entry>
  <entry>
    <title>视音频-视频简介</title>
    <url>/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<blockquote>
<p>尽管视频信号有很多类型和实现技术,但其目的只是为了实现视觉信息在不同位置之间的传送。这些视觉信息可能是来自于VCR, DVD播放器、本地广播的某个频道、有线电视,或者来自于卫星电视系统、因特网,还可能是其他各种渠道。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>但有一点是肯定的,那就是视频信息必须从一个设备传输到另一个设备。可能是从卫星电视机顶盒或DVD播放器传输到电视机,或者在卫星电视机顶盒或电视机内部不同芯片之间传输。这看起来好像很简单,但需要满足很多不同的要求,故存在很多方式来实现这种传输。</p>
</blockquote>
<h4 id="一、模拟与数字"><a href="#一、模拟与数字" class="headerlink" title="一、模拟与数字"></a>一、模拟与数字</h4><p>几年前,大多数的视频设备还主要是为模拟视频而设计的,数字视频还仅限于视频编辑这样的专业应用领域。</p>
<p>目前,普通消费者在日常生活中都用上了数字视频设备,这要得益于这些数字产品价格的不断下降。这种趋势也导致相关技术的快速发展,如DVD播放机和摄像机、数字机顶盒、数字电视(DTV)、便携视频播放器和基于因特网的视频数据传输能力等</p>
<h4 id="二、视频数据"><a href="#二、视频数据" class="headerlink" title="二、视频数据"></a>二、视频数据</h4><p>起初,视频仅仅包含灰度(也称为黑白)信息。</p>
<p>在建立彩色广播电视系统的过程中,人们试图用模拟RGB (红、绿、蓝)来发送彩色视频,然而,这种技术占用的带宽是当时使用的灰度解决方案的3倍多,因此必须创建其他的替代方法,于是,人们用Y, R-Y和G-Y数据来表示颜色信息,并开发相应的技术来传输Y, R-Y和G-Y信息。这种技术只需要一个信号,而不是3个独立的信号,因此只需要与原来传输灰度视频信号相同的带宽。今天广泛使用的NTSC、 PAL和SECAM视频标准仍然是建立在这种复合视频信号(composite video signal) 基础上的。</p>
<p>现在,尽管有很多种表示视频的方式,但它们都要通过RGB的数学公式表示出来。</p>
<p>s-Video是为了将终端设备连接(目的不是为了广播)在一起而建立的。每组信号由两个模拟信号构成:一个为灰度(Y)信息,另一个是以特定格式传输的模拟R-Y和B-Y颜色信息(也称为C或色度),这种技术曾经只在S-VHS中可用,但现在大多数消费类视频产品都支持这项技术。</p>
<p>尽管模拟RGB视频数据一直用于专业视频市场,但为了实现与高端消费设备的连接,模拟RGB视频数据也暂时应用于普通视频市场。与S-Video一样,模拟RGB视频数据也不用于广播。Y,R-Y、G-Y视频信号的另一种形式称为YPbPr,现在通常用于将消费类视频产品连接在起。其主要优点在于能够在消费类视频产品之间传输高分辨率视频。有些制造商错误地将YPbPT连接器称为YUV, YCbC或Y (B-Y) (R-Y)。</p>
<h5 id="2-1-数字视频"><a href="#2-1-数字视频" class="headerlink" title="2.1 数字视频"></a>2.1 数字视频</h5><p>目前最通用的数字信号为RGB和YCbCr. RGB是模拟RGB视频信号进行简单数字化后得到的版本。 YCbCT基本上是模拟YPbPr视频信号的数字化版本,这种格式由DVD和数字电视所采用。</p>
<h5 id="2-2最佳连接方法"><a href="#2-2最佳连接方法" class="headerlink" title="2.2最佳连接方法"></a>2.2最佳连接方法</h5><p>设备的最佳连接方法是什么?对于DVD播放器和数字有线电视/卫星电视/地面机顶盒,按照视频质量由好到差排序,一般的顺序为：</p>
<p>(1) HDMI (数字YCbCr)</p>
<p>(2) HIDMI (数字RGB)</p>
<p>(3)模拟YPbPr</p>
<p>(4)模拟RGB</p>
<p>(5)模拟S-Video</p>
<p>(6)模拟复合视频</p>
<p>有些人可能不同意这个排序。但是,大多数消费类产品都是在YCbCr颜色空间进行数字视处理的。因此,使用YCbCr作为设备互连格式可以减少所需的颜色空间转换次数。数字信号的颜色空间转换仍然优先选择进行D/A (数字到模拟)转换,接着进行AD (模拟到数字)转换,所以HDMI RGB排在模拟YPbPr之前。</p>
<p>计算机产业已经对接入计算机显示器的模拟和数字RGB信号进行了标准化。</p>
<h4 id="三、视频时序"><a href="#三、视频时序" class="headerlink" title="三、视频时序"></a>三、视频时序</h4><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E7%AE%80%E4%BB%8B/1.png" alt="1"></p>
<p>视频画面尽管看起来好像是连续运动的,其实那是一系列静止的图像。这些图像切换得足够快,  使得画面看起来像是连续运动的,如图2-1所示  对于消费类电子产品,通常情况下为每秒50或60张图像,计算机显示器为每秒70-90张图像。一种称为场同步(vertical sync)的特定时序信息被用于指定新图像从什么时候开始显示。</p>
<p>每张静止图像是由扫描线(scan line)组成的即沿着显示器从上到下、一行接着一行进行显示的数据线,如图2-1所示。另一种称为行同步(horizontal sync)的时序信息用于指定新扫描线什么时候开始显示。</p>
<p>行同步和场同步信息通常通过以下三种方式之一进行传输:</p>
<p>(1)单独的行同步和场同步信号;  </p>
<p>(2)单独的复合同步信号；</p>
<p>(3)嵌入视频信号的复合同步信号。</p>
<p>复合同步信号是由场同步和行同步信号组合而成的。使用模拟RGB视频的计算机和消费类设备通常采用技术(1)或(2),支持复合视频或模拟YPbPr视频的消费类设备通常采用技术(3)。对于数字视频,通常要么采用技术(1),要么就是将时序编码字嵌入数字视频流中。</p>
<h5 id="隔行与逐行"><a href="#隔行与逐行" class="headerlink" title="隔行与逐行"></a>隔行与逐行</h5><p>由于视频是由一系列静止图像组成的,因此,简单地连续显示每幅完整的图像是有意义的,也就是一张接一张地显示每幅图像。</p>
<p>上面所讲的就是逐行显示(progressive) [或称为非隔行(non-interlaced)显示]的基本技术。对于将图像以逐行方式“绘制”到屏幕上的设备(如CRT),每张图像都是从显示器的左上角开始,一直向右移动,直到到达显示器的右边缘为止然后向下扫描一行,重复地从左到右进行扫描。这个过程一直持续到整个屏幕全部被刷新一次为止,如图2-2所示。<br><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E7%AE%80%E4%BB%8B/2.png" alt="2"></p>
<p>在电视发展的早期,采用一种称为“隔行显(interlacing)”的技术来减少每幅图像所需发送  “绘制”出每幅图像的数据量。这种方式先发送奇数行的数据,接着发送偶数行的数据(如图2-3所示),因此每次发送的数据量为一幅图像数据量的一半。<br><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E7%AE%80%E4%BB%8B/3.png" alt="3"></p>
<p>既然隔行显示方式有这个优点,那么为什么还要多余地使用逐行显示方式呢?</p>
<p>在隔行显示方式中,每个扫描线更新的频率只有同等情况下逐行显示方式的一半。所以,为了避免由于过低的帧率而导致颜色对比显著的边缘出现闪烁,要限制扫描线之间的变化,这本质上是由于在垂直方向上对图像进行了低通滤波。而逐行显示方式对线之间的变化就没有这种限制因此,逐行显示方式能够提供更高分辨率(在垂直方向上)的没有闪烁的图像。</p>
<p>现在,大多数广播(包括HDTV)都仍然以隔行方式发射信号。大多数基于CRT的显示器也是隔行方式显示,而LCD、等离子以及计算机显示器都是采用逐行方式。</p>
<h4 id="四、视频分辨率"><a href="#四、视频分辨率" class="headerlink" title="四、视频分辨率"></a>四、视频分辨率</h4><p>在现实生活中,人们对于视频分辨率的概念往往有一些模糊的认识。我们通常见到的视频分辨率为720 x 480或1920 × 1080,然而,那只是水平采样和垂直扫描线的数目,并不等于说必须具有这么多有用信息。</p>
<p>例如,可以以13.5MHz的频率对模拟视频信号进行采样,生成每行720个采样点。对同样的信号以27MHz的频率采样可以生成每行1440个采样点。但这仅仅是每行的采样数目不同,视频内容的分辨率并没有改变。</p>
<p>因此,视频质量通常用线分辨率(lines of resolution)来度量。<br>本质上是表示在显示器上可以显示多少不同的黑白垂直线。然后将这个数目归一化为1 :1显示宽高比(对于4:3的显示器,将该数除以3/4,而对于16:9的显示器则除以916),当然,对于宽屏(16:9)显示器,这会使得视频分辨率较低,与直觉不相符。</p>
<h5 id="4-1-标准清晰度"><a href="#4-1-标准清晰度" class="headerlink" title="4.1 标准清晰度"></a>4.1 标准清晰度</h5><p>标准清晰度(standard-definition)视频通常定义为480或576的隔行有效扫描线的视频,分别称为”480i”和”576i”。</p>
<p>固定像素(非CRT)、具有4:3宽高比的消费类显示器通过转换后,对应于720 x 480i或720x576i的有效分辨率。而对于16:9的宽高比,转换后的有效分辨率对应于960 x 480i或960 x 576i</p>
<h5 id="4-2-增强清晰度"><a href="#4-2-增强清晰度" class="headerlink" title="4.2 增强清晰度"></a>4.2 增强清晰度</h5><p>增强清晰度(enhanced-definition)视频通常定义为具有480或576逐行有效扫描线的视频,分别称为”480p”或”576p”.</p>
<p>固定像素(非CRT)具有4 :3宽高比的消费类显示器转换后的有效分辨率对应于720 x480p或720 x 576p。而对于16 :9的宽高比,转换后的有效分辨率对应于960 x 480p或960 x 576p.</p>
<p>标准清晰度和增强清晰度的差异在于,标准清晰度是隔行的,而增强清晰度是逐行的。</p>
<h5 id="4-3高清晰度"><a href="#4-3高清晰度" class="headerlink" title="4.3高清晰度"></a>4.3高清晰度</h5><p>高清晰度(high-definition)视频通常定义为具有720逐行(720p)或1080隔行(1080i)有效扫描线的视频。固定像素(非CRT)、具有16:9宽高比的消费类显示器转换后的有效分辨率分别为1280 x 720p或1280 × 1080i</p>
<p>但是, HDTV显示器在技术上定义为能够显示最少720p或1080有效扫描线。它还必须能够用至少540逐行(540p)或810隔行(810i)有效扫描线来显示16:9的视频画面。这样,在制造具有4:3宽高比、基于CRT的HDTV和具有16 :9宽高比、分辨率为1024 x 1024p, 1280 x 768p, 1024×768p的LCD/等离子等显示器时,能够降低制造费用。</p>
<h4 id="五、音频与视频压缩"><a href="#五、音频与视频压缩" class="headerlink" title="五、音频与视频压缩"></a>五、音频与视频压缩</h4><p>近年来,数字电视、DVD播放机和摄像机、数字视频摄像机等消费类电子产品取得了一些最新进展,这归功于音频和视频压缩标准。这些压缩标准主要有:带有Dolbyo Digital的MEPG-2.DTS, MPEG-1或MPEG-2音频。</p>
<p>新的音频和视频编解码器,像MPEG-4 HE-AAC、 MPEG-4.10 (H.264)和SMPTE 421M (VC1),在保持同样质量时,提供了比以往编解码方法更高的压缩效率。这些进展使得可以使用新的见频发布方式(面向消费者和家庭内部)、新的消费产品(如便携视频播放器和移动视频移动电话)和更多的有线/星电视频道。</p>
<h4 id="六、应用框图"><a href="#六、应用框图" class="headerlink" title="六、应用框图"></a>六、应用框图</h4><p>下面几个简化的框图有助于我们认识视频流是如何经过各种相应处理的。</p>
<h5 id="6-1-DVD播放器"><a href="#6-1-DVD播放器" class="headerlink" title="6.1 DVD播放器"></a>6.1 DVD播放器</h5><p>图2-4为基本DVD播放机的简化框图,其中显示的是公共模块。如今所有这些模块都集成在廉价的芯片上了。<br><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E7%AE%80%E4%BB%8B/4.png" alt="4"></p>
<p>除了播放DVD (基于MPEG-2视频压缩技术)外, 目前, DVD播放器还有望处理MP3和WMA音频、MPEG-4视频(DivX视频)、 JPEG图像等。同时有望具有特定的播放模式,如以各科速度慢快进和快/慢退等。对DVD音频和SACD的支持也是很流行的。</p>
<p>DVD播放机的一个新增功能是能够接入到家庭网络中,用于播放一些存放于PC中的媒体(音乐、视频、图像等),这些“网络化的DVD播放机”也包括播放一些准备事后浏览的内容,如来源于因特网的电影和下载到内部硬盘(HDD)中的媒体。支持对各种闪存卡中的音频、视频和图像进行播放的这类需求也在不断增长。</p>
<p>有些DVD播放机制造商为了快速吸引买家的注意力,对视频的频率响应进行了超频处理,使得其产品看起来与众不同。但因为这种特性通常需要长时间的激励过程,所以很容易失败或需要调试。对于观看电影来讲,很多视频爱好者都认为频率响应应该尽可能平滑。</p>
<p>另一个问题是模拟视频信号的量化等级。尽管很容易产生每个精确的视频量化等级,但这些等级变化得相当快。目前有些评论也指出了这个问题,因为在信号源之间切换时可能会使发生变化的亮度或灰度值具有平均作用,从而使得用户进行的任何校正或手动调整失效。</p>
<h5 id="6-2-数字媒体适配器"><a href="#6-2-数字媒体适配器" class="headerlink" title="6.2 数字媒体适配器"></a>6.2 数字媒体适配器</h5><p>数字媒体适配器是连接到家庭网络、用于播放存放于PC或媒体存储器中的多媒体内容(音乐、视频、图像等)的设备。这些小而廉价的盒子使得媒体内容很容易在家庭中的任意或所有电视机上欣赏。许多数字媒体适配器支持无线网络功能,这就简化了数字媒体适配器的安装过程。</p>
<p>图2-5是基本的数字媒体适配器的简化框图,图中显示的是公共模块。如今所有这些模块都集成在一个廉价的芯片上了。</p>
<p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E7%AE%80%E4%BB%8B/5.png" alt="5"></p>
<h5 id="6-3-数字电视机顶盒"><a href="#6-3-数字电视机顶盒" class="headerlink" title="6.3 数字电视机顶盒"></a>6.3 数字电视机顶盒</h5><p>数字电视标准可以分为7大类:</p>
<p>(1) ATSC (美国先进电视系统委员会)</p>
<p>(2) DVB (数字视频广播)</p>
<p>(3) ARIB (日本无线工业及商贸协会)</p>
<p>(4) IPTV (网络电视,包括基于P的DVB和ARIB)</p>
<p>(5)开放数字有线标准,如OpenCable标准</p>
<p>(6)带版权保护的数字有线标准</p>
<p>(7)带版权保护的数字卫星电视标准</p>
<p>起初这些机顶盒都是基于MPEG-2视频和DolbyoDigital或MPEG音频, 目前的机顶盒支持新的先进音视频标准,如MPEG-4 HE-AAC音频、Dolby Digital Plus音频、MPEG-4.10 (H.264)视频和SMPTE (VC-1)视频。</p>
<p>图2-6是数字电视机顶盒的简化结构图,图中显示的是公共音视频处理模块。数字机顶盒用于接收数字电视广播,这些数字电视广播可能来自地面台站(空中电波)、有线或卫星。在数字电视内部就可能包含这些电路。</p>
<p>目前的许多电视机顶盒有两个调谐器,并具有数字视频摄像(VCR)功能。这使得在浏览个内部HDD时,还可以往另一个内部HDD中读入节目。在数字电视接收机中,有了这两个调谐器,还可以支持PIP特性(即将2个输入影像输出到同一画面上)。</p>
<p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E7%AE%80%E4%BB%8B/6.png" alt="6"></p>
]]></content>
      <categories>
        <category>视音频</category>
      </categories>
  </entry>
  <entry>
    <title>视音频-视频信号详解及测试-VGA</title>
    <url>/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95-VGA/</url>
    <content><![CDATA[<h5 id="ARGB概述"><a href="#ARGB概述" class="headerlink" title="ARGB概述"></a>ARGB概述</h5><h6 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h6><p>生活中常用设备如个人电脑、视频游戏机和家庭影院等都具有视频输出，输出信号可分为模拟信号和数字信号。这主要讲述模拟视频信号（ARGB），即以VGA 物理接口传输的RGBHV 5 线信号。   VGA 接口也叫D-Sub接口</p>
<a id="more"></a>
<h6 id="VGA接口"><a href="#VGA接口" class="headerlink" title="VGA接口"></a>VGA接口</h6><p>VGA 即视频图形阵列，它是由IBM 在1987年随同PS/2 个人电脑而引入的一种图形控制器标准。</p>
<p>VGA物理接口是RGBHV 5 线信号，使用的是<br>700mV模拟R/G/B视频电平和TTL电平H/V同步信<br>号。</p>
<p>VGA物理接口一直被广泛地使用着，它为后来的图形控制器信号而保留。尽管通常把它称为“VGA 端口”，但是在今天15 针的RGBHV 输出端口中，所传送的分辨率和彩色位深的显示格式常常超出了6 4 0 × 4 8 0 VGA 标准。</p>
<h6 id="VGA接口定义"><a href="#VGA接口定义" class="headerlink" title="VGA接口定义"></a>VGA接口定义</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95-VGA/1.jpg" alt="image"></p>
<h6 id="常见ARGB接口"><a href="#常见ARGB接口" class="headerlink" title="常见ARGB接口"></a>常见ARGB接口</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95-VGA/2.png" alt="image"><br><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95-VGA/3.png" alt="image"><br><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95-VGA/4.png" alt="image"><br><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95-VGA/5.png" alt="image"></p>
<h6 id="支持的模拟信号分辨率"><a href="#支持的模拟信号分辨率" class="headerlink" title="支持的模拟信号分辨率"></a>支持的模拟信号分辨率</h6><p>可支持各种通用的模拟RGBHV 信号分辨率，从640×480p到2048×1536p，<br>屏幕刷新速率从60Hz 直至100Hz。</p>
<h5 id="ARGB信号传输（模拟信号的传输）"><a href="#ARGB信号传输（模拟信号的传输）" class="headerlink" title="ARGB信号传输（模拟信号的传输）"></a>ARGB信号传输（模拟信号的传输）</h5><p>工程中构建一个VGA信号传输、分配系统时，长距离传输是一个常见问题。 由于信号传输距离较远，传输系统的参数及周围电磁环境对信号质量产生的影响不容忽视，常见到的现象表现为：图像模糊、变暗、 拖尾和重影，以及图像显示不稳定（如：跳动或黑屏等）等。</p>
<p>以上现象产生的原因不同，解决的方法不同。我们将其分为四大类：</p>
<p>一、由于传输系统的幅频特性及群延时特性造成的图像模糊、变暗、拖尾；</p>
<p>二、由于设备产生自激或环境电磁干扰产生的高频干扰；</p>
<p>三、由于系统电源地线处理不当造成的低频干扰；</p>
<p>四、由于设备、传输系统或接插件等阻抗不匹配而引起的重影反射及显示不稳定. </p>
<p>随着工程规模的扩大，VGA信号长距离（大于100米）和超长距离（大于500米）的应用不断出现，单纯靠电缆的传输方式明显不适应使用的要求，随着技术的发展，不断有新的传输方式出现，使这类应用成为可能。 以下为目前可实用的传输方式： </p>
<p>模拟电缆（RGB电缆）加电缆均衡器 </p>
<p>网线加均衡器 </p>
<p>光纤传输 </p>
<p>在此前提下，根据不同的距离，可采用不同的传输方式：（一般建议）</p>
<p>50米以内：好的VGA电缆；</p>
<p>50~100米，电缆加EQ；</p>
<p>100~200米，网线加EQ（或有抗干扰等需求）；</p>
<p>200米以上，光纤传输。</p>
<h5 id="VESA介绍-视频电子标准协会"><a href="#VESA介绍-视频电子标准协会" class="headerlink" title="VESA介绍(视频电子标准协会)"></a>VESA介绍(视频电子标准协会)</h5><p>随着VGA接口的信号传输速率愈来愈高，视频电子标准协会<br>（Video Electronics Standards Association）认识到，接口性能问题则显得更加重要。VESA 于1999 年发布了不具约束力的标准，其目标是更严格地定义RGBHV接口的传输参数。该标准称为视频信号标准，即VSIS（Video Signal standard），它为RGBHV信号的大多数重要参数提供了推荐值。</p>
<h5 id="ARGB信号特征"><a href="#ARGB信号特征" class="headerlink" title="ARGB信号特征"></a>ARGB信号特征</h5><p>800X600@60Hz为例：<br><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95-VGA/6.png" alt="image"></p>
<p>VESA Monitor Timing Standard</p>
<pre><code>Hor Pixels = 800; // Pixels
Ver Pixels = 600; // Lines
Hor Frequency = 37.879; // KHz = 26.4 usec /line
Ver Frequency = 60.317; // Hz = 16.6 msec /frame
Pixel Clock = 40.0; // MHz = 25.0 nsec    +/-0.05%



Scan Type = NONINTERLACED; 
Hor Sync Polarity = POSITIVE; // HBlank = 24.2% of HTotal
Ver Sync Polarity = POSITIVE; // VBlank = 4.5% of VTotal

Hor Total Time = 26.4; // (usec) =1056 Pixels
Hor Addr Time = 20.0; // (usec) = 800 Pixels
Hor Blank Start = 20.0; // (usec) = 800 Pixels
Hor Blank Time = 6.4; // (usec) = 256 Pixels
Hor Sync Start = 21; // (usec) = 840 Pixels

H Right Border = 0.000; // (usec) = 0 Pixels
H Front Porch = 1.0; // (usec) = 40 Pixels
Hor Sync Time = 3.2; // (usec) = 128 Pixels
H Back Porch = 2.2; // (usec) = 88 Pixels
H Left Border = 0.000; // (usec) = 0 Pixels


Ver Total Time = 16.579; // (msec) = 628 lines 
Ver Addr Time  = 15.84; // (msec) = 600 lines
Ver Blank Start = 15.84; // (msec) = 600 lines
Ver Blank Time = 0.739; // (msec) = 28 lines
Ver Sync Start = 15. 866; // (msec) = 601 lines

V Bottom Border = 0.000; // (msec) = 0 lines
V Front Porch = 0.026; // (msec) = 1 lines
Ver Sync Time  = 0.106; // (msec) = 4 lines
V Back Porch = 0.607; // (msec) = 23 lines 
V Top Border = 0.000; // (msec) = 0 lines</code></pre><h5 id="VESA测试内容"><a href="#VESA测试内容" class="headerlink" title="VESA测试内容"></a>VESA测试内容</h5><p>在2002年VESA 对VSIS 作了补充，增加了测试规范部分。测试规范的名称简称为“测试规范－模拟显示器件图形子系统的评估”，每项测试均给出了测试需要的设备、测试图案、测试步骤和必要的分析。</p>
<p>如果您打算执行 VSIS 测试，那么“测试规范－模拟显示器件图形子系统的评估”，是一个重要文件。这个文件有助于理解VSIS规范及其意义。</p>
<p>可以通过VESA得到VSIS文件及其相应的测试规程。这两个文件为评测VGA接口性能提供了一种有效的方法。</p>
<h6 id="信号测试项目"><a href="#信号测试项目" class="headerlink" title="信号测试项目"></a>信号测试项目</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95-VGA/7.png" alt="image"></p>
<h6 id="信号测试环境"><a href="#信号测试环境" class="headerlink" title="信号测试环境"></a>信号测试环境</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95-VGA/8.png" alt="image"><br>H/V负载电阻：2.2K 电阻，R/G/B负载电阻： 75 欧电阻</p>
<p>注：电阻精密度为0.1%。</p>
<h6 id="测试图"><a href="#测试图" class="headerlink" title="测试图"></a>测试图</h6><p>推荐使用三种静态测试图案用于VSIS测量。利用这三种测试图案激励DUT以产生RGVHV信号。图案如：<br><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95-VGA/9.png" alt="image"></p>
<p>一种称为“垂直栅格”的黑白垂直条纹交替图案，由 RGB ＝ FFh 的100 个像素和随后的RGB ＝ 00h 的100个像素组成并重复这一组合。这种栅格图案用于<br>RGB 视频幅度和瞬态响应测量。</p>
<ul>
<li>视频最大/最小亮度电压值</li>
<li>视频信号上升/下降时间</li>
<li>视频稳定建立时间</li>
<li>视频信号过冲/下冲</li>
<li>视频通道间时延</li>
</ul>
<p>水平显示的、从全黑到全白的灰度渐变斜坡或台阶信号。斜坡信号用于RGB线性和通道间失配测量。</p>
<ul>
<li>视频积分线性误差</li>
<li>视频微分线性误差</li>
<li>视频通道间失配</li>
</ul>
<p>全白平场信号或窗口信号，用于RGB视频噪声测量。</p>
<ul>
<li>视频噪声注入比</li>
</ul>
<h6 id="同步测量"><a href="#同步测量" class="headerlink" title="同步测量"></a>同步测量</h6><p>H 同步抖动</p>
<p>行同步功能是用来正确地规定每一图像显示行的位置。在理想情况下，从一个H同步脉冲到下一个H同步脉冲的时间应当是恒定的。如果H同步定时发生变化，那么在一帧中的图像部分就会发生水平位移。这种同步定时的变化称为抖动。对于一些重要的内容，漂移0.02％的图像宽度就会被察觉。</p>
<p>VSIS规定H同步抖动的最大峰峰值为像素周期的30％。这就是说，对于800×600格式，H 同步抖动的最大峰峰值为图像宽度的0.038％，而对于2048 × 1536 格式，其值为图像宽度的0.015％。</p>
<p>H 和V 定时</p>
<p>H定时和V定时测量是将同步位置与有源RGB视频进行比较，从而有助于确定显示器能否正确居中以及是否有正确的可寻址行数。</p>
<p>如果1024 × 768 屏幕格式的V 定时结果只有764显示行是因为上方和下方的边界不正确。这样上方2行和下方2行的任何信息将会被丢失。</p>
<p>H同步和V同步是测量同步脉冲的幅度、脉冲保真度和同步定时。如果这些测量参数超出容限，那么显示器的锁定可能是不可靠的。</p>
<h6 id="视频测量"><a href="#视频测量" class="headerlink" title="视频测量"></a>视频测量</h6><p>视频测量是用来评测模拟RGB信号的特性，包括电平、瞬变特性和噪声等。假定同步正确，那么RGB 视频特性将决定显示器的保真度。</p>
<p>这些测量可以划分为：<br>亮度电平、通道间失配、视频瞬变、线性、通道间畸变和噪声抑制比。</p>
<p><strong>亮度电平</strong></p>
<p>亮度电平测量用来测定DUT输出全白（其值为FFh）和黑图像信号 (其值为00h) 时的RGB 电压电平值。就理想状况而言，白电平应是700mV 而黑电平应是0mV。这些数值是绝对测量值，是以RGB信号的返回线 (接地端) 作为参考。</p>
<p>适当的电平对于显示器的正确亮度和对比度是重要的。</p>
<p><strong>通道间的失配</strong></p>
<p>通道间的失配用来比较RGB通道间的幅度匹配状况。测试是在黑(00h) 白 (FFh) 之间32个等间距的电平上进行的，使用的是阶梯波测试信号。对于阶梯波中的每一个台阶，均相对于该通道的行后肩电平以测量RGB电压。然后来比较通道间的电压（G&amp;B…）。</p>
<p>即使不考虑VSIS的规定，通道间失配的允许程度与应用也是密切相关的。通道间的失配会影响到重现的环境亮度、重现的亮度和对比度设置等</p>
<p><strong>视频瞬变特性</strong></p>
<p>视频瞬变特性是用来评估RGB通道中黑白电平跳变时的保真度。这项测量使用的是垂直栅格测试图案，由黑到白的过渡时间是一个像素的时间。每个通道均按10％至90％白电平幅度测量上升时间和下降时间、过冲(正向跳变) 、下冲(负向跳变) 和恢复稳定所需时间(settling time)。</p>
<p><strong>视频瞬变</strong></p>
<p>对于具有精密细节或锐利边界变化的任一图像而言，良好的过渡响应是非常重要的。例如，如果上升时间或下降时间过于缓慢，将会使图像的变化模糊而不清晰。过度的振铃会使图像素材在跳变之后出现亮/暗交替变化的现象。过冲和下冲是较为次要的问题，除非过渡到稳定建立需要很长的时间。事实上，某些过冲/ 下冲可能会增强图像信号跳变清晰度的感觉，许多显示器件有意地引入受控的预冲和过冲。</p>
<p><strong>线性</strong></p>
<p>线性是用来检查DUT在黑白之间的变化特性。在理想情况下，如果斜率恒定的黑白之间的斜坡测试信号加在DUT的输入端，其输出也应当是斜率恒定的斜坡。一般而言，DUT的输出斜坡会给出某种斜率的变化。这种变化表示出现了线性误差。</p>
<p>线性对于再现正确的灰度级别是重要的。如果单个RGB通道之间的线性差比较大，那么黑白之间的灰度级图案可能会在某些位置出现轻微的彩色。</p>
<p>VSIS定义了两种类型的线性测试方法。</p>
<p>第一种方法是积分非线性(INL)，它可以检查黑色和某些其它点之间的整个斜率误差。</p>
<p>第二种方法是微分非线性 (DNL)，它用来评测两个相邻点之间的斜率误差。</p>
<p>测试信号使用的一种黑白斜坡信号实际上是一连串的台阶信号。如果系统使用10比特系统就有1024 级台阶。</p>
<p><strong>噪声抑制比</strong></p>
<p>这是一项单个RGB通道中的噪声测量。VSIS规定峰至峰噪声测量是在白色图案上进行的，带宽在500MHz以上。峰至峰噪声值不应超过白色电压的5％。</p>
<p>VSIS规定在2秒的测量间隔内使用100000个噪声样值。</p>
<h5 id="什么参数对用户最重要？"><a href="#什么参数对用户最重要？" class="headerlink" title="什么参数对用户最重要？"></a>什么参数对用户最重要？</h5><p>如果互操作性－即信源在多种显示器件中均能正常工作－是最重要的，那么应当关注H和V同步测量、RGB亮度电平测量以及彩条测量。这些参数有助于建立正确的同步、正确的白/黑电平，并能使所有的RGB信号有效。</p>
<p>对于同步测量，特别要重视以下信号损伤：</p>
<ul>
<li>不正确的极性</li>
<li>频率错误</li>
<li>过度的过冲/ 下冲(特别是当偏离进入到0.5V 至2.4V范围时)</li>
<li>非单调性地上升或下降</li>
</ul>
<p>如果显示系统的灰度级性能非常重要（例如诸如彩色匹配之类的应用），那么就应当特别关注通道间的失配、线性以及RGB亮度电平测量。</p>
<p>通道间的失配测量将提供整个视频范围内各个通道相互间的跟踪是否接近的信息。</p>
<p>线性测量提供了每个通道中黑白电平转换的有关信息。</p>
<p>RGB亮度电平测量为整个700mV视频范围是否得到充分使用而提供了验证，因为这对于图像的对比度是否合适是很重要的。</p>
<p>对于图像绘制应用，例如PC视频应用，应当注重噪声、瞬态响应、RGB 亮度电平、通道间的匹配（包括通道间的幅度匹配和时间对准）以及H同步抖动等项目的测量，这对图像绘制应用是十分有利的。</p>
<p>需要注意的是，VSIS 测试没有检测运动相关图像的失真。但是，如果图像的随机噪声和抖动都很小，一般说来，尽管压缩也只会产生较低的失真。</p>
]]></content>
      <categories>
        <category>视音频</category>
      </categories>
      <tags>
        <tag>视频信号</tag>
        <tag>VESA</tag>
        <tag>ARGB</tag>
        <tag>VSIS</tag>
        <tag>VGA</tag>
      </tags>
  </entry>
  <entry>
    <title>视音频-常用视频信号配图介绍</title>
    <url>/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h5 id="常用视频信号介绍"><a href="#常用视频信号介绍" class="headerlink" title="常用视频信号介绍"></a>常用视频信号介绍</h5><a id="more"></a>
<p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/1.png" alt="image">)<img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/2.png" alt="image">)<img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/3.png" alt="image"></p>
<p>这里主要介绍可能用到的测试视频信号。<br>一般来讲，客户经常会用到灰阶、彩条这些测试信号，来测试画面显示是否正常。<br>例如每一阶能不能正常显示，过渡是否自然。<br>Color bar显示有没有偏色，Y/C 分离处理得好不好。<br>下面的资料可以参考一下。</p>
<h5 id="测试信号的类别"><a href="#测试信号的类别" class="headerlink" title="测试信号的类别"></a>测试信号的类别</h5><p>Gray Scale &amp; Levels (灰度和灰阶)</p>
<p>Geometry &amp; Convergence(几何特性和会聚)</p>
<p>Letterbox Geometry(4:3显示比例下的几何特性)</p>
<p>Wide Screen Enhanced(16:9显示比例显示特性)</p>
<p>Resolution(解析度)</p>
<p>Color Adjustment(色彩调整)</p>
<p>Special Test(包括Y/C delay,color decoder等)</p>
<h5 id="几种典型视频信号"><a href="#几种典型视频信号" class="headerlink" title="几种典型视频信号"></a>几种典型视频信号</h5><h6 id="Vertical-10-IRE-steps-灰阶信号）"><a href="#Vertical-10-IRE-steps-灰阶信号）" class="headerlink" title="Vertical 10 IRE steps(灰阶信号）"></a>Vertical 10 IRE steps(灰阶信号）</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/4.png" alt="image"></p>
<p>由左到右亮度值分别为100(white),90,80,70,60,50,40,30,20,10,7.5 IRE(black)</p>
<p>观察重点</p>
<p>1)每阶都能正常显示</p>
<p>2)阶与阶之间层次分明,宽度相同</p>
<p>3)从一阶到另一阶之间不应该有颜色变化</p>
<h6 id="Cross-Hatch"><a href="#Cross-Hatch" class="headerlink" title="Cross Hatch"></a>Cross Hatch</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/5.png" alt="image"></p>
<p>主要用来设置显示的尺寸,几何特性和会聚</p>
<p>这个画面由大小相同的水平和垂直的直线组成</p>
<p>正常的情况下,所有的方格应该大小相同,没有扭曲</p>
<p>边缘的标记用来设置显示的尺寸和中心</p>
<h6 id="MultiBurst-with-label"><a href="#MultiBurst-with-label" class="headerlink" title="MultiBurst with label"></a>MultiBurst with label</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/6.png" alt="image"></p>
<p>主要用来检查频率响应和设置Sharpness</p>
<p>该画面由几组频率相同的信号组成(其中3.58MHz是NTSC色负载波的频率,4.18MHz是广播频率的上限).上半部分的背景是50%的亮度,正常情况下下半部分的亮度<br>和信号的亮度相同</p>
<p>Sharpness设置合适时,所有的信号应该有相同的亮度,且没有边缘锐化的现象</p>
<h6 id="Resolution-200-TVL"><a href="#Resolution-200-TVL" class="headerlink" title="Resolution 200 TVL"></a>Resolution 200 TVL</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/7.png" alt="image"></p>
<p>用来测量水平和垂直方向的解析度,水平方向的解析度测量范围是200-540 TV line,垂直方向的解析度是200-480TV line.</p>
<p>周围的四个圆圈的频率分别是3.0,3.58,4.18和6.75MHz,可以作为解析度测试的补充</p>
<h6 id="Sharpness"><a href="#Sharpness" class="headerlink" title="Sharpness"></a>Sharpness</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/8.png" alt="image"></p>
<p>用来调整Sharpness和Vertical aperture</p>
<p>该画面由四部分组成</p>
<p>1)水平方向的信号用来设置频率响应</p>
<p>2)垂直方向的信号用来设置vertical aperture</p>
<p>3)其中的线和曲线用来侦测边缘的缺陷</p>
<p>4)垂直和水平的线段用来侦测模糊现象</p>
<h6 id="75-Split-Color-Bars"><a href="#75-Split-Color-Bars" class="headerlink" title="75% Split Color Bars"></a>75% Split Color Bars</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/9.png" alt="image"></p>
<p>主要用来校正色彩和色调</p>
<p>校正方法:</p>
<p>1)使灰阶信号和蓝色信号对齐来设置色度(理论上来讲,只要蓝色成分得到正确的校正,其他颜色应该可以正常的显示,因为蓝色成分经历了最多的编码)</p>
<p>2)使洋红和青色对准来调整色调</p>
<p>Note: 75% color bars接近广播信号中色彩显示的上限且满足FCC信号接口标准,所以经常被用来校正显示</p>
<h6 id="Y-C-Delay"><a href="#Y-C-Delay" class="headerlink" title="Y/C Delay"></a>Y/C Delay</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/10.png" alt="image"></p>
<p>用来测量Y/C Delay error</p>
<p>左边的部分用来测量Y/C Delay error;右边的部分用来观察是否存在Y/C delay error.正常情况下,红色竖条边缘应该没有扭曲</p>
<p>Y/C delay正常的情况下,R,G,B方块应与其对应的灰色方块在0度时对齐</p>
<h6 id="Color-Decoder"><a href="#Color-Decoder" class="headerlink" title="Color Decoder"></a>Color Decoder</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/11.png" alt="image"></p>
<p>用来测量RGB解码的准确度</p>
<p>该画面包含77 IRE的灰色背景和色度范围从+25%到-25%的R,G,B色块</p>
<p>测量时,需要只打开R,G,B中的一种颜色,然后看在0%位置,该颜色是否与其对应的背景颜色是否一致</p>
<h6 id="Overscan"><a href="#Overscan" class="headerlink" title="Overscan"></a>Overscan</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/12.png" alt="image"></p>
<p>用来测量屏幕隐藏的部分的百分比,也可以用来调整显示的区域和使屏幕置中</p>
<p>边缘的数字表示当前显示隐藏的图象的百分比.品质比较好的显示最多允许存在3%到5%隐藏比例</p>
<p>另外可以用该画面来调整水平和垂直的位置,使上下左右有同样的隐藏比例,从而保证画面位于屏幕的中央</p>
<h6 id="Gamma"><a href="#Gamma" class="headerlink" title="Gamma"></a>Gamma</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/13.png" alt="image"></p>
<p>用来测量显示设备的gamma值</p>
<p>该画面由六组标有gamma值的灰色方块组成</p>
<p>测量时,找出与背景颜色最接近的方块,该方块的数值就是显示设备的gamma值</p>
<h6 id="Center-Cross"><a href="#Center-Cross" class="headerlink" title="Center Cross"></a>Center Cross</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/14.png" alt="image"></p>
<p>主要用来设置R,G,B CRT电子枪的静会聚(static convergence).</p>
<p>十字线周围的短线指明了显示的安全区域,显示的区域至少应该短线包含的范围内</p>
]]></content>
      <categories>
        <category>视音频</category>
      </categories>
      <tags>
        <tag>视频信号</tag>
      </tags>
  </entry>
  <entry>
    <title>视音频中ES PS TS 等流的区别</title>
    <url>/2019/11/25/%E8%A7%86%E9%9F%B3%E9%A2%91%E4%B8%ADES-PS-TS-%E7%AD%89%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h4 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h4><h5 id="1-ES"><a href="#1-ES" class="headerlink" title="1. ES"></a>1. ES</h5><p>ES–Elementary  Streams  (原始流)是直接从编码器出来的数据流，可以是编码过的视频数据流（H.264,MJPEG等），音频数据流（AAC），或其他编码数据流的统称。ES流经过PES打包器之后，被转换成PES包。</p>
<a id="more"></a>
<p>ES是只包含一种内容的数据流，如只含视频或只含音频等，打包之后的PES也是只含一种性质的ES,如只含视频ES的PES,只含音频ES的PES等。每个ES都由若干个存取单元（AU）组成，每个视频AU或音频AU都是由头部和编码数据两部分组成，1个AU相当于编码的1幅视频图像或1个音频帧，也可以说，每个AU实际上是编码数据流的显示单元，即相当于解码的1幅视频图像或1个音频帧的取样。</p>
<h5 id="2-PES"><a href="#2-PES" class="headerlink" title="2. PES"></a>2. PES</h5><p>PES–Packetized  Elementary Streams  (分组的ES)，ES形成的分组称为PES分组，是用来传递ES的一种数据结构。PES流是ES流经过PES打包器处理后形成的数据流，在这个过程中完成了将ES流分组、打包、加入包头信息等操作（对ES流的第一次打包）。PES流的基本单位是PES包。PES包由包头和payload组成。</p>
<h5 id="3-PTS、DTS"><a href="#3-PTS、DTS" class="headerlink" title="3. PTS、DTS"></a>3. PTS、DTS</h5><p>PTS–PresentationTime Stamp（显示时间标记）表示显示单元出现在系统目标解码器（H.264、MJPEG等）的时间。</p>
<p>DTS–Decoding Time Stamp（解码时间标记）表示将存取单元全部字节从解码缓存器移走的时间。</p>
<p>PTS/DTS是打在PES包的包头里面的，这两个参数是解决音视频同步显示，防止解码器输入缓存上溢或下溢的关键。每一个I（关键帧）、P（预测帧）、B（双向预测 帧）帧的包头都有一个PTS和DTS，但PTS与DTS对于B帧不一样，无需标出B帧的DTS，对于I帧和P帧，显示前一定要存储于视频解码器的重新排序缓存器中，经过延迟（重新排序）后再显示，所以一定要分别标明PTS和DTS。</p>
<h5 id="4-PS"><a href="#4-PS" class="headerlink" title="4. PS"></a>4. PS</h5><p>PS–Program Stream(节目流)PS流由PS包组成，而一个PS包又由若干个PES包组成（到这里，ES经过了两层的封装）。PS包的包头中包含了同步信息与时钟恢复信息。一个PS包最多可包含具有同一时钟基准的16个视频PES包和32个音频PES包。</p>
<h5 id="5-TS"><a href="#5-TS" class="headerlink" title="5. TS"></a>5. TS</h5><p>TS–Transport Stream（传输流）由定长的TS包组成（188字节），而TS包是对PES包的一个重新封装（到这里，ES也经过了两层的封装）。PES包的包头信息依然存在于TS包中。</p>
<h5 id="6-TS流与PS流的区别"><a href="#6-TS流与PS流的区别" class="headerlink" title="6. TS流与PS流的区别"></a>6. TS流与PS流的区别</h5><p>TS流与PS流的区别在于TS流的包结构是固定长度的,而PS流的包结构是可变长度的。PS包由于长度是变化的,一旦丢失某一PS包的同步信息,接收机就会进入失步状态,从而导致严重的信息丢失事件。而TS码流由于采用了固定长度的包结构,当传输误码破坏了某一TS包的同步信息时,接收机可在固定的位置检测它后面包中的同步信息,从而恢复同步,避免了信息丢失。因此在信道环境较为恶劣、传输误码较高时一般采用TS码流,而在信环境较好、传输误码较低时一般采用PS码流。</p>
<h5 id="7-TS单一码流、混合码流"><a href="#7-TS单一码流、混合码流" class="headerlink" title="7.TS单一码流、混合码流"></a>7.TS单一码流、混合码流</h5><p>单一性：TS流的基本组成单位是长度为188字节的TS包。</p>
<p>混合性： TS流由多种数据组合而成，一个TS包中的数据可以是视频数据，音频数据，填充数据，PSI/SI表格数据等（唯一的PID对应）。</p>
<h5 id="8-封装"><a href="#8-封装" class="headerlink" title="8. 封装"></a>8. 封装</h5><p>封装，就是捆绑打包, 将画面视频文件和音轨文件打包在一起,并按照一定规则建立排序和索引, 便于播放器或播放软件来索引播放. 包括AVI / PS(Program Stream)/ TS（Transport Stream）/ MKV（Matroska）等.</p>
<h4 id="二、基本流程"><a href="#二、基本流程" class="headerlink" title="二、基本流程"></a>二、基本流程</h4><p><img src="/2019/11/25/%E8%A7%86%E9%9F%B3%E9%A2%91%E4%B8%ADES-PS-TS-%E7%AD%89%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB/1.jpg" alt="1"></p>
<ol>
<li>A/D转换后，通过MPEG-2压缩编码得到的ES基本流。这个数据流很大，并且只是I，P，B的这些视频帧或音频取样信息</li>
<li>通过PES打包器，打包并在每个帧中插入 PTS/DTS标志，变成PES。原来是流的格式，现在成了数据包的分割形式。</li>
<li>PES根据需要打包成PS或TS包进行存储（DVD）或传输(DVB)。因每路音/视频只包含一路的编码数据流，所以每路PES也只包含相应的数据流。</li>
</ol>
<p><img src="/2019/11/25/%E8%A7%86%E9%9F%B3%E9%A2%91%E4%B8%ADES-PS-TS-%E7%AD%89%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB/2.jpg" alt="2"></p>
<h4 id="三、推理过程"><a href="#三、推理过程" class="headerlink" title="三、推理过程"></a>三、推理过程</h4><h5 id="3-1-TS流的解码过程：ES-PES-DTS-PTS-PCR"><a href="#3-1-TS流的解码过程：ES-PES-DTS-PTS-PCR" class="headerlink" title="3.1 TS流的解码过程：ES-PES-DTS-PTS-PCR"></a>3.1 TS流的解码过程：ES-PES-DTS-PTS-PCR</h5><ol>
<li>获取TS中的PAT</li>
<li>获取TS中的PMT</li>
<li>根据PMT可以知道当前网络中传输的视频（音频）类型（H264），相应的PID，PCR的PID等信息。</li>
<li>设置demux 模块的视频Filter 为相应视频的PID和stream type等。</li>
<li>从视频Demux Filter 后得到的TS数据包中的payload 数据就是 one piece of PES，在TS header中有一些关于此 payload属于哪个PES的第多少个数据包。 因此软件中应该将此payload中的数据copy到PES的buffer中，用于拼接一个PES包。</li>
<li>拼接好的PES包的包头会有PTS，DTS信息，去掉PES的header就是ES。</li>
<li>直接将被拔掉PES包头的ES包送给decoder就可以进行解码。解码出来的数据就是一帧一帧的视频数据，这些数据至少应当与PES中的PTS关联一下，以便进行视音频同步。</li>
<li>I，B，B，P 信息是在ES中的。</li>
</ol>
<h5 id="3-2-具体描述"><a href="#3-2-具体描述" class="headerlink" title="3.2 具体描述"></a>3.2 具体描述</h5><p>ES 是直接从编码器出来的数据流，可以是编码过的视频数据流，音频数据流，或其他编码数据流的统称。 ES 流经过 PES 打包器之后，被转换成 PES 包。 PES 包由包头和 payload 组成。</p>
<p>在 PES 层，主要是在 PES 包头信息中加入 PTS( 显示时间标签 ) 和 DTS （解码时间标签）用于视频、音频同步。 其实， Mpeg-2 用于视音频同步以及系统时钟恢复的时间标签分别在 ES ， PES 和 TS 这 3 个层次中。</p>
<p>在 ES 层，与同步有关的主要是视频缓冲验证 VBV （ Video Buffer Verifier ），用以防止解码器的缓冲器出现上溢或下溢；在 PES 层，主要是在 PES 头信息里出现的显示时间标签 PTS （ Presentation Time Stamp ）和解码时间标签 DTS （ Decoding Time Stamp ）；</p>
<p>在 TS 层中， TS 头信息包含了节目时钟参考 PCR （ Program Clock Reference ），用于恢复出与编码端一致的系统时序时钟 STC （ System Time Clock ）。</p>
<p>基本流程如下：</p>
<p>首先 MPEG-2 压缩编码得到的 ES 基本流，这个数据流很大，并且只是 I ， P ， B 的这些视频帧或音频取样信息， 然后加入一些同步信息，打包成长度可变长度的数据包 PES ，原来是流的格式，现在成了数据包的分割形式。</p>
<p>同时要注意的是， ES 是只包含一种内容的数据流，如只含视频，或只含音频等，打包之后的 PES 也是只含一种性质的 ES, 如只含视频 ES 的 PES, 只含音频 ES 的 PES 等。</p>
<p>可以知道， ES 是编码视频数据流或音频数据流，每个 ES 都由若干个存取单元（ AU ）组成，每个视频 AU 或音频 AU 都是由头部和编码数据两部分组成， 1 个 AU 相当于编码的 1 幅视频图像或 1 个音频帧，也可以说，每个 AU 实际上是编码数据流的显示单元，即相当于解码的 1 幅视频图像或 1 个音频帧的取样。 </p>
<p>PEG-2 对视频的压缩产生 I 帧、 P 帧、 B 帧。把帧顺序 I1,P4,B2,B3,P7,B5,B6 帧的编码 ES ，通过打包并在每个帧中插入 PTS/DTS 标志，变成 PES 。</p>
<p>在插入 PTS/DTS 标志时，由于在 B 帧 PTS 和 DTS 相等，所以无须在 B 帧多插入 DTS 。</p>
<p>而对于 I 帧 和 P 帧，由于经过复用后数据包的顺序会发生变化，显示前一定要存储于视频解码器的从新排序缓存器中，经过从新排序后再显示，所以一定要同时插入 PTS 和 DTS 作为从新排序的依据。</p>
<p>其中，有否 PTS/DTS 标志，是解决视音频同步显示、防止解码器输入缓存器上溢或下溢的关键所在。 </p>
<p>PTS 表明显示单元出现在系统目标解码器（ STD- System Target Decoder ）的时间 , DTS 表明将存取单元全部字节从 STD 的 ES 解码缓存器移走的时刻。</p>
<p>视频编码图像帧次序为 I1,P4,B2,B3,P7,B5,B6,I10,B8,B9 的 ES ，加入 PTS/DTS 后，打包成一个个视频 PES 包。</p>
<p>每个 PES 包都有一个包头，用于定义 PES 内的数据内容，提供定时资料。</p>
<p>每个 I 、 P 、 B帧的包头都有一个 PTS 和 DTS ，但 PTS 与 DTS 对 B 帧都是一样的，无须标出 B 帧的 DTS 。</p>
<p>对 I 帧和 P 帧，显示前一定要存储于视频解码器的重新排序缓存器中，经过延迟（重新排序）后再显示，一定要分别标明 PTS 和 DTS 。</p>
<p>例如，解码器输入的图像帧次序为 I1,P4,B2,B3,P7,B5,B6,I10,B8,B9 ，依解码器输出的帧次序，应该 P4 比 B2 、 B3 在先，但显示时 P4 一定要比 B2 、 B3 在后，即 P4 要在提前插入数据流中的时间标志指引下，经过缓存器重新排序，以重建编码前视频帧次序 I1,B2,B3,P4,B5,B6,P7,B8,B9,I10 。</p>
<p>显然， PTS/DTS 标志表明对确定事件或确定信息解码的专用时标的存在，依靠专用时标解码器，可知道该确定事件或确定信息开始解码或显示的时刻。</p>
<p>例如， PTS/DTS 标志可用于确定编码、多路复用、解码、重建的时间。</p>
<p>PCR<br>PCR 是 TS 里面的，即 TS packet 的 header 里面可能会有，他用来指定所期望的该 ts packet 到达 decoder 的时间，他的作用于 SCR 类似。</p>
]]></content>
      <categories>
        <category>视音频</category>
      </categories>
      <tags>
        <tag>AVFormat</tag>
        <tag>ES</tag>
        <tag>PS</tag>
        <tag>TS</tag>
      </tags>
  </entry>
  <entry>
    <title>Video Timing 解释说明</title>
    <url>/2019/11/24/Video-Timing-%E8%A7%A3%E9%87%8A%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h6 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h6><p>大家应该都知道，视频看起来是持续动态的，但是实际上是由一系列的静态画面，在很短的时间内更替,在人眼上就产生视觉残留，以至于你的眼睛感觉是动态画面。大家看到的视频中大多数是每秒闪过50-60幅画面，对于电脑画面大概是每秒闪过70-80幅画面。</p>
<a id="more"></a>

<p>要说timing是什么，先说下一般的图像是怎么显示在屏幕上的。</p>
<p>视频源发出的一幅幅的画面，送到屏幕后，屏幕将每一幅画面从上到下逐行的扫描每个像素显示在屏幕上，不间断的重复，直到一段视频数据结束。</p>
<p>而视频数据是连续的，怎么就知道哪段数据是显示一个画面？</p>
<p>怎么知道一个画面中哪一段数据又是显示这一行的？</p>
<p>Timing 就是解决这两问题的。</p>
<pre><code>Video timing 包含两个信号：水平同步Hs（horizontal sync）和垂直同步Vs（vertical sync）
Vertical sync --&gt;用来标识什么时候开始送出一幅新画面
Horizontal sync --&gt;用来标识什么时候开始新一行的图像扫描</code></pre><h6 id="Vertical-sync-和-Horizontal-sync-信号有三种传送方式："><a href="#Vertical-sync-和-Horizontal-sync-信号有三种传送方式：" class="headerlink" title="Vertical sync 和 Horizontal sync 信号有三种传送方式："></a>Vertical sync 和 Horizontal sync 信号有三种传送方式：</h6><ol>
<li>单独传送vertical sync 和 Horizontal sync两路信号，如电脑上用的VGA信号，HDMI高清数字视频信号；</li>
<li>将vertical sync和horizontal sync信号复合在一路单独传送，如S-Video型号（其timing信号时复合在其Y信号中）；</li>
<li>将vertical sync和horizontal sync复合在一起的信号又再复合进视频信号中一起传送，如CVBS信号；</li>
</ol>
<h6 id="举个例子说明timing中包含了哪些信息："><a href="#举个例子说明timing中包含了哪些信息：" class="headerlink" title="举个例子说明timing中包含了哪些信息："></a>举个例子说明timing中包含了哪些信息：</h6><p>如一个视频信号timing为（1024x768@60），1024x768表示是SVGA分辨率（其中1024表示一幅图像的列数，因每一个象素点有R/G/B三点组成，故共有1024*3列；768表示一幅图像的行数，共768行），60Hz表示的就是vertical sync（即每一个画面的显示时间为1/60s=16.67ms），由于每一幅画面要扫描768行，所以每一行的扫描时间即为16.67ms/768=21.7us，即可得出horizontal sync。</p>
]]></content>
      <categories>
        <category>视音频</category>
      </categories>
      <tags>
        <tag>Timing</tag>
        <tag>Vertical sync</tag>
        <tag>Horizontal sync</tag>
      </tags>
  </entry>
  <entry>
    <title>工程设计-CAN转以太网</title>
    <url>/2019/11/24/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-CAN%E8%BD%AC%E4%BB%A5%E5%A4%AA%E7%BD%91/</url>
    <content><![CDATA[<p>暂略</p>
]]></content>
      <categories>
        <category>工程设计</category>
      </categories>
  </entry>
  <entry>
    <title>工程设计-Hdmi转以太网</title>
    <url>/2019/11/24/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-Hdmi%E8%BD%AC%E4%BB%A5%E5%A4%AA%E7%BD%91/</url>
    <content><![CDATA[<p>暂略</p>
]]></content>
      <categories>
        <category>工程设计</category>
      </categories>
  </entry>
  <entry>
    <title>C语言-ip地址合法性判断</title>
    <url>/2019/11/23/C%E8%AF%AD%E8%A8%80-ip%E5%9C%B0%E5%9D%80%E5%90%88%E6%B3%95%E6%80%A7%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<h5 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h5><p>工作中我们有时候处理一些IP地址和端口号。这些东西需要保存到配置文件中，所以在保存之前，必须要进行合法性判断。</p>
<h6 id="1-对于IP地址"><a href="#1-对于IP地址" class="headerlink" title="1. 对于IP地址"></a>1. 对于IP地址</h6><p>输入一个字符串，判断是否是合法的IPV4地址<br>首先，IPV4 地址满足3个条件</p>
<ul>
<li>三个点 “ . ”</li>
<li>四部分整数，0~255 之间</li>
<li>前导数不能是0，例如 012.1.1.1 非法<a id="more"></a>
<h6 id="2-对于端口号"><a href="#2-对于端口号" class="headerlink" title="2. 对于端口号"></a>2. 对于端口号</h6>满足0-65535的十进制整数即可</li>
</ul>
<h5 id="二、代码如下"><a href="#二、代码如下" class="headerlink" title="二、代码如下"></a>二、代码如下</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    1、只有三个点 , 四部分，每个数都在 0 ~ 255 </span><br><span class="line">    2、数字不能是 0开头 如：012.1.1.1 </span><br><span class="line">*/</span><br><span class="line">bool IsIpv4(char*str)</span><br><span class="line">&#123;</span><br><span class="line">    char* ptr;</span><br><span class="line">	static char ptrip[20];</span><br><span class="line">    int count = 0;</span><br><span class="line">    const char *p = str;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    1.判断是不是三个 ‘.’</span><br><span class="line">    2.判断是不是四部分数,每个数都在 0 ~ 255</span><br><span class="line">    3.判断是不是先导0,如:012.1.1.1 </span><br><span class="line">    */</span><br><span class="line">	printf(&quot;输入的 ip %s\n&quot;,str);</span><br><span class="line">	printf(&quot;未切割str&apos; Adress is 0x%X\n&quot;,str);</span><br><span class="line">	</span><br><span class="line">#if 1</span><br><span class="line">    while(*p !=&apos;\0&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*p == &apos;.&apos;)</span><br><span class="line">        count++;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(count != 3)  return false;</span><br><span class="line">    count = 0;</span><br><span class="line">    ptr = strtok(str,&quot;.&quot;);</span><br><span class="line">	memset(ptrip, 0, sizeof(ptrip));</span><br><span class="line">	strcpy(ptrip,ptr);</span><br><span class="line">    while(ptr != NULL)</span><br><span class="line">    &#123;   </span><br><span class="line">        count++;</span><br><span class="line">        if(ptr[0] == &apos;0&apos; &amp;&amp; isdigit(ptr[1])) return false;</span><br><span class="line">        int a = atoi(ptr);</span><br><span class="line">        if(count == 1 &amp;&amp; a == 0) return false;</span><br><span class="line">        if(a&lt;0 || a&gt;255) return false;</span><br><span class="line">        ptr = strtok(NULL,&quot;.&quot;);</span><br><span class="line">		if(ptr != NULL)</span><br><span class="line">		&#123;	</span><br><span class="line">			strcat(ptrip,&quot;.&quot;);</span><br><span class="line">			strcat(ptrip,ptr);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(count == 4)  </span><br><span class="line">	&#123;</span><br><span class="line">		//str = ptrip;//改变指针指向与内存拷贝的区别?ptrip也有一块静态存储空间的</span><br><span class="line">		memcpy(str,ptrip,strlen(ptrip));</span><br><span class="line">		printf(&quot;return ip=%s\n&quot;,str);</span><br><span class="line">		printf(&quot;str&apos;s Adress is 0x%X\n&quot;,str);</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">    else&#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;  </span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//格式是0-65535的10进制整数</span><br><span class="line">bool Isport(unsigned int port)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;port=%d\n&quot;,port);</span><br><span class="line">	if(port&lt;=65535)</span><br><span class="line">	&#123;</span><br><span class="line">		return true;	</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char buf[100];</span><br><span class="line">	short port = 0xFFFF;</span><br><span class="line">	</span><br><span class="line">	#if 1</span><br><span class="line">	while(cin&gt;&gt;buf,buf[0] != &apos;#&apos;)</span><br><span class="line">    &#123;   </span><br><span class="line">        if(IsIpv4(buf))</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;合法&quot;&lt;&lt;endl; </span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;非法&quot;&lt;&lt;endl; </span><br><span class="line">        &#125;</span><br><span class="line">		printf(&quot;输入buf的IP is %s\n&quot;,buf);</span><br><span class="line">		printf(&quot;buf Adress is 0x%X\n&quot;,buf);</span><br><span class="line">    &#125;</span><br><span class="line">	#endif</span><br><span class="line">	</span><br><span class="line">	#if 0</span><br><span class="line">	if(Isport(port))</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;合法&quot;&lt;&lt;endl; </span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;非法&quot;&lt;&lt;endl; </span><br><span class="line">    &#125;</span><br><span class="line">	#endif</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="三、执行效果"><a href="#三、执行效果" class="headerlink" title="三、执行效果"></a>三、执行效果</h5><p><img src="/2019/11/23/C%E8%AF%AD%E8%A8%80-ip%E5%9C%B0%E5%9D%80%E5%90%88%E6%B3%95%E6%80%A7%E5%88%A4%E6%96%AD/1.jpg" alt="1"></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>ip地址</tag>
        <tag>strcat</tag>
        <tag>strtok</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言-从一包数据中提取有效的数据帧</title>
    <url>/2019/11/23/C%E8%AF%AD%E8%A8%80-%E4%BB%8E%E4%B8%80%E5%8C%85%E6%95%B0%E6%8D%AE%E4%B8%AD%E6%8F%90%E5%8F%96%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E6%8D%AE%E5%B8%A7/</url>
    <content><![CDATA[<h5 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h5><p>有的时候我们一次接收数据可能是20个byte,需要在这20个byte中并不都是我们想要的。</p>
<h6 id="具体要求："><a href="#具体要求：" class="headerlink" title="具体要求："></a>具体要求：</h6><ol>
<li>这个有效长度必须满足收尾都是0x64</li>
<li>这个有效长度最短长度不得少于8个byte</li>
<li>这个有效长度的数据必须符合校验和的计算方式</li>
<li>满足上面3条即可提取这个数据帧</li>
<li>注意:在真正想要的数据帧之间是没有0x64的,这种情况先假设它不存在(后面会根据校验和的方式来处理)<a id="more"></a>
<h5 id="二、代码如下"><a href="#二、代码如下" class="headerlink" title="二、代码如下"></a>二、代码如下</h5></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//校验和之前所有字节累加取和之后，对累加和最低字节取反。</span><br><span class="line">UINT8 checksum(ComFrameData *pData, int len)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i,sum=0;</span><br><span class="line">    UINT8 ccsum=0;  </span><br><span class="line">	UINT8 *pdata;</span><br><span class="line">	pdata = (UINT8 *)pData;//将结构体类型强制转换成char类型</span><br><span class="line">	</span><br><span class="line">    for(i=0;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        #if 1</span><br><span class="line">        printf(&quot;%X\n&quot;,*pdata);</span><br><span class="line">        #endif</span><br><span class="line">        sum += *(pdata++); </span><br><span class="line">    &#125;</span><br><span class="line">    ccsum = ~(sum&amp;0xFF);  </span><br><span class="line">	</span><br><span class="line">#if 1</span><br><span class="line">    printf(&quot;累加和:0x%X\n&quot;,sum);</span><br><span class="line">    printf(&quot;校验和:0x%X\n&quot;,ccsum);</span><br><span class="line">#endif</span><br><span class="line">    return ccsum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void exception_handling_extract(UINT8 *fraBuf, UINT8 buflen, UINT8 **prealBUF, UINT8 *preallen)</span><br><span class="line">&#123;</span><br><span class="line">	UINT8 len = 0;//n = 0,</span><br><span class="line">	UINT8 *pcur,*p;//*pBuf,</span><br><span class="line">	</span><br><span class="line">	printf(&quot;接收到的数据的长度是:%d\n&quot;,buflen);</span><br><span class="line">	p = fraBuf;</span><br><span class="line">	while(buflen--)</span><br><span class="line">	&#123;</span><br><span class="line">		if(*p == 0x64)</span><br><span class="line">		&#123;</span><br><span class="line">			pcur = p;</span><br><span class="line">			while(buflen--)</span><br><span class="line">			&#123;</span><br><span class="line">				p++;</span><br><span class="line">				if(*p == 0x64)</span><br><span class="line">				&#123;</span><br><span class="line">					len = p-pcur;</span><br><span class="line">					printf(&quot;两个0x64之间的数据长度:%d\n&quot;,len);</span><br><span class="line">					if(len&gt;=8)</span><br><span class="line">					&#123;</span><br><span class="line">						//进行相应的校验和计算</span><br><span class="line">						if(*(p-1) == checksum((ComFrameData*)pcur,len-1))</span><br><span class="line">						&#123;</span><br><span class="line">							printf(&quot;这个真实帧的校验和满足条件!\n&quot;);</span><br><span class="line">							//开始提取这个有效的数据帧</span><br><span class="line">							*preallen = len+1;</span><br><span class="line">							*prealBUF = pcur;</span><br><span class="line">							printf(&quot;prealBuf-4:%X\n&quot;,*prealBUF);</span><br><span class="line">							break;</span><br><span class="line">						&#125;else&#123;</span><br><span class="line">							printf(&quot;这个真实帧的校验和不满足条件!\n&quot;);</span><br><span class="line">						&#125;</span><br><span class="line">						</span><br><span class="line">					&#125;else&#123;</span><br><span class="line">						//说明真正想要的数据帧帧头不是前面的一个0x64,可能是这一个,或者是下一个。之后继续对p进行遍历</span><br><span class="line">						pcur = p;</span><br><span class="line">						len = 0;</span><br><span class="line">					&#125;	</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				printf(&quot;此时N2的长度是:%d\n&quot;,buflen);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		p++;	</span><br><span class="line">		printf(&quot;此时N1的长度是:%d\n&quot;,buflen);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UINT8 ReceiveBuf[20] = &#123;</span><br><span class="line">0x00, 0x64, 0x00, 0x64, 0x01, 0x04, 0x00, 0x08, </span><br><span class="line">0x55, 0x07, 0xE2, 0x01, 0x06, 0x01, 0x1C, 0x18, </span><br><span class="line">0x14, 0x64, 0x30, 0x11&#125;;//模拟接收到的MCU响应的时间</span><br><span class="line"></span><br><span class="line">//实际接收的数据</span><br><span class="line">//0x64, 0x01, 0x04, 0x00, 0x08, 0x55, 0x07, 0xE2, 0x01, 0x06, 0x01, 0x1C,0x18, 0x14, 0x64</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">	UINT8 i,buflen,reallen;</span><br><span class="line">	UINT8 Buf[64]; </span><br><span class="line">	UINT8 *prealBuf;//UINT8 realBuf[32];</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	#if 0//这里暂时不需要对prealBuf分配内存空间,因为ReceiveBuf数组是已经假设是全局变量了。prealBuf指向就是ReceiveBuf[3],位置其实是不会变的。</span><br><span class="line">	UINT8 *prealBuf = (UINT8 *)malloc(sizeof(UINT8 *)*32);//定义一个全局realBuf[32];之后memset</span><br><span class="line">	</span><br><span class="line">	if(prealBuf == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;prealBuf malloc is failed\n&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	free(prealBuf);</span><br><span class="line">	prealBuf=NULL;</span><br><span class="line">	#endif</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//数据帧的异常处理,接收到的一帧数据可能是20byte,提取自己想要的。</span><br><span class="line">	buflen = 20;//接收数据帧的长度是一个byte一个byte的接收,还是？</span><br><span class="line">	printf(&quot;prealBuf-1:%X\n&quot;,prealBuf);</span><br><span class="line">	exception_handling_extract(ReceiveBuf, buflen, &amp;prealBuf, &amp;reallen);</span><br><span class="line">	printf(&quot;prealBuf-2:%X\n&quot;,prealBuf);</span><br><span class="line">	printf(&quot;接收的真实数据帧长度是:%d\n&quot;,reallen);</span><br><span class="line">	for(i=0;i&lt;reallen;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;接收的真实数据帧是:0x%X\n&quot;,prealBuf[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;prealBuf-3:%X\n&quot;,prealBuf);</span><br><span class="line">	printf(&quot;prealBuf-4:%X\n&quot;,&amp;ReceiveBuf[3]);//可以看到prealBuf此时指向的地址和ReceiveBuf[3]的地址一模一样，所以这里不需要用malloc来申请内存空间</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="三、执行效果"><a href="#三、执行效果" class="headerlink" title="三、执行效果"></a>三、执行效果</h5><p><img src="/2019/11/23/C%E8%AF%AD%E8%A8%80-%E4%BB%8E%E4%B8%80%E5%8C%85%E6%95%B0%E6%8D%AE%E4%B8%AD%E6%8F%90%E5%8F%96%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E6%8D%AE%E5%B8%A7/1.jpg" alt="1"></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>全局变量</tag>
        <tag>生存周期</tag>
        <tag>内存分配</tag>
      </tags>
  </entry>
  <entry>
    <title>工程设计-COM口16进制通信设计</title>
    <url>/2019/11/23/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-COM%E5%8F%A316%E8%BF%9B%E5%88%B6%E9%80%9A%E4%BF%A1%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h4 id="一、16进制数据格式通过串口调试工具验证"><a href="#一、16进制数据格式通过串口调试工具验证" class="headerlink" title="一、16进制数据格式通过串口调试工具验证"></a>一、16进制数据格式通过串口调试工具验证</h4><p>拿到MCU板子，根据《mcu com软件接口设计方案_v002.xlsx》进行串口调试验证，见下表。</p>
<a id="more"></a>

<p><img src="/2019/11/23/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-COM%E5%8F%A316%E8%BF%9B%E5%88%B6%E9%80%9A%E4%BF%A1%E8%AE%BE%E8%AE%A1/1.jpg" alt="1"><br>具体操作是用一个串口监视MCU的运行打印信息，用另一个串口作为16进制指令调试发送。稍微验证符合要求，即可进行下一步。</p>
<h4 id="二、数据格式耦合-解耦合"><a href="#二、数据格式耦合-解耦合" class="headerlink" title="二、数据格式耦合/解耦合"></a>二、数据格式耦合/解耦合</h4><p>数据的传输最终是按照大小端、高低位一个bit个bit的buffer数组方式进行传输。所以我们发送/接收都需要对数据进行封装与解析。</p>
<h5 id="2-1-数据结构类型"><a href="#2-1-数据结构类型" class="headerlink" title="2.1    数据结构类型"></a>2.1    数据结构类型</h5><p>根据上图构造一个可拓展的数据结构类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef _HEX_H_</span><br><span class="line">#define _HEX_H_</span><br><span class="line"></span><br><span class="line">typedef unsigned char UINT8;</span><br><span class="line">typedef unsigned short int UINT16;</span><br><span class="line">typedef unsigned int UINT32;</span><br><span class="line"></span><br><span class="line">#define COMMFRA_SEND_HEAD               0x64</span><br><span class="line">#define COMMFRA_SEND_UP_DOWN            0x01</span><br><span class="line">#define COMMFRA_SEND_TAIL               0x64</span><br><span class="line"></span><br><span class="line">#pragma   pack(1)</span><br><span class="line">typedef enum&#123;//关键字</span><br><span class="line">    RESET,</span><br><span class="line">	SOFT_HARD_VER,</span><br><span class="line">	HEART,</span><br><span class="line">	SET_MCU_TIME,</span><br><span class="line">	GET_MCU_TIME,</span><br><span class="line">	SWITCH_SIM,</span><br><span class="line">	GET_SIM,</span><br><span class="line">	GET_GPS,</span><br><span class="line">	LOW_POWER,</span><br><span class="line">	POWER_STATE,</span><br><span class="line">	POWER_OFF,</span><br><span class="line">	FIRMWARE_UPDATE,</span><br><span class="line">	</span><br><span class="line">	SET_SAMPLING_RATE = 0x10,</span><br><span class="line">	GET_SAMPLING_RATE,</span><br><span class="line">	START_SENSOR,</span><br><span class="line">	STOP_SENSOR,</span><br><span class="line">	CHECK_SENSOR,</span><br><span class="line">	SENSOR_BUFFER_FULL,</span><br><span class="line">	GET_SENSOR,</span><br><span class="line">	UPLOAD_SENSOR,</span><br><span class="line">	</span><br><span class="line">	START_BUZZER = 0x20</span><br><span class="line">&#125;keyword;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef enum&#123;</span><br><span class="line">	KEY1 = 0x55,</span><br><span class="line">	KEY2 = 0xAA,</span><br><span class="line">	KEY3 = 0x01,</span><br><span class="line">	KEY4 = 0x02,</span><br><span class="line">&#125;key;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">联合体里面的单元数组，在定义的时候会按照最大的长度进行分配内存，所以接收到校验和,帧尾有时候会跑到item数据域中去，</span><br><span class="line">后面的结构体的校验和、帧尾会匹配不到。</span><br><span class="line">解决这种问题：</span><br><span class="line">1. 定义发送/接收item数据域的内容时,用指针变量，用的时候malloc堆内存，用的时候再free。但有的时候会遗忘。</span><br><span class="line">2. union中的成员，同一时刻只会用一种，将所有的item数据域的内容长度按照最长的分配。帧尾和校验和在在item数据域中去找。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">typedef union&#123;</span><br><span class="line"></span><br><span class="line">	union&#123;</span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">		&#125;ComFrameDataReset_Request;//item-reset 			</span><br><span class="line">	&#125;ComFrameDataReset;</span><br><span class="line"></span><br><span class="line">	union&#123;</span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">		&#125;ComFrameDataVer_Request;  //获取软硬件板本，</span><br><span class="line">	</span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">			UINT8 data[2];</span><br><span class="line">		&#125;ComFrameDataVer_Response;  //得到软硬件板本，</span><br><span class="line">	&#125;ComFrameDataVer;//item-Version</span><br><span class="line"></span><br><span class="line">	union&#123;</span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">			UINT8 item_data[2];</span><br><span class="line">		&#125;ComFrameDataHeart_Request;  </span><br><span class="line">		</span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">			UINT8 item_data[2];</span><br><span class="line">		&#125;ComFrameDataHeart_Response;</span><br><span class="line">	&#125;ComFrameDataHeart;//item-Heart</span><br><span class="line"></span><br><span class="line">#if 1</span><br><span class="line">	union&#123;</span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">			UINT8 item_data[7];</span><br><span class="line">		&#125;ComFrameDataSetMCUTime_Request;  </span><br><span class="line"> </span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">			UINT8 item_data[7];</span><br><span class="line">		&#125;ComFrameDataSetMCUTime_Response;  	</span><br><span class="line">	&#125;ComFrameDataSetMCUTime;//item-SetMCUTime	</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	union&#123;</span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">		&#125;ComFrameDataGetMCUTime_Request;  </span><br><span class="line">	</span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">			UINT8 item_data[7];</span><br><span class="line">		&#125;ComFrameDataGetMCUTime_Response; </span><br><span class="line">	&#125;ComFrameDataGetMCUTime; //item-GetMCUTime</span><br><span class="line">	</span><br><span class="line">	union&#123;</span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">			UINT8 item_data;</span><br><span class="line">		&#125;ComFrameDataSwitchSIM_Request; </span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">			UINT8 item_data[2];</span><br><span class="line">		&#125;ComFrameDataSwitchSIM_Response;</span><br><span class="line">	&#125;ComFrameDataSwitchSIM;//切换SIM卡</span><br><span class="line">		</span><br><span class="line">	union&#123;</span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">		&#125;ComFrameDataGetSIM_Request; </span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">			UINT8 item_data;</span><br><span class="line">		&#125;ComFrameDataGetSIM_Response;</span><br><span class="line">	&#125;ComFrameDataGetSIM;//获取目前使用的SIM卡</span><br><span class="line">	</span><br><span class="line">	union&#123;</span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">		&#125;ComFrameDataStartGPS_Request; </span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">		&#125;ComFrameDataStartGPS_Response;</span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">			UINT8 item_data;</span><br><span class="line">		&#125;ComFrameDataGPS_Response;//响应成功or失败</span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">		&#125;ComFrameDataGPSGet_Request;//读取GPS坐标，那么下面是不是还有一个响应</span><br><span class="line">		</span><br><span class="line">	&#125;ComFrameDataGPS;//GPS坐标</span><br><span class="line">	</span><br><span class="line">	union&#123;</span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">		&#125;ComFrameData4GInLowPower_Request; </span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">			UINT8 item_data;</span><br><span class="line">		&#125;ComFrameData4GInLowPower_Response; </span><br><span class="line">	&#125;ComFrameData4GInLowPower;//进入低功耗</span><br><span class="line">	</span><br><span class="line">	union&#123;</span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">		&#125;ComFrameData4GExitLowPower_Request; </span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">			UINT8 item_data;</span><br><span class="line">		&#125;ComFrameData4GExitLowPower_Response; </span><br><span class="line">	&#125;ComFrameData4GExitLowPower;//退出低功耗</span><br><span class="line">	</span><br><span class="line">	union&#123;</span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">		&#125;ComFrameDataPower_Request; </span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">			UINT8 item_data[12];//这里数据大小的内容长度不能大于强制转换的数组的数据域内容，否则会错位</span><br><span class="line">		&#125;ComFrameDataPower_Response;//是主动获取还是定时上报</span><br><span class="line">	&#125;ComFrameDataPower;//电源情况</span><br><span class="line">	</span><br><span class="line">	union&#123;</span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">		&#125;ComFrameDataPowerOff_Request; </span><br><span class="line">	&#125;ComFrameDataPowerOff;</span><br><span class="line">	</span><br><span class="line">	union&#123;</span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">			UINT8 item_data;</span><br><span class="line">		&#125;ComFrameDataPowerOff_Request; </span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">			UINT8 item_data;</span><br><span class="line">		&#125;ComFrameDataPowerOff_Response; </span><br><span class="line">	&#125;ComFrameDataFrimwareUpdate;//更新程序</span><br><span class="line">	</span><br><span class="line">	union&#123;</span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">			UINT8 item_data;</span><br><span class="line">		&#125;ComFrameDataSetSampleRate_Request; </span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">			UINT8 item_data;</span><br><span class="line">		&#125;ComFrameDataSetSampleRate_Response;</span><br><span class="line">	&#125;ComFrameDataSetSampleRate;//设置采样率</span><br><span class="line">	</span><br><span class="line">	union&#123;</span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">			UINT8 item_data;</span><br><span class="line">		&#125;ComFrameDataGetSampleRate_Request; </span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">			UINT8 item_data;</span><br><span class="line">		&#125;ComFrameDataGetSampleRate_Response;</span><br><span class="line">	&#125;ComFrameDataGetSampleRate;//读取采样率</span><br><span class="line">	</span><br><span class="line">	union&#123;</span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">			UINT8 item_data;</span><br><span class="line">		&#125;ComFrameDataStartSensor_Request; </span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">			UINT8 item_data[2];</span><br><span class="line">		&#125;ComFrameDataStartSensor_Response;</span><br><span class="line">	&#125;ComFrameDataStartSensor;//启动传感器</span><br><span class="line"></span><br><span class="line">	union&#123;</span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">			UINT8 item_data;</span><br><span class="line">		&#125;ComFrameDataStopSensor_Request; </span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">			UINT8 item_data[2];</span><br><span class="line">		&#125;ComFrameDataStopSensor_Response;</span><br><span class="line">	&#125;ComFrameDataStopSensor;//停止传感器</span><br><span class="line">	</span><br><span class="line">	union&#123;</span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">			UINT8 item_data;</span><br><span class="line">		&#125;ComFrameDataCheckSensor_Request; </span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">			UINT8 item_data[2];</span><br><span class="line">		&#125;ComFrameDataCheckSensor_Response;</span><br><span class="line">	&#125;ComFrameDataCheckSensor;//传感器自检</span><br><span class="line">		</span><br><span class="line">	union&#123;</span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">			UINT8 item_data[3];</span><br><span class="line">		&#125;ComFrameDataSensorBuffFull_Response;		</span><br><span class="line">	&#125;ComFrameDataSensorBuffFull;//传感器buffer满</span><br><span class="line">	</span><br><span class="line">	union&#123;</span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">			UINT8 item_data[3];</span><br><span class="line">		&#125;ComFrameDataGetSensor_Request;	</span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">			UINT8 item_data;</span><br><span class="line">		&#125;ComFrameDataGetSensor_Response;				</span><br><span class="line">	&#125;ComFrameDataGetSensor;//获取传感器数据</span><br><span class="line"></span><br><span class="line">	union&#123;</span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">			UINT8 item_data[2];</span><br><span class="line">		&#125;ComFrameDataStartBuzzer_Request;	</span><br><span class="line">		struct&#123;</span><br><span class="line">			UINT8 item_key;</span><br><span class="line">			UINT8 item_data[2];</span><br><span class="line">		&#125;ComFrameDataStartBuzzer_Response;		</span><br><span class="line">	&#125;ComFrameDataStartBuzzer;//启动蜂鸣器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;ComFrameDataItem;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    UINT8   		frame_start;</span><br><span class="line">    UINT8   		frame_up_down;</span><br><span class="line">	</span><br><span class="line">    UINT8   		frame_key_word;</span><br><span class="line">    UINT16   		frame_datalength;//UINT8 (frame_datalength_high+frame_datalength_low)   		</span><br><span class="line">	</span><br><span class="line">    ComFrameDataItem   frame_item;</span><br><span class="line">	//将校验和帧尾从这里拿出去，放到每一个组包/解包函数中去。</span><br><span class="line">    //UINT8   		frame_CRC;</span><br><span class="line">    //UINT8   		frame_stop;</span><br><span class="line">&#125;ComFrameData;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h5 id="2-2-强制转换和初始化"><a href="#2-2-强制转换和初始化" class="headerlink" title="2.2    强制转换和初始化"></a>2.2    强制转换和初始化</h5><p>数据传输之前，需要将buffer数组强制成转换成我们需要的数据结构类型，然后再进行赋值。<br>数据接收之后，需要将buffer数组强制转换成我们需要的数据结构类型，便于查看。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pdata = (UINT8 *)pData;//将结构体类型强制转换成unsigned char类型</span><br><span class="line">pBuf = (ComFrameData *)fraBuf;//将unsigned char类型强制转换成结构体类型</span><br></pre></td></tr></table></figure>

<h5 id="2-3-注意字节对齐与大小端"><a href="#2-3-注意字节对齐与大小端" class="headerlink" title="2.3    注意字节对齐与大小端"></a>2.3    注意字节对齐与大小端</h5><p>整个数据结构中有char型、short型、char型数组，所以需要考虑到32位机字节对齐的问题。加上：</p>
<pre><code>#pragma   pack(1)，强制连续存放，对齐边界为1。</code></pre><h4 id="三、数据格式的组包-解包"><a href="#三、数据格式的组包-解包" class="headerlink" title="三、数据格式的组包/解包"></a>三、数据格式的组包/解包</h4><p>数据传输时，需要对数据进行初始化、校验、打包。</p>
<h5 id="3-1-校验和"><a href="#3-1-校验和" class="headerlink" title="3.1 校验和"></a>3.1 校验和</h5><p>在组包解包之前有校验和，这里从帧头开始到校验和之前开始累加，对最低byte取反即可。具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UINT8 checksum(ComFrameData *pData, int len)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i,sum=0;</span><br><span class="line">    UINT8 ccsum=0;  </span><br><span class="line">	UINT8 *pdata;</span><br><span class="line">	pdata = (UINT8 *)pData;//将结构体类型强制转换成char类型</span><br><span class="line">	</span><br><span class="line">    for(i=0;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        #if 1</span><br><span class="line">        printf(&quot;%X\n&quot;,*pdata);</span><br><span class="line">        #endif</span><br><span class="line">        sum += *(pdata++); </span><br><span class="line">    &#125;</span><br><span class="line">    ccsum = ~(sum&amp;0xFF);  </span><br><span class="line">	</span><br><span class="line">#if 1</span><br><span class="line">    printf(&quot;累加和:0x%X\n&quot;,sum);</span><br><span class="line">    printf(&quot;校验和:0x%X\n&quot;,ccsum);</span><br><span class="line">#endif</span><br><span class="line">    return ccsum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-将要Request的组包"><a href="#3-2-将要Request的组包" class="headerlink" title="3.2 将要Request的组包"></a>3.2 将要Request的组包</h5><p>举个例子，对上图Excel表中的reset命令进行组包，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void commFraSend_ResetBulid_Request(UINT8 *fraBuf, UINT8 *plen)</span><br><span class="line">&#123;</span><br><span class="line">	ComFrameData *pBuf;</span><br><span class="line">	pBuf = (ComFrameData *)fraBuf;//将char类型强制转换成结构体类型</span><br><span class="line">	UINT8 frame_CRC,frame_stop;	</span><br><span class="line">	</span><br><span class="line">	pBuf-&gt;frame_start   		= COMMFRA_SEND_HEAD;	//64</span><br><span class="line">	pBuf-&gt;frame_up_down 		= COMMFRA_SEND_UP_DOWN; //1</span><br><span class="line">	pBuf-&gt;frame_key_word		= RESET;				//0 </span><br><span class="line">	</span><br><span class="line">	pBuf-&gt;frame_datalength		= 0x0001;				//高低位 大小端</span><br><span class="line">	pBuf-&gt;frame_item.ComFrameDataReset.ComFrameDataReset_Request.item_key	= KEY1;					//55</span><br><span class="line">	</span><br><span class="line">	frame_CRC 			= checksum(pBuf,6);</span><br><span class="line">	frame_stop    		= COMMFRA_SEND_TAIL;</span><br><span class="line">	printf(&quot;帧尾:0x%X\n&quot;,frame_stop);</span><br><span class="line">	*plen = sizeof(pBuf-&gt;frame_start)</span><br><span class="line">			+sizeof(pBuf-&gt;frame_up_down)</span><br><span class="line">			+sizeof(pBuf-&gt;frame_key_word)</span><br><span class="line">			+sizeof(pBuf-&gt;frame_datalength)</span><br><span class="line">			+sizeof(pBuf-&gt;frame_item.ComFrameDataReset.ComFrameDataReset_Request.item_key)</span><br><span class="line">			+sizeof(frame_CRC)</span><br><span class="line">			+sizeof(frame_stop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-将要Response的解包"><a href="#3-3-将要Response的解包" class="headerlink" title="3.3 将要Response的解包"></a>3.3 将要Response的解包</h5><p>举个例子，对上图Excel表中的Response命令进行解包包，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void commFraSend_SetMCUTimeAnalysis_Response(UINT8 *fraBuf)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	char i,item_len;</span><br><span class="line">	ComFrameData *pBuf;</span><br><span class="line">	pBuf = (ComFrameData *)fraBuf;//将char类型强制转换成结构体类型</span><br><span class="line">	UINT8 frame_CRC,frame_stop;</span><br><span class="line">	</span><br><span class="line">	printf(&quot;帧头:0x%X\n&quot;,pBuf-&gt;frame_start);</span><br><span class="line">	printf(&quot;上下行:0x%X\n&quot;,pBuf-&gt;frame_up_down);</span><br><span class="line">	printf(&quot;关键字:0x%X\n&quot;,pBuf-&gt;frame_key_word);</span><br><span class="line">	</span><br><span class="line">	item_len = (pBuf-&gt;frame_datalength&amp;0xFF)|(pBuf-&gt;frame_datalength&gt;&gt;8);</span><br><span class="line">	printf(&quot;数据长度:0x%X\n&quot;,item_len);</span><br><span class="line">	</span><br><span class="line">	printf(&quot;数据域-Key:0x%X\n&quot;,pBuf-&gt;frame_item.ComFrameDataSetMCUTime.ComFrameDataSetMCUTime_Response.item_key);</span><br><span class="line">	for(i=0;i&lt;item_len-1;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;数据域内容:0x%X\n&quot;,pBuf-&gt;frame_item.ComFrameDataSetMCUTime.ComFrameDataSetMCUTime_Response.item_data[i]);</span><br><span class="line">	&#125;	</span><br><span class="line">	</span><br><span class="line">	frame_CRC = pBuf-&gt;frame_item.ComFrameDataSetMCUTime.ComFrameDataSetMCUTime_Response.item_data[i];</span><br><span class="line">	frame_stop = pBuf-&gt;frame_item.ComFrameDataSetMCUTime.ComFrameDataSetMCUTime_Response.item_data[i+1];</span><br><span class="line">	</span><br><span class="line">	printf(&quot;校验:0x%X\n&quot;,frame_CRC);</span><br><span class="line">	printf(&quot;帧尾:0x%X\n&quot;,frame_stop);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-4-对接收数据进行的异常处理"><a href="#3-4-对接收数据进行的异常处理" class="headerlink" title="3.4 对接收数据进行的异常处理"></a>3.4 对接收数据进行的异常处理</h5><p>关于异常处理与提取,接收数据可能是20个byte,需要在这20个byte中提取有效的长度。</p>
<ol>
<li>这个有效长度必须满足收尾都是0x64</li>
<li>这个有效长度最短长度不得少于8个byte</li>
<li>这个有效长度的数据必须符合校验和的计算方式</li>
<li>满足上面3条即可提取这个数据帧</li>
<li>注意:在真正想要的数据帧之间是没有0x64的,这种情况先假设它不存在(后面会根据校验和的方式来处理)</li>
</ol>
<p>代码如下：（循环遍历+判断条件）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UINT8 ReceiveBuf[20] = &#123;</span><br><span class="line">0x00, 0x64, 0x00, 0x64, 0x01, 0x04, 0x00, 0x08, </span><br><span class="line">0x55, 0x07, 0xE2, 0x01, 0x06, 0x01, 0x1C, 0x18, </span><br><span class="line">0x14, 0x64, 0x30, 0x11&#125;;//模拟接收到的MCU响应的时间</span><br><span class="line"></span><br><span class="line">void exception_handling_extract(UINT8 *fraBuf, UINT8 buflen, UINT8 **prealBUF, UINT8 *preallen)</span><br><span class="line">&#123;</span><br><span class="line">	UINT8 len = 0;//n = 0,</span><br><span class="line">	UINT8 *pcur,*p;//*pBuf,</span><br><span class="line">	</span><br><span class="line">	printf(&quot;接收到的数据的长度是:%d\n&quot;,buflen);</span><br><span class="line">	p = fraBuf;</span><br><span class="line">	while(buflen--)</span><br><span class="line">	&#123;</span><br><span class="line">		if(*p == 0x64)</span><br><span class="line">		&#123;</span><br><span class="line">			pcur = p;</span><br><span class="line">			while(buflen--)</span><br><span class="line">			&#123;</span><br><span class="line">				p++;</span><br><span class="line">				if(*p == 0x64)</span><br><span class="line">				&#123;</span><br><span class="line">					len = p-pcur;</span><br><span class="line">					printf(&quot;两个0x64之间的数据长度:%d\n&quot;,len);</span><br><span class="line">					if(len&gt;=8)</span><br><span class="line">					&#123;</span><br><span class="line">						//进行相应的校验和计算</span><br><span class="line">						if(*(p-1) == checksum((ComFrameData*)pcur,len-1))</span><br><span class="line">						&#123;</span><br><span class="line">							printf(&quot;这个真实帧的校验和满足条件!\n&quot;);</span><br><span class="line">							//开始提取这个有效的数据帧</span><br><span class="line">							*preallen = len+1;</span><br><span class="line">							*prealBUF = pcur;</span><br><span class="line">							break;</span><br><span class="line">						&#125;else&#123;</span><br><span class="line">							printf(&quot;这个真实帧的校验和不满足条件!\n&quot;);</span><br><span class="line">						&#125;</span><br><span class="line">						</span><br><span class="line">					&#125;else&#123;</span><br><span class="line">						//说明真正想要的数据帧帧头不是前面的一个0x64,可能是这一个,或者是下一个。之后继续对p进行遍历</span><br><span class="line">						pcur = p;</span><br><span class="line">						len = 0;</span><br><span class="line">					&#125;	</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				printf(&quot;此时N2的长度是:%d\n&quot;,buflen);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		p++;	</span><br><span class="line">		printf(&quot;此时N1的长度是:%d\n&quot;,buflen);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="四、SEND-RECEIVE-数据"><a href="#四、SEND-RECEIVE-数据" class="headerlink" title="四、SEND/RECEIVE-数据"></a>四、SEND/RECEIVE-数据</h4><p>海思和MCU通信是通过串口通信，这里有现成的接口函数，驱动部分不需要做出太多的改动，现在主要考虑的应用逻辑部分。</p>
<h5 id="4-1-数据长度必须要满足最小值"><a href="#4-1-数据长度必须要满足最小值" class="headerlink" title="4.1    数据长度必须要满足最小值"></a>4.1    数据长度必须要满足最小值</h5><h5 id="4-2-帧头、帧尾要符合要求，最好要有冗余检测"><a href="#4-2-帧头、帧尾要符合要求，最好要有冗余检测" class="headerlink" title="4.2    帧头、帧尾要符合要求，最好要有冗余检测"></a>4.2    帧头、帧尾要符合要求，最好要有冗余检测</h5><h5 id="4-3-校验对比"><a href="#4-3-校验对比" class="headerlink" title="4.3    校验对比"></a>4.3    校验对比</h5><p>前面在组包的时候已经有了，在接收数据的时候可以对刚接收到的数据进行校验对比。</p>
<h5 id="4-4-发送数据之后是否有反馈"><a href="#4-4-发送数据之后是否有反馈" class="headerlink" title="4.4    发送数据之后是否有反馈"></a>4.4    发送数据之后是否有反馈</h5><p>根据下面(5 软件图&amp;流程图)可以看到有些是有反馈的有些是没有反馈的。</p>
<h4 id="五、软件图-amp-流程图"><a href="#五、软件图-amp-流程图" class="headerlink" title="五、软件图&amp;流程图"></a>五、软件图&amp;流程图</h4><h5 id="5-1-Request-Response图"><a href="#5-1-Request-Response图" class="headerlink" title="5.1 Request Response图"></a>5.1 Request Response图</h5><p><img src="/2019/11/23/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-COM%E5%8F%A316%E8%BF%9B%E5%88%B6%E9%80%9A%E4%BF%A1%E8%AE%BE%E8%AE%A1/2.jpg" alt="2"></p>
<h5 id="5-1-流程图"><a href="#5-1-流程图" class="headerlink" title="5.1 流程图"></a>5.1 流程图</h5><p><img src="/2019/11/23/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-COM%E5%8F%A316%E8%BF%9B%E5%88%B6%E9%80%9A%E4%BF%A1%E8%AE%BE%E8%AE%A1/3.jpg" alt="3"></p>
<h4 id="六、完整版程序代码"><a href="#六、完整版程序代码" class="headerlink" title="六、完整版程序代码"></a>六、完整版程序代码</h4><p>配合《mcu com软件接口设计方案》,且测试验证通过，支持和MCU多次重发3次、支持多次重读20次，每次1ms,且可设置参数。<br><a href="https://github.com/faihung/test/tree/master/5-16%E8%BF%9B%E5%88%B6%E9%80%9A%E4%BF%A1" target="_blank" rel="noopener">参考代码</a></p>
]]></content>
      <categories>
        <category>工程设计</category>
      </categories>
      <tags>
        <tag>字节对齐</tag>
        <tag>大小端</tag>
        <tag>pragma pack()</tag>
        <tag>通信设计</tag>
        <tag>数据结构构造</tag>
        <tag>流程图</tag>
        <tag>解耦合</tag>
      </tags>
  </entry>
  <entry>
    <title>视音频-视音频信号种类和物理接口</title>
    <url>/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h5 id="模拟视频信号的格式"><a href="#模拟视频信号的格式" class="headerlink" title="模拟视频信号的格式"></a>模拟视频信号的格式</h5><h6 id="复合信号Composite-Video"><a href="#复合信号Composite-Video" class="headerlink" title="复合信号Composite Video"></a>复合信号Composite Video</h6><p>在一路信号中,使用不同的频率把亮度、色度、同步等所有视频信号结合在一起。只使用一个连接线传输即可。标准的PAL和NTSC信号就是复合信号。信号使用BNC或者“莲花”端子连接。</p>
<a id="more"></a>

<h6 id="分量信号Component-Video"><a href="#分量信号Component-Video" class="headerlink" title="分量信号Component Video"></a>分量信号Component Video</h6><p>使用3路信号分别传输模拟的经过Gamma校正的RGB信号,或者更常见地, YPbPr信号,就是模拟YuV信号经过某种线形变换之后的形式,通常线缆上或者接口上会标注Y,Pb,Pr或者Y、U、V或者Y,R-YB-Y等。信号使用BNC或者“莲花”端子连接。</p>
<h6 id="S-Video或YC"><a href="#S-Video或YC" class="headerlink" title="S-Video或YC"></a>S-Video或YC</h6><p>用两路信号分别传送亮度信号Y和将U、V正交调制而成的色度信号C。信号使用专门的4针mini-DIN端了连接。</p>
<h5 id="数字视频信号的格式"><a href="#数字视频信号的格式" class="headerlink" title="数字视频信号的格式"></a>数字视频信号的格式</h5><h6 id="SDI"><a href="#SDI" class="headerlink" title="SDI"></a>SDI</h6><p>Serial Digital Interface串行数字接口。SMPTE定义的专业视频数据传输接口,速率为143Mb/s或者360Mb/s通常用来传输非压缩视频数据。HD SDI标准由SMPTE 292M定义,速率为1.485 Gbitls. SMPTE 372M定义了Dual Link SDI,速率为2.970 Gbit/s,最近又定义了3G-SDI,同样速率,都是为HD电视之上的数字影院使用。SDI信号一般使用同轴电缆和BNC端子连接,传输距离设计为演播室内部使用(300米以内)。</p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/1.jpg" alt="1"></p>
<h6 id="SDTI"><a href="#SDTI" class="headerlink" title="SDTI"></a>SDTI</h6><p>Serial Data Transmission Interface串行数据传输接口。SMPTE定义的SDI的变体,用来传输任意格式的数据,而非限于非压缩视频数据。主要是压缩到视频流数据(DV, DVCPRO, BetaSX, MPEG2),由于是在SDI实时传输非压缩数据的定义的逻辑和物理结构的基础之上传输压缩数据,所以可以做到超实时(2x, 4x等)。270Mb/s速率的SDTI由SMPTE 305M定义,而1.5Gb/s的HD SDTI由SMPTE 348M定义。</p>
<h5 id="模拟音频信号"><a href="#模拟音频信号" class="headerlink" title="模拟音频信号"></a>模拟音频信号</h5><h6 id="非平衡音频连接及其弱点"><a href="#非平衡音频连接及其弱点" class="headerlink" title="非平衡音频连接及其弱点"></a>非平衡音频连接及其弱点</h6><p>音频电缆中有2根铜线,一条信号线、一条地线,即普通的一条RCA线和莲花插头。家用音响多为非平衡输入输出。非平衡连接的弱点在于噪声控制比较差,如下图噪声透过电缆保护层加入到信号中无法去除。</p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/2.jpg" alt="2"></p>
<h6 id="平衡音频"><a href="#平衡音频" class="headerlink" title="平衡音频"></a>平衡音频</h6><p>平衡音频电缆中采用3根导线, 2条传输信号, 1条是地线。源设备通过这2条信号线传输相位完全相反的信号,两条导线制作成具有相当一致的阻抗特性和缠绕方式,所以各自拾取的噪声信号也相同,接收设各收到信号后,将第2路反相回来,这样其中的噪声就变成与第1路中的噪声反相了, 2路信号相加,即除去了噪声。专业音频设备多使用平衡线路。</p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/3.jpg" alt="3"></p>
<p>平衡音频使用3针XLR接头(卡农)或1/4”TRS接头。</p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/4.jpg" alt="4"></p>
<h5 id="数字音频信号的格式"><a href="#数字音频信号的格式" class="headerlink" title="数字音频信号的格式"></a>数字音频信号的格式</h5><h6 id="SDI嵌入式音频信号"><a href="#SDI嵌入式音频信号" class="headerlink" title="SDI嵌入式音频信号"></a>SDI嵌入式音频信号</h6><p>在SDI信号中,都提供16路单声道音频信号的传输,格式均为24bit,48KHz的PCM音频。音频数据记录在水平消隐期对应的信号数据中。</p>
<h6 id="AES-EBU音频信号"><a href="#AES-EBU音频信号" class="headerlink" title="AES/EBU音频信号"></a>AES/EBU音频信号</h6><p>AES/EBU的全称是Audio Engineering Society/European Broadcast Union (音频工程师协会/欧洲广播联盟),现已成为专业数字音频较为流行的标准。大量民用产品和专业音频数字设备如CD机、DAT, MD机、数字调音台、数字音频工作站等都支持AES/EBU。</p>
<p>AES/EBU是一种通过基于单根绞合线对来传输数字音频数据的串行位传输协议。它无须均衡即可在长达100m的距离上传输数据,如果均衡,可以传输更远距离。它提供两个信道的音频数据(最高24比特量化),信道是自动计时和自同步的。它也提供了传输控制的方法和状态信息的表示(channel status bi)和一些误码的检测能力。它的时钟信息是由传输端控制,来自AES/EBU的位流。它的三个标准采样率是32kHz44.1kHz、48kHz,当然许多接口能够工作在其它不同的采样率上。</p>
<p>AES/EBU提供“专业”和“消费”两种模式。它们两者最大的不同在于信道状态位格式的提供上。专业模式的状态位格式里包括数字信道的源和目的地址、日期时间码、采样点数、字节长度和其它信息。消费模式包括的东西就比较少,但包含了拷贝保护信息。另外, AES/EBU标准提供“用户数据”,在它的位流里包含用户说明(例如厂商说明等)。</p>
<p>AES/EBU的普通物理连接媒质有: </p>
<p>(1)平衡或差分连接,使用XLR (卡依)连接器的三芯话筒屏蔽电缆参数为阻抗11032,电平范围0.2V~5Vpp,抖动为土20ns。</p>
<p>(2)单端非平衡连接,使用RCA插头的音频同轴电缆。</p>
<p>(3)光学连接,使用光纤连接器。</p>
<h5 id="同步Genlock"><a href="#同步Genlock" class="headerlink" title="同步Genlock"></a>同步Genlock</h5><p>Genlock (Generator Lock)同步锁相也是一种帧同步技术,通常用于视频后期处理、非线性编辑(NLE)和演播室。该技术可以使工作站图形系统的输出信号与外部生成的(GEN)信号进行同步(LOCK),从而确保演播室中的所有设备(摄像机、录像机、动画或字幕机等等)之间的有效协作。</p>
<p>各个设备间行、场扫描的同步信号必须一致,如果使用复合信号,则其中的色度付载波的相位也必须相同。广播系统中的同步信号通常使用同步信号发生器产生,其中包含垂直和水平同步脉冲和色度相位脉冲。这个模拟信号通常称为Black Burst (BB)黑场同步信号。</p>
<h6 id="双电平同步信号Bilevel-Sync"><a href="#双电平同步信号Bilevel-Sync" class="headerlink" title="双电平同步信号Bilevel Sync"></a>双电平同步信号Bilevel Sync</h6><p>传统的BB信号。有一个同步脉冲,从消隐电平向下到达同步峰值电平-285 5/7mV或者-300mV。双电平同步信号主要用于标清设备,也可以用于高清设备。</p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/5.jpg" alt="5"></p>
<h6 id="三电平同步信号Bi-evel-Sync"><a href="#三电平同步信号Bi-evel-Sync" class="headerlink" title="三电平同步信号Bi-evel Sync"></a>三电平同步信号Bi-evel Sync</h6><p>有2个反向的脉冲,从消隐电平向下到达同步峰值电平-300mV,再向上到达+300mV,然后回到消隐电平。三电平的主要好处是使接收端的模拟电路更容易找到同步信号,也更容易在信号送往显示电路前从中剔除同步信号,避免串扰。三电平同步信号应用于高清设备中,是SMPTE的HD标准之一(SMPTE 240)。</p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/6.jpg" alt="6"></p>
<h5 id="视音频信号端子"><a href="#视音频信号端子" class="headerlink" title="视音频信号端子"></a>视音频信号端子</h5><h6 id="BNC端子"><a href="#BNC端子" class="headerlink" title="BNC端子"></a>BNC端子</h6><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/7.jpg" alt="7"></p>
<p>Bayonet Neill-Concelman (Neill-Concelman卡销):一种同轴电缆连接头,现在由IEC-168标准定义。广泛应用于专业视频领域。在贝尔实验室工作的Paul Neill曾经开发了一种带螺纹的接头,被美国海军采用,叫做N接头,后来Carl Concelman又开发了一种接头,采用了滑入在旋转卡住的办法,称为C接头。两人合作开发了一种类似的较小的接头,成了现在的BNC。</p>
<h6 id="RCA莲花插头RCA-plug-RCA-phono-唱机-connector"><a href="#RCA莲花插头RCA-plug-RCA-phono-唱机-connector" class="headerlink" title="RCA莲花插头RCA plug, RCA phono (唱机) connector"></a>RCA莲花插头RCA plug, RCA phono (唱机) connector</h6><p>RCA是Radio Corporation of American的缩写词,因为RCA接头由这家公司发明的。RCA俗称莲花插座,几乎所有的电视机、影碟机类产品都有这个接口。它并不是专门为哪一种接口设计,既可以用在音频,又可以用在普通的视频信号,也是DVD分量(YCICb)的插座,只不过数量是三个。 RCA接头是目前为止最为常见的一种音/视频接线端子。这种双线连接方式的端子早在收音机出现的时代便由RCA录音公司发明出来,还有一个更老式、也比较奇怪的称呼叫做”唱盘”接头。</p>
<p>RCA端子采用同轴传输信号的方式,中轴用来传输信号,外沿一圈的接触层用来接地,可以用来传输数字音频信号和模拟视频信号。RCA音频端子一般成对地用不同颜色标注:右声道用红色,左声道用黑色或白色。有的时候,中置和环绕声道连接线会用其他的颜色标注来方便接线时区分,但整个系统中所有的RCA接头在电气性能上都是一样的。一般来讲, RCA立体声音频线都是左右声道为一组,每声道外观上是一根线。</p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/8.jpg" alt="8"></p>
<p>不像射频接口那样包含了音频信号,复合视频(Composite)通常采用黄色的RCA (莲花插座)接头。”复合”含义是同一信道中传输亮度和色度信号的模拟信号,但电视机如果不能很好的分离这两种信号,就会出现虚影。</p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/9.jpg" alt="9"></p>
<p>色差(Component)通常标记为YPb/Pr,用红、绿、蓝三种颜色来标注每条线缆和接口。绿色线缆(Y),传输亮度信号。蓝色和红色线缆(Pb和Pr)传输的是颜色差别信号。色差的效果要好于s端子,因此不少DVD以及高清播放设备上都采用该接口。如果使用优质的线材和接口,即使采用10米长的线缆,色差线也能传输优秀的画面。</p>
<h6 id="Mini-DIN端子"><a href="#Mini-DIN端子" class="headerlink" title="Mini-DIN端子"></a>Mini-DIN端子</h6><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/10.jpg" alt="10"></p>
<p>德国标准机构Deutsches Instiut fur Normung早期开发的一组多针的电气接口称为DIN端子,后来开发了更小的接头, 叫Mini-DIN,包括3针到9针共7个完全不同的标准。其中, 4针被S-Video信号标准采用作为专用接头; 6针则被PS/2键盘鼠标设备采用。</p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/11.jpg" alt="11"></p>
<p>s端子(S-Video)连接采用YIC (亮度/色度)分离式输出,使用四芯线传送信号,接口为四针接口。接口中,两针接地,另外两针分别传输亮度和色度信号。因为分别传送亮度和色度信号, s端子效果要好于复合视频。不过s端子的抗干扰能力较弱,所以s端子线的长度最好不要超过7米。</p>
<h6 id="射频端子"><a href="#射频端子" class="headerlink" title="射频端子"></a>射频端子</h6><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/12.jpg" alt="12"></p>
<p>天线和模拟闭路连接电视机就是采用射频(RF)接口。作为最常见的视频连接方式,它可同时传输模拟视频以及音频信号。RF接口传输的是视频和音频混合编码后的信号,显示设备的电路将混合编码信号进行一系列分离、解码在输出成像。由于需要进行视频、音频混合编码,信号会互相干扰,所以它的画质输出质量是所有接口中最差的。有线电视和卫星电视接收设备也常用RF连接,但这种情况下,它们传输的是数字信号。</p>
<h6 id="VGA端子"><a href="#VGA端子" class="headerlink" title="VGA端子"></a>VGA端子</h6><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/13.jpg" alt="13"></p>
<p>VGA (Video Graphics Array)还有一个名称叫D-Sub, VGA接口共有15针,分成3排,每排5个孔,是显卡上应用最为广泛的接口类型,绝大多数显卡都带有此种接口。它传输红、绿、蓝模拟信号以及同步信号(水平和垂直信号)。使用VGA连接设备,线缆长度最好不要超过10米,而且要注意接头是否安装牢固,否则可能引起图像中出现虚影。</p>
<h6 id="DVI端子"><a href="#DVI端子" class="headerlink" title="DVI端子"></a>DVI端子</h6><p>DVI (Digital Visual Interface)接口与VGA都是电脑中最常用的接口,与VGA不同的是, DVI可以传输数字信号,不用再进过数模转换,所以画面质量非常高。目前,很多高清电视上也提供了DVI接口。需要注意的是, DVI接口有多种规范,常见的是DVI-D (Digital)和DVI-I (Interated), DVI-D只能传输数字信号,大家可以用它来连接显卡和平板电视。DVI-I则在DVI-D可以和VGA相互转换。</p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/14.jpg" alt="14"></p>
<h6 id="HDMI"><a href="#HDMI" class="headerlink" title="HDMI"></a>HDMI</h6><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/15.jpg" alt="15"></p>
<p>HDMI (High Definition Multimedia Interface)按口是最近才出现的接口,它同DVI一样是传输全数字信号的。不同的是HDMI接口不仅能传输高清数字视频信号,还可以同时传输高质量的音频信号。同时功能跟射频接口相同,不过由于采用了全数字化的信号传输,不会像射频接口那样出现画质不佳的情况。对于没有HDMI接口的用户,可以用适配器将HDMI接口转换位DVI接口,但是这样就失去了音频信号。高质量的HDMI线材,即使长达20米,也能保证优质的画质。</p>
<h6 id="IEEE-1394"><a href="#IEEE-1394" class="headerlink" title="IEEE 1394"></a>IEEE 1394</h6><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/16.jpg" alt="16"></p>
<p>IEEE 1394也称为火线或ilLink,它能够传输数字视频和音频及机器控制信号,具有较高的带宽,且十分稳定。通常它主要用来连接数码摄像机、DVD录像机等设备。IEEE 1394接口有两种类型: 6针的六角形接口和4针的小型四角形接口。6针的六角形接口可向所连接的设备供电,而4针的四角形接口则不能。</p>
]]></content>
      <categories>
        <category>视音频</category>
      </categories>
      <tags>
        <tag>端子</tag>
      </tags>
  </entry>
  <entry>
    <title>视音频-色彩空间介绍(Video Demystified Chapter 3)</title>
    <url>/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%BB%8B%E7%BB%8D-Video-Demystified-Chapter-3/</url>
    <content><![CDATA[<p>色彩空间是表示一组颜色的数学模型。</p>
<p>最常用的3种色彩空间是:</p>
<p>RGB-应用于计算机图形</p>
<p>YIQ, YUv,或者YCbCr-视频领域使用</p>
<p>CMYK-印刷领域</p>
<p>但这些都不直接对应直观的色调(Hue)、饱和度(Saturation)和亮度(Brightess)的说法,所以还有HSI和HSV的模型。</p>
<a id="more"></a>
<h4 id="RGB色彩空间"><a href="#RGB色彩空间" class="headerlink" title="RGB色彩空间"></a>RGB色彩空间</h4><p>红绿蓝三基色相加产生其它颜色,使用三维笛卡尔(Cartesian)坐标系表示:</p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%BB%8B%E7%BB%8D-Video-Demystified-Chapter-3/1.jpg" alt="1"></p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%BB%8B%E7%BB%8D-Video-Demystified-Chapter-3/2.jpg" alt="2"></p>
<p>彩色显示器都使用红绿蓝三基色相加产生其它颜色,所以RGB空间使用非常普遍。但RGB模型没有区分亮度和色度信息,造成处理不便和数字处理数据量比较大的问题。</p>
<h4 id="YUV色彩空间"><a href="#YUV色彩空间" class="headerlink" title="YUV色彩空间"></a>YUV色彩空间</h4><p>YUV模型被PAL和NTSC电视系统所采用。黑白电视系统只使用Y亮度信息,彩色电视在加入UV信息。</p>
<pre><code>Y=0.299R + 0.587G +0.114B
U=-0.147R-0.289G + 0.436B= 0.492 (B-Y)
V=0.615R-0.515G-0.100B = 0.877(R-Y)

R=Y+1.140V
G=Y-0.395U-0.581V
B=Y+ 2.032U

RGB: 0-255,
Y: 0-255,
U: 0-+-112
V: 0-+-157.</code></pre><p>通常都会转换到0-255的范围之内。</p>
<h4 id="YIQ色彩空间"><a href="#YIQ色彩空间" class="headerlink" title="YIQ色彩空间"></a>YIQ色彩空间</h4><p>在NTSC复合信号中有应用。I是in-phase (同相位), Q是quadrature (正交),是调制信号的方法。</p>
<pre><code>Y=0.299R + 0.587G + 0.114B
I=0.596R-0.275G-0.321B= Vcos 33&apos;-Usin 33&apos;= 0.736(R-Y)-0.268(B-Y)
Q=0.212R-0.523G + 0.311B= Vsin 33&apos;+ Ucos 33&apos;= 0.478(R-Y) + 0.413(B-Y)(VQ就是把U/V相位旋转了33度)


R=Y+0.9561 + 0.6210
G=Y-0.2721-0.6470
B=Y-1.1071 + 1.704Q

RGB: 0-255,
Y: 0-255,
I: 0-+-152,
Q: 0-+/134</code></pre><h4 id="YCbCr色彩空间-有时也被称为VUV空间"><a href="#YCbCr色彩空间-有时也被称为VUV空间" class="headerlink" title="YCbCr色彩空间(有时也被称为VUV空间)"></a>YCbCr色彩空间(有时也被称为VUV空间)</h4><p>这是世界通用的分量信号的色彩空间(ITU.601/709标准),实际上是一个经过缩放和位移的YUV空间。其中Y的归一化范围是16-235, CbCr是16-240。</p>
<h5 id="标清转换公式"><a href="#标清转换公式" class="headerlink" title="标清转换公式:"></a>标清转换公式:</h5><h6 id="视频RGB-16-235-和YCbCr"><a href="#视频RGB-16-235-和YCbCr" class="headerlink" title="视频RGB (16-235)和YCbCr:"></a>视频RGB (16-235)和YCbCr:</h6><pre><code>Y601 = 0.299R + 0.587G + 0.114B
Cb=-0.172R 0.339G +0.511B + 128
Cr=0.511R - 0.428G - 0.083B + 128

R=Y601 + 1.371(Cr-128)
G=Y601 -0.698(Cr- 128) -0.336(Cb- 128)
B=Y601 + 1.732(Cb- 128)</code></pre><h6 id="计算机RGB-0-255-和YCbCr"><a href="#计算机RGB-0-255-和YCbCr" class="headerlink" title="计算机RGB (0-255)和YCbCr:"></a>计算机RGB (0-255)和YCbCr:</h6><pre><code>Y601 = 0.257R + 0.504G +0.098B + 16
Сb = -0.148R -0.291G + 0.439B + 128
Cr = 0.439R -0.368G - 0.071B + 128

R = 1.164(Y601- 16) + 1.596(Cr-128)
G = 1.164(Y601- 16)-0.813(Cr-128)- 0.391(Cb- 128)
В = 1.164(Y601 - 16) + 2.018(Сb - 128)</code></pre><h5 id="高清转换公式"><a href="#高清转换公式" class="headerlink" title="高清转换公式:"></a>高清转换公式:</h5><h6 id="视频RGB-16-235-和YCbCr-1"><a href="#视频RGB-16-235-和YCbCr-1" class="headerlink" title="视频RGB (16-235)和YCbCr:"></a>视频RGB (16-235)和YCbCr:</h6><pre><code>Y709 =0.213R + 0.715G + 0.072B
Cb= -0.117R -0.394G + 0.511B+ 128
Cr=0.511R - 0.464G-0.047B + 128

R=Y709 + 1.540(Cr-128)
G=Y709 -0.459(Cr -128)-0.183(Cb - 128)
B=Y709 + 1.816(Cb-128</code></pre><h6 id="计算机RGB-0-255-和YCbCr-1"><a href="#计算机RGB-0-255-和YCbCr-1" class="headerlink" title="计算机RGB (0-255)和YCbCr:"></a>计算机RGB (0-255)和YCbCr:</h6><pre><code>Y709 = 0.183R + 0.614G + 0.062B+ 16
Cb= -0.101R-0.338G + 0.439B + 128
Cr = 0.439R - 0.399G - 0.040B + 128

R=1.164(Y709-16) + 1.793(Cr- 128)
G= 1.164(Y709- 16) -0.534(Cr -128) -0.213(Cb - 128)
B= 1.164(709- 16) + 2.115(Cb- 128)</code></pre><h6 id="YCbCr转换成RGB会产生非法值"><a href="#YCbCr转换成RGB会产生非法值" class="headerlink" title="YCbCr转换成RGB会产生非法值"></a>YCbCr转换成RGB会产生非法值</h6><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%BB%8B%E7%BB%8D-Video-Demystified-Chapter-3/3.jpg" alt="3"></p>
<h5 id="YCbCr的格式"><a href="#YCbCr的格式" class="headerlink" title="YCbCr的格式:"></a>YCbCr的格式:</h5><p>4:4-每个像素有Y, Cb, Cr三个分量。</p>
<p>4:2:2-水平方向上,每2个像素有2个Y,和1个Cb,1个Cr分量。</p>
<p>4:1:1-水平方向上,每4个像素有4个Y,和1个Cb, 1个Cr分量。</p>
<p>4:2:0-每个2x2像素块,有4个Y,和1个Cb, 1个Cr分量。有3种变体。</p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%BB%8B%E7%BB%8D-Video-Demystified-Chapter-3/4.jpg" alt="4"></p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%BB%8B%E7%BB%8D-Video-Demystified-Chapter-3/5.jpg" alt="5"></p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%BB%8B%E7%BB%8D-Video-Demystified-Chapter-3/6.jpg" alt="6"></p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%BB%8B%E7%BB%8D-Video-Demystified-Chapter-3/7.jpg" alt="7"></p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%BB%8B%E7%BB%8D-Video-Demystified-Chapter-3/8.jpg" alt="8"></p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%BB%8B%E7%BB%8D-Video-Demystified-Chapter-3/9.jpg" alt="9"></p>
<h4 id="HSI-HLS和HSV色彩空间"><a href="#HSI-HLS和HSV色彩空间" class="headerlink" title="HSI, HLS和HSV色彩空间"></a>HSI, HLS和HSV色彩空间</h4><p>H-hue色度, S-saturation饱和度, I-intensity, L-lightness, V-value都指亮度。</p>
<p>一些系统用来提供直观的色彩表达方式。</p>
<p>HSI和HLS等同, HSV与之的不同点在于从RGB计算亮度值的公式不同,同时影响到饱和度值的计算。HSI的1值等量依赖于RGB值,适合用来进行亮度处理;HSV的饱和度动态空间比较大,适合用来调整饱和度和色度。</p>
<h5 id="色品图chromaticity-diagram"><a href="#色品图chromaticity-diagram" class="headerlink" title="色品图chromaticity diagram"></a>色品图chromaticity diagram</h5><p>1931年CIE组织(International Commission on Ilumination or Commission Internationale de I’ Eclairage)绘制了色品图,把所有的RGB表示的颜色放置在一个图形中。</p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%BB%8B%E7%BB%8D-Video-Demystified-Chapter-3/10.jpg" alt="10"></p>
<p>坐标计算公式: x=R/(R+G+B), y=G/(R+G+B), z=B/(R+G+B)由于x+y+z总是1,所以一个颜色值可以用x.y在二维平面图上唯一代表。</p>
<p>沿形状的曲线外沿一周是红绿蓝三基色(波长从700nm到400nm),以及各种最饱和颜色,下方直线是紫色线。形状内部越接近中心饱和度越小,直至白色。形状外不是颜色区,图中没有黑色。</p>
<p>注意各种电视制式都不能产生所有RGB可以表示的颜色,只能覆盖一定的区域。</p>
<h5 id="Gamma校正"><a href="#Gamma校正" class="headerlink" title="Gamma校正"></a>Gamma校正</h5><p>在电视和图形监视器中,显像管发生的电子束及其生成的图像亮度并不是随显像管的输入电压线性变化,输入电压与对应亮度的转换关系曲线,称为伽玛曲线(Gamma Curve),以传统CRT (Cathode Ray Tube)屏幕的特性而言,该曲线通常是一个乘幂函数, Y-(Xte)y,其中, Y为亮度、X为输出电压、e为补偿系数、乘幂值(y)为伽玛值,改变乘幂值(y)的大小,就能改变CRT的伽玛曲线。</p>
<p>电子流与输入电压相比是按照指数曲线变化的,输入电压的指数要大于电子束的指数。</p>
<p>这说明暗区的信号要比实际情况更暗,而亮区要比实际情况更高。所以,要重现摄像机拍摄的画面,电视和监视器必须进行伽玛补偿。这种伽玛校正也可以由摄像机完成。</p>
<p>我们对整个电视系统进行伽玛补偿的目的,是使摄像机根据入射光亮度与显像管的亮度对称而产生的输出信号,所以应对图像信号引入一个相反的非线性失真,即与电视系统的伽玛曲线对应的摄像机伽玛曲线,它的值应为1/y,我们称为摄像机的伽玛值。</p>
<p>电视系统的伽玛值约为2.2,所以电视系统的摄像机非线性补偿伽玛值为0.45,彩色显像管的伽玛值为2.8,它的图像信号校正指数应为1/2.8-0.35,但由于显像管内外杂散光的影响,重现图像的对比度和饱和度均有所降低,所以现在的彩色摄像机的伽玛值仍多采用0.45。在实际应用中,我们可以根据实际情况在一定范围内调整伽玛值,以获得最佳效果。</p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%BB%8B%E7%BB%8D-Video-Demystified-Chapter-3/11.jpg" alt="11"></p>
<h5 id="模拟信号幅度的表示单位"><a href="#模拟信号幅度的表示单位" class="headerlink" title="模拟信号幅度的表示单位"></a>模拟信号幅度的表示单位</h5><p>这里的YUV模拟信号是针对ITU.601规定的SD的PAL和NTSC来说的。对于HD,由于根本没有这样的模拟YUV信号传送(见Digital Video and HDTV 335页,即使SD的分量信号实际上也不用模拟YUV),也就不存在一个HD YCbCr信号到YUV的转换公式。</p>
<p>对于PAL制,画面信号的亮度范围ITU.601规定为0到700mV,即归一化的Y的0到1线性对应于0到700mV; UV和Y的单位一致,也就是色度幅度信号sqrt(U的2次幂+ V的2次幂)的0到1线性对应于0到700mV,显示时再乘以2。</p>
<p>0叫做Blanking Level (等同于Black Level), 100叫做White Level。</p>
<p>PAL制我们也可以采用计算机化的0-100%来显示,有利于表示100%, 75%彩条的标准位置。</p>
<p>顺便指出, HD系统的信号范围和PAL制相同;尽管示波器显示对于HD的YCbCr转换后的显示无意义。</p>
<p>NTSC的情况如下:</p>
<p>总的画面信号亮度范围是0到714-2/7mV,或者用IRE位表示, 0到100 IRE,所以每个IRE单位约为71.4mV. IRE是Institute of Radio Engineers,是IEEE (美国电气电子工程师协会)的前身。</p>
<p>在日本N制中, Y的0到1被线性映射到上述整个物理范围。</p>
<p>在美国N制中, Y的0到1被线性映射到7.5-100 IRE之间,或者5344/7 mV到714+2/7mV之间。色度幅度信号sqrt(U的2次幂 + V的2次幂)的0到1映射范围相同,注意美国N制时映射到0到92.5 IRE。</p>
<p>这里0叫做Blanking Level, 100叫做White Level,在日本N制中Black Level等同于Blanking Level;美国N制的Black Level则是7.5 IRE,被称为黑电平提升(setup, lif, pedestal [pedistl]文架等等);日本N制,PAL制, HD被对应地称为”0 Setup”。</p>
<p>N制我们也可以采用计算机化的0-100%来显示,在日本N制中等同于IRE表示,但在美国N制中0到100%映射在7.5到100 IRE的区域内,因此不同于IRE显示。</p>
<p>有的文档(包括Video Denystified)中,对PAL信号也用IRE表示。Video Demystified 710页把IRE定义成把Blanking Level到White Level之间等分为100份的单位,而不是只限于N制的相当于71.4mV的单位。除了美国N制外,其它制式Black Level等同于Blanking Level,所以这些制式中IRE等同于百分比,在PAL制和HD中相当于70mv。</p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%BB%8B%E7%BB%8D-Video-Demystified-Chapter-3/12.jpg" alt="12"></p>
]]></content>
      <categories>
        <category>视音频</category>
      </categories>
      <tags>
        <tag>色彩空间</tag>
      </tags>
  </entry>
  <entry>
    <title>视音频-电视制式的基本概念</title>
    <url>/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E7%94%B5%E8%A7%86%E5%88%B6%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h5 id="标清电视制式-Standard-Definition-SD"><a href="#标清电视制式-Standard-Definition-SD" class="headerlink" title="标清电视制式(Standard Definition-SD)"></a>标清电视制式(Standard Definition-SD)</h5><h6 id="NTSC"><a href="#NTSC" class="headerlink" title="NTSC"></a>NTSC</h6><p>标准编号: SMPTE 125M/267M</p>
<p>分辨率: 720 x486 (DVMPEG2等编解码系统使用480以适应8x8的block)长宽比: 4:3 (非方形像素,像素宽小于高)</p>
<p>扫描方式:隔行扫描、下方一场首先显示</p>
<p>帧率: 29.97帧/秒</p>
<a id="more"></a>

<h6 id="PAL"><a href="#PAL" class="headerlink" title="PAL"></a>PAL</h6><p>标准编号: ITU.BT656/601.5</p>
<p>分辨率: 720 x 576</p>
<p>长宽比: 4:3 (非方形像素,像素宽大于高)</p>
<p>扫描方式:隔行扫描、上方一场首先显示</p>
<p>帧率: 25帧/秒</p>
<h5 id="高清电视制式-High-Definition-SD"><a href="#高清电视制式-High-Definition-SD" class="headerlink" title="高清电视制式(High Definition-SD)"></a>高清电视制式(High Definition-SD)</h5><h6 id="720p"><a href="#720p" class="headerlink" title="720p"></a>720p</h6><p>标准编号: SMPTE 296M-2001</p>
<p>辨率: 1280 x 720</p>
<p>长宽比: 16:9 (方形像素)</p>
<p>扫描方式:逐行扫描</p>
<p>帧率: 50帧/秒、59.94帧/秒、60帧/秒</p>
<h6 id="1080i"><a href="#1080i" class="headerlink" title="1080i"></a>1080i</h6><p>标准编号: SMPTE 274M</p>
<p>辨率： 1920 x 1080</p>
<p>长宽比: 16:9 (方形像素)</p>
<p>扫描方式:隔行扫描、上方一场首先显示</p>
<p>帧率: 25帧/秒、29.97帧/秒、30帧/秒</p>
<h6 id="1080p"><a href="#1080p" class="headerlink" title="1080p"></a>1080p</h6><p>标准编号: SMPTE 274M</p>
<p>分辨率: 1920 x 1080</p>
<p>长宽比: 16:9 (方形像素)</p>
<p>扫描方式:逐行扫描</p>
<p>帧率: <del>23.98帧/秒、24帧/秒、25帧/秒、29.97帧/秒、30帧/秒</del> 59.94帧/秒 60帧/秒</p>
<h5 id="标准机构"><a href="#标准机构" class="headerlink" title="标准机构"></a>标准机构</h5><h6 id="SMIPTE"><a href="#SMIPTE" class="headerlink" title="SMIPTE"></a>SMIPTE</h6><p>美国电影和电视工程师协会The Society of Motion Picture and Television Engineers,成立于1916年,现在有来自世界85个国家超过7500名的会员,制定电影电视行业的技术标准。</p>
<h6 id="ITU"><a href="#ITU" class="headerlink" title="ITU"></a>ITU</h6><p>国际电信联盟(International Telecommunication Union), ITU的历史可以追溯到1865年成立的国际电报联盟(International Telegraph Union , ITU),经联合国同意,1947年10月15日国际电信联盟成为联合国的一个专门机构,其总部由瑞士伯尔尼迁至到日内瓦。</p>
<h5 id="关于PAL和NTSC"><a href="#关于PAL和NTSC" class="headerlink" title="关于PAL和NTSC"></a>关于PAL和NTSC</h5><p>NTSC是National Television System Commite的缩写, (美国)国家电视标准委员会。其标准主要应用于日本、美国,加拿大、墨西哥等等, </p>
<p>PAL是Phase Alternating Line (逐行倒相)的缩写。它是西德在1962年指定的彩色电视广播标准,它采用逐行倒相正交平衡调幅的技术方法,克服了NTSC制相位敏感造成色彩失真的缺点。西德、英国等一些西欧国家,新加坡、中国大陆及香港,澳大利亚、新西兰等国家采用这种制式。</p>
<p>PAL由德国人Walter Bruch在1967年提出,当时他是为德律风根(Telefunken)工作。”PAL”有时亦被用来指625线,每秒25格,隔行扫描,PAL色彩编码的电视制式。</p>
<p>PAL制式中根据不同的参数细节又可以进一步划分为G、1、D等制式,其中PAL-D制是我国大陆采用的制式。这两种制式是不能互相兼容的,如果在PAL制式的电视上播放NTSC的影像,画面将变成黑白, NTSC制式的也是一样。</p>
<h5 id="分辨率-Resolution-、画面宽高比-Aspect-Ratio-和像素宽高比-Pixel-Aspect-Ratio"><a href="#分辨率-Resolution-、画面宽高比-Aspect-Ratio-和像素宽高比-Pixel-Aspect-Ratio" class="headerlink" title="分辨率(Resolution)、画面宽高比(Aspect Ratio)和像素宽高比(Pixel Aspect Ratio)"></a>分辨率(Resolution)、画面宽高比(Aspect Ratio)和像素宽高比(Pixel Aspect Ratio)</h5><p>分辨率就是构成画面的像素的个数,对于程序员来说,最重要的是1/0设备中的FrameBuffer的分辨率。对于电视信号来说,指信号中含有的可见画面的分辨率。</p>
<p>宽高比是指画面物理显示尺寸的宽度比其高度:</p>
<p>SDTV (1.33: 1)  </p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E7%94%B5%E8%A7%86%E5%88%B6%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/1.jpg" alt="1"></p>
<p>宽屏SDTV, HDTV (1.78:1)</p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E7%94%B5%E8%A7%86%E5%88%B6%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2.jpg" alt="2"></p>
<p>35毫米胶片(1.5:1) </p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E7%94%B5%E8%A7%86%E5%88%B6%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/3.jpg" alt="3"></p>
<p>美国电影(或欧洲1.66:1) </p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E7%94%B5%E8%A7%86%E5%88%B6%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/4.jpg" alt="4"></p>
<p>全景宽银幕电影(或70mm胶片2.20:1)</p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E7%94%B5%E8%A7%86%E5%88%B6%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/5.jpg" alt="5"></p>
<p>由画面的分辨率和宽高比可以计算出<strong>像素宽高比(Pixel Aspect Ratio)</strong>:</p>
<pre><code>(ResX * PixW) / (ResY * PixH) =AR即PixAR = PixW/ PixH=AR * ResY / Resx</code></pre><p>PAL制和NTSC制的电视在显示时,每个像素覆盖的面积不是正方形的</p>
<p>PAL制,</p>
<pre><code>PixAR= (4/3) * (576/720) = 1.07;</code></pre><p>NTSC制, </p>
<pre><code>PixAR= (4/3) * (486/720) =0.9</code></pre><p>而HDTV标准都是像素横纵方向的数量比值等同于画面宽高比,像素宽高比都是1:1,就是方形像素。</p>
<p>我们产生计算机图形时,很多都是按照方形像素的假设来做的,但如果像素宽高比不是1:1,那么这样产生的图形显示时就会变形了,所以很多图形软件都考虑了各种像素宽高比的影响,输出时进行校正保证画面在那种像素宽高比的显示设备上输出时不变形。下图示意,一个半径为某一固定像素值的圆形在计算机屏幕(通常方形像素)和PAL及NTSC显示器上显示的结果。</p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E7%94%B5%E8%A7%86%E5%88%B6%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/6.jpg" alt="6"></p>
<p>某种画面宽高比的画面在不同宽高比的显示设备上保持其比例进行显示时需要进行一些转换,下面是一些常用方法。</p>
<p>LetterBox (信箱)-较宽画面显示在较窄监视器上,上下留空。</p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E7%94%B5%E8%A7%86%E5%88%B6%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/7.jpg" alt="7">2.35:1画面显示在4:3电视上。</p>
<p>PilarBox (邮简)-较窄画面显示在较宽监视器上,两侧留空。</p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E7%94%B5%E8%A7%86%E5%88%B6%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/8.jpg" alt="8">4:3画面显示在16:9电视上。</p>
<p>WindowBox (窗口)-画面经过LetterBox和PillarBox两道处理显示出来,四边留空。比如用HD拍的广告在SD广播中做了LetterBox,但观众用HD电视收看这个SD画面,又做了PillarBox。</p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E7%94%B5%E8%A7%86%E5%88%B6%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/9.jpg" alt="9"></p>
<p>Pan and Scan (摇动和扫描)-把电影转成电视画面常用的技术之一。编辑人员使用扫描器以4:3或者16:9点取景框在较宽的电影画面中选取一部分画面,通常集中在主要的人物活动上,制作成宽高比较窄的画面。</p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E7%94%B5%E8%A7%86%E5%88%B6%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/10.jpg" alt="10"></p>
<h5 id="扫描方式-Scan-Mode"><a href="#扫描方式-Scan-Mode" class="headerlink" title="扫描方式(Scan Mode)"></a>扫描方式(Scan Mode)</h5><p>通常显示器分隔行扫描(Interlace)和逐行扫描(Progressive)两种扫描方式。隔行扫描指显示屏在显示幅图像时,先扫描奇数行,全部完成奇数行扫描后再扫描偶数行,因此每幅图像需扫描两次才能完成,造成图像显示画面闪烁较大。因此该种扫描方式较为落后,通常用在早期的显示产品中。</p>
<p>隔行扫描就是每一帧(frame)被分割为两场(field) ,每一场包含了一帧中所有的奇数扫描行或者偶数扫描行,通常是先扫描奇数行得到第一场,然后扫描偶数行得到第一场。由于视觉暂留效应,人眼将会看到平滑的运动而不是闪动的半帧半帧的图像。但是这时会有几乎不会被注意到的闪烁出现,使得人眼容易疲劳。当屏幕的内容是横条纹时,这种闪烁特别容易被注意到。</p>
<p>每一帧图像由电子束顺序地一行接着一行连续扫描而成,这种扫描方式称为逐行扫描。把每一帧图像通过两场扫描完成则1隔行扫描,两场扫描中,第一场(奇数场)只扫描奇数行,依次扫描1、3、5..行,而第二场(偶数场)只扫描偶数行,依次扫描2、4、6..行。隔行扫描技术在传送信号带宽不够的情况下起了很大作用,逐行扫描和隔行扫描的显示效果主要区别在稳定性上面,隔行扫描的行间闪烁比较明显,逐行扫描克服了隔行扫描的缺点,画面平滑自然无闪烁。在电视的标准显示模式中, i表示隔行扫描, p表示逐行扫描。</p>
<p>场的命名,以时间顺序(temporal order)成为第一场和第二场(First Field and Second Field),以空间顺序(spatial order)分为上面一场和下面一场(Top Field and Bottom rield, Upper Field and Lower Field),还有一个含义不清的说法-奇数场和偶数场(Odd Field and Even Field) 。注意NTSC制中,是lower-field-first的扫描方式,其它均为upper-field-firsto。</p>
<p>回扫(Retracing)指CRT显示电视画面时,其电子枪的扫描束在结束一行或一帧/场画面扫描时移动到下一行(行逆程)或下一帧/场的第一行开始(场逆程)时需要进行的扫描移动,这个期间,电子束实际是被关闭的,所以也叫空白区间(Blanking Interval)。从一行的结尾到下一行开始的回扫叫水平回扫,约占每行的15%时间,从一帧/场到下一帧/场的回扫称为垂直回扫(VBI),约占一帧/场的8%时间。PAL的总扫描线数是625行, NTSC是525行, 1080i和1080p都是1125行, 720p是750行。在模拟电视信号中,行场的同步信息是加在回扫区间的信号中的,还可以夹带VITC (Vertical Interval Time Code), VIrS (VerticalInterval Test Signal)和闭路字幕(Closed Caption)。</p>
<p>隔行扫描产生的抖动,对于图文字幕尤其明显,需要专门的防抖动技术予以消除,通常采用三行平均的算法。另外,在图文字幕的动画关键帧插值中,由于一帧中两场的显示时间有前后,所以参数插值必须按照场时间进行。</p>
<p>另外,还有一种Progressive Segmented Frame (PSF)扫描方式,还是将一帧分为上下隔行的两场记录和发送,但播放时是按照一帧逐行在同一时刻显示。发明者们说是要以传统隔行设备记录和传送逐行画面。</p>
<h5 id="帧率-Frame-Rate"><a href="#帧率-Frame-Rate" class="headerlink" title="帧率(Frame Rate)"></a>帧率(Frame Rate)</h5><p>为什么NTSC制是29.97? 3000/1001 NTSC制早期发展时需要兼容当时的黑白电视,包括水平扫描、颜色和声音的传送,这些限制最后使用减小场扫描频率(60Hz)来解决,最后减小了1000/10010。</p>
<h6 id="时码"><a href="#时码" class="headerlink" title="时码"></a>时码</h6><p>LTC (longitudinallinear timecode)线性时码-时码记录在磁带的专门轨道中,与音频轨道类似,信号输入也使用XLR接口。</p>
<p>VITC (vertical interval timecode)时码-在场逆程中含有时码信息。克服了LTC的缺点-在磁带停止或者慢速播放时不能读取。</p>
<p>DFTC (Drop frame timecode)-在NTSC制中,如果时码按照每帧累加,并按照30帧/秒的速率来显示的话,显示的时间就比实际慢,每秒差1000/1001,每小时累计达到3.6秒。所以DFTC就是大约数每100帧扔掉一个时码计数,让计算的时码与实际时间相符。实际计算时以每10分钟为一周期,在其中的1:06:202:13:10. 3:20:00, 4:26:20, 5:33:10、 6:40:00, 7:46:20, 8:53:10时丢掉一帧的计数。</p>
<h6 id="电影到电视影像的转换-Telecine-中的帧率转换"><a href="#电影到电视影像的转换-Telecine-中的帧率转换" class="headerlink" title="电影到电视影像的转换(Telecine)中的帧率转换"></a>电影到电视影像的转换(Telecine)中的帧率转换</h6><p>电影(24帧/秒)和PAL (25帧/秒-包括HD)每秒只差1帧,所以以前一般来说就直接一帧对一帧进行制作,这样PAL每秒会比电影多放一帧,也就是速度提高了124,而且声音的音调会升高。这就是一些DVD爱好者不喜欢PAL制DVD的原因之一。但是据说现在有些PAL制DVD采取了24+1的制作方法,就是把24帧中的一帧重复一次,从而获得跟电影一样的播放速度。</p>
<p>而NTSC (29.97帧/秒-包括HD)因为每秒约有30帧,不能直接一帧对一帧制作,所以要通过2-3PULLDOWN等办法把24个电影帧转成30个视频帧,这30个视频帧里所包含的内容和24个电影帧是相等的,所以NTSC的播放速度和电影一样。</p>
<p>2-3 PULLDOWN的具体解释:电影胶片以4帧为一个循环, A帧转换为视频第1帧的两场, B帧转换为视频第2帧的两场和第3帧的第一场, C帧转换为视频第3帧的第二场和第4帧的第一场, D帧转换为视频第4帧的第二场和第5帧的两场,这样以2:3:2:3的循序,通过把B和D帧重复采样一场,将4个电影帧转换为5个视频帧,视频以30帧/秒播放画面动感速度和24帧/秒播放的电影一样;实际上上由于是29.97帧秒(3000/1001),动感速度还是较电影慢了1/1000,以电影帧计算是23.98帧/秒(24/1001 )。</p>
<p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E7%94%B5%E8%A7%86%E5%88%B6%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/11.jpg" alt="11"></p>
<p>如果把上述循环从电影B帧开始看,模式变成了3:2:3:2,所以也叫3-2 PULLDOWN,但SMPTE标准(RP197)规定的是2:3模式。另外还有3:3:2:2, 2:3:32, 2:2:3:3等模式,但产生的颤抖略大。</p>
]]></content>
      <categories>
        <category>视音频</category>
      </categories>
      <tags>
        <tag>标清高清</tag>
        <tag>NTSC</tag>
        <tag>PAL</tag>
        <tag>帧率</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言-数组强制转换成结构体类型存储(2)</title>
    <url>/2019/11/16/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8-2/</url>
    <content><![CDATA[<p>废话不多说，直接上代码</p>
<a id="more"></a>

<h5 id="1-没有-pragma-pack-1"><a href="#1-没有-pragma-pack-1" class="headerlink" title="1. 没有#pragma   pack(1)"></a>1. 没有#pragma   pack(1)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;      /*标准输入输出定义*/</span><br><span class="line">#include &lt;stdlib.h&gt;     /*标准函数库定义*/</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;      /*文件控制定义*/</span><br><span class="line">#include &lt;termios.h&gt;    /*PPSIX 终端控制定义*/</span><br><span class="line">#include &lt;unistd.h&gt;     /*Unix 标准函数定义*/</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line"></span><br><span class="line">#define UI_PARAM_FILE &quot;/mnt/hgfs/VMWARE/test/config/2.txt&quot;</span><br><span class="line"></span><br><span class="line">unsigned char appWritePara(unsigned char* Para, unsigned int paraSize, char *fileName)</span><br><span class="line">&#123;</span><br><span class="line">	int fd = 0;</span><br><span class="line"></span><br><span class="line">	fd = open(fileName,O_RDWR, 0644); //O_SYNC O_DIRECT</span><br><span class="line">	if (-1 == fd)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;open file:%s\n&quot;, fileName);</span><br><span class="line">		close(fd);</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;Open %s success\n&quot;, fileName);</span><br><span class="line">	write(fd,Para,paraSize);</span><br><span class="line">	printf(&quot;-----------write----------\n&quot;);</span><br><span class="line">	close(fd);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char ch[12] = &#123;&#125;;</span><br><span class="line">typedef struct arr_s</span><br><span class="line">&#123;</span><br><span class="line">	char i;</span><br><span class="line">	short j;</span><br><span class="line">	char l;</span><br><span class="line"></span><br><span class="line">&#125;arr_t;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	char * filename = UI_PARAM_FILE;</span><br><span class="line">	arr_t* p = (arr_t*)ch;</span><br><span class="line">	p-&gt;i = 0x30;</span><br><span class="line">	p-&gt;j = 0x3132;</span><br><span class="line">	p-&gt;l = 0x33;</span><br><span class="line">	printf(&quot;%X, %X, %X\n&quot;,p-&gt;i,p-&gt;j,p-&gt;l);	</span><br><span class="line">	</span><br><span class="line">	appWritePara(ch,sizeof(ch),filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果演示：</p>
<p><img src="/2019/11/16/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8-2/1.jpg" alt="1"></p>
<p><img src="/2019/11/16/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8-2/2.jpg" alt="2"></p>
<p>可以看到文本文件中保持12个字节大小的数据。其中i类型之后是填空补充的。<br>这说明数据是4个字节数据，结构体是6个字节数据。</p>
<h5 id="2-有-pragma-pack-1"><a href="#2-有-pragma-pack-1" class="headerlink" title="2. 有#pragma   pack(1)"></a>2. 有#pragma   pack(1)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;      /*标准输入输出定义*/</span><br><span class="line">#include &lt;stdlib.h&gt;     /*标准函数库定义*/</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;      /*文件控制定义*/</span><br><span class="line">#include &lt;termios.h&gt;    /*PPSIX 终端控制定义*/</span><br><span class="line">#include &lt;unistd.h&gt;     /*Unix 标准函数定义*/</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line"></span><br><span class="line">#define UI_PARAM_FILE &quot;/mnt/hgfs/VMWARE/test/config/2.txt&quot;</span><br><span class="line"></span><br><span class="line">unsigned char appWritePara(unsigned char* Para, unsigned int paraSize, char *fileName)</span><br><span class="line">&#123;</span><br><span class="line">	int fd = 0;</span><br><span class="line"></span><br><span class="line">	fd = open(fileName,O_RDWR, 0644); //O_SYNC O_DIRECT</span><br><span class="line">	if (-1 == fd)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;open file:%s\n&quot;, fileName);</span><br><span class="line">		close(fd);</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;Open %s success\n&quot;, fileName);</span><br><span class="line">	write(fd,Para,paraSize);</span><br><span class="line">	printf(&quot;-----------write----------\n&quot;);</span><br><span class="line">	close(fd);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char ch[12] = &#123;&#125;;</span><br><span class="line">#pragma   pack(1) //强制连续存放,对齐边界为 1</span><br><span class="line">typedef struct arr_s</span><br><span class="line">&#123;</span><br><span class="line">	char i;</span><br><span class="line">	short j;</span><br><span class="line">	char l;</span><br><span class="line"></span><br><span class="line">&#125;arr_t;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	char * filename = UI_PARAM_FILE;</span><br><span class="line">	arr_t* p = (arr_t*)ch;</span><br><span class="line">	p-&gt;i = 0x30;</span><br><span class="line">	p-&gt;j = 0x3132;</span><br><span class="line">	p-&gt;l = 0x33;</span><br><span class="line">	printf(&quot;%X, %X, %X\n&quot;,p-&gt;i,p-&gt;j,p-&gt;l);	</span><br><span class="line">	</span><br><span class="line">	appWritePara(ch,sizeof(ch),filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果演示:</p>
<p><img src="/2019/11/16/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8-2/3.jpg" alt="3"></p>
<p><img src="/2019/11/16/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8-2/4.jpg" alt="4"></p>
<p>这说明数据是4个字节数据，结构体是4个字节数据。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>结构体</tag>
        <tag>强制转换</tag>
        <tag>字节对齐</tag>
        <tag>大小端</tag>
        <tag>pragma pack()</tag>
        <tag>配置文件</tag>
        <tag>文本保存</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言-数组强制转换成结构体类型存储(1)</title>
    <url>/2019/11/16/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8-1/</url>
    <content><![CDATA[<h5 id="1-数组强制转换成结构类型-数组类型和结构体成员类型一致"><a href="#1-数组强制转换成结构类型-数组类型和结构体成员类型一致" class="headerlink" title="1. 数组强制转换成结构类型,数组类型和结构体成员类型一致"></a>1. 数组强制转换成结构类型,数组类型和结构体成员类型一致</h5><a id="more"></a>
<p>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;      /*标准输入输出定义*/</span><br><span class="line">#include &lt;stdlib.h&gt;     /*标准函数库定义*/</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;      /*文件控制定义*/</span><br><span class="line">#include &lt;termios.h&gt;    /*PPSIX 终端控制定义*/</span><br><span class="line">#include &lt;unistd.h&gt;     /*Unix 标准函数定义*/</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">/*</span><br><span class="line">字节对齐问题，一个数组强制转换成结构体类型</span><br><span class="line">*/</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">int ch[] = &#123;0x12, 0x34, 0x56, 0x78&#125;;</span><br><span class="line">typedef struct arr_s</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	int j;</span><br><span class="line">&#125;arr_t;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	arr_t* p = (arr_t*)ch;</span><br><span class="line">	printf(&quot;数组强制转换成结构类型,数组类型和结构体成员类型一致:0x%X, 0x%X\n&quot;,p-&gt;i,p-&gt;j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组是int类型，结构体成员也是int类型。</p>
<p>演示效果：</p>
<p><img src="/2019/11/16/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8-1/1.jpg" alt="1"></p>
<h5 id="2-数组强制转换成结构类型-数组类型和结构体成员类型不一致"><a href="#2-数组强制转换成结构类型-数组类型和结构体成员类型不一致" class="headerlink" title="2.  数组强制转换成结构类型,数组类型和结构体成员类型不一致"></a>2.  数组强制转换成结构类型,数组类型和结构体成员类型不一致</h5><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;      /*标准输入输出定义*/</span><br><span class="line">#include &lt;stdlib.h&gt;     /*标准函数库定义*/</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;      /*文件控制定义*/</span><br><span class="line">#include &lt;termios.h&gt;    /*PPSIX 终端控制定义*/</span><br><span class="line">#include &lt;unistd.h&gt;     /*Unix 标准函数定义*/</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line"></span><br><span class="line">char ch[] = &#123;0x12, 0x34, 0x56, 0x78&#125;;</span><br><span class="line">typedef struct arr_s</span><br><span class="line">&#123;</span><br><span class="line">	char i;</span><br><span class="line">	short j;</span><br><span class="line">	char l;</span><br><span class="line"></span><br><span class="line">&#125;arr_t;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	arr_t* p = (arr_t*)ch;</span><br><span class="line">	printf(&quot;数组大小:%d\n&quot;,sizeof(ch));</span><br><span class="line">	printf(&quot;结构体成员大小:%d\n&quot;,sizeof(arr_t));</span><br><span class="line">	printf(&quot;数组强制转换成结构类型,数组类型和结构体成员类型不一致:%X, %X, %X\n&quot;,p-&gt;i,p-&gt;j,p-&gt;l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>效果演示：</p>
<p><img src="/2019/11/16/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8-1/2.jpg" alt="2"></p>
<p>数组为char型，结构体成员为依次char型，short型，char型。其中数组有四个字节，结构体成员因为对齐的原因有6个字节。</p>
<p>可以看到，i的类型因为j的类型的原因，补充了一个字节，所以当数组强制转换成结构体类型之后，0x34会漏掉。 0x56 0x78 因为小端的原因，排序成0x7856</p>
<p>但是如果稍微将j和l位置替换一下，结果又不一样，请看示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;      /*标准输入输出定义*/</span><br><span class="line">#include &lt;stdlib.h&gt;     /*标准函数库定义*/</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;      /*文件控制定义*/</span><br><span class="line">#include &lt;termios.h&gt;    /*PPSIX 终端控制定义*/</span><br><span class="line">#include &lt;unistd.h&gt;     /*Unix 标准函数定义*/</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line"></span><br><span class="line">char ch[] = &#123;0x12, 0x34, 0x56, 0x78&#125;;</span><br><span class="line">typedef struct arr_s</span><br><span class="line">&#123;</span><br><span class="line">	char i;</span><br><span class="line">	char l;</span><br><span class="line">	short j;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;arr_t;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	arr_t* p = (arr_t*)ch;</span><br><span class="line">	printf(&quot;数组大小:%d\n&quot;,sizeof(ch));</span><br><span class="line">	printf(&quot;结构体成员大小:%d\n&quot;,sizeof(arr_t));</span><br><span class="line">	printf(&quot;数组强制转换成结构类型,数组类型和结构体成员类型不一致:%X, %X, %X\n&quot;,p-&gt;i,p-&gt;j,p-&gt;l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果演示：</p>
<p><img src="/2019/11/16/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8-1/3.jpg" alt="3"></p>
<p>看到没有，此时数组的大小和结构体大小一致。那么此时打印出来的数据也是一样的。</p>
<p>其实还可以这样，加一个</p>
<pre><code>#pragma   pack(1)</code></pre><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;      /*标准输入输出定义*/</span><br><span class="line">#include &lt;stdlib.h&gt;     /*标准函数库定义*/</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;      /*文件控制定义*/</span><br><span class="line">#include &lt;termios.h&gt;    /*PPSIX 终端控制定义*/</span><br><span class="line">#include &lt;unistd.h&gt;     /*Unix 标准函数定义*/</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line"></span><br><span class="line">char ch[] = &#123;0x12, 0x34, 0x56, 0x78&#125;;</span><br><span class="line">#pragma   pack(1) //强制连续存放,对齐边界为 1</span><br><span class="line">typedef struct arr_s</span><br><span class="line">&#123;</span><br><span class="line">	char i;</span><br><span class="line">	short j;</span><br><span class="line">	char l;</span><br><span class="line">&#125;arr_t;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	arr_t* p = (arr_t*)ch;</span><br><span class="line">	printf(&quot;数组大小:%d\n&quot;,sizeof(ch));</span><br><span class="line">	printf(&quot;结构体成员大小:%d\n&quot;,sizeof(arr_t));</span><br><span class="line">	printf(&quot;数组强制转换成结构类型,数组类型和结构体成员类型不一致:%X, %X, %X\n&quot;,p-&gt;i,p-&gt;j,p-&gt;l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果演示：</p>
<p><img src="/2019/11/16/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8-1/4.jpg" alt="4"></p>
<p>由此可以看到，其实结构体的存储和数组的存储其实本质上是一样的，不同的是数组只能有一种数据类型，结构体可以有多种数据类型，他们之间强制转换时，要考虑到字节对齐、大小端问题。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>结构体</tag>
        <tag>强制转换</tag>
        <tag>字节对齐</tag>
        <tag>大小端</tag>
        <tag>pragma pack()</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言-字符串拼接</title>
    <url>/2019/11/16/C%E8%AF%AD%E8%A8%80-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5/</url>
    <content><![CDATA[<blockquote>
<p>工作中我们经常用到字符串相关操作，前面讲到对字符串拆分的、格式转换的sscanf()函数，现在讲一下字符串拼接相关函数。</p>
</blockquote>
<a id="more"></a>


<h5 id="一、利用strcat-函数函数"><a href="#一、利用strcat-函数函数" class="headerlink" title="一、利用strcat()函数函数"></a>一、利用strcat()函数函数</h5><p>strcat() 函数用来将两个字符串连接（拼接）起来</p>
<p>头文件：string.h</p>
<p>语法/原型：</p>
<pre><code>char*strcat(char* strDestination, const char* strSource);</code></pre><p>参数说明：</p>
<pre><code>strDestination：目的字符串；
strSource：源字符串。</code></pre><p>strcat() 函数把 strSource 所指向的字符串追加到 strDestination 所指向的字符串的结尾，所以必须要保证 strDestination 有足够的内存空间来容纳两个字符串，否则会导致溢出错误。</p>
<p>注意：<br>strDestination 末尾的\0会被覆盖，strSource 末尾的\0会一起被复制过去，最终的字符串只有一个\0。</p>
<p>返回值：<br>指向 strDestination 的指针。</p>
<p>事例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char str1[101] = &#123; 0 &#125;;</span><br><span class="line">    char str2[50] = &#123; 0 &#125;;</span><br><span class="line">    gets(str1);</span><br><span class="line">    gets(str2);</span><br><span class="line">    strcat(str1, str2);</span><br><span class="line">    puts(str1);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="/2019/11/16/C%E8%AF%AD%E8%A8%80-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5/1.jpg" alt="1"></p>
<h5 id="二、利用sprintf-函数"><a href="#二、利用sprintf-函数" class="headerlink" title="二、利用sprintf()函数"></a>二、利用sprintf()函数</h5><blockquote>
<p>sprintf函数不光可以用来做字符串格式转换，还可以用来做字符串拼接，简单又实用。</p>
</blockquote>
<p>直接看代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">char rtmppush_URL[35] = &quot;rtmp://&quot;;</span><br><span class="line">char ip[20] = &quot;121.199.24.64&quot;;</span><br><span class="line">char Strmedia_No = 23;</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">	sprintf(rtmppush_URL,&quot;%s%s%s%s%s%d&quot;,&quot;rtmp://&quot;,ip,&quot;:&quot;,&quot;10990&quot;,&quot;/myapp&quot;,Strmedia_No);</span><br><span class="line">	printf(&quot;rtmppush_URL=%s\n&quot;,rtmppush_URL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：看sprintf中的格式转换，可以将字符、整数、进制统统转换成字符类型，然后打印到内存中去。这个功能很强大。</p>
<p>效果：</p>
<p><img src="/2019/11/16/C%E8%AF%AD%E8%A8%80-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5/2.jpg" alt="2"></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>sprintf</tag>
        <tag>strcat</tag>
        <tag>字符串拼接</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言-整数与字符串的相互转换</title>
    <url>/2019/11/10/C%E8%AF%AD%E8%A8%80-%E6%95%B4%E6%95%B0%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h4 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h4><p>C语言中整数与字符串的相互转换，有广泛应用的拓展函数(非标准库)，也可以自己尝试简单的实现。</p>
<a id="more"></a>

<h4 id="二、整数转字符串"><a href="#二、整数转字符串" class="headerlink" title="二、整数转字符串"></a>二、整数转字符串</h4><h5 id="1-拓展函数itoa"><a href="#1-拓展函数itoa" class="headerlink" title="1. 拓展函数itoa"></a>1. 拓展函数itoa</h5><pre><code>itoa (表示 integer to alphanumeric)是把整型数转换成字符串的一个函数。</code></pre><p>windows环境下，在&lt;stdlib.h&gt;头文件中有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char* itoa(int value,char*string,int radix);</span><br></pre></td></tr></table></figure>
<p>参数：value，要转换的整数，string， 转换后的字符串,radix， 转换进制数，如2,8,10,16 进制等。</p>
<p>返回值：函数返回一个指向 str，无错误返回。</p>
<p>功能：将整数value 转换成字符串存入string 指向的内存空间 ,radix 为转换时所用基数(保存到字符串中的数据的进制基数)。</p>
<p>注意：itoa不是一个标准的c函数，他是windows特有的，跨平台写程序，要用sprintf。</p>
<h6 id="函数源码："><a href="#函数源码：" class="headerlink" title="函数源码："></a>函数源码：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char* itoa(int num,char* str,int radix)</span><br><span class="line">&#123;</span><br><span class="line">	char index[]=&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;//索引表</span><br><span class="line">	unsigned unum;//存放要转换的整数的绝对值,转换的整数可能是负数</span><br><span class="line">	int i=0,j,k;//i用来指示设置字符串相应位，转换之后i其实就是字符串的长度；转换后顺序是逆序的，有正负的情况，k用来指示调整顺序的开始位置;j用来指示调整顺序时的交换。</span><br><span class="line"> </span><br><span class="line">	//获取要转换的整数的绝对值</span><br><span class="line">	if(radix==10&amp;&amp;num&lt;0)//要转换成十进制数并且是负数</span><br><span class="line">	&#123;</span><br><span class="line">		unum=(unsigned)-num;//将num的绝对值赋给unum</span><br><span class="line">		str[i++]=&apos;-&apos;;//在字符串最前面设置为&apos;-&apos;号，并且索引加1</span><br><span class="line">	&#125;</span><br><span class="line">	else unum=(unsigned)num;//若是num为正，直接赋值给unum</span><br><span class="line"> </span><br><span class="line">	//转换部分，注意转换后是逆序的</span><br><span class="line">	do</span><br><span class="line">	&#123;</span><br><span class="line">		str[i++]=index[unum%(unsigned)radix];//取unum的最后一位，并设置为str对应位，指示索引加1</span><br><span class="line">		unum/=radix;//unum去掉最后一位</span><br><span class="line"> </span><br><span class="line">	&#125;while(unum);//直至unum为0退出循环</span><br><span class="line"> </span><br><span class="line">	str[i]=&apos;\0&apos;;//在字符串最后添加&apos;\0&apos;字符，c语言字符串以&apos;\0&apos;结束。</span><br><span class="line"> </span><br><span class="line">	//将顺序调整过来</span><br><span class="line">	if(str[0]==&apos;-&apos;) k=1;//如果是负数，符号不用调整，从符号后面开始调整</span><br><span class="line">	else k=0;//不是负数，全部都要调整</span><br><span class="line"> </span><br><span class="line">	char temp;//临时变量，交换两个值时用到</span><br><span class="line">	for(j=k;j&lt;=(i-1)/2;j++)//头尾一一对称交换，i其实就是字符串的长度，索引最大值比长度少1</span><br><span class="line">	&#123;</span><br><span class="line">		temp=str[j];//头部赋值给临时变量</span><br><span class="line">		str[j]=str[i-1+k-j];//尾部赋值给头部</span><br><span class="line">		str[i-1+k-j]=temp;//将临时变量的值(其实就是之前的头部值)赋给尾部</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return str;//返回转换后的字符串</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="示例程序："><a href="#示例程序：" class="headerlink" title="示例程序："></a>示例程序：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int number1 = 123456;</span><br><span class="line">	int number2 = -123456;</span><br><span class="line">	char string[16] = &#123;0&#125;;</span><br><span class="line">	itoa(number1,string,10);</span><br><span class="line">	printf(&quot;数字：%d 转换后的字符串为：%s\n&quot;,number1,string);</span><br><span class="line">	itoa(number2,string,10);</span><br><span class="line">	printf(&quot;数字：%d 转换后的字符串为：%s\n&quot;,number2,string);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行代码如下：(linux环境下略)</p>
<h5 id="2-自己简单实现"><a href="#2-自己简单实现" class="headerlink" title="2. 自己简单实现"></a>2. 自己简单实现</h5><h6 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">char* Int2String(int num,char *str);//函数声明 </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int number1 = 123456;</span><br><span class="line">	int number2 = -123456;</span><br><span class="line">	char string[16] = &#123;0&#125;;</span><br><span class="line">	Int2String(number1,string);</span><br><span class="line">	printf(&quot;数字：%d 转换后的字符串为：%s\n&quot;,number1,string);</span><br><span class="line">	Int2String(number2,string);</span><br><span class="line">	printf(&quot;数字：%d 转换后的字符串为：%s\n&quot;,number2,string);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">char* Int2String(int num,char *str)//10进制 </span><br><span class="line">&#123;</span><br><span class="line">	int i = 0;//指示填充str </span><br><span class="line">	if(num&lt;0)//如果num为负数，将num变正 </span><br><span class="line">	&#123;</span><br><span class="line">		num = -num;</span><br><span class="line">		str[i++] = &apos;-&apos;;</span><br><span class="line">	&#125; </span><br><span class="line">	//转换 </span><br><span class="line">	do</span><br><span class="line">	&#123;</span><br><span class="line">		str[i++] = num%10+48;//取num最低位 字符0~9的ASCII码是48~57；简单来说数字0+48=48，ASCII码对应字符&apos;0&apos; </span><br><span class="line">		num /= 10;//去掉最低位	</span><br><span class="line">	&#125;while(num);//num不为0继续循环</span><br><span class="line">	</span><br><span class="line">	str[i] = &apos;\0&apos;;</span><br><span class="line">	</span><br><span class="line">	//确定开始调整的位置 </span><br><span class="line">	int j = 0;</span><br><span class="line">	if(str[0]==&apos;-&apos;)//如果有负号，负号不用调整 </span><br><span class="line">	&#123;</span><br><span class="line">		j = 1;//从第二位开始调整 </span><br><span class="line">		++i;//由于有负号，所以交换的对称轴也要后移1位 </span><br><span class="line">	&#125;</span><br><span class="line">	//对称交换 </span><br><span class="line">	for(;j&lt;i/2;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		//对称交换两端的值 其实就是省下中间变量交换a+b的值：a=a+b;b=a-b;a=a-b; </span><br><span class="line">		str[j] = str[j] + str[i-1-j];</span><br><span class="line">		str[i-1-j] = str[j] - str[i-1-j];</span><br><span class="line">		str[j] = str[j] - str[i-1-j];</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	return str;//返回转换后的值 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="执行代码如下："><a href="#执行代码如下：" class="headerlink" title="执行代码如下："></a>执行代码如下：</h6><p><img src="/2019/11/10/C%E8%AF%AD%E8%A8%80-%E6%95%B4%E6%95%B0%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/1.jpg" alt="1"></p>
<h4 id="三、字符串转整数"><a href="#三、字符串转整数" class="headerlink" title="三、字符串转整数"></a>三、字符串转整数</h4><h5 id="1-拓展函数"><a href="#1-拓展函数" class="headerlink" title="1.拓展函数"></a>1.拓展函数</h5><pre><code>atoi (表示 alphanumeric to integer)是把字符串转换成整型数的一个函数。</code></pre><p>windows环境下，在&lt;stdlib.h&gt;头文件中</p>
<pre><code>int  atoi(const char *nptr);//字符串转整数函数，nptr: 要转换的字符串</code></pre><h6 id="实现源码"><a href="#实现源码" class="headerlink" title="实现源码"></a>实现源码</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int  atoi(const char *nptr)</span><br><span class="line">&#123;</span><br><span class="line">        return (int)atol(nptr);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">long  atol(const char *nptr)</span><br><span class="line">&#123;</span><br><span class="line">        int c;              /* 当前要转换的字符(一个一个字符转换成数字) */</span><br><span class="line">        long total;         /* 当前转换结果 */</span><br><span class="line">        int sign;           /* 标志转换结果是否带负号*/</span><br><span class="line"> </span><br><span class="line">        /*跳过空格，空格不进行转换*/</span><br><span class="line">        while ( isspace((int)(unsigned char)*nptr) )</span><br><span class="line">            ++nptr;</span><br><span class="line"> </span><br><span class="line">        c = (int)(unsigned char)*nptr++;//获取一个字符准备转换 </span><br><span class="line">        sign = c;           /*保存符号标示*/</span><br><span class="line">        if (c == &apos;-&apos; || c == &apos;+&apos;)</span><br><span class="line">            c = (int)(unsigned char)*nptr++;    /*跳过&apos;+&apos;、&apos;-&apos;号，不进行转换*/</span><br><span class="line"> </span><br><span class="line">        total = 0;//设置转换结果为0 </span><br><span class="line"> </span><br><span class="line">        while (isdigit(c)) &#123;//如果字符是数字 </span><br><span class="line">            total = 10 * total + (c - &apos;0&apos;);     /* 根据ASCII码将字符转换为对应的数字，并且乘10累积到结果 */</span><br><span class="line">            c = (int)(unsigned char)*nptr++;    /* 取下一个字符 */</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"> 		//根据符号指示返回是否带负号的结果 </span><br><span class="line">        if (sign == &apos;-&apos;)</span><br><span class="line">            return -total;</span><br><span class="line">        else</span><br><span class="line">            return total;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="示例程序：-1"><a href="#示例程序：-1" class="headerlink" title="示例程序："></a>示例程序：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt; </span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;字符串\&quot;123456\&quot;转换为数字：%d\n&quot;,atoi(&quot;123456&quot;));</span><br><span class="line">	printf(&quot;字符串\&quot;-123456\&quot;转换为数字：%d\n&quot;,atoi(&quot;-123456&quot;));</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行代码如下：</p>
<p><img src="/2019/11/10/C%E8%AF%AD%E8%A8%80-%E6%95%B4%E6%95%B0%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/2.jpg" alt="2"></p>
<h5 id="2-自己简单实现-1"><a href="#2-自己简单实现-1" class="headerlink" title="2.自己简单实现"></a>2.自己简单实现</h5><h6 id="实现源码-1"><a href="#实现源码-1" class="headerlink" title="实现源码-1"></a>实现源码-1</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int String2Int(char *str);//函数声明 </span><br><span class="line"></span><br><span class="line">int String2Int(char *str)//字符串转数字 </span><br><span class="line">&#123;</span><br><span class="line">	char flag = &apos;+&apos;;//指示结果是否带符号 </span><br><span class="line">	long res = 0;</span><br><span class="line">	</span><br><span class="line">	if(*str==&apos;-&apos;)//字符串带负号 </span><br><span class="line">	&#123;</span><br><span class="line">		++str;//指向下一个字符 </span><br><span class="line">		flag = &apos;-&apos;;//将标志设为负号 </span><br><span class="line">	&#125; </span><br><span class="line">	//逐个字符转换，并累加到结果res </span><br><span class="line">	while(*str&gt;=48 &amp;&amp; *str&lt;57)//如果是数字才进行转换，数字0~9的ASCII码：48~57 </span><br><span class="line">	&#123;</span><br><span class="line">		res = 10*res+  *str++-48;//字符&apos;0&apos;的ASCII码为48,48-48=0刚好转化为数字0 </span><br><span class="line">	&#125; </span><br><span class="line"> </span><br><span class="line">    if(flag == &apos;-&apos;)//处理是负数的情况</span><br><span class="line">	&#123;</span><br><span class="line">		res = -res;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return (int)res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;字符串\&quot;123456\&quot;转换为数字：%d\n&quot;,String2Int(&quot;123456&quot;));</span><br><span class="line">	printf(&quot;字符串\&quot;-123456\&quot;转换为数字：%d\n&quot;,String2Int(&quot;-123456&quot;));</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行代码如下：</p>
<p><img src="/2019/11/10/C%E8%AF%AD%E8%A8%80-%E6%95%B4%E6%95%B0%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/3.jpg" alt="3"></p>
<h6 id="实现源码-2"><a href="#实现源码-2" class="headerlink" title="实现源码-2"></a>实现源码-2</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int ASCIItoINT(char s[])  </span><br><span class="line">&#123;  </span><br><span class="line">    int i;  </span><br><span class="line">    int n = 0;  </span><br><span class="line">    for (i = 0; s[i] &gt;= &apos;0&apos; &amp;&amp; s[i] &lt;= &apos;9&apos;; ++i)  </span><br><span class="line">    &#123;  </span><br><span class="line">        n = 10 * n + (s[i] - &apos;0&apos;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return n;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">	char *str = &quot;1234&quot;;</span><br><span class="line">	printf(&quot;整数:%d\n&quot;,ASCIItoINT(str));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="执行代码如下：-1"><a href="#执行代码如下：-1" class="headerlink" title="执行代码如下："></a>执行代码如下：</h6><p><img src="/2019/11/10/C%E8%AF%AD%E8%A8%80-%E6%95%B4%E6%95%B0%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/4.jpg" alt="4"></p>
<h4 id="四、利用sprintf-函数和sscanf-函数"><a href="#四、利用sprintf-函数和sscanf-函数" class="headerlink" title="四、利用sprintf()函数和sscanf()函数"></a>四、利用sprintf()函数和sscanf()函数</h4><h5 id="整数转字符串"><a href="#整数转字符串" class="headerlink" title="整数转字符串"></a>整数转字符串</h5><h6 id="测试代码："><a href="#测试代码：" class="headerlink" title="测试代码："></a>测试代码：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">char* Int2String(int num,char *str);//函数声明 </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int number1 = 123456;</span><br><span class="line">	int number2 = -123456;</span><br><span class="line">	char string[16] = &#123;0&#125;;</span><br><span class="line">	Int2String(number1,string);</span><br><span class="line">	printf(&quot;数字：%d 转换后的字符串为：%s\n&quot;,number1,string);</span><br><span class="line">	Int2String(number2,string);</span><br><span class="line">	printf(&quot;数字：%d 转换后的字符串为：%s\n&quot;,number2,string);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">char* Int2String(int num,char *str)</span><br><span class="line">&#123;</span><br><span class="line">	sprintf(str, &quot;%d&quot;, num);</span><br><span class="line"> </span><br><span class="line">	return str;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="执行代码如下：-2"><a href="#执行代码如下：-2" class="headerlink" title="执行代码如下："></a>执行代码如下：</h6><p><img src="/2019/11/10/C%E8%AF%AD%E8%A8%80-%E6%95%B4%E6%95%B0%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/5.jpg" alt="5"></p>
<h5 id="字符串转整数"><a href="#字符串转整数" class="headerlink" title="字符串转整数"></a>字符串转整数</h5><h6 id="测试代码：-1"><a href="#测试代码：-1" class="headerlink" title="测试代码："></a>测试代码：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int String2Int(char *str);//函数声明 </span><br><span class="line"></span><br><span class="line">int String2Int(char *str)//字符串转数字 </span><br><span class="line">&#123;</span><br><span class="line">	char flag = &apos;+&apos;;//指示结果是否带符号 </span><br><span class="line">	long res = 0;</span><br><span class="line">	</span><br><span class="line">	if(*str==&apos;-&apos;)//字符串带负号 </span><br><span class="line">	&#123;</span><br><span class="line">		++str;//指向下一个字符 </span><br><span class="line">		flag = &apos;-&apos;;//将标志设为负号 </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	sscanf(str, &quot;%ld&quot;, &amp;res);</span><br><span class="line">	if(flag == &apos;-&apos;)</span><br><span class="line">	&#123;</span><br><span class="line">		res = -res;</span><br><span class="line">	&#125;</span><br><span class="line">	return (int)res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;字符串\&quot;123456\&quot;转换为数字：%d\n&quot;,String2Int(&quot;123456&quot;));</span><br><span class="line">	printf(&quot;字符串\&quot;-123456\&quot;转换为数字：%d\n&quot;,String2Int(&quot;-123456&quot;));</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="执行代码如下：-3"><a href="#执行代码如下：-3" class="headerlink" title="执行代码如下："></a>执行代码如下：</h6><p><img src="/2019/11/10/C%E8%AF%AD%E8%A8%80-%E6%95%B4%E6%95%B0%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/6.jpg" alt="6"></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>sprintf</tag>
        <tag>sscanf</tag>
        <tag>整数转字符串</tag>
        <tag>字符串转整数</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言-10进制与16进制的互转</title>
    <url>/2019/11/10/C%E8%AF%AD%E8%A8%80-10%E8%BF%9B%E5%88%B6%E4%B8%8E16%E8%BF%9B%E5%88%B6%E7%9A%84%E4%BA%92%E8%BD%AC/</url>
    <content><![CDATA[<blockquote>
<p>所谓的10进制数据和16进制数据本质上都是2进制数据，下面的显示大多最终还是以字符串的形式显示出来的。</p>
</blockquote>
<h4 id="16进制转10进制"><a href="#16进制转10进制" class="headerlink" title="16进制转10进制"></a>16进制转10进制</h4><h5 id="16进制转10进制-大端数组显示"><a href="#16进制转10进制-大端数组显示" class="headerlink" title="16进制转10进制-大端数组显示"></a>16进制转10进制-大端数组显示</h5><a id="more"></a>

<h6 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h6><p>先描述一个16进制转10进制的，即通过网络传输，大端显示的一个16进制的数组。</p>
<h6 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h6><ol>
<li>先对16进制数组Port中的每一个元素的高四位和低四位进行拆分，分别放到对应的数组port中。</li>
<li>调用pow函数,如pow(x,y)，即为求x的y次方。</li>
<li>编译执行即可，注意编译时要加 -lm。</li>
</ol>
<h6 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;math.h&gt; </span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	unsigned char Port[2] = &#123;0x2A,0xEE&#125;;</span><br><span class="line">	unsigned char port[4];</span><br><span class="line">	short port_Num = 0x2AEE;</span><br><span class="line">	unsigned int port_num,port_num1,port_num2;</span><br><span class="line"></span><br><span class="line">	port[0] = Port[0]&gt;&gt;4;</span><br><span class="line">    port[1] = Port[0]&amp;0x0F;</span><br><span class="line">    port[2] = Port[1]&gt;&gt;4;</span><br><span class="line">    port[3] = Port[1]&amp;0x0F;</span><br><span class="line">	</span><br><span class="line">	//第一种情况</span><br><span class="line">	port_num = port[0]*16*16*16 + port[1]*16*16+port[2]*16 + port[3];</span><br><span class="line">	printf(&quot;port_num1:%d\n&quot;,port_num);</span><br><span class="line">	</span><br><span class="line">	//第二种情况</span><br><span class="line">	port_num1 = port[0]*pow(16,3) + port[1]*pow(16,2) + port[2]*pow(16,1) + port[3]*pow(16,0);</span><br><span class="line">	printf(&quot;port_num1:%d\n&quot;,port_num1);</span><br><span class="line">	</span><br><span class="line">	//第三种情况</span><br><span class="line">	for(i=3;i&gt;=0;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		port_num2 += port[3-i]*pow(16,i);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;port_num2:%d\n&quot;,port_num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="执行代码如下：（-lm）"><a href="#执行代码如下：（-lm）" class="headerlink" title="执行代码如下：（-lm）"></a>执行代码如下：（-lm）</h6><p><img src="/2019/11/10/C%E8%AF%AD%E8%A8%80-10%E8%BF%9B%E5%88%B6%E4%B8%8E16%E8%BF%9B%E5%88%B6%E7%9A%84%E4%BA%92%E8%BD%AC/1.jpg" alt="1"></p>
<h5 id="16进制转换为十进制-指针字符串显示"><a href="#16进制转换为十进制-指针字符串显示" class="headerlink" title="16进制转换为十进制-指针字符串显示"></a>16进制转换为十进制-指针字符串显示</h5><h6 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a>应用场景：</h6><p>16进制的数据，以字符串的形式体现出来（可以带0x，可以不带）。</p>
<h6 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h6><ol>
<li>通过指针变量得到一个16进制的字符串</li>
<li>获取16进制字符串的长度</li>
<li>逆序从最后一个字符的数据获取10进制的整数</li>
<li>通过16进制权重从低位到高位累加。</li>
</ol>
<h6 id="代码如下：-1"><a href="#代码如下：-1" class="headerlink" title="代码如下："></a>代码如下：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">/* 十六进制数转换为十进制数 */</span><br><span class="line">long hexToDec(char *source);</span><br><span class="line"> </span><br><span class="line">/* 返回ch字符在sign数组中的序号 */</span><br><span class="line">int getIndexOfSigns(char ch);</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char *hex = &quot;75BCD15&quot;;</span><br><span class="line"> </span><br><span class="line">    printf(&quot;16进制数：\t%s\n&quot;, hex);</span><br><span class="line">    printf(&quot;10进制数：\t%ld\n&quot;, hexToDec(hex));</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* 十六进制数转换为十进制数 */</span><br><span class="line">long hexToDec(char *source)</span><br><span class="line">&#123;</span><br><span class="line">    long sum = 0;</span><br><span class="line">    long t = 1;</span><br><span class="line">    int i, len;</span><br><span class="line"> </span><br><span class="line">    len = strlen(source);</span><br><span class="line">    for(i=len-1; i&gt;=0; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += t * getIndexOfSigns(*(source + i));</span><br><span class="line">        t *= 16;</span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* 返回ch字符在sign数组中的序号 */</span><br><span class="line">int getIndexOfSigns(char ch)</span><br><span class="line">&#123;</span><br><span class="line">    if(ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        return ch - &apos;0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ch &gt;= &apos;A&apos; &amp;&amp; ch &lt;=&apos;F&apos;) </span><br><span class="line">    &#123;</span><br><span class="line">        return ch - &apos;A&apos; + 10;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ch &gt;= &apos;a&apos; &amp;&amp; ch &lt;= &apos;f&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        return ch - &apos;a&apos; + 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="执行代码如下："><a href="#执行代码如下：" class="headerlink" title="执行代码如下："></a>执行代码如下：</h6><p><img src="/2019/11/10/C%E8%AF%AD%E8%A8%80-10%E8%BF%9B%E5%88%B6%E4%B8%8E16%E8%BF%9B%E5%88%B6%E7%9A%84%E4%BA%92%E8%BD%AC/2.jpg" alt="2"></p>
<h5 id="16进制转10进制-使用sscanf函数显示10进制数"><a href="#16进制转10进制-使用sscanf函数显示10进制数" class="headerlink" title="16进制转10进制-使用sscanf函数显示10进制数"></a>16进制转10进制-使用sscanf函数显示10进制数</h5><blockquote>
<p>sscanf函数的用法与printf函数很像，都是以格式化的形式进行操作，例如如下的例子中，sscanf(“A23CD”, “%x”, &amp;a);<br>“%x”是将字符串A23CD以十六进制形式输入a中，如果将”%x”换成为”%d”的话，就是将字符串A23CD以十进制形式输入a中，这显然是错误的，因为将A23CD转换为十进制的时候，无法解析A，CD等字符，所以得出的结果就是错误的。</p>
</blockquote>
<h6 id="使用场景（略）"><a href="#使用场景（略）" class="headerlink" title="使用场景（略）"></a>使用场景（略）</h6><h6 id="步骤：-2"><a href="#步骤：-2" class="headerlink" title="步骤："></a>步骤：</h6><ol>
<li>将以字符串形式的十六进制数转换为整型的十六进制。</li>
<li><del>再将16进制数据以16进制的权重类加起来</del>。</li>
<li>这里因为获取的16进制数据已经存放在整型变量当中了，所以没必要通过通过16进制权重进行累加计算。</li>
</ol>
<h6 id="代码如下：-2"><a href="#代码如下：-2" class="headerlink" title="代码如下："></a>代码如下：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	int a;</span><br><span class="line">	sscanf(&quot;A23CD&quot;, &quot;%x&quot;, &amp;a);</span><br><span class="line">	printf(&quot;%x\n&quot;,a);</span><br><span class="line">	printf(&quot;%d\n&quot;,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="执行代码如下：-1"><a href="#执行代码如下：-1" class="headerlink" title="执行代码如下："></a>执行代码如下：</h6><p><img src="/2019/11/10/C%E8%AF%AD%E8%A8%80-10%E8%BF%9B%E5%88%B6%E4%B8%8E16%E8%BF%9B%E5%88%B6%E7%9A%84%E4%BA%92%E8%BD%AC/3.jpg" alt="3"></p>
<h5 id="16进制转10进制-使用sprintf函数最终显示10进制数据字符串"><a href="#16进制转10进制-使用sprintf函数最终显示10进制数据字符串" class="headerlink" title="16进制转10进制-使用sprintf函数最终显示10进制数据字符串"></a>16进制转10进制-使用sprintf函数最终显示10进制数据字符串</h5><h6 id="应用场景：-2"><a href="#应用场景：-2" class="headerlink" title="应用场景："></a>应用场景：</h6><p>16进制数据转10进制，最终得到的是一个10进制的字符串，很简单，不需要再经过itoa转换了。</p>
<h6 id="步骤：-3"><a href="#步骤：-3" class="headerlink" title="步骤："></a>步骤：</h6><p>直接利用sprintf函数进行格式化转换，然后打印到内存中即可</p>
<h6 id="代码如下：-3"><a href="#代码如下：-3" class="headerlink" title="代码如下："></a>代码如下：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	short port_Num = 0x2AEE;</span><br><span class="line">	char str[6] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">	sprintf(str, &quot;%d&quot;, port_Num);</span><br><span class="line">	printf(&quot;10进制数据字符串:%s\n&quot;,str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="执行代码如下：-2"><a href="#执行代码如下：-2" class="headerlink" title="执行代码如下："></a>执行代码如下：</h6><p><img src="/2019/11/10/C%E8%AF%AD%E8%A8%80-10%E8%BF%9B%E5%88%B6%E4%B8%8E16%E8%BF%9B%E5%88%B6%E7%9A%84%E4%BA%92%E8%BD%AC/4.jpg" alt="4"></p>
<h4 id="10进制转16进制"><a href="#10进制转16进制" class="headerlink" title="10进制转16进制"></a>10进制转16进制</h4><h5 id="10进制转16进制-sprintf函数最终显示16进制数据字符串"><a href="#10进制转16进制-sprintf函数最终显示16进制数据字符串" class="headerlink" title="10进制转16进制- sprintf函数最终显示16进制数据字符串"></a>10进制转16进制- sprintf函数最终显示16进制数据字符串</h5><h6 id="应用场景：-3"><a href="#应用场景：-3" class="headerlink" title="应用场景："></a>应用场景：</h6><p>10进制数据转换成16进制数据，而且是一个16进制的字符串</p>
<h6 id="步骤：-4"><a href="#步骤：-4" class="headerlink" title="步骤："></a>步骤：</h6><ol>
<li>定义一个char型数组，用于存放16进制的字符串</li>
<li>利用sprintf函数将得到的10进制整型数，进行16进制格式化<h6 id="代码如下：-4"><a href="#代码如下：-4" class="headerlink" title="代码如下："></a>代码如下：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">char buffer[33];//用于存放转换好的16进制字符串，可根据需要定义长度</span><br><span class="line">char* int2hex(int NUM)</span><br><span class="line">&#123;</span><br><span class="line">	sprintf(buffer,&quot;%X&quot;, NUM);</span><br><span class="line">	return(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int num;</span><br><span class="line">	char* hex_str;</span><br><span class="line">	printf(&quot;Enter a number:&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;num);</span><br><span class="line">	hex_str = int2hex(num);</span><br><span class="line">	printf(&quot;Hexadecimal number:0x%s\n&quot;,hex_str);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="执行代码如下：-3"><a href="#执行代码如下：-3" class="headerlink" title="执行代码如下："></a>执行代码如下：</h6><img src="/2019/11/10/C%E8%AF%AD%E8%A8%80-10%E8%BF%9B%E5%88%B6%E4%B8%8E16%E8%BF%9B%E5%88%B6%E7%9A%84%E4%BA%92%E8%BD%AC/5.jpg" alt="5"></li>
</ol>
<h5 id="10进制转16进制-自己编写"><a href="#10进制转16进制-自己编写" class="headerlink" title="10进制转16进制-自己编写"></a>10进制转16进制-自己编写</h5><h6 id="应用场景：-4"><a href="#应用场景：-4" class="headerlink" title="应用场景："></a>应用场景：</h6><h6 id="步骤：-5"><a href="#步骤：-5" class="headerlink" title="步骤："></a>步骤：</h6><ol>
<li>先将输入的十进制数除以16得到商和余数。</li>
<li>再将得到的商继续除以16得到商和余数，以此类推直到商为0为止。</li>
<li>然后将所得余数顺序存入一个数组，再将这个数组倒序通过switch语句依次转成十六进制数存入一个字符串数组，最后顺序输出即可。<h6 id="代码如下：-5"><a href="#代码如下：-5" class="headerlink" title="代码如下："></a>代码如下：</h6></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;                  //输入的十进制数</span><br><span class="line">    int i;</span><br><span class="line">    int index = 0;          //记录输入的十进制数的长度</span><br><span class="line">    int len = 0;            //记录十六进制数组的长度</span><br><span class="line">    int remainder[200];     //存储余数</span><br><span class="line">    char sixteen[200];      //存储转换后的十六进制数</span><br><span class="line">	printf(&quot;输入一个10进制数:&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    if(n == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        remainder[0] = 0;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        for(i = 0; n &gt; 0; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            remainder[i] = n % 16;</span><br><span class="line">            n /= 16;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i = index - 1; i &gt;= 0; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        switch(remainder[i])</span><br><span class="line">        &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                sixteen[len++] = &apos;0&apos;;</span><br><span class="line">            break;</span><br><span class="line">            case 1:</span><br><span class="line">                sixteen[len++] = &apos;1&apos;;</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                sixteen[len++] = &apos;2&apos;;</span><br><span class="line">                break;</span><br><span class="line">            case 3:</span><br><span class="line">                sixteen[len++] = &apos;3&apos;;</span><br><span class="line">                break;</span><br><span class="line">            case 4:</span><br><span class="line">                sixteen[len++] = &apos;4&apos;;</span><br><span class="line">                break;</span><br><span class="line">            case 5:</span><br><span class="line">                sixteen[len++] = &apos;5&apos;;</span><br><span class="line">                break;</span><br><span class="line">            case 6:</span><br><span class="line">                sixteen[len++] = &apos;6&apos;;</span><br><span class="line">                break;</span><br><span class="line">            case 7:</span><br><span class="line">                sixteen[len++] = &apos;7&apos;;</span><br><span class="line">                break;</span><br><span class="line">            case 8:</span><br><span class="line">                sixteen[len++] = &apos;8&apos;;</span><br><span class="line">                break;</span><br><span class="line">            case 9:</span><br><span class="line">                sixteen[len++] = &apos;9&apos;;</span><br><span class="line">                break;</span><br><span class="line">            case 10:</span><br><span class="line">                sixteen[len++] = &apos;A&apos;;</span><br><span class="line">                break;</span><br><span class="line">            case 11:</span><br><span class="line">                sixteen[len++] = &apos;B&apos;;</span><br><span class="line">                break;</span><br><span class="line">            case 12:</span><br><span class="line">                sixteen[len++] = &apos;C&apos;;</span><br><span class="line">                break;</span><br><span class="line">            case 13:</span><br><span class="line">                sixteen[len++] = &apos;D&apos;;</span><br><span class="line">                break;</span><br><span class="line">            case 14:</span><br><span class="line">                sixteen[len++] = &apos;E&apos;;</span><br><span class="line">                break;</span><br><span class="line">            case 15:</span><br><span class="line">                sixteen[len++] = &apos;F&apos;;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	printf(&quot;16进制字符串:&quot;);</span><br><span class="line">    for(i = 0; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%c&quot;,sixteen[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="执行代码如下：-4"><a href="#执行代码如下：-4" class="headerlink" title="执行代码如下："></a>执行代码如下：</h6><p><img src="/2019/11/10/C%E8%AF%AD%E8%A8%80-10%E8%BF%9B%E5%88%B6%E4%B8%8E16%E8%BF%9B%E5%88%B6%E7%9A%84%E4%BA%92%E8%BD%AC/6.jpg" alt="6"></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>16进制转10进制</tag>
        <tag>10进制转16进制</tag>
        <tag>sprintf</tag>
        <tag>sscanf</tag>
      </tags>
  </entry>
  <entry>
    <title>Camera-摄像头工作原理（转载）</title>
    <url>/2019/11/09/Camera-%E6%91%84%E5%83%8F%E5%A4%B4%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>回想这工作的这几年，尝尽社会的辛酸艰难，从一开始什么都没有到30万，从30万到200万，从200万到1300万，不是炫耀，我只是想通过我自己的经历告诉我的朋友们「手机像素越高，拍的照片越清晰」</p>
</blockquote>
<a id="more"></a>

<h5 id="摄像头结构"><a href="#摄像头结构" class="headerlink" title="摄像头结构"></a>摄像头结构</h5><p><img src="/2019/11/09/Camera-%E6%91%84%E5%83%8F%E5%A4%B4%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/1.png" alt="1"></p>
<p><img src="/2019/11/09/Camera-%E6%91%84%E5%83%8F%E5%A4%B4%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/2.png" alt="2"></p>
<p>我初中的时候，有一次我考了年级第7名，学校奖励了 200块钱，我当时非常开心，第一时间就想去买一个照相机，我想把自己那时看到的画面都记录下来，可惜的是，我看上那个最便宜的也要两百多，然后我妈跟我说先把钱存她那里，等过阵子有钱了再给我买，然后，你可能想知道然后怎么了，然后就没有然后了，我最开始的照相机就是大学的时候，我哥给我买的那个大块头手机，铃声一响起来，一头熟睡的母猪都能被吵醒。</p>
<p>最开始的照相机是那种手动对焦的，就是转动马达让感光芯片能接收到最好的信号，俗称对焦。</p>
<p><img src="/2019/11/09/Camera-%E6%91%84%E5%83%8F%E5%A4%B4%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/3.png" alt="3"></p>
<h5 id="最原始的Camera成像原理"><a href="#最原始的Camera成像原理" class="headerlink" title="最原始的Camera成像原理"></a>最原始的Camera成像原理</h5><p>说起成像原理，我们不得不说小孔成像，就是有了小孔成像，我们才有了相机这么神奇的东西。</p>
<p>小孔成像是是比较古老的方式了，随着现在技术的发展，已经使用了新的方式替代小孔成像，因为小孔成像的孔很小，也造成了拍摄存在很多局限性。</p>
<p><img src="/2019/11/09/Camera-%E6%91%84%E5%83%8F%E5%A4%B4%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/4.png" alt="4"></p>
<h5 id="现代Camera-工作原理"><a href="#现代Camera-工作原理" class="headerlink" title="现代Camera 工作原理"></a>现代Camera 工作原理</h5><p>camera工作原理是外部光线穿过 lens 后， 经过 color filter 滤波后照射到 Sensor 面上， Sensor 将从 lens 上传导过来的光线转换为电信号，再通过内部的 AD 转换为数字信号。如果 Sensor 没有集 成 DSP，则通过 DVP 的方式传输到baseband，此时的数据格式是 RAW DATA。如果集成 了 DSP， RAW DATA 数据经过 AWB、 则 color matrix、 lens shading、 gamma、 sharpness、 AE 和 de-noise 处理（手机一般在cpu isp端做），后输出 YUV 或者 RGB 格式的数据。最后会由 CPU 送到 framebuffer 中进行显示，这样我们就看到 camera 拍摄到的景象了。</p>
<p><img src="/2019/11/09/Camera-%E6%91%84%E5%83%8F%E5%A4%B4%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/5.png" alt="5"></p>
<p>我们先用眼睛通过目镜确定当前拍摄的这个人是不是一个靓仔，然后呢，让这个靓仔做一个比较帅点的姿势，然后按下快门就，挡光板抬起，把光线照到感光器上，感光器是一个模拟图片，通过ADC转换数字信号，存储到存储芯片上。</p>
<p><img src="/2019/11/09/Camera-%E6%91%84%E5%83%8F%E5%A4%B4%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/6.png" alt="6"></p>
<h5 id="Camera硬件原理图"><a href="#Camera硬件原理图" class="headerlink" title="Camera硬件原理图"></a>Camera硬件原理图</h5><p>硬件原理图分析</p>
<p><img src="/2019/11/09/Camera-%E6%91%84%E5%83%8F%E5%A4%B4%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/7.png" alt="7"></p>
<p><strong>POWER:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VDD_CAMA28   ----2.8v   camera的模拟电压</span><br><span class="line">VDD_CAMD28   ----1.5v   camera的工作电压</span><br><span class="line">VDD_CAMIO28  ----2.8v   camera的GPIO口数字电压</span><br></pre></td></tr></table></figure>

<p><strong>OUTPUT:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CAM_DATA: camera的数据管脚。此数据脚可以输出的格式有YUV、RGB、JPEG</span><br><span class="line"></span><br><span class="line">CAM_VSYNC: camera的帧同步信号管脚。一个VYSNC信号结束表示一帧（即一个画面）的数据已经输出完毕</span><br><span class="line"></span><br><span class="line">CAM_HSYNC: camera行同步信号管脚。一个HSYNC信号结束表示一行的数据已经输出完毕</span><br><span class="line"></span><br><span class="line">CAM_PCLK: 像素同步信号管脚。一个PCLK信号结束表示一个数据已经输出完毕</span><br></pre></td></tr></table></figure>

<p><strong>INPUT:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CAM_PWDN:  camera的使能管脚，当camera处于PWDN模式时，一切对camera的操作都是无效的，因此，在RST之前，一定要将PWDN管脚置为normal模式</span><br><span class="line"></span><br><span class="line">CAM_RST:  camera的复位管脚。此方式为硬复位模式，一般管脚置为低，camera处于硬复位状态，camera的各个IO口恢复到出厂默认状态。只有在XCLK开启后，将RESET置为低，硬复位才有效，否则复位无效。</span><br><span class="line"></span><br><span class="line">CAM_MCLK:  camera工作时钟管脚。此管脚为主控提供camera的工作时钟</span><br><span class="line"></span><br><span class="line">CAM_I2C:  camera与主控的通信管脚 Camera主要的通信接口是i2c，数据传输是mipi</span><br></pre></td></tr></table></figure>
<p><strong>我们在软件调试时，camera大致流程：</strong></p>
<p>第一步，给sensor进行上电和输出时钟信号；</p>
<p>第二步，然后通过i2c进行通信，通过发送地址，cpu查找camera；</p>
<p>第三步，在打开camera时，通过i2c下发，对sensor寄存器进行适配和准备工作；</p>
<p>第四步，camera数据输出，通过mipi给到cpu端进行采集；</p>
<h5 id="Sensor类型"><a href="#Sensor类型" class="headerlink" title="Sensor类型"></a>Sensor类型</h5><h6 id="1-常见的摄像头传感器类型主要有两种"><a href="#1-常见的摄像头传感器类型主要有两种" class="headerlink" title="1. 常见的摄像头传感器类型主要有两种"></a>1. 常见的摄像头传感器类型主要有两种</h6><p><strong>CCD（Chagre Couled Device）</strong>，即电荷耦合器，目前被广泛应用于大部分数码相机上，这是一种特殊的半导体材料，它由大量独立的光敏元件组成，这些光敏元件通常按矩阵排列。光线透过镜头照射到CCD上，并转换成电荷，每个元件上的电荷量取决于其受到的光照强度。当摄影者按动快门时，CCD可将各个元件的信息传送到模/数转换器上，然后将模拟电信号转变为数字信号，数字信号再以一定的格式压缩后存入缓存内，这样就完成了数码相片的整个拍摄。</p>
<p><strong>CMOS（Complementary Metal-Oxide-Semiconductor）</strong>，即互补金属氧化物半导体，它在微处理器和闪存等半导体技术上占有重要的地位，也是一种可用来感受光线变化的半导体，其组成元素主要是硅和锗，通过CMOS上带负电和带正电的晶体管来实现基本功能。这两个互补效应所产生的电流即可被处理芯片记录和解读成影像。由于CMOS结构相对简单，与现有的大规模集成电路生产工艺相同，从而生产成本可以降低，理论上讲，CMOS的信号是以点为单位的电荷信号，CCD是以行为单位的电流信号，相比较而言，前者更为敏感、速度更快、更为省电。目前CMOS技术发展还不成熟，这种高质量的CMOS还只应用于一些专业的数码相机上，而在一些低档数码相机上常使用廉价低档的CMOS，成像质量一般比较差。所以目前要购买消费级数码相机的话，建议用户最好选择以CCD为影像传感器的产品</p>
<h6 id="2-图像采集数据的模式有两种"><a href="#2-图像采集数据的模式有两种" class="headerlink" title="2. 图像采集数据的模式有两种"></a>2. 图像采集数据的模式有两种</h6><p>Color Filter Array—CFA 图像传感器都采用一定的模式来采集图像数据，常用的有 BGR 模式和 CFA 模式。</p>
<p><strong>BGR 模式：</strong><br>BGR 模式是一种可直接进行显示和压缩等处理的图像数据模式，它由 R( 红)、G( 绿) 、B( 蓝) 三原色值来共同确定 1 个像素点，例如富士数码相机采用的 SUPER CCD 图像传感器就采用这种模式，其优点是图像传感器产生的图像数据无需插值就可直接进行显示等后续处理，图像效果最好，但是成本高，常用于专业相机中。</p>
<p><strong>CFA 模式：</strong><br>为了减少成本，缩小体积，市场上的数码相机大多采用 CFA 模式，即在像素阵列的表面覆盖一层彩色滤波阵列（Color Filter Array，CFA），彩色滤波阵列有多种，现在应用最广泛的是 Bayer 格式滤波阵列，满足 GRBG 规律，绿色像素数是红色或蓝色像素数的两倍，这是因为人眼对可见光光谱敏感度的峰值位于中波段，这正好对应着绿色光谱成分。在该模式下图像数据只用R, G, B三个值中的一个值来表示一个像素点，而缺失另外两个颜色值，这时得到的是一副马赛克图片，为了得到全彩色的图像，需要使用其周围像素点的色彩信息来估计缺失的另外两种颜色，这种处理叫做色彩插值。</p>
]]></content>
      <categories>
        <category>Camera</category>
      </categories>
      <tags>
        <tag>摄像头</tag>
      </tags>
  </entry>
  <entry>
    <title>cURL-04_基于libcurl库的开发</title>
    <url>/2019/11/06/cURL-04-%E5%9F%BA%E4%BA%8Elibcurl%E5%BA%93%E7%9A%84%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<blockquote>
<p>libcurl是一个简单易用的基于URL传输的客户端开发库，支持多种平台以及三十多种开发语言绑定。libcurl是线程安全的，兼容IPv6，功能强大且运行效率高，很多知名公司如Google、Adobe的产品都应用过libcurl。</p>
</blockquote>
<p>做libcurl开发，需要将静态库文件加到编译链接环境中，并且要dll动态运行库支持。</p>
<a id="more"></a>

<h5 id="1-关于curl-global-init-和curl-global-cleanup"><a href="#1-关于curl-global-init-和curl-global-cleanup" class="headerlink" title="1. 关于curl_global_init()和curl_global_cleanup()"></a>1. 关于curl_global_init()和curl_global_cleanup()</h5><p>libcurl提供了一组C语言API函数直接调用。首先需要提到的两个函数就是curl_global_init()和curl_global_cleanup()。</p>
<p>libcurl要用到一系列的全局常量，curl_global_init()函数就是初始化这些变量，并分配一些全局资源；curl_global_cleanup()则负责释放这些资源。因此一般情况下，在调用libcurl函数之前，先用curl_global_init(CURL_GLOBAL_ALL)做初始化，在调用完毕后，用curl_global_cleanup()退出。</p>
<p>需要注意的是，这些全局变量和资源并不是线程安全的，因此，在多线程应用的环境中，最好不要多次调用curl_global_init()和curl_global_cleanup()，调用其他函数并不会改变这些全局变量和资源。</p>
<h5 id="2-调用方式"><a href="#2-调用方式" class="headerlink" title="2. 调用方式"></a>2. 调用方式</h5><p>libcurl支持3种不同的接口调用方式，分别是”easy”、”multi”和”share”模式。</p>
<p>libcurl-easy是一组同步接口，函数都是curl_easy_*形式，这种模式调用curl_easy_perform()函数进行URL数据传输，直到传输完成函数才返回；</p>
<p>libcurl-multi是一组异步接口，函数都是curl_multi_*形式，调用curl_multi_perform()函数进行传输，但是每次调用只传一片数据，我们可以用select()函数控制多个下载任务进行同步下载，来实现在一个线程中同时下载多个文件；</p>
<p>libcurl-share允许在多线程中操作共享数据。下面以libcurl-easy为例讲一下libcurl的函数。</p>
<h6 id="1-CURL-curl-easy-init"><a href="#1-CURL-curl-easy-init" class="headerlink" title="1. CURL *curl_easy_init()"></a>1. CURL *curl_easy_init()</h6><blockquote>
<p>此函数需要最先被调用，返回CRUL easy句柄；后续其他函数调用都要用到这个句柄。如果没有调用curl_global_init()，该函数自动调用，但是考虑到线程安全的问题，最好自己调用curl_global_init()。</p>
</blockquote>
<h6 id="2-CURLcode-curl-easy-setopt-CURL-handle-CURLoption-option-parameter"><a href="#2-CURLcode-curl-easy-setopt-CURL-handle-CURLoption-option-parameter" class="headerlink" title="2. CURLcode curl_easy_setopt(CURL *handle, CURLoption option, parameter)"></a>2. CURLcode curl_easy_setopt(CURL *handle, CURLoption option, parameter)</h6><blockquote>
<p>所有参数和选项设置都是通过这个函数完成的，它告诉libcurl怎样去进行传输。参数handle即为curl_easy_init()返回的句柄，后面根据option的类型，设置相应的parameter值，该函数每次调用只能设置一个选项。</p>
</blockquote>
<p>这里只总结一下与下载有关的常用选项设置。</p>
<pre><code>CURLOPT_URL</code></pre><p>字符串类型，该选项设置要处理的URL地址，该选项是进行curl_easy_perform之前唯一必须要设置的选项。</p>
<pre><code>CURLOPT_COOKIE</code></pre><p>字符串类型，设置http头中的cookie信息。</p>
<pre><code>CURLOPT_COOKIEFILE</code></pre><p>字符串类型，同CURLOPT_COOKIE，不过cookie信息从文件中读取。</p>
<pre><code>CURLOPT_FOLLOWLOCATION  </code></pre><p>布尔值类型，该参数设置为非零值表示follow服务器返回的重定向信息。</p>
<pre><code>CURLOPT_POSTFIELDS</code></pre><p>字符串类型，提交http的post操作字符串数据。</p>
<pre><code>CURLOPT_TIMEOUT</code></pre><p>long数值类型，设置函数执行的最长时间，时间单位为s。</p>
<pre><code>CURLOPT_CONNECTTIMEOUT</code></pre><p>long数值类型，设置连接服务器最长时间，时间单位为s；当置为0时表示无限长。</p>
<pre><code>CURLOPT_MAX_RECV_SPEED_LARGE</code></pre><p>curl_off_t类型数据，指定下载过程中最大速度，单位bytes/s。</p>
<pre><code>CURLOPT_HEADERFUNCTION</code></pre><p>函数指针类型，该选项设置一个处理接收到的header数据的回调函数，函数原型为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size_t function( void *ptr, size_t size, size_t nmemb, void *stream)；</span><br></pre></td></tr></table></figure>
<p>其中，ptr指向接收到的header头数据，数据大小为size*nmemb，stream指向调用CURLOPT_WRITEHEADER选项设置的参数。该回调函数应返回实际处理的数据量大小，或者出错返回-1。</p>
<pre><code>CURLOPT_WRITEFUNCTION</code></pre><p>函数指针类型，该选项设置一个处理接收到的下载数据的回调函数，函数原型为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size_t function( void *ptr, size_t size, size_t nmemb, void *stream);</span><br></pre></td></tr></table></figure>
<p>其中，ptr指向接收到的数据，数据大小为size*nmemb，stream指向调用CURLOPT_WRITEDATA选项设置的参数。</p>
<p>如果函数指针置为NULL，则会调用默认的函数，将数据写入到由CURLOPT_WRITEDATA指定的FILE*中。</p>
<pre><code>CURLOPT_HTTPHEADER</code></pre><p>curl_slist结构体类型，该选项自定义请求头信息。</p>
<pre><code>CURLOPT_NOPROGRESS</code></pre><p>布尔值类型，设置该值为非零值关闭PHP为CRUL传输显示的进度条。</p>
<h6 id="3-void-curl-easy-reset-CURL-handle"><a href="#3-void-curl-easy-reset-CURL-handle" class="headerlink" title="3. void curl_easy_reset(CURL *handle )"></a>3. void curl_easy_reset(CURL *handle )</h6><p>重新初始化CURL句柄的选项设置。</p>
<h6 id="4-CURLcode-curl-easy-getinfo-CURL-curl-CURLINFO-info-…"><a href="#4-CURLcode-curl-easy-getinfo-CURL-curl-CURLINFO-info-…" class="headerlink" title="4. CURLcode curl_easy_getinfo(CURL *curl, CURLINFO info, … )"></a>4. CURLcode curl_easy_getinfo(CURL *curl, CURLINFO info, … )</h6><p>查询CRUL会话的内部信息，具体说明请参考curl自带文档。</p>
<h6 id="5-void-curl-easy-cleanup-CURL-handle"><a href="#5-void-curl-easy-cleanup-CURL-handle" class="headerlink" title="5. void curl_easy_cleanup(CURL * handle )"></a>5. void curl_easy_cleanup(CURL * handle )</h6><p>该函数与curl_easy_init函数成对出现，handle即为调用curl_easy_init返回的句柄。该函数在CURL会话结束退出时调用，之后handle无效。</p>
]]></content>
      <categories>
        <category>cURL</category>
      </categories>
      <tags>
        <tag>cURL</tag>
      </tags>
  </entry>
  <entry>
    <title>cURL-02_在命令行中使用cURL</title>
    <url>/2019/11/03/cURL-02-%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E4%BD%BF%E7%94%A8cURL/</url>
    <content><![CDATA[<h4 id="一、获取和安装-cURL-libcurl"><a href="#一、获取和安装-cURL-libcurl" class="headerlink" title="一、获取和安装 cURL/libcurl"></a>一、获取和安装 cURL/libcurl</h4><p>获取和安装 libcurl 非常简单，取决于您所运行的 Linux 发行版。如果运行的是 Ubuntu，您可以使用 apt-get轻松安装这些包。以下行演示了如何为 libcurl 安装 libcurl 和 Python 绑定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install libcurl3</span><br><span class="line">$ sudo apt-get install python-pycurl</span><br></pre></td></tr></table></figure>
<blockquote>
<p>apt-get实用工具确保该过程满足所有的依赖关系。</p>
</blockquote>
<a id="more"></a>

<h4 id="二、相对简单的用法"><a href="#二、相对简单的用法" class="headerlink" title="二、相对简单的用法"></a>二、相对简单的用法</h4><h5 id="1-从百度的网页服务器上获得该网站的主页："><a href="#1-从百度的网页服务器上获得该网站的主页：" class="headerlink" title="1. 从百度的网页服务器上获得该网站的主页："></a>1. 从百度的网页服务器上获得该网站的主页：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl http://www.baidu.com/</span><br></pre></td></tr></table></figure>
<p>如果要把这个网页保存下来，可以使用<code>-o</code>参数，这就相当于使用wget命令了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -o [文件名] www.baidu.com</span><br></pre></td></tr></table></figure>


<h5 id="2-自动跳转"><a href="#2-自动跳转" class="headerlink" title="2. 自动跳转"></a>2. 自动跳转</h5><p>有的网址是自动跳转的。使用<code>-L</code>参数，curl就会跳转到新的网址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -L www.baidu.com</span><br></pre></td></tr></table></figure>

<p>输入上面的命令，结果就自动跳转为<a href="http://www.baidu.com。" target="_blank" rel="noopener">www.baidu.com。</a></p>
<h5 id="3-显示头信息"><a href="#3-显示头信息" class="headerlink" title="3. 显示头信息"></a>3. 显示头信息</h5><p><code>-i</code>参数可以显示http response的头信息，连同网页代码一起。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -i www.baidu.com</span><br></pre></td></tr></table></figure>
<p><code>-I</code>参数则是只显示http response的头信息。</p>
<h5 id="4-显示通信过程"><a href="#4-显示通信过程" class="headerlink" title="4. 显示通信过程"></a>4. 显示通信过程</h5><p><code>-v</code>参数可以显示一次http通信的整个过程，包括端口连接和http request头信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -v www.baidu.com</span><br></pre></td></tr></table></figure>

<p>如果你觉得上面的信息还不够，那么下面的命令可以查看更详细的通信过程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl --trace output.txt www.baidu.com</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl --trace-ascii output.txt www.baidu.com</span><br></pre></td></tr></table></figure>
<p>运行后，请打开output.txt文件查看。</p>
<h5 id="5-发送表单信息"><a href="#5-发送表单信息" class="headerlink" title="5. 发送表单信息"></a>5. 发送表单信息</h5><p>发送表单信息有GET和POST两种方法。GET方法相对简单，只要把数据附在网址后面就行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl example.com/form.cgi?data=xxx</span><br></pre></td></tr></table></figure>
<p>POST方法必须把数据和网址分开，curl就要用到–data参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -X POST --data &quot;data=xxx&quot; example.com/form.cgi</span><br></pre></td></tr></table></figure>
<p>如果你的数据没有经过表单编码，还可以让curl为你编码，参数是<code>--data-urlencode</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -X POST--data-urlencode &quot;date=April 1&quot; example.com/form.cgi</span><br></pre></td></tr></table></figure>

<h5 id="6-HTTP动词"><a href="#6-HTTP动词" class="headerlink" title="6. HTTP动词"></a>6. HTTP动词</h5><p>curl默认的HTTP动词是GET，使用<code>-X</code>参数可以支持其他动词。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -X POST www.example.com</span><br><span class="line">$ curl -X DELETE www.example.com</span><br></pre></td></tr></table></figure>

<h5 id="7-文件上传"><a href="#7-文件上传" class="headerlink" title="7. 文件上传"></a>7. 文件上传</h5><p>假定文件上传的表单是下面这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form method=&quot;POST&quot; enctype=&apos;multipart/form-data&apos; action=&quot;upload.cgi&quot;&gt;</span><br><span class="line">&lt;input type=file name=upload&gt;</span><br><span class="line">&lt;input type=submit name=press value=&quot;OK&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>你可以用curl这样上传文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl --form upload=@localfilename --form press=OK [URL]</span><br></pre></td></tr></table></figure>

<h5 id="8-Referer字段"><a href="#8-Referer字段" class="headerlink" title="8. Referer字段"></a>8. Referer字段</h5><p>有时你需要在http request头信息中，提供一个referer字段，表示你是从哪里跳转过来的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl --referer http://www.example.com http://www.example.com</span><br></pre></td></tr></table></figure>

<h5 id="9-User-Agent字段"><a href="#9-User-Agent字段" class="headerlink" title="9. User Agent字段"></a>9. User Agent字段</h5><p>这个字段是用来表示客户端的设备信息。服务器有时会根据这个字段，针对不同设备，返回不同格式的网页，比如手机版和桌面版。</p>
<p>iPhone4的User Agent是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_0 like Mac OS X; en-us) AppleWebKit/532.9 (KHTML, like Gecko) Version/4.0.5 Mobile/8A293 Safari/6531.22.7</span><br></pre></td></tr></table></figure>
<p>curl可以这样模拟：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl --user-agent &quot;[User Agent]&quot; [URL]</span><br></pre></td></tr></table></figure>

<h5 id="10-cookie"><a href="#10-cookie" class="headerlink" title="10. cookie"></a>10. cookie</h5><p>使用<code>--cookie</code>参数，可以让curl发送cookie。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl --cookie &quot;name=xxx&quot; www.example.com</span><br></pre></td></tr></table></figure>
<p>至于具体的cookie的值，可以从http response头信息的<code>Set-Cookie</code>字段中得到。</p>
<p><code>-c cookie-file</code>可以保存服务器返回的cookie到文件，<code>-b cookie-file</code>可以使用这个文件作为cookie信息，进行后续的请求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -c cookies http://example.com</span><br><span class="line">$ curl -b cookies http://example.com</span><br></pre></td></tr></table></figure>

<h5 id="11-增加头信息"><a href="#11-增加头信息" class="headerlink" title="11. 增加头信息"></a>11. 增加头信息</h5><p>有时需要在http request之中，自行增加一个头信息。<code>--header</code>参数就可以起到这个作用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl --header &quot;Content-Type:application/json&quot; http://example.com</span><br></pre></td></tr></table></figure>
<h5 id="12-HTTP认证"><a href="#12-HTTP认证" class="headerlink" title="12. HTTP认证"></a>12. HTTP认证</h5><p>有些网域需要HTTP认证，这时curl需要用到<code>--user</code>参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl --user name:password example.com</span><br></pre></td></tr></table></figure>




<h5 id="13-cURL还有很多命令行操作，这里就不作陈诉了。"><a href="#13-cURL还有很多命令行操作，这里就不作陈诉了。" class="headerlink" title="13. cURL还有很多命令行操作，这里就不作陈诉了。"></a>13. cURL还有很多命令行操作，这里就不作陈诉了。</h5>]]></content>
      <categories>
        <category>cURL</category>
      </categories>
      <tags>
        <tag>cURL</tag>
      </tags>
  </entry>
  <entry>
    <title>cURL-03-cURL的几种语言支持</title>
    <url>/2019/11/03/cURL-03-cURL%E7%9A%84%E5%87%A0%E7%A7%8D%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81/</url>
    <content><![CDATA[<h5 id="一、基于-C-的-HTTP-客户端"><a href="#一、基于-C-的-HTTP-客户端" class="headerlink" title="一、基于 C 的 HTTP 客户端"></a>一、基于 C 的 HTTP 客户端</h5><p>C API 在 libcurl 功能上提供了两个 API。easy 接口是一个简单的同步 API（意味着当您使用请求调用 libcurl 时，将能够满足您的请求，直到完成或发生错误）。多接口可以进一步控制 libcurl，您的应用程序可以执行多个同步传输，并控制 libcurl 何时何地移动数据。</p>
<p>该示例使用 easy 接口。该 API 还能控制数据移动过程（使用回调），但正如其名称所示，使用起来非常简单。下面请看HTTP 的 C 语言示例,使用 libcurl easy 接口的 C HTTP 客户端。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">#include &lt;string.h&gt; </span><br><span class="line">#include &lt;curl/curl.h&gt; </span><br><span class="line"> </span><br><span class="line">#define MAX_BUF     65536 </span><br><span class="line"> </span><br><span class="line">char wr_buf[MAX_BUF+1]; </span><br><span class="line">int  wr_index; </span><br><span class="line"> </span><br><span class="line">/* </span><br><span class="line">* Write data callback function (called within the context of </span><br><span class="line">* curl_easy_perform. </span><br><span class="line">*/ </span><br><span class="line">size_t write_data( void *buffer, size_t size, size_t nmemb, void *userp ) </span><br><span class="line">&#123; </span><br><span class="line"> int segsize = size * nmemb; </span><br><span class="line"> </span><br><span class="line"> /* Check to see if this data exceeds the size of our buffer. If so, </span><br><span class="line">  * set the user-defined context value and return 0 to indicate a </span><br><span class="line">  * problem to curl. </span><br><span class="line">  */ </span><br><span class="line"> if ( wr_index + segsize &gt; MAX_BUF ) &#123; </span><br><span class="line">   *(int *)userp = 1; </span><br><span class="line">   return 0; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> /* Copy the data from the curl buffer into our buffer */ </span><br><span class="line"> memcpy( (void *)&amp;wr_buf[wr_index], buffer, (size_t)segsize ); </span><br><span class="line"> </span><br><span class="line"> /* Update the write index */ </span><br><span class="line"> wr_index += segsize; </span><br><span class="line"> </span><br><span class="line"> /* Null terminate the buffer */ </span><br><span class="line"> wr_buf[wr_index] = 0; </span><br><span class="line"> </span><br><span class="line"> /* Return the number of bytes received, indicating to curl that all is okay */ </span><br><span class="line"> return segsize; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/* </span><br><span class="line">* Simple curl application to read the index.html file from a Web site. </span><br><span class="line">*/ </span><br><span class="line">int main( void ) </span><br><span class="line">&#123; </span><br><span class="line"> CURL *curl; </span><br><span class="line"> CURLcode ret; </span><br><span class="line"> int  wr_error; </span><br><span class="line"> </span><br><span class="line"> wr_error = 0; </span><br><span class="line"> wr_index = 0; </span><br><span class="line"> </span><br><span class="line"> /* First step, init curl */ </span><br><span class="line"> curl = curl_easy_init(); </span><br><span class="line"> if (!curl) &#123; </span><br><span class="line">   printf(&quot;couldn&apos;t init curl\n&quot;); </span><br><span class="line">   return 0; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> /* Tell curl the URL of the file we&apos;re going to retrieve */ </span><br><span class="line"> curl_easy_setopt( curl, CURLOPT_URL, &quot;www.exampledomain.com&quot; ); </span><br><span class="line"> </span><br><span class="line"> /* Tell curl that we&apos;ll receive data to the function write_data, and </span><br><span class="line">  * also provide it with a context pointer for our error return. </span><br><span class="line">  */ </span><br><span class="line"> curl_easy_setopt( curl, CURLOPT_WRITEDATA, (void *)&amp;wr_error ); </span><br><span class="line"> curl_easy_setopt( curl, CURLOPT_WRITEFUNCTION, write_data ); </span><br><span class="line"> </span><br><span class="line"> /* Allow curl to perform the action */ </span><br><span class="line"> ret = curl_easy_perform( curl ); </span><br><span class="line"> </span><br><span class="line"> printf( &quot;ret = %d (write_error = %d)\n&quot;, ret, wr_error ); </span><br><span class="line"> </span><br><span class="line"> /* Emit the page if curl indicates that no errors occurred */ </span><br><span class="line"> if ( ret == 0 ) printf( &quot;%s\n&quot;, wr_buf ); </span><br><span class="line"> </span><br><span class="line"> curl_easy_cleanup( curl ); </span><br><span class="line"> </span><br><span class="line"> return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最上方是必需的 include文件，包括 cURL 根文件。接下来，定义了两个用于传输的变量。第一个变量是 wr_buf，表示将在其中写入传入数据的缓冲区。wr_index表示缓冲区的当前写入索引。</p>
<p>转到 main函数，该函数使用 easy API 进行设置。所有 cURL 调用都通过维护特定请求状态的句柄进行操作。这称为 CURL指针引用。本例还创建一个特殊的返回码，称为 CURLcode。在使用任何 libcurl 函数之前，您需要调用 curl_easy_init获取 CURL句柄。接下来，注意 curl_easy_setopt调用的数量。它们为特定的操作配置句柄。对于这些调用，您提供句柄、命令和选项。首先，本例使用 CURLOPT_URL指定要获取的 URL。然后，它使用 CURL_WRITEDATA提供一个上下文变量（在本例中，它是内部的 write 错误变量）。最后，它使用 CURLOPT_WRITEFUNCTION指定数据可用时应该调用的函数。在启动 API 之后，API 将使用它读取的数据多次调用该函数。</p>
<p>要开始传输，调用 curl_easy_perform。它的工作是根据之前的配置执行传输。调用该函数时，在完成传输或发生错误之前该函数不会返回。main的最后一步是提交返回状态，提交页面读取，最后使用 curl_easy_cleanup清除（当使用句柄执行完操作后）。</p>
<p>现在看看 write_data函数。该函数是针对特定操作收到数据时调用的回调。注意，当您从网站读取数据时，将写入该数据（write_data）。将向回调提供一个缓冲区（包含可用数据）、成员数量和大小（缓冲中可用数据总量）、上下文指针。第一个任务是确保缓冲区（wr_buf）的空间足以写入数据。如果不够，它将设置上下文指针并返回 0，表示出现问题。否则，它将 cURL 缓冲区的数据复制到您的缓冲区，并增加索引，指向要写入的下一个位置。本例还终止字符串，稍后可以对其使用 printf。最后，它返回 libcurl 操作的字节数量。这将告诉 libcurl 数据被提取，它也可以丢弃该数据。这就是从网站将文件读取到内存的相对简单的方法。</p>
<h5 id="二、基于-Python-的-HTTP-客户端"><a href="#二、基于-Python-的-HTTP-客户端" class="headerlink" title="二、基于 Python 的 HTTP 客户端"></a>二、基于 Python 的 HTTP 客户端</h5><p>Python 是一种非常有用的面向对象的脚本语言，在原型化和构建生产软件方面非常突出。示例假设您较熟悉 Python，但使用不多，因此不要期望过高。</p>
<p>这个简单的 Python HTTP 客户端使用 pycurl，如下：</p>
<p>使用 libcurl 的 pycurl接口的 Python HTTP 客户端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys </span><br><span class="line">import pycurl </span><br><span class="line"> </span><br><span class="line">wr_buf = &apos;&apos;</span><br><span class="line"> </span><br><span class="line">def write_data( buf ): </span><br><span class="line">    global wr_buf </span><br><span class="line">    wr_buf += buf </span><br><span class="line"> </span><br><span class="line">def main(): </span><br><span class="line">    c = pycurl.Curl() </span><br><span class="line">    c.setopt( pycurl.URL, &apos;http://www.exampledomain.com&apos; ) </span><br><span class="line">    c.setopt( pycurl.WRITEFUNCTION, write_data ) </span><br><span class="line"> </span><br><span class="line">    c.perform() </span><br><span class="line"> </span><br><span class="line">    c.close() </span><br><span class="line"> </span><br><span class="line">main() </span><br><span class="line">sys.stdout.write(wr_buf)</span><br></pre></td></tr></table></figure>

<p>这比 C 语言版本简单的多。它首先导入必需的模块（用于标准系统的 sys和 pycurl模块）。接下来，它定义 write 缓冲区（wr_buf）。像 C 程序中一样，声明一个 write_data函数。注意，该函数只有一个参数：从 HTTP 服务器中读取的数据缓冲区。我将该缓冲区连接到全局 write 缓冲区。main函数首先创建一个 Curl句柄，然后使用 setopt方法为传输定义 URL和 WRITEFUNCTION。它调用 perform方法启动传输并关闭句柄。最后，它调用 main函数，并将 write 缓冲区提交到 stdout。注意，在这种情况下，不需要错误上下文指针，因为使用了 Python 字符串连接，这就是说您不会使用大小固定的字符串。</p>
]]></content>
      <categories>
        <category>cURL</category>
      </categories>
      <tags>
        <tag>cURL</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言-sscanf()函数使用详解</title>
    <url>/2019/11/03/C%E8%AF%AD%E8%A8%80-sscanf-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="一、描述："><a href="#一、描述：" class="headerlink" title="一、描述："></a>一、描述：</h4><p>sscanf通常被用来解析并转换字符串，其格式定义灵活多变，可以实现很强大的字符串解析功能。</p>
<p>sscanf的原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int sscanf(const char *str, const char *format, ...);</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>str:待解析的字符串;</p>
<p>format:字符串格式描述;</p>
<p>其后是一序列数目不定的指针参数，存储解析后的数据.</p>
<h4 id="二、示例用法："><a href="#二、示例用法：" class="headerlink" title="二、示例用法："></a>二、示例用法：</h4><h5 id="sscanf的基本用法"><a href="#sscanf的基本用法" class="headerlink" title="sscanf的基本用法"></a>sscanf的基本用法</h5><h6 id="整形数转换"><a href="#整形数转换" class="headerlink" title="整形数转换"></a>整形数转换</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int year, month, day;</span><br><span class="line"></span><br><span class="line">int converted = sscanf(&quot;20191103&quot;, &quot;%04d%02d%02d&quot;, &amp;year, &amp;month, &amp;day);</span><br><span class="line">printf(&quot;converted=%d, year=%d, month=%d, day=%d/n&quot;, converted, year, month, day);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">converted=3, year=2019, month=11, day=03</span><br></pre></td></tr></table></figure>

<p>“%04d%02d%02d”是用来解析字符串的格式，%表示格式转换的开始，d表示转换为一个整数，04作为d的修饰，表示这是一个长度为4位的整数，不足4位时以0补齐。</p>
<p>例子返回结果等于3，表示有3个数据成功转换，转换成功数目同时取决于被解析的字符串以及其转换格式，如果我们把例子中的格式改为”%04d%02d”，那么sscanf将只返回2，day的数值不会被sscanf更改。</p>
<h6 id="浮点数转换"><a href="#浮点数转换" class="headerlink" title="浮点数转换"></a>浮点数转换</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double longitude, latitude;</span><br><span class="line">int converted = sscanf(&quot;113.123456789 31.123456789&quot;, &quot;%lf %lf&quot;, &amp;longitude, &amp;latitude);</span><br><span class="line">printf(&quot;converted=%d, longitude=%.9lf, latitude=%lf/n&quot;, converted, longitude, latitude);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">converted=2, longitude=113.123456789, latitude=31.123457</span><br></pre></td></tr></table></figure>
<p>sscanf的格式字符串中，f表示这是一个浮点数，其修饰词l表示这是一个double的浮点数。</p>
<h5 id="sscanf的高级用法"><a href="#sscanf的高级用法" class="headerlink" title="sscanf的高级用法"></a>sscanf的高级用法</h5><h6 id="数字-字符串"><a href="#数字-字符串" class="headerlink" title="数字+字符串"></a>数字+字符串</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char str[32] = &quot;&quot;;</span><br><span class="line">sscanf(&quot;123456abcdedf&quot;, &quot;%31[0-9]&quot;, str);</span><br><span class="line">printf(&quot;str=%s/n&quot;, str);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str=123456</span><br></pre></td></tr></table></figure>
<p>上面的格式中，[0-9]表示这是一个仅包含0-9这几个字符的字符串，==前面使用数字31修饰词表示这个字符串缓冲区的最大长度(这也是sscanf最为人诟病的地方，很容易出现缓冲区溢出错误，实际上sscanf是可以避免出现缓冲区溢出的，只要在书写任何字符串解析的格式时，注意加上其缓冲区尺寸的限制)。==</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char str[32] = &quot;&quot;;</span><br><span class="line">sscanf(&quot;123456abcdedf&quot;, &quot;%31[0-9a-z]&quot;, str);</span><br><span class="line">printf(&quot;str=%s/n&quot;, str);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str=123456abcdedf</span><br></pre></td></tr></table></figure>
<p>在格式[]中增加了a-z的描述。</p>
<h6 id="使用-示例："><a href="#使用-示例：" class="headerlink" title="使用^示例："></a>使用^示例：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char str[32] = &quot;&quot;;</span><br><span class="line">sscanf(&quot;123456abcdedf&quot;, &quot;%31[^a-z]&quot;, str);</span><br><span class="line">printf(&quot;str=%s/n&quot;, str);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str=123456</span><br></pre></td></tr></table></figure>
<p>在[]中增加^表示相反的意思，上面的[^a-z]表示一个不包含任何a-z之间的字符串。</p>
<h6 id="使用-的例子："><a href="#使用-的例子：" class="headerlink" title="使用*的例子："></a>使用*的例子：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char str[32] = &quot;&quot;;</span><br><span class="line">int ret = sscanf(&quot;123456abcdedf&quot;, &quot;%*[0-9]%31[a-z]&quot;, str);</span><br><span class="line">printf(&quot;ret=%d, str=%s/n&quot;,ret, str);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ret=1, str=abcdedf</span><br></pre></td></tr></table></figure>
<p>加上*修饰表示一个被忽略的数据，同时也不需要为它准备空间存放解析结果。如上面的例子中，我们就只使用了str一个参数存放%31[a-z]的解析结果，而sscanf也只返回1，表示只解析了一个数据。</p>
<p>掌握了[], ^, *如何使用后，我们会发现sscanf原来是一个如此强大的工具，很多我们原先认为必须使用正则表达式的地方，很可能使用sscanf就可以实现。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>sscanf</tag>
        <tag>字符串拆分</tag>
        <tag>格式转换</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 通过系统函数设置系统时间</title>
    <url>/2019/11/03/linux-%E9%80%9A%E8%BF%87%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h5 id="一、描述："><a href="#一、描述：" class="headerlink" title="一、描述："></a>一、描述：</h5><p>通过settimeofday()函数来设置系统时间，这个函数设置的精度可以精确到微秒。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">int settimeofday(const struct timeval *tv , const struct timezone *tz);</span><br><span class="line"></span><br><span class="line">struct timeval &#123;</span><br><span class="line">    time_t      tv_sec;     /* seconds */</span><br><span class="line">    suseconds_t tv_usec;    /* microseconds */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct timezone &#123;</span><br><span class="line">    int tz_minuteswest;     /* minutes west of Greenwich */</span><br><span class="line">    int tz_dsttime;         /* type of DST correction */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tz参数为时区，时区结构中tz_dsttime在linux中不支持，应该置为0，通常将参数tz设置为NULL，表示使用当前系统的时区。该函数是glib中的，但在mingw中没有实现。</p>
</blockquote>
<a id="more"></a>

<h5 id="二、代码演示："><a href="#二、代码演示：" class="headerlink" title="二、代码演示："></a>二、代码演示：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/time.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int SetSystemTime(char *dt)</span><br><span class="line">&#123;</span><br><span class="line">    struct tm rtc_time;</span><br><span class="line">    struct tm _tm;</span><br><span class="line">    struct timeval tv;</span><br><span class="line">    time_t timep;</span><br><span class="line">    sscanf(dt, &quot;%d-%d-%d %d:%d:%d&quot;, &amp;rtc_time.tm_year,</span><br><span class="line">		&amp;rtc_time.tm_mon, &amp;rtc_time.tm_mday,&amp;rtc_time.tm_hour,</span><br><span class="line">        &amp;rtc_time.tm_min, &amp;rtc_time.tm_sec);</span><br><span class="line">    _tm.tm_sec = rtc_time.tm_sec;</span><br><span class="line">    _tm.tm_min = rtc_time.tm_min;</span><br><span class="line">    _tm.tm_hour = rtc_time.tm_hour;</span><br><span class="line">    _tm.tm_mday = rtc_time.tm_mday;</span><br><span class="line">    _tm.tm_mon = rtc_time.tm_mon - 1;</span><br><span class="line">    _tm.tm_year = rtc_time.tm_year - 1900;</span><br><span class="line"> </span><br><span class="line">    timep = mktime(&amp;_tm);</span><br><span class="line">    tv.tv_sec = timep;</span><br><span class="line">    tv.tv_usec = 0;</span><br><span class="line">    // if(settimeofday (&amp;tv, (struct timezone *) 0) &lt; 0)</span><br><span class="line">	if(settimeofday (&amp;tv, NULL) &lt; 0)	</span><br><span class="line">    &#123;</span><br><span class="line">		printf(&quot;Set system datatime error!\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	printf(&quot;现在的时间是:&quot;);</span><br><span class="line">	fflush(stdout);</span><br><span class="line">	system(&quot;date&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  SetSystemTime(&quot;2019-11-03 16:30:30&quot;);//2019-11-01 21:19:05  </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="三、效果如下："><a href="#三、效果如下：" class="headerlink" title="三、效果如下："></a>三、效果如下：</h5><p><img src="/2019/11/03/linux-%E9%80%9A%E8%BF%87%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/1.jpg" alt="1"><br>注意：</p>
<ol>
<li>调用settimeofday函数时必须要在root权限下执行。</li>
<li>设置时间之前最好把虚拟机网络断开。</li>
</ol>
]]></content>
      <categories>
        <category>系统函数&amp;库函数</category>
      </categories>
      <tags>
        <tag>系统时间</tag>
      </tags>
  </entry>
  <entry>
    <title>cURL-01_基本概念与了解</title>
    <url>/2019/11/03/cURL-01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<h5 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h5><p>cURL（Client URL Library Functions）is a command line tool for transfering data with URL syntax（使用 URL 语法传输数据的命令行工具），即客户端向服务器请求资源的工具。</p>
<p><img src="/2019/11/03/cURL-01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BA%86%E8%A7%A3/1.png" alt="1"></p>
<a id="more"></a>

<p>curl库是C语言封装的一个强大的库，使用curl比封装socket更加方便。</p>
<p>cURL 最初的设计初衷是使用不同的协议（比如 FTP、HTTP、SCP 等）在端点之间移动文件。它最初是一个命令行实用工具，但现在也是一个绑定了 30 多种语言的库。因此，现在不仅可以通过 shell 使用 cURL，您还可以构建合并了这个重要功能的应用程序。libcurl 库也是可以移植的，支持 Linux®、IBM®AIX®操作系统、BSD、Solaris 以及许多其他 UNIX®变体。</p>
<p>cURL是一个命令行工具和库，实现了各种客户端协议。它支持 12 种以上的协议，包括 FTP、HTTP、Telnet 以及其他安全变体。许多平台上都能找到 cURL，包括 Linux、AIX、BSD 和 Solaris，它支持 30 多种语言。</p>
<p>PycURL是 libcurl API 之上的一个薄层，PycURL 速度非常快。使用 PycURL，您可以使用 libcurl 库开发 Python 应用程序。</p>
<p>关于cURL,<a href="https://curl.haxx.se/" target="_blank" rel="noopener">这里</a>有更详细的介绍。</p>
<h5 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h5><p>1.网页资源（例如编写网页爬虫）</p>
<p>2.WebService 数据接口资源（比如动态获取接口数据，比如天气、号码归属地等）</p>
<p>3.FTP 服务器里的文件资源（下载 FTP 服务器里面的文件）</p>
<p>4.其他资源（所有网络上的资源都可以使用 cURL 访问和下载到）</p>
<h5 id="三、延伸-为什么要用cURL"><a href="#三、延伸-为什么要用cURL" class="headerlink" title="三、延伸(为什么要用cURL)"></a>三、延伸(为什么要用cURL)</h5><p>开发 HTTP 和 FTP 之类依赖于应用层协议的应用程序并不复杂，但也不简单。进一步讲，这不是应用程序的重点，因为大部分情况下，协议之上的内容才是真正重要的内容。因此，libcurl 引起了许多人的兴趣，因为它的重点是应用程序而不是开发的各个方面。注意，很少有应用程序开发自己的 TCP/IP 堆栈，所以老话重提：尽可能重用以最小化开发安排并提高应用程序的可靠性。</p>
<h6 id="关于Web-协议"><a href="#关于Web-协议" class="headerlink" title="关于Web 协议"></a>关于Web 协议</h6><p>如今构建应用程序已与过去大不相同。现在的应用程序需要能够通过网络或 Internet 进行通讯（提供人类可用的网络 API 或接口），还要能支持用户脚本化以提高灵活性。现代应用程序通常使用 HTTP 公开 Web 接口，并通过 Simple Mail Transport Protocol (SMTP) 提供警告通知。这些协议允许您将 Web 浏览器指向设备以获得配置或状态信息，并从设备或常用的电子邮件客户端接收标准电子邮件（分别通过 HTTP 和 SMTP）。</p>
<p>这些 Web 服务通常构建在网络堆栈的套接字层上（见图 1）。套接字层实现一个最先出现在 Berkeley Software Distribution (BSD) 操作系统上的 API，并提取底层传输和网络层协议的详细信息。</p>
<p>图 1. 网络堆栈和 libcurl</p>
<p><img src="/2019/11/03/cURL-01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BA%86%E8%A7%A3/2.gif" alt="2"></p>
<p>Web 服务发生在客户端和服务器之间的协议对话中。在 HTTP 上下文中，服务器是终端设备，客户端是位于端点上的浏览器。对于 SMTP，服务器是邮件网关或端点用户，客户端是终端设备。在某些情况下，协议对话发生在两个步骤（请求和响应）中，但另一些情况下，需要协商和通讯的通信量更多。这种协商可能增加了大量复杂性，这可以通过 API 进行抽象，比如 libcurl。</p>
]]></content>
      <categories>
        <category>cURL</category>
      </categories>
      <tags>
        <tag>cURL</tag>
      </tags>
  </entry>
  <entry>
    <title>工具-虚拟机VMware与Windows主机共享文件介绍</title>
    <url>/2019/11/03/%E5%B7%A5%E5%85%B7-%E8%99%9A%E6%8B%9F%E6%9C%BAVMware%E4%B8%8EWindows%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h5 id="一、设置共享文件夹功能"><a href="#一、设置共享文件夹功能" class="headerlink" title="一、设置共享文件夹功能"></a>一、设置共享文件夹功能</h5><p>虚拟机VMware提供了在宿主机与虚拟机系统之间交换文件的共享文件夹（Shared Folder）功能。不管虚拟机操作系统是Linux还是Windows都可用。你可以通过设置（ Settings）&gt;共享文件夹（Shared Folder）来设置。但是此功能选项必须要安装虚拟机工具（VMware Tools），否则如下所示，否则该功能选项不可用。</p>
<p><img src="/2019/11/03/%E5%B7%A5%E5%85%B7-%E8%99%9A%E6%8B%9F%E6%9C%BAVMware%E4%B8%8EWindows%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/1.jpg" alt="1"></p>
<a id="more"></a>
<h5 id="二、安装虚拟机工具步骤如下所示："><a href="#二、安装虚拟机工具步骤如下所示：" class="headerlink" title="二、安装虚拟机工具步骤如下所示："></a>二、安装虚拟机工具步骤如下所示：</h5><h6 id="1-在对应虚拟机的设置选项（Settings-下，为虚拟机光驱指定虚拟机系统的镜像文件。"><a href="#1-在对应虚拟机的设置选项（Settings-下，为虚拟机光驱指定虚拟机系统的镜像文件。" class="headerlink" title="1. 在对应虚拟机的设置选项（Settings)下，为虚拟机光驱指定虚拟机系统的镜像文件。"></a>1. 在对应虚拟机的设置选项（Settings)下，为虚拟机光驱指定虚拟机系统的镜像文件。</h6><p>注意：在执行下面步骤前，必须确保虚拟机的电源开启、虚拟机系统正在运行。</p>
<p><img src="/2019/11/03/%E5%B7%A5%E5%85%B7-%E8%99%9A%E6%8B%9F%E6%9C%BAVMware%E4%B8%8EWindows%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/2.png" alt="2"></p>
<h6 id="2-在VM下选择”Install-VMware-Tools”"><a href="#2-在VM下选择”Install-VMware-Tools”" class="headerlink" title="2. 在VM下选择”Install VMware Tools”."></a>2. 在VM下选择”Install VMware Tools”.</h6><p><img src="/2019/11/03/%E5%B7%A5%E5%85%B7-%E8%99%9A%E6%8B%9F%E6%9C%BAVMware%E4%B8%8EWindows%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/3.png" alt="3"></p>
<ol start="3">
<li>然后安装虚拟机组件工具，详细步骤如下所示：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@DB-Server ~]# cd /mnt</span><br><span class="line">[root@DB-Server mnt]# mkdir cdrom</span><br><span class="line">[root@DB-Server mnt]# mount /dev/cdrom  /mnt/cdrom</span><br><span class="line">[root@DB-Server mnt]# cd /mnt/cdrom</span><br><span class="line">[root@DB-Server cdrom]# cp  VMwareTools-8.8.2-590212.tar.gz /tmp</span><br><span class="line">[root@DB-Server cdrom]#tar xz</span><br><span class="line">[root@DB-Server tmp]# ls</span><br><span class="line">gconfd-root     orbit-root           VMwareTools-8.8.2-590212.tar.gz</span><br><span class="line">keyring-qO15Cg  ssh-EWUeHQ4064       vmware-tools-distrib</span><br><span class="line">mapping-root    virtual-root.9mZzaq</span><br><span class="line">[root@DB-Server tmp]# cd vmware-tools-distrib/</span><br><span class="line">[root@DB-Server vmware-tools-distrib]# ls</span><br><span class="line">bin  doc  etc  FILES  INSTALL  installer  lib  vmware-install.pl</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[root@DB-Server vmware-tools-distrib]# ./vmware-install.pl </span><br><span class="line">A previous installation of VMware Tools has been detected.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">之后直接安装即可。</span><br></pre></td></tr></table></figure>
安装完成后重启虚拟机</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title>工具-Source Insight 使用技巧整理</title>
    <url>/2019/11/03/%E5%B7%A5%E5%85%B7-Source-Insight-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h4 id="通用设置"><a href="#通用设置" class="headerlink" title="通用设置"></a>通用设置</h4><p>Options - File Type Options:</p>
<ul>
<li>显示行号：勾选Show line mumbers</li>
<li>选中自动高亮：勾选Hightlight references to selected sysmbol</li>
<li>转换tab成空格：勾选Expand tabs to spaces，设置Tab width：4<br><img src="/2019/11/03/%E5%B7%A5%E5%85%B7-Source-Insight-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/1.png" alt="1"></li>
</ul>
<a id="more"></a>
<p><strong>高亮选中符号：</strong><br>F8</p>
<p><strong>代码折叠：</strong><br>View –&gt; Show Outlining </p>
<p><strong>代码默认字体大小：</strong><br>Ctrl + 滑动鼠标滑轮，可以增大缩小代码字体大小</p>
<blockquote>
<p>对所有代码文件字体都生效，步骤如：<br>Preferences –&gt; File Type Options -&gt; Screen Font<br>Preferences –&gt; Languages –&gt; File Types –&gt; Screen Font</p>
</blockquote>
<p><strong>只为主界面导入配色方案（不是全局，全局在Options-&gt;Load Configuration..）</strong></p>
<ol>
<li>Options –&gt; Style properties -&gt; Load</li>
<li>背景色修改： Options –&gt; Preferences –&gt;  Colors –&gt; Window Background </li>
<li>字体修改：在需要修改的词处点击，选择style Properties 会自动对应到需要修改的词语类型，然后直接修改颜色即可。</li>
</ol>
<p><strong>替换：</strong><br>Ctrl + h<br><strong>查找：</strong><br>Ctrl + f<br><strong>全局查找：</strong><br>Ctrl + /<br><strong>向上搜索</strong><br>Ctrl + F3<br><strong>向下搜索</strong><br>Ctrl + F4<br><strong>跳转到行：</strong><br>F5<br><strong>跳转到定义：</strong><br>Ctrl + 鼠标左键</p>
<h4 id="显示中文乱码"><a href="#显示中文乱码" class="headerlink" title="显示中文乱码"></a>显示中文乱码</h4><p>File - Reload As Encoding - GB2312</p>
<p><img src="/2019/11/03/%E5%B7%A5%E5%85%B7-Source-Insight-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/2.png" alt="2"></p>
<h4 id="添加注释快捷键"><a href="#添加注释快捷键" class="headerlink" title="添加注释快捷键"></a>添加注释快捷键</h4><blockquote>
<p>添加一些配置文件宏，比如：注释掉代码：单行注释、多行注释，将选中内容注释掉；在一行代码的前、后添加注释性文字等。</p>
</blockquote>
<h5 id="操作步骤："><a href="#操作步骤：" class="headerlink" title="操作步骤："></a>操作步骤：</h5><p>打开Projcet-&gt;Open project，选择base，可以看到utils.em文件，将下列宏添加到该文件中，并在其他工程里加入该文件，在上面介绍的快捷键添加方式里找到该宏并自定义快捷键。</p>
<h5 id="单行、多行注释："><a href="#单行、多行注释：" class="headerlink" title="单行、多行注释："></a>单行、多行注释：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">macro MultiLineComment()  </span><br><span class="line">&#123;  </span><br><span class="line">    hwnd = GetCurrentWnd()  </span><br><span class="line">    selection = GetWndSel(hwnd)  </span><br><span class="line">    LnFirst = GetWndSelLnFirst(hwnd)      //取首行行号  </span><br><span class="line">    LnLast = GetWndSelLnLast(hwnd)      //取末行行号  </span><br><span class="line">    hbuf = GetCurrentBuf()  </span><br><span class="line">   </span><br><span class="line">    if(GetBufLine(hbuf, 0) == &quot;//magic-number:tph85666031&quot;)&#123;  </span><br><span class="line">        stop  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    Ln = Lnfirst  </span><br><span class="line">    buf = GetBufLine(hbuf, Ln)  </span><br><span class="line">    len = strlen(buf)  </span><br><span class="line">   </span><br><span class="line">    while(Ln &lt;= Lnlast) &#123;  </span><br><span class="line">        buf = GetBufLine(hbuf, Ln)  //取Ln对应的行  </span><br><span class="line">        if(buf == &quot;&quot;)&#123;                    //跳过空行  </span><br><span class="line">            Ln = Ln + 1  </span><br><span class="line">            continue  </span><br><span class="line">        &#125;  </span><br><span class="line">   </span><br><span class="line">        if(StrMid(buf, 0, 1) == &quot;/&quot;) &#123;       //需要取消注释,防止只有单字符的行  </span><br><span class="line">            if(StrMid(buf, 1, 2) == &quot;/&quot;)&#123;  </span><br><span class="line">                PutBufLine(hbuf, Ln, StrMid(buf, 2, Strlen(buf)))  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">   </span><br><span class="line">        if(StrMid(buf,0,1) != &quot;/&quot;)&#123;          //需要添加注释  </span><br><span class="line">            PutBufLine(hbuf, Ln, Cat(&quot;//&quot;, buf))  </span><br><span class="line">        &#125;  </span><br><span class="line">        Ln = Ln + 1  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    SetWndSel(hwnd, selection)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上面的代码保存到utils.em文件，打开source insight，将该文件添加到工程中，然后在Options-&gt;Key Assignments中你就可以看到这个宏了，宏的名字是MultiLineComments，然后我们为它分配快捷键“Ctrl + /”，然后就可以了。</p>
<p>添加“#ifdef 0”和“#endif”的宏代码，定义快捷键为Ctrl+/+Shift：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">macro AddMacroComment()  </span><br><span class="line">&#123;  </span><br><span class="line">    hwnd=GetCurrentWnd()  </span><br><span class="line">    sel=GetWndSel(hwnd)  </span><br><span class="line">    lnFirst=GetWndSelLnFirst(hwnd)  </span><br><span class="line">    lnLast=GetWndSelLnLast(hwnd)  </span><br><span class="line">    hbuf=GetCurrentBuf()  </span><br><span class="line">   </span><br><span class="line">    if(LnFirst == 0) &#123;  </span><br><span class="line">            szIfStart = &quot;&quot;  </span><br><span class="line">    &#125;else&#123;  </span><br><span class="line">            szIfStart = GetBufLine(hbuf, LnFirst-1)  </span><br><span class="line">    &#125;  </span><br><span class="line">    szIfEnd = GetBufLine(hbuf, lnLast+1)  </span><br><span class="line">    if(szIfStart == &quot;#if 0&quot; &amp;&amp; szIfEnd == &quot;#endif&quot;) &#123;  </span><br><span class="line">            DelBufLine(hbuf, lnLast+1)  </span><br><span class="line">            DelBufLine(hbuf, lnFirst-1)  </span><br><span class="line">            sel.lnFirst = sel.lnFirst – 1  </span><br><span class="line">            sel.lnLast = sel.lnLast – 1  </span><br><span class="line">    &#125;else&#123;  </span><br><span class="line">            InsBufLine(hbuf, lnFirst, &quot;#if 0&quot;)  </span><br><span class="line">            InsBufLine(hbuf, lnLast+2, &quot;#endif&quot;)  </span><br><span class="line">            sel.lnFirst = sel.lnFirst + 1  </span><br><span class="line">            sel.lnLast = sel.lnLast + 1  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    SetWndSel( hwnd, sel )  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>操作和上面类似</p>
<h4 id="添加快捷键，快速打开当前文件所在文件夹"><a href="#添加快捷键，快速打开当前文件所在文件夹" class="headerlink" title="添加快捷键，快速打开当前文件所在文件夹"></a>添加快捷键，快速打开当前文件所在文件夹</h4><ol>
<li><p>选择【Tools】-&gt;【custom commands】，在add -&gt;【Command】输入名字：Explorer Project</p>
</li>
<li><p>在【Run：】中输入： ShellExecute open explorer /e,/select,%f 或 ShellExecute open explorer /select,%f 或  explorer %d 或 explorer /select,%f<br>注意中间的逗号:ShellExecute open explorer /select,%f</p>
</li>
<li><p>在点击【Keys…】，点击【Assign New Key…】，设置快捷键 Ctrl+Alt+O</p>
</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Source Insight</tag>
      </tags>
  </entry>
  <entry>
    <title>工具-Ubuntu配置NFS及其挂载设备</title>
    <url>/2019/11/02/%E5%B7%A5%E5%85%B7-Ubuntu%E9%85%8D%E7%BD%AENFS%E5%8F%8A%E5%85%B6%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87/</url>
    <content><![CDATA[<h5 id="在Ubuntu系统中安装NFS"><a href="#在Ubuntu系统中安装NFS" class="headerlink" title="在Ubuntu系统中安装NFS"></a>在Ubuntu系统中安装NFS</h5><p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nfs-kernel-server</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同时会有两个软件包nfs-common和portmap被安装上，如果没有安装成功多安装几次。</p>
</blockquote>
<a id="more"></a>

<h5 id="在Ubuntu系统中的-mnt下建立共享项目nfs-shared"><a href="#在Ubuntu系统中的-mnt下建立共享项目nfs-shared" class="headerlink" title="在Ubuntu系统中的/mnt下建立共享项目nfs_shared"></a>在Ubuntu系统中的/mnt下建立共享项目nfs_shared</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mkdir nfs_shared </span><br><span class="line"># chmod 777 -R nfs_shared/</span><br></pre></td></tr></table></figure>
<p>保证使用者都能够读、写、执行。如图</p>
<p><img src="/2019/11/02/%E5%B7%A5%E5%85%B7-Ubuntu%E9%85%8D%E7%BD%AENFS%E5%8F%8A%E5%85%B6%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87/1.png" alt="1"></p>
<h5 id="在Ubuntu系统中修改NFS配置文件"><a href="#在Ubuntu系统中修改NFS配置文件" class="headerlink" title="在Ubuntu系统中修改NFS配置文件"></a>在Ubuntu系统中修改NFS配置文件</h5><p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/exports</span><br></pre></td></tr></table></figure>
<p>在exports最后一行添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/mnt/nfs_shared 192.168.0.*(rw,sync,no_root_squash,no_subtree_check)</span><br><span class="line">其中，</span><br><span class="line">/mnt/nfs_shared  ---要共享的目录</span><br><span class="line">192.168.0.*---允许访问的网段，也可以是ip地址、主机名（能够被服务器解析）、</span><br><span class="line">     *（所有人都能访问）</span><br><span class="line">(rw,sync,no_root_squash,no_subtree_check)---</span><br><span class="line">rw:读/写权限</span><br><span class="line">sync:数据同步写入内存和硬盘</span><br><span class="line">no_root_squash:服务器允许远程系统以root特权存取该目录</span><br><span class="line">no_subtree_check:关闭子树检查</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/02/%E5%B7%A5%E5%85%B7-Ubuntu%E9%85%8D%E7%BD%AENFS%E5%8F%8A%E5%85%B6%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87/2.png" alt="2"></p>
<h5 id="在Ubuntu系统中启动服务"><a href="#在Ubuntu系统中启动服务" class="headerlink" title="在Ubuntu系统中启动服务"></a>在Ubuntu系统中启动服务</h5><p>依次执行下列命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service rpcbind restart</span><br><span class="line">sudo service nfs-kernel-server restart</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/02/%E5%B7%A5%E5%85%B7-Ubuntu%E9%85%8D%E7%BD%AENFS%E5%8F%8A%E5%85%B6%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87/3.png" alt="3"></p>
<h5 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h5><h6 id="测试Ubuntu-nfs"><a href="#测试Ubuntu-nfs" class="headerlink" title="测试Ubuntu nfs"></a>测试Ubuntu nfs</h6><p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$showmount -e</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/02/%E5%B7%A5%E5%85%B7-Ubuntu%E9%85%8D%E7%BD%AENFS%E5%8F%8A%E5%85%B6%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87/4.png" alt="4"></p>
<h6 id="设备挂载"><a href="#设备挂载" class="headerlink" title="设备挂载"></a>设备挂载</h6><p>在《Hi3519AV100 SDK 安装及升级使用说明.pdf》中4.2 使用 NFS 文件系统进行开发可以看到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -t nfs -o nolock -o tcp -o rsize=32768,wsize=32768 xx.xx.xx.xx:/your-nfs-path /mnt</span><br></pre></td></tr></table></figure>

<p>改为：（在设备中挂载）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -t nfs -o nolock -o tcp -o rsize=32768,wsize=32768 192.168.0.180:/mnt/</span><br></pre></td></tr></table></figure>
<p>之后就可以在设备的/mnt下面查看Ubuntu/mnt/nfs_shared的文件了。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>nfs</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/02/%E7%AE%80%E5%8D%95%E7%9A%84rtsp%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>这里C表示rtsp客户端,S表示rtsp服务端。 </p>
</blockquote>
<h6 id="C-gt-发送流媒体数据前的准备"><a href="#C-gt-发送流媒体数据前的准备" class="headerlink" title="C-&gt;:发送流媒体数据前的准备"></a>C-&gt;:发送流媒体数据前的准备</h6><ul>
<li>C-&gt;S:OPTION request  //询问S有哪些方法可用 </li>
<li>S-&gt;C:OPTION response //S回应信息中包括提供的所有可用方法 </li>
</ul>
<ul>
<li>C-&gt;S:DESCRIBE request //要求得到S提供的媒体初始化描述信息 </li>
<li>S-&gt;C:DESCRIBE response //S回应媒体初始化描述信息，主要是sdp </li>
</ul>
<ul>
<li>C-&gt;S:SETUP request //设置会话的属性，以及传输模式，提醒S建立会话 </li>
<li>S-&gt;C:SETUP response //S建立会话，返回会话标识符，以及会话相关信息 </li>
</ul>
<ul>
<li>C-&gt;S:PLAY request //C请求播放 </li>
<li>S-&gt;C:PLAY response //S回应该请求的信息 </li>
</ul>
<h6 id="S-gt-C-发送流媒体数据"><a href="#S-gt-C-发送流媒体数据" class="headerlink" title="S-&gt;C:发送流媒体数据"></a>S-&gt;C:发送流媒体数据</h6><ul>
<li>C-&gt;S:TEARDOWN request //C请求关闭会话 </li>
<li>S-&gt;C:TEARDOWN response //S回应该请求</li>
</ul>
]]></content>
      <categories>
        <category>流媒体</category>
      </categories>
  </entry>
</search>
