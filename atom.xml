<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Faihung&#39;s blog</title>
  
  <subtitle>作者：faihung</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.faihung.net/"/>
  <updated>2020-01-10T03:21:24.247Z</updated>
  <id>http://www.faihung.net/</id>
  
  <author>
    <name>faihung</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C语言-shell命令方式&amp;函数方式执行汇总</title>
    <link href="http://www.faihung.net/2020/01/10/C%E8%AF%AD%E8%A8%80-shell%E5%91%BD%E4%BB%A4%E6%96%B9%E5%BC%8F-%E5%87%BD%E6%95%B0%E6%96%B9%E5%BC%8F%E6%89%A7%E8%A1%8C%E6%B1%87%E6%80%BB/"/>
    <id>http://www.faihung.net/2020/01/10/C语言-shell命令方式-函数方式执行汇总/</id>
    <published>2020-01-10T03:10:41.000Z</published>
    <updated>2020-01-10T03:21:24.247Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一、调用linux系统函数system执行shell命令"><a href="#一、调用linux系统函数system执行shell命令" class="headerlink" title="一、调用linux系统函数system执行shell命令"></a>一、调用linux系统函数system执行shell命令</h5><p><strong>编译验证过的源码码</strong>：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">#define FILE_PATH_HISI_TAR &quot;/mnt/hgfs/VMWARE/curl/app/temp/&quot;</span><br><span class="line">#define FILE_PATH_HISI_TAR_AFTER &quot;/mnt/hgfs/VMWARE/curl/app/temp/root/&quot;</span><br><span class="line">#define FILE_PATH_MD5 &quot;/mnt/hgfs/VMWARE/test/12-shell_cmd_func/&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int shell_system(char *pcmd)</span><br><span class="line">&#123;</span><br><span class="line">pid_t status;</span><br><span class="line"></span><br><span class="line">printf(&quot;execute cmd:%s\n&quot;,pcmd);</span><br><span class="line">status = system(pcmd);</span><br><span class="line">if (-1 == status)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;system error!&quot;);</span><br><span class="line">return -1;</span><br><span class="line">    &#125;</span><br><span class="line">if(WIFEXITED(status) != 0)//正常退出</span><br><span class="line">&#123;</span><br><span class="line">if(WEXITSTATUS(status) == 0)//操作正确</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;run command success\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;run error\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else//异常退出</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;exit error is %d\n&quot;, WEXITSTATUS(status));</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">char shell_cmd_ls[128];</span><br><span class="line">char shell_cmd_tar[128];</span><br><span class="line">char shell_cmd_md5[128];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sprintf(shell_cmd_ls,&quot;ls -al&quot;);</span><br><span class="line">if(0 != shell_system(shell_cmd_ls))</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;System call failed!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">/* </span><br><span class="line">//解压文件</span><br><span class="line">sprintf(shell_cmd_tar,&quot;tar zxvf %s%s -C %s&quot;,FILE_PATH_HISI_TAR,&quot;hisi_app.tar.gz&quot;,FILE_PATH_HISI_TAR_AFTER);</span><br><span class="line">if(0 != shell_system(shell_cmd_tar))</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;System call failed!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//拷贝文件</span><br><span class="line">//删除文件</span><br><span class="line">//统计文件</span><br><span class="line">//改变文件权限</span><br><span class="line">//计算md5值</span><br><span class="line">sprintf(shell_cmd_md5,&quot;md5sum %s%s&quot;,FILE_PATH_MD5,&quot;chmod.c&quot;);</span><br><span class="line">if(0 != shell_system(shell_cmd_md5))</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;System call failed!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="二、调用linux管道函数popen执行shell命令"><a href="#二、调用linux管道函数popen执行shell命令" class="headerlink" title="二、调用linux管道函数popen执行shell命令"></a>二、调用linux管道函数popen执行shell命令</h5><p><strong>编译验证过的源码码</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">#define FILE_PATH_HISI_TAR &quot;/mnt/hgfs/VMWARE/curl/app/temp/&quot;</span><br><span class="line">#define FILE_PATH_HISI_TAR_AFTER &quot;/mnt/hgfs/VMWARE/curl/app/temp/root/&quot;</span><br><span class="line">#define FILE_PATH_MD5 &quot;/mnt/hgfs/VMWARE/test/12-shell_cmd_func/&quot;</span><br><span class="line"></span><br><span class="line">int shell_popen(char *pbuf,char *pfile_path)</span><br><span class="line">&#123;</span><br><span class="line">char cmd_buf[64];</span><br><span class="line">FILE* fp = NULL;</span><br><span class="line">sprintf(cmd_buf,&quot;md5sum %s&quot;,pfile_path);</span><br><span class="line">fp = popen(cmd_buf, &quot;r&quot;);</span><br><span class="line">if(NULL == fp)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;popen&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">while(fgets(pbuf, 1024, fp) != NULL);</span><br><span class="line"></span><br><span class="line">pclose(fp);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void) </span><br><span class="line">&#123;</span><br><span class="line">char buf[128] = &#123;0&#125;;</span><br><span class="line">char file_path[128];</span><br><span class="line"></span><br><span class="line">//ls -al</span><br><span class="line">//拷贝文件</span><br><span class="line">//删除文件</span><br><span class="line">//统计文件</span><br><span class="line">//改变文件权限</span><br><span class="line">//解压文件</span><br><span class="line">//计算md5值</span><br><span class="line">sprintf(file_path,&quot;%s/%s&quot;,FILE_PATH_MD5,&quot;chmod.c&quot;);</span><br><span class="line">if(0 == shell_popen(buf,file_path))</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;MD5:%s\n&quot;, buf);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">printf(&quot;get MD5&apos;s value is failed!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">memset(buf, 0x0, sizeof(buf));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以前用shell命令通过管道或者系统方式执行一条命令，这样会在线程里面开启新的进程，从而会造成代码出现不可控的状态。<br>管道或者system会返回出各种状态值，这些状态值是不可控。</p><h5 id="三、直接通过函数方式删除文件"><a href="#三、直接通过函数方式删除文件" class="headerlink" title="三、直接通过函数方式删除文件"></a>三、直接通过函数方式删除文件</h5><p><strong>编译验证过的源码码</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#ifndef _DELETE_FILE</span><br><span class="line">#define _DELETE_FILE</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;limits.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line"></span><br><span class="line">//判断是否为目录</span><br><span class="line">bool is_dir(const char *path)</span><br><span class="line">&#123;</span><br><span class="line">    struct stat statbuf;</span><br><span class="line">    if(lstat(path, &amp;statbuf) ==0)//lstat返回文件的信息，文件信息存放在stat结构中</span><br><span class="line">    &#123;</span><br><span class="line">        return S_ISDIR(statbuf.st_mode) != 0;//S_ISDIR宏，判断文件类型是否为目录</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//判断是否为常规文件</span><br><span class="line">bool is_file(const char *path)</span><br><span class="line">&#123;</span><br><span class="line">    struct stat statbuf;</span><br><span class="line">    if(lstat(path, &amp;statbuf) ==0)</span><br><span class="line">        return S_ISREG(statbuf.st_mode) != 0;//判断文件是否为常规文件</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//判断是否是特殊目录</span><br><span class="line">bool is_special_dir(const char *path)</span><br><span class="line">&#123;</span><br><span class="line">    return strcmp(path, &quot;.&quot;) == 0 || strcmp(path, &quot;..&quot;) == 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//生成完整的文件路径</span><br><span class="line">void get_file_path(const char *path, const char *file_name,  char *file_path)</span><br><span class="line">&#123;</span><br><span class="line">    strcpy(file_path, path);</span><br><span class="line">    if(file_path[strlen(path) - 1] != &apos;/&apos;)</span><br><span class="line">        strcat(file_path, &quot;/&quot;);</span><br><span class="line">    strcat(file_path, file_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void delete_file(const char *path)</span><br><span class="line">&#123;</span><br><span class="line">    DIR *dir;</span><br><span class="line">    struct dirent *dir_info;</span><br><span class="line">    char file_path[PATH_MAX];</span><br><span class="line">    if(is_file(path))</span><br><span class="line">    &#123;</span><br><span class="line">        remove(path);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(is_dir(path))</span><br><span class="line">    &#123;</span><br><span class="line">        if((dir = opendir(path)) == NULL)</span><br><span class="line">            return;</span><br><span class="line">        while((dir_info = readdir(dir)) != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            get_file_path(path, dir_info-&gt;d_name, file_path);</span><br><span class="line">            if(is_special_dir(dir_info-&gt;d_name))</span><br><span class="line">                continue;</span><br><span class="line">            delete_file(file_path);</span><br><span class="line">            rmdir(file_path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;argv[1]=%s\n&quot;,argv[1]);</span><br><span class="line">    delete_file(argv[1]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h5 id="四、直接通过函数方式统计某个目录下的文件个数"><a href="#四、直接通过函数方式统计某个目录下的文件个数" class="headerlink" title="四、直接通过函数方式统计某个目录下的文件个数"></a>四、直接通过函数方式统计某个目录下的文件个数</h5><p><strong>编译验证过的源码码</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define MAX 1024</span><br><span class="line">/*</span><br><span class="line">返回值,返回该文件夹中的文件个数</span><br><span class="line">参数ppathfile,所求文件夹目录的路径</span><br><span class="line">*/</span><br><span class="line">int get_file_count(char *ppathfile)</span><br><span class="line">&#123;</span><br><span class="line">DIR *dir;</span><br><span class="line">struct dirent * ptr;</span><br><span class="line">int total = 0;</span><br><span class="line">char path[MAX];</span><br><span class="line">dir = opendir(ppathfile); /* 打开目录*/</span><br><span class="line">if(dir == NULL)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;fail to open dir&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line">errno = 0;</span><br><span class="line">while((ptr = readdir(dir)) != NULL)</span><br><span class="line">&#123;</span><br><span class="line">//顺序读取每一个目录项；</span><br><span class="line">//跳过“..”和“.”两个目录</span><br><span class="line">if(strcmp(ptr-&gt;d_name,&quot;.&quot;) == 0 || strcmp(ptr-&gt;d_name,&quot;..&quot;) == 0)</span><br><span class="line">&#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">//printf(&quot;%s%s\n&quot;,ppathfile,ptr-&gt;d_name);</span><br><span class="line">//如果是目录，则递归调用 get_file_count函数</span><br><span class="line">if(ptr-&gt;d_type == DT_DIR)</span><br><span class="line">&#123;</span><br><span class="line">sprintf(path,&quot;%s%s/&quot;,ppathfile,ptr-&gt;d_name);</span><br><span class="line">//printf(&quot;%s\n&quot;,path);</span><br><span class="line"></span><br><span class="line">total += get_file_count(path);</span><br><span class="line">&#125;</span><br><span class="line">if(ptr-&gt;d_type == DT_REG)</span><br><span class="line">&#123;</span><br><span class="line">total++;</span><br><span class="line">printf(&quot;%s%s\n&quot;,ppathfile,ptr-&gt;d_name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(errno != 0)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;fail to read dir&quot;); //失败则输出提示信息</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line">closedir(dir);</span><br><span class="line">return total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">int total;</span><br><span class="line">if(argc != 2)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;wrong usage\n&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line">total = get_file_count(argv[1]);</span><br><span class="line">printf(&quot;%s have %d files\n&quot;,argv[1],total);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="五、直接通过函数方式改变文件权限"><a href="#五、直接通过函数方式改变文件权限" class="headerlink" title="五、直接通过函数方式改变文件权限"></a>五、直接通过函数方式改变文件权限</h5><p><strong>编译验证过的源码码</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    chmod(&quot;/home/yhh/123&quot;, S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IWGRP|S_IXGRP|S_IROTH|S_IWOTH|S_IXOTH);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#if 0</span><br><span class="line">函数说明：</span><br><span class="line">chmod()会依参数mode 权限来更改参数path 指定文件的权限</span><br><span class="line"></span><br><span class="line">参数 mode 有下列数种组合：</span><br><span class="line">S_ISUID 04000 文件的 (set user-id on execution)位</span><br><span class="line">S_ISGID 02000 文件的 (set group-id on execution)位</span><br><span class="line">S_ISVTX 01000 文件的sticky 位</span><br><span class="line">S_IRUSR (S_IREAD) 00400 文件所有者具可读取权限</span><br><span class="line">S_IWUSR (S_IWRITE)00200 文件所有者具可写入权限</span><br><span class="line">S_IXUSR (S_IEXEC) 00100 文件所有者具可执行权限</span><br><span class="line">S_IRGRP 00040 用户组具可读取权限</span><br><span class="line">S_IWGRP 00020 用户组具可写入权限</span><br><span class="line">S_IXGRP 00010 用户组具可执行权限</span><br><span class="line">S_IROTH 00004 其他用户具可读取权限</span><br><span class="line">S_IWOTH 00002 其他用户具可写入权限</span><br><span class="line">S_IXOTH 00001 其他用户具可执行权限</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h5 id="六、直接通过函数方式计算文件的md5值"><a href="#六、直接通过函数方式计算文件的md5值" class="headerlink" title="六、直接通过函数方式计算文件的md5值"></a>六、直接通过函数方式计算文件的md5值</h5><p><strong>编译验证过的源码码</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned int count[2];  </span><br><span class="line">    unsigned int state[4];  </span><br><span class="line">    unsigned char buffer[64];     </span><br><span class="line">&#125;MD5_CTX;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define F(x,y,z) ((x &amp; y) | (~x &amp; z))  </span><br><span class="line">#define G(x,y,z) ((x &amp; z) | (y &amp; ~z))  </span><br><span class="line">#define H(x,y,z) (x^y^z)  </span><br><span class="line">#define I(x,y,z) (y ^ (x | ~z))  </span><br><span class="line">#define ROTATE_LEFT(x,n) ((x &lt;&lt; n) | (x &gt;&gt; (32-n)))  </span><br><span class="line">#define FF(a,b,c,d,x,s,ac) \</span><br><span class="line">&#123; \</span><br><span class="line">    a += F(b,c,d) + x + ac; \</span><br><span class="line">    a = ROTATE_LEFT(a,s); \</span><br><span class="line">    a += b; \</span><br><span class="line">&#125;  </span><br><span class="line">#define GG(a,b,c,d,x,s,ac) \</span><br><span class="line">&#123; \</span><br><span class="line">    a += G(b,c,d) + x + ac; \</span><br><span class="line">    a = ROTATE_LEFT(a,s); \</span><br><span class="line">    a += b; \</span><br><span class="line">&#125;  </span><br><span class="line">#define HH(a,b,c,d,x,s,ac) \</span><br><span class="line">&#123; \</span><br><span class="line">    a += H(b,c,d) + x + ac; \</span><br><span class="line">    a = ROTATE_LEFT(a,s); \</span><br><span class="line">    a += b; \</span><br><span class="line">&#125;  </span><br><span class="line">#define II(a,b,c,d,x,s,ac) \</span><br><span class="line">&#123; \</span><br><span class="line">    a += I(b,c,d) + x + ac; \</span><br><span class="line">    a = ROTATE_LEFT(a,s); \</span><br><span class="line">    a += b; \</span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line">unsigned char PADDING[]=&#123;</span><br><span class="line">0x80,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  </span><br><span class="line">0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  </span><br><span class="line">0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  </span><br><span class="line">0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">void MD5Encode(unsigned char *output,unsigned int *input,unsigned int len)  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned int i = 0,j = 0;  </span><br><span class="line">    while(j &lt; len)  </span><br><span class="line">    &#123;  </span><br><span class="line">        output[j] = input[i] &amp; 0xFF;    </span><br><span class="line">        output[j+1] = (input[i] &gt;&gt; 8) &amp; 0xFF;  </span><br><span class="line">        output[j+2] = (input[i] &gt;&gt; 16) &amp; 0xFF;  </span><br><span class="line">        output[j+3] = (input[i] &gt;&gt; 24) &amp; 0xFF;  </span><br><span class="line">        i++;  </span><br><span class="line">        j+=4;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">void MD5Decode(unsigned int *output,unsigned char *input,unsigned int len)  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned int i = 0,j = 0;  </span><br><span class="line">    while(j &lt; len)  </span><br><span class="line">    &#123;  </span><br><span class="line">        output[i] = (input[j]) |  </span><br><span class="line">            (input[j+1] &lt;&lt; 8) |  </span><br><span class="line">            (input[j+2] &lt;&lt; 16) |  </span><br><span class="line">            (input[j+3] &lt;&lt; 24);  </span><br><span class="line">        i++;  </span><br><span class="line">        j+=4;   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">void MD5Transform(unsigned int state[4],unsigned char block[64])  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned int a = state[0];  </span><br><span class="line">    unsigned int b = state[1];  </span><br><span class="line">    unsigned int c = state[2];  </span><br><span class="line">    unsigned int d = state[3];  </span><br><span class="line">    unsigned int x[64];  </span><br><span class="line">    MD5Decode(x,block,64);  </span><br><span class="line">    FF(a, b, c, d, x[ 0], 7, 0xd76aa478);   </span><br><span class="line">    FF(d, a, b, c, x[ 1], 12, 0xe8c7b756);   </span><br><span class="line">    FF(c, d, a, b, x[ 2], 17, 0x242070db);   </span><br><span class="line">    FF(b, c, d, a, x[ 3], 22, 0xc1bdceee);   </span><br><span class="line">    FF(a, b, c, d, x[ 4], 7, 0xf57c0faf);   </span><br><span class="line">    FF(d, a, b, c, x[ 5], 12, 0x4787c62a);   </span><br><span class="line">    FF(c, d, a, b, x[ 6], 17, 0xa8304613);   </span><br><span class="line">    FF(b, c, d, a, x[ 7], 22, 0xfd469501);   </span><br><span class="line">    FF(a, b, c, d, x[ 8], 7, 0x698098d8);   </span><br><span class="line">    FF(d, a, b, c, x[ 9], 12, 0x8b44f7af);   </span><br><span class="line">    FF(c, d, a, b, x[10], 17, 0xffff5bb1);   </span><br><span class="line">    FF(b, c, d, a, x[11], 22, 0x895cd7be);   </span><br><span class="line">    FF(a, b, c, d, x[12], 7, 0x6b901122);   </span><br><span class="line">    FF(d, a, b, c, x[13], 12, 0xfd987193);   </span><br><span class="line">    FF(c, d, a, b, x[14], 17, 0xa679438e);   </span><br><span class="line">    FF(b, c, d, a, x[15], 22, 0x49b40821);   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    GG(a, b, c, d, x[ 1], 5, 0xf61e2562);   </span><br><span class="line">    GG(d, a, b, c, x[ 6], 9, 0xc040b340);   </span><br><span class="line">    GG(c, d, a, b, x[11], 14, 0x265e5a51);   </span><br><span class="line">    GG(b, c, d, a, x[ 0], 20, 0xe9b6c7aa);   </span><br><span class="line">    GG(a, b, c, d, x[ 5], 5, 0xd62f105d);   </span><br><span class="line">    GG(d, a, b, c, x[10], 9,  0x2441453);   </span><br><span class="line">    GG(c, d, a, b, x[15], 14, 0xd8a1e681);   </span><br><span class="line">    GG(b, c, d, a, x[ 4], 20, 0xe7d3fbc8);   </span><br><span class="line">    GG(a, b, c, d, x[ 9], 5, 0x21e1cde6);   </span><br><span class="line">    GG(d, a, b, c, x[14], 9, 0xc33707d6);   </span><br><span class="line">    GG(c, d, a, b, x[ 3], 14, 0xf4d50d87);   </span><br><span class="line">    GG(b, c, d, a, x[ 8], 20, 0x455a14ed);   </span><br><span class="line">    GG(a, b, c, d, x[13], 5, 0xa9e3e905);   </span><br><span class="line">    GG(d, a, b, c, x[ 2], 9, 0xfcefa3f8);   </span><br><span class="line">    GG(c, d, a, b, x[ 7], 14, 0x676f02d9);   </span><br><span class="line">    GG(b, c, d, a, x[12], 20, 0x8d2a4c8a);   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    HH(a, b, c, d, x[ 5], 4, 0xfffa3942);   </span><br><span class="line">    HH(d, a, b, c, x[ 8], 11, 0x8771f681);   </span><br><span class="line">    HH(c, d, a, b, x[11], 16, 0x6d9d6122);   </span><br><span class="line">    HH(b, c, d, a, x[14], 23, 0xfde5380c);   </span><br><span class="line">    HH(a, b, c, d, x[ 1], 4, 0xa4beea44);   </span><br><span class="line">    HH(d, a, b, c, x[ 4], 11, 0x4bdecfa9);   </span><br><span class="line">    HH(c, d, a, b, x[ 7], 16, 0xf6bb4b60);   </span><br><span class="line">    HH(b, c, d, a, x[10], 23, 0xbebfbc70);   </span><br><span class="line">    HH(a, b, c, d, x[13], 4, 0x289b7ec6);   </span><br><span class="line">    HH(d, a, b, c, x[ 0], 11, 0xeaa127fa);   </span><br><span class="line">    HH(c, d, a, b, x[ 3], 16, 0xd4ef3085);   </span><br><span class="line">    HH(b, c, d, a, x[ 6], 23,  0x4881d05);   </span><br><span class="line">    HH(a, b, c, d, x[ 9], 4, 0xd9d4d039);   </span><br><span class="line">    HH(d, a, b, c, x[12], 11, 0xe6db99e5);   </span><br><span class="line">    HH(c, d, a, b, x[15], 16, 0x1fa27cf8);   </span><br><span class="line">    HH(b, c, d, a, x[ 2], 23, 0xc4ac5665);   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    II(a, b, c, d, x[ 0], 6, 0xf4292244);   </span><br><span class="line">    II(d, a, b, c, x[ 7], 10, 0x432aff97);   </span><br><span class="line">    II(c, d, a, b, x[14], 15, 0xab9423a7);   </span><br><span class="line">    II(b, c, d, a, x[ 5], 21, 0xfc93a039);   </span><br><span class="line">    II(a, b, c, d, x[12], 6, 0x655b59c3);   </span><br><span class="line">    II(d, a, b, c, x[ 3], 10, 0x8f0ccc92);   </span><br><span class="line">    II(c, d, a, b, x[10], 15, 0xffeff47d);   </span><br><span class="line">    II(b, c, d, a, x[ 1], 21, 0x85845dd1);   </span><br><span class="line">    II(a, b, c, d, x[ 8], 6, 0x6fa87e4f);   </span><br><span class="line">    II(d, a, b, c, x[15], 10, 0xfe2ce6e0);   </span><br><span class="line">    II(c, d, a, b, x[ 6], 15, 0xa3014314);   </span><br><span class="line">    II(b, c, d, a, x[13], 21, 0x4e0811a1);   </span><br><span class="line">    II(a, b, c, d, x[ 4], 6, 0xf7537e82);   </span><br><span class="line">    II(d, a, b, c, x[11], 10, 0xbd3af235);   </span><br><span class="line">    II(c, d, a, b, x[ 2], 15, 0x2ad7d2bb);   </span><br><span class="line">    II(b, c, d, a, x[ 9], 21, 0xeb86d391);   </span><br><span class="line">    state[0] += a;  </span><br><span class="line">    state[1] += b;  </span><br><span class="line">    state[2] += c;  </span><br><span class="line">    state[3] += d;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">void MD5Init(MD5_CTX *context)  </span><br><span class="line">&#123;  </span><br><span class="line">    context-&gt;count[0] = 0;  </span><br><span class="line">    context-&gt;count[1] = 0;  </span><br><span class="line">    context-&gt;state[0] = 0x67452301;  </span><br><span class="line">    context-&gt;state[1] = 0xEFCDAB89;  </span><br><span class="line">    context-&gt;state[2] = 0x98BADCFE;  </span><br><span class="line">    context-&gt;state[3] = 0x10325476;  </span><br><span class="line">&#125;  </span><br><span class="line">void MD5Update(MD5_CTX *context,unsigned char *input,unsigned int inputlen)  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned int i = 0,index = 0,partlen = 0;  </span><br><span class="line">    index = (context-&gt;count[0] &gt;&gt; 3) &amp; 0x3F;  </span><br><span class="line">    partlen = 64 - index;  </span><br><span class="line">    context-&gt;count[0] += inputlen &lt;&lt; 3;  </span><br><span class="line">    if(context-&gt;count[0] &lt; (inputlen &lt;&lt; 3))  </span><br><span class="line">        context-&gt;count[1]++;  </span><br><span class="line">    context-&gt;count[1] += inputlen &gt;&gt; 29;  </span><br><span class="line"></span><br><span class="line">    if(inputlen &gt;= partlen)  </span><br><span class="line">    &#123;  </span><br><span class="line">        memcpy(&amp;context-&gt;buffer[index],input,partlen);  </span><br><span class="line">        MD5Transform(context-&gt;state,context-&gt;buffer);  </span><br><span class="line">        for(i = partlen;i+64 &lt;= inputlen;i+=64)  </span><br><span class="line">            MD5Transform(context-&gt;state,&amp;input[i]);  </span><br><span class="line">        index = 0;          </span><br><span class="line">    &#125;    </span><br><span class="line">    else  </span><br><span class="line">    &#123;  </span><br><span class="line">        i = 0;  </span><br><span class="line">    &#125;  </span><br><span class="line">    memcpy(&amp;context-&gt;buffer[index],&amp;input[i],inputlen-i);  </span><br><span class="line">&#125;  </span><br><span class="line">void MD5Final(MD5_CTX *context,unsigned char digest[16])  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned int index = 0,padlen = 0;  </span><br><span class="line">    unsigned char bits[8];  </span><br><span class="line">    index = (context-&gt;count[0] &gt;&gt; 3) &amp; 0x3F;  </span><br><span class="line">    padlen = (index &lt; 56)?(56-index):(120-index);  </span><br><span class="line">    MD5Encode(bits,context-&gt;count,8);  </span><br><span class="line">    MD5Update(context,PADDING,padlen);  </span><br><span class="line">    MD5Update(context,bits,8);  </span><br><span class="line">    MD5Encode(digest,context-&gt;state,16);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* md5函数测试 */</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">FILE *fp = fopen(&quot;chmod.c&quot;, &quot;r&quot;);</span><br><span class="line">    struct stat st;</span><br><span class="line">    unsigned char digest[16] = &#123;0&#125;;</span><br><span class="line">    MD5_CTX context;</span><br><span class="line">    int i = 0;</span><br><span class="line"></span><br><span class="line">    MD5Init(&amp;context);</span><br><span class="line">if(0 == stat(&quot;chmod.c&quot;, &amp;st))//获取文件信息</span><br><span class="line">    &#123;</span><br><span class="line">/* 计算文件MD5 */</span><br><span class="line">char *data = NULL;</span><br><span class="line">int ret = 0;</span><br><span class="line"></span><br><span class="line">if(!fp)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;fopen&quot;);</span><br><span class="line">exit(-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data = malloc(st.st_size);</span><br><span class="line">if(!data)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;malloc&quot;);</span><br><span class="line">exit(-1);</span><br><span class="line">&#125;</span><br><span class="line">ret = fread(data, 1, st.st_size, fp);</span><br><span class="line">if(ret != st.st_size)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;fread&quot;);</span><br><span class="line">exit(-1);</span><br><span class="line">&#125; </span><br><span class="line">MD5Update(&amp;context, data, st.st_size);</span><br><span class="line">fclose(fp);</span><br><span class="line">free(data);</span><br><span class="line">    &#125;</span><br><span class="line">    MD5Final(&amp;context, digest);</span><br><span class="line"></span><br><span class="line">    /* 打印MD5值 */</span><br><span class="line">    printf(&quot;md5: &quot;);</span><br><span class="line">    for(i = 0; i &lt; 16; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%02x&quot;, digest[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="七、直接通过函数方式查看磁盘空间"><a href="#七、直接通过函数方式查看磁盘空间" class="headerlink" title="七、直接通过函数方式查看磁盘空间"></a>七、直接通过函数方式查看磁盘空间</h5><p><strong>编译验证过的源码码</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/statfs.h&gt;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">void get_system_available(unsigned long long *pavailable)</span><br><span class="line">&#123;</span><br><span class="line">struct statfs diskInfo;</span><br><span class="line"></span><br><span class="line">statfs(&quot;/&quot;, &amp;diskInfo);</span><br><span class="line">unsigned long long blocksize = diskInfo.f_bsize;//每个block里包含的字节数</span><br><span class="line">unsigned long long totalsize = blocksize * diskInfo.f_blocks; //总的字节数，f_blocks为block的数目</span><br><span class="line">printf(&quot;Total_size = %llu B = %llu KB = %llu MB = %llu GB\n&quot;, totalsize, totalsize&gt;&gt;10, totalsize&gt;&gt;20, totalsize&gt;&gt;30);</span><br><span class="line"></span><br><span class="line">unsigned long long freeDisk = diskInfo.f_bfree * blocksize;//剩余空间的大小</span><br><span class="line">*pavailable = diskInfo.f_bavail * blocksize; //可用空间大小</span><br><span class="line">printf(&quot;Disk_free = %llu MB = %llu GB\n&quot;, freeDisk&gt;&gt;20, freeDisk&gt;&gt;30);</span><br><span class="line">//printf(&quot;Disk_available = %llu MB = %llu GB\n&quot;, availableDisk&gt;&gt;20, availableDisk&gt;&gt;30);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">unsigned long long available;</span><br><span class="line">get_system_available(&amp;available);</span><br><span class="line">printf(&quot;Disk_available = %llu MB = %llu GB\n&quot;, available&gt;&gt;20, available&gt;&gt;30);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;一、调用linux系统函数system执行shell命令&quot;&gt;&lt;a href=&quot;#一、调用linux系统函数system执行shell命令&quot; class=&quot;headerlink&quot; title=&quot;一、调用linux系统函数system执行shell命令&quot;&gt;&lt;/a&gt;一、调用linux系统函数system执行shell命令&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;编译验证过的源码码&lt;/strong&gt;：&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://www.faihung.net/categories/C/"/>
    
    
      <category term="system" scheme="http://www.faihung.net/tags/system/"/>
    
      <category term="popen" scheme="http://www.faihung.net/tags/popen/"/>
    
      <category term="remove" scheme="http://www.faihung.net/tags/remove/"/>
    
      <category term="dirent" scheme="http://www.faihung.net/tags/dirent/"/>
    
      <category term="chmod" scheme="http://www.faihung.net/tags/chmod/"/>
    
      <category term="MD5" scheme="http://www.faihung.net/tags/MD5/"/>
    
      <category term="statfs" scheme="http://www.faihung.net/tags/statfs/"/>
    
  </entry>
  
  <entry>
    <title>Git-02_gitlab的配置与准备工作</title>
    <link href="http://www.faihung.net/2020/01/01/Git-02-gitlab%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"/>
    <id>http://www.faihung.net/2020/01/01/Git-02-gitlab的配置与准备工作/</id>
    <published>2020-01-01T15:44:57.000Z</published>
    <updated>2020-01-01T16:01:02.388Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前面简单介绍了Web端gitlab的一些基本信息，这里主要介绍gitlab 一些配置和准备工作。</p></blockquote><h5 id="1-修改密码和邮箱"><a href="#1-修改密码和邮箱" class="headerlink" title="1.修改密码和邮箱"></a>1.修改密码和邮箱</h5><p>略</p><h5 id="2-配置SSH-Keys"><a href="#2-配置SSH-Keys" class="headerlink" title="2.配置SSH Keys"></a>2.配置SSH Keys</h5><p>前面Web端介绍时提到了SSH Keys的设置（见web端界面2.12账户设置）。<br>在往前我们建立一个新项目的时候也看到了一个SSH协议（见Web界面2.2.1点击按钮“New project”建立一个新项目，那里还有一个http协议，http协议不需要配置，但是push代码比较慢）。<br>都有提到关于SSH，这是因为我们git仓库和Gitlab仓库之间是通过SSH加密的，所以需要进行相应的配置。</p><a id="more"></a><h6 id="第1步：创建SSH-Key"><a href="#第1步：创建SSH-Key" class="headerlink" title="第1步：创建SSH Key"></a>第1步：创建SSH Key</h6><p>在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：<br>ssh-keygen -t rsa -C <a href="mailto:email@example.com" target="_blank" rel="noopener">email@example.com</a><br>之后一路回车，使用默认值，就可以获得一个Key值。一切顺利可以在用户主目录下面找到.ssh文件夹，可以看到里面有两个文件id_rsa和id_rsa.pub。其中id_rsa是私钥，id_rsa.pub是公钥。</p><p>如图：<br><img src="/2020/01/01/Git-02-gitlab%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/1.png" alt="1"></p><h6 id="第2步：登陆GitLab，打开账户设置，“SSH-Keys”页面："><a href="#第2步：登陆GitLab，打开账户设置，“SSH-Keys”页面：" class="headerlink" title="第2步：登陆GitLab，打开账户设置，“SSH Keys”页面："></a>第2步：登陆GitLab，打开账户设置，“SSH Keys”页面：</h6><p><img src="/2020/01/01/Git-02-gitlab%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/2.png" alt="2"></p><p><img src="/2020/01/01/Git-02-gitlab%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/3.png" alt="3"><br>这样就成功添加了。<br>其实在前面创建项目的时候提示这个，就表示要添加SSH Keys了。<br><img src="/2020/01/01/Git-02-gitlab%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/4.png" alt="4"></p><h5 id="3-安装Git"><a href="#3-安装Git" class="headerlink" title="3.安装Git"></a>3.安装Git</h5><p>Windows端需要下载一个git 客户端工具GitHubDesktopSetup.exe，这里主要是以Linux为主。<br>执行命令：</p><pre><code>sudo apt install git</code></pre><p>然后直接安装即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前面简单介绍了Web端gitlab的一些基本信息，这里主要介绍gitlab 一些配置和准备工作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;1-修改密码和邮箱&quot;&gt;&lt;a href=&quot;#1-修改密码和邮箱&quot; class=&quot;headerlink&quot; title=&quot;1.修改密码和邮箱&quot;&gt;&lt;/a&gt;1.修改密码和邮箱&lt;/h5&gt;&lt;p&gt;略&lt;/p&gt;
&lt;h5 id=&quot;2-配置SSH-Keys&quot;&gt;&lt;a href=&quot;#2-配置SSH-Keys&quot; class=&quot;headerlink&quot; title=&quot;2.配置SSH Keys&quot;&gt;&lt;/a&gt;2.配置SSH Keys&lt;/h5&gt;&lt;p&gt;前面Web端介绍时提到了SSH Keys的设置（见web端界面2.12账户设置）。&lt;br&gt;在往前我们建立一个新项目的时候也看到了一个SSH协议（见Web界面2.2.1点击按钮“New project”建立一个新项目，那里还有一个http协议，http协议不需要配置，但是push代码比较慢）。&lt;br&gt;都有提到关于SSH，这是因为我们git仓库和Gitlab仓库之间是通过SSH加密的，所以需要进行相应的配置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://www.faihung.net/categories/Git/"/>
    
    
      <category term="gitlab" scheme="http://www.faihung.net/tags/gitlab/"/>
    
      <category term="github" scheme="http://www.faihung.net/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Git-01_gitlab的Web端界面</title>
    <link href="http://www.faihung.net/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/"/>
    <id>http://www.faihung.net/2019/12/30/Git-01-gitlab的Web端界面/</id>
    <published>2019-12-30T15:42:15.000Z</published>
    <updated>2020-01-01T16:00:07.174Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、gitlab的登录"><a href="#一、gitlab的登录" class="headerlink" title="一、gitlab的登录"></a>一、gitlab的登录</h4><p>Web网页输入：<a href="http://xxx.wicp.vip/" target="_blank" rel="noopener">http://xxx.wicp.vip/</a> 进入gitlab登录界面，输入账号密码之后，选择 standard登录，进入Web页面。不同权限的人进入的界面是不一样的。<br>如下：<br><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/1.png" alt="1"></p><a id="more"></a><h4 id="二、gitlab-Web端的介绍"><a href="#二、gitlab-Web端的介绍" class="headerlink" title="二、gitlab Web端的介绍"></a>二、gitlab Web端的介绍</h4><p>点击Web端菜单栏上标签按钮，可以进入不同的功能任务主窗口。</p><h5 id="2-1-gitlab-一个logo标志-，进入或者恢复初始界面。"><a href="#2-1-gitlab-一个logo标志-，进入或者恢复初始界面。" class="headerlink" title="2.1 gitlab(一个logo标志)，进入或者恢复初始界面。"></a>2.1 gitlab(一个logo标志)，进入或者恢复初始界面。</h5><h5 id="2-2-Project，根据下拉列表或者Project标签页中的Tab列表选择同类型的项目。如下图"><a href="#2-2-Project，根据下拉列表或者Project标签页中的Tab列表选择同类型的项目。如下图" class="headerlink" title="2.2 Project，根据下拉列表或者Project标签页中的Tab列表选择同类型的项目。如下图"></a>2.2 Project，根据下拉列表或者Project标签页中的Tab列表选择同类型的项目。如下图</h5><p><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/2.png" alt="2"><br><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/3.png" alt="3"></p><h6 id="2-2-1点击按钮“New-project”建立项目"><a href="#2-2-1点击按钮“New-project”建立项目" class="headerlink" title="2.2.1点击按钮“New project”建立项目"></a>2.2.1点击按钮“New project”建立项目</h6><p><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/4.png" alt="4"><br>可以看到主窗口中有三个待选标签页：Blank project、Create from template、 Import project分别表示不同project的创建方式，一般我们用第一种。</p><p>根据项目Group的下拉菜单，选择beacom_firmware开发小组，输入项目名名称test，添加项目描述信息。</p><p>最后选择Visibility Level 的权限(可以选上README文件，最后会生成一个README文件)，点击按钮“Create project”就在这个开发小组中可以建立一个项目了。<br>如下图：<br><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/5.png" alt="5"></p><p>注意: </p><ol><li>点击按钮“clone”弹出一个对话框，上面有关于SSH和HTTP方式的链接，后续会有介绍。</li><li>每建立一个project 都会有这样一个命令：Command line instructions，这个是让我我们上传代码的命令，后面所有的操作基本上都是围绕这几步来，一般我们用这个命令：Create a new repository，后续会有介绍。</li></ol><h6 id="2-2-2回到刚才的Project-gt-Your-project-页面中可以看到新建的子项目xxx-firmware-test，以后开发就可以从这里进入"><a href="#2-2-2回到刚才的Project-gt-Your-project-页面中可以看到新建的子项目xxx-firmware-test，以后开发就可以从这里进入" class="headerlink" title="2.2.2回到刚才的Project-&gt;Your project 页面中可以看到新建的子项目xxx_firmware/test，以后开发就可以从这里进入"></a>2.2.2回到刚才的Project-&gt;Your project 页面中可以看到新建的子项目xxx_firmware/test，以后开发就可以从这里进入</h6><h5 id="2-3-Group-根据顶级菜单的下拉列表或者是子菜单的Tab列表都可以进如到不同的开发小组中去。"><a href="#2-3-Group-根据顶级菜单的下拉列表或者是子菜单的Tab列表都可以进如到不同的开发小组中去。" class="headerlink" title="2.3 Group,根据顶级菜单的下拉列表或者是子菜单的Tab列表都可以进如到不同的开发小组中去。"></a>2.3 Group,根据顶级菜单的下拉列表或者是子菜单的Tab列表都可以进如到不同的开发小组中去。</h5><p>以XXX_firmware开发小组为例，可以看到左边的的功能菜单上有：<br><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/6.png" alt="6"></p><h6 id="2-3-1-Owerview"><a href="#2-3-1-Owerview" class="headerlink" title="2.3.1 Owerview"></a>2.3.1 Owerview</h6><p>是一些项目细节或者是开发人员的活跃记录，如上图和下图所示。<br><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/7.png" alt="7"></p><h6 id="2-3-2-Issues"><a href="#2-3-2-Issues" class="headerlink" title="2.3.2 Issues"></a>2.3.2 Issues</h6><p>在这里这个项目组成员可以提交一些问题，大家相互交流，项目开发进度等等，代码发布版本都可以在这里做记录，这里没做研究。</p><h6 id="2-3-3-Merge-Requests"><a href="#2-3-3-Merge-Requests" class="headerlink" title="2.3.3 Merge Requests"></a>2.3.3 Merge Requests</h6><p>主要是别人提交代码请求合并的记录</p><h6 id="2-3-4-Kubernetes"><a href="#2-3-4-Kubernetes" class="headerlink" title="2.3.4 Kubernetes"></a>2.3.4 Kubernetes</h6><p>略</p><h6 id="2-3-5-Members"><a href="#2-3-5-Members" class="headerlink" title="2.3.5 Members"></a>2.3.5 Members</h6><p>这里有开发人员的相关信息，包括各级权限。</p><h5 id="2-4-Activity"><a href="#2-4-Activity" class="headerlink" title="2.4 Activity"></a>2.4 Activity</h5><p>不同人员各种代码提交、活跃记录都在上面。</p><h5 id="2-5-Milestones"><a href="#2-5-Milestones" class="headerlink" title="2.5 Milestones"></a>2.5 Milestones</h5><p>同2.3.2Issues中的milestones,就是项目开发达到某一个程度，比如可以发布的一个版本。（后面给代码打标签设置版本号还会提到如：git tag v1.0）</p><h5 id="2-6-Snippet"><a href="#2-6-Snippet" class="headerlink" title="2.6 Snippet"></a>2.6 Snippet</h5><p>个人的一些工作中的Idea启发,都可以记录在这里，有权限设置，相当于个人blog。</p><h5 id="2-7-“-”"><a href="#2-7-“-”" class="headerlink" title="2.7 “+”"></a>2.7 “+”</h5><p>根据下拉列表看到New Project、New group、New snippet，这个前面都有相关介绍。</p><h5 id="2-8-Issues"><a href="#2-8-Issues" class="headerlink" title="2.8 Issues"></a>2.8 Issues</h5><p>同2.3.2 Issues</p><h5 id="2-9-Merge-Requests"><a href="#2-9-Merge-Requests" class="headerlink" title="2.9 Merge Requests"></a>2.9 Merge Requests</h5><p>同2.3.3 Merge Requests</p><h5 id="2-9-Todos"><a href="#2-9-Todos" class="headerlink" title="2.9 Todos"></a>2.9 Todos</h5><p>接下来要做的事情，同2.3.2 Issues</p><h5 id="2-10？"><a href="#2-10？" class="headerlink" title="2.10？"></a>2.10？</h5><p>一款工具不能少的，常见帮助信息。</p><h5 id="2-11-账户设置"><a href="#2-11-账户设置" class="headerlink" title="2.11 账户设置"></a>2.11 账户设置</h5><p>选择账户中下拉列表Setings进入账户设置。如下图</p><p><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/8.png" alt="8"></p><p>这里主要是一些个人信息的设置，比如修改账户密码、邮箱等。还有一个重要的操作修改添加SSH Keys后面会有介绍。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、gitlab的登录&quot;&gt;&lt;a href=&quot;#一、gitlab的登录&quot; class=&quot;headerlink&quot; title=&quot;一、gitlab的登录&quot;&gt;&lt;/a&gt;一、gitlab的登录&lt;/h4&gt;&lt;p&gt;Web网页输入：&lt;a href=&quot;http://xxx.wicp.vip/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://xxx.wicp.vip/&lt;/a&gt; 进入gitlab登录界面，输入账号密码之后，选择 standard登录，进入Web页面。不同权限的人进入的界面是不一样的。&lt;br&gt;如下：&lt;br&gt;&lt;img src=&quot;/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/1.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://www.faihung.net/categories/Git/"/>
    
    
      <category term="gitlab" scheme="http://www.faihung.net/tags/gitlab/"/>
    
      <category term="github" scheme="http://www.faihung.net/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>工程设计-软件升级之设备端版本号管理(3)</title>
    <link href="http://www.faihung.net/2019/12/29/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E8%BD%AF%E4%BB%B6%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%AE%BE%E5%A4%87%E7%AB%AF%E7%89%88%E6%9C%AC%E5%8F%B7%E7%AE%A1%E7%90%86-3/"/>
    <id>http://www.faihung.net/2019/12/29/工程设计-软件升级之设备端版本号管理-3/</id>
    <published>2019-12-29T15:30:15.000Z</published>
    <updated>2019-12-29T15:38:30.021Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于版本号管控需要满足以空间分支为主导,用时间变更作定位,方便bug查找修改。</p></blockquote><p>1.需要满足设备的向上兼容,通过版本号的变更迭代可以实现。形如：3.000.0001</p><p>2.需要满足事物存在的3要素：</p><ul><li><p>时间(就是设备发货时间,也是设备的初始版本号,例如3.000.0001到3.000.0002的变更，就是一个时间变迁的过程)</p></li><li><p>地点(就是设备发货地点,同时对应代码库的分支)</p></li><li><p>设备(设备是必须存在的)</p></li></ul><p>每往一个地方发送设备,设备端代码通过git库建立一个分支,之后这个分支代码就主要是这个地方设备运行代码,方便以后bug查找,但不会对这个分支代码进行修改。<br>初始版本,以发往四川的为例：sichuan-3.000.0001</p><p>3.我们的程序不断的在master分支上进行更新迭代。</p><p>4.关于升级,会出现两种情况。(其它各种情况都离不开这两种情况)</p><p>4.1 一种情况就是某一个地方的设备出现了bug被人发现了,这个时候必须要对这个地方的设备进行升级,此时修改master分支测试验证通过<br>将master分支代码克隆到这个地方分支上去,代码的版本号变更由sichuan-3.000.0001到sichuan-3.000.0002的变更。</p><p>4.2 此时master分支,对4.1中bug进行修复并验证通过,同时我们也解决了一个其它的代码bug或者实现了一个功能,代码测试验证通过之后,感觉可以升级了,<br>这就是第二种情况升级(第二种升级又是系列情况升级)。<br>但并不是所有的设备都能升级,所以将master分支代码克隆到能够升级的地方分支上去。(时刻谨记地点分支代码不是用来修改的,是用来定位查找bug的)<br>形如：</p><pre><code>sichuan-3.000.0002到sichuan-3.001.0000的升级tieling-3.000.0001到tieling-3.001.0000的升级xian-3.000.00001  到xian-3.000.00001不升级</code></pre><p>5.所以从上面可以看出：sichuan-3.000.00000,从右往左起,<br>第1段是bug&amp;功能的升级<br>第2段是代码进行系列的升级<br>第3段前半部分是地方名称,后半部分是产品换代升级</p><p>6.代码的升级虽然是在服务器端升级的,但其实还是由设备端提供代码进行升级的。<br>所以每发一批设备,设备端都要给服务器端一个版本号：地点+一串号码,用来放入软件升级代码中去。</p><p>每次发出去之前,肯定要经过相应的一系列测试,这些测试必然包括版本升级测试。<br>(关于软件升级版本号必然是以if else if的方式不端的扩张的,因为它是未知的。)</p><p>7.软件升级代码以后要集中到运行程序中去,这样软件升级代码自身也会不断的迭代更新。</p><blockquote><p>注：此只为自己的一些不成熟的想法，真正版本号管理需要领导们自己决定。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;关于版本号管控需要满足以空间分支为主导,用时间变更作定位,方便bug查找修改。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.需要满足设备的向上兼容,通过版本号的变更迭代可以实现。形如：3.000.0001&lt;/p&gt;
&lt;p&gt;2.需要满足事物存在的3要
      
    
    </summary>
    
    
      <category term="工程设计" scheme="http://www.faihung.net/categories/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>系统函数&amp;库函数-Linux中的popen函数和system函数(转)</title>
    <link href="http://www.faihung.net/2019/12/22/%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0-%E5%BA%93%E5%87%BD%E6%95%B0-Linux%E4%B8%AD%E7%9A%84popen%E5%87%BD%E6%95%B0%E5%92%8Csystem%E5%87%BD%E6%95%B0-%E8%BD%AC/"/>
    <id>http://www.faihung.net/2019/12/22/系统函数-库函数-Linux中的popen函数和system函数-转/</id>
    <published>2019-12-22T15:57:19.000Z</published>
    <updated>2019-12-22T16:05:12.314Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>说在前面，在实际编程中尽量减少使用system函数。</p></blockquote><h5 id="int-system-const-char-command"><a href="#int-system-const-char-command" class="headerlink" title="int system(const char *command);"></a>int system(const char *command);</h5><h6 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h6><p>system()通过调用/bin/sh -c命令执行命令中指定的命令，并在命令完成后返回。在执行该命令期间，SIGCHLD将被阻塞，并且SIGINT和SIGQUIT将被忽略。</p><a id="more"></a><h6 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h6><p>实际上system调用了三个函数：fork()、exec()、waitpid()。因此有三种返回值：</p><ol><li>fork()失败或者waitpid()返回除了EINTR之外的出错，则system返回-1.而且errno中设置了错误类型值。</li><li>如果exec失败（表示不能执行shell），则其返回值如同shell执行了exit（127）一样</li><li>如果三个函数都执行成功，并且system的返回值是shell的终止状态，其格式已在已在waitpid中说明。</li></ol><h6 id="system的实现："><a href="#system的实现：" class="headerlink" title="system的实现："></a>system的实现：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int system(const char * cmdstring)  </span><br><span class="line">&#123;   </span><br><span class="line">  pid_t pid;   </span><br><span class="line">  int status;   </span><br><span class="line">  if(cmdstring == NULL)  </span><br><span class="line">    &#123;   </span><br><span class="line">      return (1);   </span><br><span class="line">    &#125;   </span><br><span class="line">  if((pid = fork())&lt;0)  </span><br><span class="line">    &#123;   </span><br><span class="line">      status = -1;   </span><br><span class="line">    &#125;   </span><br><span class="line">  else if(pid = 0)  </span><br><span class="line">    &#123;  </span><br><span class="line">       execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-c&quot;, cmdstring, (char *)0); -exit(127); //子进程正常执行则不会执行此语句 &#125;   </span><br><span class="line">  else  </span><br><span class="line">    &#123;   </span><br><span class="line">       while(waitpid(pid, &amp;status, 0) &lt; 0)  </span><br><span class="line">    &#123;  </span><br><span class="line">  if(errno != EINTER)&#123; status = -1; break;   </span><br><span class="line">    &#125;   </span><br><span class="line">   &#125;  </span><br><span class="line">  &#125;   </span><br><span class="line">  return status;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="简单的使用："><a href="#简单的使用：" class="headerlink" title="简单的使用："></a>简单的使用：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int status = 0;</span><br><span class="line">  status = system(&quot;ls -a&quot;);</span><br><span class="line">  if(-1 == status)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(&quot;system&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  if(WIFEXITED(status) != 0)  //正常退出</span><br><span class="line">  &#123;</span><br><span class="line">    if(WEXITSTATUS(status) == 0)  //操作正确</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;run command success\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;run error\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else      //异常退出</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;exit error is %d\n&quot;, WEXITSTATUS(status));</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以看到，system在使用时的一个弊端，由于返回值太多，要安全的使用它就要进行许多步的出错处理。</p><p>所以，不太建议使用system。</p><h6 id="使用system需要注意："><a href="#使用system需要注意：" class="headerlink" title="使用system需要注意："></a>使用system需要注意：</h6><p>1.建议system()函数只用来执行shell命令，因为一般来讲，system()返回值不是0就说明出错了； </p><p>2.监控一下system()函数的执行完毕后的errno值，争取出错时给出更多有用信息； </p><h5 id="建议使用popen函数取代system"><a href="#建议使用popen函数取代system" class="headerlink" title="建议使用popen函数取代system();"></a>建议使用popen函数取代system();</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *popen(const char *command, const char *type);</span><br><span class="line">int pclose(FILE *stream);返回值： command的终止状态， 出错返回-1</span><br></pre></td></tr></table></figure><h6 id="popen-函数较于system-函数的优势在于使用简单，popen-函数只返回两个值："><a href="#popen-函数较于system-函数的优势在于使用简单，popen-函数只返回两个值：" class="headerlink" title="popen()函数较于system()函数的优势在于使用简单，popen()函数只返回两个值："></a>popen()函数较于system()函数的优势在于使用简单，popen()函数只返回两个值：</h6><p>成功返回子进程的status，使用WIFEXITED相关宏就可以取得command的返回结果；</p><p>失败返回-1，我们可以使用perro()函数或strerror()函数得到有用的错误信息。</p><p>popen先执行fork，然后调用exec以执行command并返回一个标准I/O文件指针。如果type是“r”，则文件指针链接到command的标准输出。如果type是“w”,则文件指针链接到command的标准输入。将popen和fopen进行类比，方便记忆其最后一个参数及其作用，如果type是“r”，则返回文件指针是刻度的，如果type是是“w”，则是可写的。</p><p><img src="/2019/12/22/%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0-%E5%BA%93%E5%87%BD%E6%95%B0-Linux%E4%B8%AD%E7%9A%84popen%E5%87%BD%E6%95%B0%E5%92%8Csystem%E5%87%BD%E6%95%B0-%E8%BD%AC/1.png" alt="1"></p><p>简单使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  FILE* fp = NULL;</span><br><span class="line">  char buf[1024] = &#123;0&#125;;</span><br><span class="line">  fp = popen(&quot;ls -a&quot;, &quot;r&quot;);</span><br><span class="line">  if(NULL == fp)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(&quot;popen&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  while(fgets(buf, 1024, fp) != NULL)</span><br><span class="line">  &#123;</span><br><span class="line">   fprintf(stdout, &quot;%s&quot;, buf); </span><br><span class="line">  &#125;</span><br><span class="line">  pclose(fp);</span><br><span class="line"> </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，popen绝不应该由设置用户ID或设置组ID程序调用。当它执行命令</p><p>popen等同于execl(“/bin/sh”, “sh”, “-c”, command ,NULL);</p><p>它在从调用者继承的环境中执行shell，并由shell解释执行command。一个心怀不轨的用户可以操纵这种环境，使得shell能以设置ID文件模式所授予的提升了的权限以及非预期的方式执行命令。</p><p>popen特别适用于构造简单的过滤程序，它变换运行命令的输入或输出。</p><p>当命令希望构建自己的管道线时就是这种情形。</p><blockquote><p>借楼发个问题：在多次调用system和popen（中间没有做delay处理）后，再次调用是直接fp返回空或system返回无此目录或文件。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;说在前面，在实际编程中尽量减少使用system函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;int-system-const-char-command&quot;&gt;&lt;a href=&quot;#int-system-const-char-command&quot; class=&quot;headerlink&quot; title=&quot;int system(const char *command);&quot;&gt;&lt;/a&gt;int system(const char *command);&lt;/h5&gt;&lt;h6 id=&quot;说明：&quot;&gt;&lt;a href=&quot;#说明：&quot; class=&quot;headerlink&quot; title=&quot;说明：&quot;&gt;&lt;/a&gt;说明：&lt;/h6&gt;&lt;p&gt;system()通过调用/bin/sh -c命令执行命令中指定的命令，并在命令完成后返回。在执行该命令期间，SIGCHLD将被阻塞，并且SIGINT和SIGQUIT将被忽略。&lt;/p&gt;
    
    </summary>
    
    
      <category term="系统函数&amp;库函数" scheme="http://www.faihung.net/categories/%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0-%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="system" scheme="http://www.faihung.net/tags/system/"/>
    
      <category term="popen" scheme="http://www.faihung.net/tags/popen/"/>
    
  </entry>
  
  <entry>
    <title>系统函数&amp;库函数-popen 的使用方法及场景(转)</title>
    <link href="http://www.faihung.net/2019/12/22/%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0-%E5%BA%93%E5%87%BD%E6%95%B0-popen-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%8F%8A%E5%9C%BA%E6%99%AF-%E8%BD%AC/"/>
    <id>http://www.faihung.net/2019/12/22/系统函数-库函数-popen-的使用方法及场景-转/</id>
    <published>2019-12-22T15:56:46.000Z</published>
    <updated>2019-12-22T16:02:47.363Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-Popen的应用场景"><a href="#1-Popen的应用场景" class="headerlink" title="1.Popen的应用场景"></a>1.Popen的应用场景</h5><p>popen应用于执行shell命令，并读取此命令的返值，或者与执行的命令进行交互。</p><a id="more"></a><h5 id="2-Popen的实现"><a href="#2-Popen的实现" class="headerlink" title="2.Popen的实现"></a>2.Popen的实现</h5><p>popen()函数通过创建一个管道，调用fork()产生一个子进程，执行一个shell以运行命令来开启一个进程。可以通过这个管道执行标准输入输出操作。这个管道必须由pclose()函数关闭，必须由pclose()函数关闭，必须由pclose()函数关闭，而不是fclose()函数（若使用fclose则会产生僵尸进程）。pclose()函数关闭标准I/O流，等待命令执行结束，然后返回shell的终止状态。如果shell不能被执行，则pclose()返回的终止状态与shell已执行exit一样。</p><p>type参数只能是读或者写中的一种，得到的返回值（标准I/O流）也具有和type相应的只读或只写类型。如果type是”r”则文件指针连接到command的标准输出；如果type是”w”则文件指针连接到command的标准输入。</p><p>command参数是一个指向以NULL结束的shell命令字符串的指针。这行命令将被传到bin/sh并使用-c标志，shell将执行这个命令。</p><p>popen()的返回值是个标准I/O流，必须由pclose来终止。前面提到这个流是单向的（只能用于读或写）。向这个流写内容相当于写入该命令的标准输入，命令的标准输出和调用popen()的进程相同；与之相反的，从流中读数据相当于读取命令的标准输出，命令的标准输入和调用popen()的进程相同。</p><p><strong>返回值</strong></p><p>如果调用fork()或pipe()失败，或者不能分配内存将返回NULL，否则返回标准I/O流。popen()没有为内存分配失败设置errno值。如果调用fork()或pipe()时出现错误，errno被设为相应的错误类型。如果type参数不合法，errno将返回EINVAL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *popen(const char *command, const char *type);</span><br><span class="line">int pclose(FILE *stream);</span><br></pre></td></tr></table></figure><h5 id="3-Pclose操作"><a href="#3-Pclose操作" class="headerlink" title="3.Pclose操作"></a>3.Pclose操作</h5><p>Pclose()函数会闭标准i/0流，等待子进程结束，然后返回shell终止状态。如果不执行，则pclose()返回终止状态就是shell的exit状态。</p><p><strong>源码附上：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line">/* Copyright (C) 2004       Manuel Novoa III    &lt;mjn3@codepoet.org&gt;</span><br><span class="line"> * Copyright (C) 2000-2006 Erik Andersen &lt;andersen@uclibc.org&gt;</span><br><span class="line"> *</span><br><span class="line"> * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.</span><br><span class="line"> *</span><br><span class="line"> * Dedicated to Toni.  See uClibc/DEDICATION.mjn3 for details.</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/* Jan 1, 2004</span><br><span class="line"> *</span><br><span class="line"> * Rewrite popen for SUSv3 compliance.</span><br><span class="line"> *   Added a list of popen()&apos;d to store pids and use waitpid() in pclose().</span><br><span class="line"> *   Loop on waitpid() failure due to EINTR as required.</span><br><span class="line"> *   Close parent&apos;s popen()&apos;d FILEs in the &#123;v&#125;fork()&apos;d child.</span><br><span class="line"> *   Fix failure exit code for failed execve().</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;bits/uClibc_mutex.h&gt;</span><br><span class="line"> </span><br><span class="line">#ifdef __UCLIBC_MJN3_ONLY__</span><br><span class="line">#warning &quot;hmm... susv3 says Pipe streams are byte-oriented.&quot;</span><br><span class="line">#endif /* __UCLIBC_MJN3_ONLY__ */</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/* uClinux-2.0 has vfork, but Linux 2.0 doesn&apos;t */</span><br><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line">#if ! defined __NR_vfork</span><br><span class="line"># define vfork fork</span><br><span class="line"># define VFORK_LOCK((void) 0)</span><br><span class="line"># define VFORK_UNLOCK((void) 0)</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">#ifndef VFORK_LOCK</span><br><span class="line">__UCLIBC_MUTEX_STATIC(mylock, PTHREAD_MUTEX_INITIALIZER);</span><br><span class="line"># define VFORK_LOCK__UCLIBC_MUTEX_LOCK(mylock)</span><br><span class="line"># define VFORK_UNLOCK__UCLIBC_MUTEX_UNLOCK(mylock)</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">struct popen_list_item &#123;</span><br><span class="line">struct popen_list_item *next;</span><br><span class="line">FILE *f;</span><br><span class="line">pid_t pid;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">static struct popen_list_item *popen_list /* = NULL (bss initialized) */;</span><br><span class="line"> </span><br><span class="line">FILE *popen(const char *command, const char *modes)</span><br><span class="line">&#123;</span><br><span class="line">FILE *fp;</span><br><span class="line">struct popen_list_item *pi;</span><br><span class="line">struct popen_list_item *po;</span><br><span class="line">int pipe_fd[2];</span><br><span class="line">int parent_fd;</span><br><span class="line">int child_fd;</span><br><span class="line">int child_writing;/* Doubles as the desired child fildes. */</span><br><span class="line">pid_t pid;</span><br><span class="line"> </span><br><span class="line">child_writing = 0;/* Assume child is writing. */</span><br><span class="line">if (modes[0] != &apos;w&apos;) &#123;/* Parent not writing... */</span><br><span class="line">++child_writing;/* so child must be writing. */</span><br><span class="line">if (modes[0] != &apos;r&apos;) &#123;/* Oops!  Parent not reading either! */</span><br><span class="line">__set_errno(EINVAL);</span><br><span class="line">goto RET_NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">if (!(pi = malloc(sizeof(struct popen_list_item)))) &#123;</span><br><span class="line">goto RET_NULL;</span><br><span class="line">&#125;</span><br><span class="line">// 打开一个pipe，管道是单向。故数据流只能单向流动。</span><br><span class="line">if (pipe(pipe_fd)) &#123;</span><br><span class="line">goto FREE_PI;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//下面两个描述符就是管道的两端的描述，一个为读一个为写。</span><br><span class="line">child_fd = pipe_fd[child_writing]; </span><br><span class="line">parent_fd = pipe_fd[1-child_writing]; </span><br><span class="line">//fdopen就是打开一个描述，fd相同模式或者字集的方式打开。意思就是把一个已找打开的流与一个文件描述符相关联，且</span><br><span class="line">//这个文件描述是唯一的，这样也就可以保证这个函数接口的可重入性。如果设计的不可重入性，也就没必要再做一次fdopen了。</span><br><span class="line">if (!(fp = fdopen(parent_fd, modes))) &#123;</span><br><span class="line">close(parent_fd);</span><br><span class="line">close(child_fd);</span><br><span class="line">goto FREE_PI;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">VFORK_LOCK;</span><br><span class="line">//再这里创建一个子进程，然后执行 shell命令。这里最重的两步就是用pipe的两个描述替换标准输入或者输出。</span><br><span class="line">if ((pid = vfork()) == 0) &#123;/* Child of vfork... */</span><br><span class="line">close(parent_fd);</span><br><span class="line">if (child_fd != child_writing) &#123;</span><br><span class="line">dup2(child_fd, child_writing); //用child_fd来代替标准输入或输出。</span><br><span class="line">close(child_fd);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* SUSv3 requires that any previously popen()&apos;d streams in the</span><br><span class="line"> * parent shall be closed in the child. */</span><br><span class="line">//关闭不必要的资源。</span><br><span class="line">for (po = popen_list ; po ; po = po-&gt;next) &#123;</span><br><span class="line">close(po-&gt;f-&gt;__filedes);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//执行exec shell,这个时候标准输入/输出就变为pipe管道的一端了。</span><br><span class="line">//这里只能实现单向的功能。要么读要么写。</span><br><span class="line">execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-c&quot;, command, (char *)0);</span><br><span class="line"> </span><br><span class="line">/* SUSv3 mandates an exit code of 127 for the child if the</span><br><span class="line"> * command interpreter can not be invoked. */</span><br><span class="line">_exit(127);</span><br><span class="line">&#125;</span><br><span class="line">VFORK_UNLOCK;</span><br><span class="line"> </span><br><span class="line">/* We need to close the child filedes whether vfork failed or</span><br><span class="line"> * it succeeded and we&apos;re in the parent. */</span><br><span class="line">close(child_fd);</span><br><span class="line">//将当前的信息保存到全局链表。为了是pclose可以找到对的子进程与通信文件描述。</span><br><span class="line">if (pid &gt; 0) &#123;/* Parent of vfork... */</span><br><span class="line">pi-&gt;pid = pid;</span><br><span class="line">pi-&gt;f = fp;</span><br><span class="line">VFORK_LOCK;</span><br><span class="line">pi-&gt;next = popen_list;</span><br><span class="line">popen_list = pi;</span><br><span class="line">VFORK_UNLOCK;</span><br><span class="line"> </span><br><span class="line">return fp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* If we get here, vfork failed. */</span><br><span class="line">fclose(fp);/* Will close parent_fd. */</span><br><span class="line"> </span><br><span class="line"> FREE_PI:</span><br><span class="line">free(pi);</span><br><span class="line"> </span><br><span class="line"> RET_NULL:</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#warning is pclose correct wrt the new mutex semantics?</span><br><span class="line"> </span><br><span class="line">int pclose(FILE *stream)</span><br><span class="line">&#123;</span><br><span class="line">struct popen_list_item *p;</span><br><span class="line">int stat;</span><br><span class="line">pid_t pid;</span><br><span class="line"> </span><br><span class="line">/* First, find the list entry corresponding to stream and remove it</span><br><span class="line"> * from the list.  Set p to the list item (NULL if not found). */</span><br><span class="line">VFORK_LOCK;</span><br><span class="line">if ((p = popen_list) != NULL) &#123;</span><br><span class="line">if (p-&gt;f == stream) &#123;// 找到stream对应的popen结点。</span><br><span class="line">popen_list = p-&gt;next;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">struct popen_list_item *t;</span><br><span class="line">do &#123;</span><br><span class="line">t = p;</span><br><span class="line">if (!(p = t-&gt;next)) &#123;</span><br><span class="line">__set_errno(EINVAL); /* Not required by SUSv3. */</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if (p-&gt;f == stream) &#123;</span><br><span class="line">t-&gt;next = p-&gt;next;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125; while (1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">VFORK_UNLOCK;</span><br><span class="line"> </span><br><span class="line">if (p) &#123;</span><br><span class="line">pid = p-&gt;pid;/* Save the pid we need */</span><br><span class="line">free(p);/* and free the list item. */</span><br><span class="line"> </span><br><span class="line">fclose(stream);/* The SUSv3 example code ignores the return. */</span><br><span class="line"> </span><br><span class="line">/* SUSv3 specificly requires that pclose not return before the child</span><br><span class="line"> * terminates, in order to disallow pclose from returning on EINTR. */</span><br><span class="line">do &#123;</span><br><span class="line">if (waitpid(pid, &amp;stat, 0) &gt;= 0) &#123; //等待子进程返回。获取返回值。</span><br><span class="line">return stat;</span><br><span class="line">&#125;</span><br><span class="line">if (errno != EINTR) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125; while (1);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>举例附上：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">FILE *fp = NULL;</span><br><span class="line">char buf[1024] = &quot;&quot;;</span><br><span class="line"> </span><br><span class="line">fp = popen(&quot;ls -al&quot;, &quot;r&quot;);</span><br><span class="line">if(fp == NULL)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;popen error\n&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">while(fgets(buf, sizeof(buf), fp) != 0)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%s\n&quot;, buf);</span><br><span class="line">memset(buf, 0x0, sizeof(buf));</span><br><span class="line">&#125;</span><br><span class="line">pclose(fp);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;1-Popen的应用场景&quot;&gt;&lt;a href=&quot;#1-Popen的应用场景&quot; class=&quot;headerlink&quot; title=&quot;1.Popen的应用场景&quot;&gt;&lt;/a&gt;1.Popen的应用场景&lt;/h5&gt;&lt;p&gt;popen应用于执行shell命令，并读取此命令的返值，或者与执行的命令进行交互。&lt;/p&gt;
    
    </summary>
    
    
      <category term="系统函数&amp;库函数" scheme="http://www.faihung.net/categories/%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0-%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="popen" scheme="http://www.faihung.net/tags/popen/"/>
    
  </entry>
  
  <entry>
    <title>工程设计-软件升级之设备端版本号管理(2)</title>
    <link href="http://www.faihung.net/2019/12/22/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E8%BD%AF%E4%BB%B6%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%AE%BE%E5%A4%87%E7%AB%AF%E7%89%88%E6%9C%AC%E5%8F%B7%E7%AE%A1%E7%90%86-2/"/>
    <id>http://www.faihung.net/2019/12/22/工程设计-软件升级之设备端版本号管理-2/</id>
    <published>2019-12-22T14:44:26.000Z</published>
    <updated>2019-12-29T15:50:44.020Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于版本号管理，之前升级都是在嵌入式设备中移植一个微型服务器，然后通过web端进行升级。现在是设备作为客户端向http发送版本号，http发送下载指令，设备端再想ftp服务器请求下载文件。所以思维方式要转换一下。<br>并且预期忘版本号的管理符合git库版本管理规则。</p></blockquote><a id="more"></a><h5 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h5><p>服务器只有一个，而设备却有很多种，且分布在全国各地，各个地方情况不一样。<br>有的地方因为设备或者其它原因，软件不需要更新。<br>有的设备因为硬件与软件兼容性问题，只能升级特定的版本。<br>所以远程升级必须需要满足下面两种情况。</p><h5 id="二、远程升级满足下面两种情况"><a href="#二、远程升级满足下面两种情况" class="headerlink" title="二、远程升级满足下面两种情况"></a>二、远程升级满足下面两种情况</h5><h6 id="2-1-后台服务器的手动升级-暴力升级"><a href="#2-1-后台服务器的手动升级-暴力升级" class="headerlink" title="2.1 后台服务器的手动升级(暴力升级)"></a>2.1 后台服务器的手动升级(暴力升级)</h6><h6 id="2-2-设备端的自动升级"><a href="#2-2-设备端的自动升级" class="headerlink" title="2.2 设备端的自动升级"></a>2.2 设备端的自动升级</h6><p>参考：<img src="/2019/12/22/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E8%BD%AF%E4%BB%B6%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%AE%BE%E5%A4%87%E7%AB%AF%E7%89%88%E6%9C%AC%E5%8F%B7%E7%AE%A1%E7%90%86-2/1.png" alt="1"></p><h5 id="三、关于版本号管控"><a href="#三、关于版本号管控" class="headerlink" title="三、关于版本号管控"></a>三、关于版本号管控</h5><p>版本号管控或称三段式管控，形如：3.000.00000，3.100.10000,以10进制字符串的方式体现出来。（关于版本号的管控也可以按照设备发送的地方进行管控。按照时间来进行版本号回退管理，按照空间(发货地点)来进行分支进退管理。）</p><p>注意：16进制数据和字符串型数据容易混淆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HISI_APP:3.01.0001 </span><br><span class="line">16进制方式：(0x03 0x2e 0x00 0x01 0x2e 0x00 0x00 0x00 0x01) </span><br><span class="line">字符串方式：(0x33 0x2e 0x30 0x31 0x2e 0x30 0x30 0x30 0x31)</span><br></pre></td></tr></table></figure><h6 id="3-1-第3段—-00001，子功能升级-amp-BUG的修改（软件对应子功能添加-amp-BUG的修改的升级）"><a href="#3-1-第3段—-00001，子功能升级-amp-BUG的修改（软件对应子功能添加-amp-BUG的修改的升级）" class="headerlink" title="3.1 第3段—-00001，子功能升级&amp;BUG的修改（软件对应子功能添加&amp;BUG的修改的升级）"></a>3.1 第3段—-00001，子功能升级&amp;BUG的修改（软件对应子功能添加&amp;BUG的修改的升级）</h6><p>从文本文件中读取的’.’后面的第一位，为1表示该不可以升级，为0表示该段程序可以升级。</p><p>之后的4位，表示版本号的范围：0000-9999。</p><p>关于兼容性：修改bug有9999种版本完全够用，可能还没有达到这么多，就进入了系列升级。</p><h6 id="3-2-第2段—-001，产品系列的升级（软件对应硬件方面的升级）"><a href="#3-2-第2段—-001，产品系列的升级（软件对应硬件方面的升级）" class="headerlink" title="3.2 第2段—-001，产品系列的升级（软件对应硬件方面的升级）"></a>3.2 第2段—-001，产品系列的升级（软件对应硬件方面的升级）</h6><p>从文本文件中读取的’.’后面的第一位，为1表示该不可以升级，为0表示该段程序可以升级。</p><p>之后的2位，表示版本号的范围：00-99</p><p>关于兼容性：修改bug有99种版本完全够用，可能还没有达到这么多，就进入了换代升级</p><h6 id="3-3-第1段—-3，产品的换代升级（软件对应产品发布方面的升级）"><a href="#3-3-第1段—-3，产品的换代升级（软件对应产品发布方面的升级）" class="headerlink" title="3.3 第1段—-3，产品的换代升级（软件对应产品发布方面的升级）"></a>3.3 第1段—-3，产品的换代升级（软件对应产品发布方面的升级）</h6>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;关于版本号管理，之前升级都是在嵌入式设备中移植一个微型服务器，然后通过web端进行升级。现在是设备作为客户端向http发送版本号，http发送下载指令，设备端再想ftp服务器请求下载文件。所以思维方式要转换一下。&lt;br&gt;并且预期忘版本号的管理符合git库版本管理规则。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="工程设计" scheme="http://www.faihung.net/categories/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="FTP" scheme="http://www.faihung.net/tags/FTP/"/>
    
      <category term="流程图" scheme="http://www.faihung.net/tags/%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    
      <category term="http" scheme="http://www.faihung.net/tags/http/"/>
    
      <category term="版本号" scheme="http://www.faihung.net/tags/%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>C语言-函数返回局部变量的几种方式</title>
    <link href="http://www.faihung.net/2019/12/15/C%E8%AF%AD%E8%A8%80-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.faihung.net/2019/12/15/C语言-函数返回局部变量的几种方式/</id>
    <published>2019-12-15T04:46:13.000Z</published>
    <updated>2019-12-18T10:53:21.032Z</updated>
    
    <content type="html"><![CDATA[<p>一般的来说，函数是可以返回局部变量的。</p><p>局部变量的作用域只在函数内部，在函数返回后，局部变量的内存已经释放了。</p><p>因此，如果函数返回的是局部变量的值，不涉及地址，程序不会出错。</p><p>但是如果返回的是局部变量的地址(指针)的话，程序运行后会出错。</p><p>因为函数只是把指针复制后返回了，但是指针指向的内容已经被释放了，这样指针指向的内容就是不可预料的内容，调用就会出错。</p><p>准确的来说，函数不能通过返回指向栈内存的指针(注意这里指的是栈，返回指向堆内存的指针是可以的)。</p><a id="more"></a><p>下面以函数返回局部变量的指针举几个典型的例子来说明：</p><h5 id="1-字符串常量’hello-world’，存放在只读数据段"><a href="#1-字符串常量’hello-world’，存放在只读数据段" class="headerlink" title="1. 字符串常量’hello world’，存放在只读数据段"></a>1. 字符串常量’hello world’，存放在只读数据段</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;   </span><br><span class="line">char *returnStr()   </span><br><span class="line">&#123;   </span><br><span class="line">    char *p=&quot;hello world!&quot;;   </span><br><span class="line">    return p;   </span><br><span class="line">&#125;   </span><br><span class="line">int main()   </span><br><span class="line">&#123;   </span><br><span class="line">    char *str;   </span><br><span class="line">    str=returnStr();   </span><br><span class="line">    printf(&quot;%s\n&quot;, str);   </span><br><span class="line">    return 0;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个没有任何问题，因为”hello world!”是一个字符串常量，存放在只读数据段，把该字符串常量存放的只读数据段的首地址赋值给了指针，所以returnStr函数退出时，该该字符串常量所在内存不会被回收，故能够通过指针顺利无误的访问。</p><h5 id="2-局部变量’hello-world’存放在栈中"><a href="#2-局部变量’hello-world’存放在栈中" class="headerlink" title="2. 局部变量’hello world’存放在栈中"></a>2. 局部变量’hello world’存放在栈中</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;   </span><br><span class="line"></span><br><span class="line">char *returnStr()   </span><br><span class="line">&#123;   </span><br><span class="line">    char p[]=&quot;hello world!&quot;;   </span><br><span class="line">    return p;   </span><br><span class="line">&#125;   </span><br><span class="line">int main()   </span><br><span class="line">&#123;   </span><br><span class="line">    char *str;   </span><br><span class="line">    str=returnStr();   </span><br><span class="line">    printf(&quot;%s\n&quot;, str);   </span><br><span class="line">    return 0;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“hello world!”是局部变量存放在栈中。当returnStr函数退出时，栈要清空，局部变量的内存也被清空了，所以这时的函数返回的是一个已被释放的内存地址，所以有可能打印出来的是乱码。 </p><h5 id="3-局部变量（实参与型参）、地址（指针）栈（指向内存的释放）、静态变量地址（指针）的生存周期"><a href="#3-局部变量（实参与型参）、地址（指针）栈（指向内存的释放）、静态变量地址（指针）的生存周期" class="headerlink" title="3. 局部变量（实参与型参）、地址（指针）栈（指向内存的释放）、静态变量地址（指针）的生存周期"></a>3. 局部变量（实参与型参）、地址（指针）栈（指向内存的释放）、静态变量地址（指针）的生存周期</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int func()  </span><br><span class="line">&#123;  </span><br><span class="line">      int a;  </span><br><span class="line">      ....  </span><br><span class="line">      return a;    //允许  </span><br><span class="line">&#125;                     </span><br><span class="line">  </span><br><span class="line">int * func()  </span><br><span class="line">&#123;  </span><br><span class="line">      int a;  </span><br><span class="line">      ....  </span><br><span class="line">      return &amp;a;    //无意义，不应该这样做  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部变量也分局部自动变量和局部静态变量，由于a返回的是值，因此返回一个局部变量是可以的，无论自动还是静态，因为这时候返回的是这个局部变量的值。</p><p>但不应该返回指向局部自动变量的指针，因为函数调用结束后该局部自动变量<br>被抛弃，这个指针指向一个不再存在的对象，是无意义的。</p><p>但可以返回指向局部静态变量的指针，因为静态变量的生存期从定义起到程序结束。</p><h5 id="4-如果函数的返回值非要是一个局部变量的地址，那么该局部变量一定要申明为static类型。"><a href="#4-如果函数的返回值非要是一个局部变量的地址，那么该局部变量一定要申明为static类型。" class="headerlink" title="4. 如果函数的返回值非要是一个局部变量的地址，那么该局部变量一定要申明为static类型。"></a>4. 如果函数的返回值非要是一个局部变量的地址，那么该局部变量一定要申明为static类型。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;   </span><br><span class="line">char *returnStr()   </span><br><span class="line">&#123;   </span><br><span class="line">    static char p[]=&quot;hello world!&quot;;   </span><br><span class="line">    return p;   </span><br><span class="line">&#125;   </span><br><span class="line">int main()   </span><br><span class="line">&#123;   </span><br><span class="line">    char *str;   </span><br><span class="line">    str=returnStr();   </span><br><span class="line">    printf(&quot;%s\n&quot;, str);   </span><br><span class="line">  </span><br><span class="line">    return 0;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-数组是不能作为函数的返回值的，原因是编译器把数组名认为是局部变量（数组）的地址。返回一个数组一般用返回指向这个数组的指针代替，而且这个指针不能指向一个自动数组，因为函数结束后自动数组被抛弃，但可以返回一个指向静态局部数组的指针，因为静态存储期是从对象定义到程序结束的。"><a href="#5-数组是不能作为函数的返回值的，原因是编译器把数组名认为是局部变量（数组）的地址。返回一个数组一般用返回指向这个数组的指针代替，而且这个指针不能指向一个自动数组，因为函数结束后自动数组被抛弃，但可以返回一个指向静态局部数组的指针，因为静态存储期是从对象定义到程序结束的。" class="headerlink" title="5. 数组是不能作为函数的返回值的，原因是编译器把数组名认为是局部变量（数组）的地址。返回一个数组一般用返回指向这个数组的指针代替，而且这个指针不能指向一个自动数组，因为函数结束后自动数组被抛弃，但可以返回一个指向静态局部数组的指针，因为静态存储期是从对象定义到程序结束的。"></a>5. 数组是不能作为函数的返回值的，原因是编译器把数组名认为是局部变量（数组）的地址。返回一个数组一般用返回指向这个数组的指针代替，而且这个指针不能指向一个自动数组，因为函数结束后自动数组被抛弃，但可以返回一个指向静态局部数组的指针，因为静态存储期是从对象定义到程序结束的。</h5><p>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int* func( void )  </span><br><span class="line">&#123;  </span><br><span class="line">    static int a[10];  </span><br><span class="line">    ........  </span><br><span class="line">    return a;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-返回指向堆内存的指针是可以的"><a href="#6-返回指向堆内存的指针是可以的" class="headerlink" title="6. 返回指向堆内存的指针是可以的"></a>6. 返回指向堆内存的指针是可以的</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">char *GetMemory3(int num)  </span><br><span class="line">&#123;  </span><br><span class="line">    char *p = (char *)malloc(sizeof(char) * num);  </span><br><span class="line">    return p;  </span><br><span class="line">&#125;  </span><br><span class="line">void Test3(void)  </span><br><span class="line">&#123;  </span><br><span class="line">    char *str = NULL;  </span><br><span class="line">    str = GetMemory3(100);  </span><br><span class="line">    strcpy(str, &quot;hello&quot;);  </span><br><span class="line">    cout&lt;&lt; str &lt;&lt; endl;  </span><br><span class="line">    free(str);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序在运行的时候用 malloc 申请任意多少的内存,程序员自己负责在何时用 free释放内存。动态内存的生存期由程序员自己决定,使用非常灵活。</p><h5 id="7-通过局部变量在另一个函数去取值-传一个地址，用指针变量来接收，用指针来指向一个值"><a href="#7-通过局部变量在另一个函数去取值-传一个地址，用指针变量来接收，用指针来指向一个值" class="headerlink" title="7. 通过局部变量在另一个函数去取值(传一个地址，用指针变量来接收，用指针来指向一个值)"></a>7. 通过局部变量在另一个函数去取值(传一个地址，用指针变量来接收，用指针来指向一个值)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void get_value(int* Temp)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;2:0x%x\n&quot;,Temp);</span><br><span class="line">    *Temp = 6;</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    int temp;</span><br><span class="line">    printf(&quot;1:0x%x\n&quot;,&amp;temp);</span><br><span class="line">    </span><br><span class="line">    get_value(&amp;temp);</span><br><span class="line">    printf(&quot;3:%d\n&quot;,temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-通过局部变量数组在另一个函数去取值-传一个地址，用指针变量来接收，用指针来指向一个值"><a href="#8-通过局部变量数组在另一个函数去取值-传一个地址，用指针变量来接收，用指针来指向一个值" class="headerlink" title="8. 通过局部变量数组在另一个函数去取值(传一个地址，用指针变量来接收，用指针来指向一个值)"></a>8. 通过局部变量数组在另一个函数去取值(传一个地址，用指针变量来接收，用指针来指向一个值)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void get_value(char * ptemp)</span><br><span class="line">&#123;</span><br><span class="line">char i;</span><br><span class="line">    printf(&quot;2:0x%x\n&quot;,ptemp);</span><br><span class="line">    ptemp = &quot;hello world!&quot;;//这样不行，字符串常量放在只读数据段，和主函数中的temp局部数据区域有冲突</span><br><span class="line"></span><br><span class="line">printf(&quot;3:%s\n&quot;,ptemp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char temp[13]=&#123;0&#125;;</span><br><span class="line">    printf(&quot;1:0x%x\n&quot;,temp);</span><br><span class="line">    </span><br><span class="line">    get_value(temp);</span><br><span class="line"></span><br><span class="line">    printf(&quot;4:%s\n&quot;,temp);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2019/12/15/C%E8%AF%AD%E8%A8%80-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/1.png" alt="1"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void get_value(char * ptemp)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;2:0x%x\n&quot;,ptemp);</span><br><span class="line">    for(char i=0;i&lt;13;i++)//这样可以，temp和ptemp都在栈函数数据区域中，main函数调用get_value，get_value会先释放，但是temp申请的内存空间，此时并没有释放，所以可以拿到值。</span><br><span class="line">&#123;</span><br><span class="line">ptemp[i] = &apos;h&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;3:%s\n&quot;,ptemp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char temp[13]=&#123;0&#125;;</span><br><span class="line">    printf(&quot;1:0x%x\n&quot;,temp);</span><br><span class="line">    </span><br><span class="line">    get_value(temp);</span><br><span class="line"></span><br><span class="line">    printf(&quot;4:%s\n&quot;,temp);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2019/12/15/C%E8%AF%AD%E8%A8%80-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/2.png" alt="2"></p><h5 id="9-通过结构体类型的局部变量数组在另一个函数去取值-传一个结构体变量的地址，用指针变量来接收，用指针来指向一个值"><a href="#9-通过结构体类型的局部变量数组在另一个函数去取值-传一个结构体变量的地址，用指针变量来接收，用指针来指向一个值" class="headerlink" title="9. 通过结构体类型的局部变量数组在另一个函数去取值(传一个结构体变量的地址，用指针变量来接收，用指针来指向一个值)"></a>9. 通过结构体类型的局部变量数组在另一个函数去取值(传一个结构体变量的地址，用指针变量来接收，用指针来指向一个值)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">char hisi_app[9];</span><br><span class="line">char sys_lib[9];</span><br><span class="line">char mb_mcu[9];</span><br><span class="line">char mcu_4g[9];</span><br><span class="line">char mcu_1256[9];</span><br><span class="line">char device[7];</span><br><span class="line">&#125;file_ver_t;</span><br><span class="line"></span><br><span class="line">void read_file_version(file_ver_t *pfile_ver)</span><br><span class="line">&#123;</span><br><span class="line">memset(pfile_ver-&gt;hisi_app,0,9);</span><br><span class="line">memcpy(pfile_ver-&gt;hisi_app,&quot;3.01.0001&quot;,9);</span><br><span class="line">printf(&quot;%s\n&quot;, pfile_ver-&gt;hisi_app);</span><br><span class="line">memcpy(pfile_ver-&gt;sys_lib,&quot;3.01.0001&quot;,9);</span><br><span class="line">printf(&quot;%s\n&quot;, pfile_ver-&gt;sys_lib);</span><br><span class="line">memcpy(pfile_ver-&gt;mb_mcu,&quot;3.01.0001&quot;,9);</span><br><span class="line">printf(&quot;%s\n&quot;, pfile_ver-&gt;mb_mcu);</span><br><span class="line">memcpy(pfile_ver-&gt;mcu_4g,&quot;3.01.0001&quot;,9);</span><br><span class="line">printf(&quot;%s\n&quot;, pfile_ver-&gt;mcu_4g);</span><br><span class="line">memcpy(pfile_ver-&gt;mcu_1256,&quot;3.01.0001&quot;,9);</span><br><span class="line">printf(&quot;%s\n&quot;, pfile_ver-&gt;mcu_1256);</span><br><span class="line">memcpy(pfile_ver-&gt;device,&quot;1.00.00&quot;,7);</span><br><span class="line">printf(&quot;%s\n&quot;, pfile_ver-&gt;device);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">file_ver_t file_ver;</span><br><span class="line">read_file_version(&amp;file_ver);</span><br><span class="line"></span><br><span class="line">printf(&quot;%s\n&quot;, file_ver.hisi_app);</span><br><span class="line">printf(&quot;%s\n&quot;, file_ver.sys_lib);</span><br><span class="line">printf(&quot;%s\n&quot;, file_ver.mb_mcu);</span><br><span class="line">printf(&quot;%s\n&quot;, file_ver.mcu_4g);</span><br><span class="line">printf(&quot;%s\n&quot;, file_ver.mcu_1256);</span><br><span class="line">printf(&quot;%s\n&quot;, file_ver.device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2019/12/15/C%E8%AF%AD%E8%A8%80-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/3.png" alt="3"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般的来说，函数是可以返回局部变量的。&lt;/p&gt;
&lt;p&gt;局部变量的作用域只在函数内部，在函数返回后，局部变量的内存已经释放了。&lt;/p&gt;
&lt;p&gt;因此，如果函数返回的是局部变量的值，不涉及地址，程序不会出错。&lt;/p&gt;
&lt;p&gt;但是如果返回的是局部变量的地址(指针)的话，程序运行后会出错。&lt;/p&gt;
&lt;p&gt;因为函数只是把指针复制后返回了，但是指针指向的内容已经被释放了，这样指针指向的内容就是不可预料的内容，调用就会出错。&lt;/p&gt;
&lt;p&gt;准确的来说，函数不能通过返回指向栈内存的指针(注意这里指的是栈，返回指向堆内存的指针是可以的)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://www.faihung.net/categories/C/"/>
    
    
      <category term="指针" scheme="http://www.faihung.net/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="生存周期" scheme="http://www.faihung.net/tags/%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F/"/>
    
      <category term="内存分配" scheme="http://www.faihung.net/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
      <category term="局部变量" scheme="http://www.faihung.net/tags/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"/>
    
      <category term="数组取值" scheme="http://www.faihung.net/tags/%E6%95%B0%E7%BB%84%E5%8F%96%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>问题-notepadd++  ANSI编码与UTF-8编码</title>
    <link href="http://www.faihung.net/2019/12/15/%E9%97%AE%E9%A2%98-notepadd-ANSI%E7%BC%96%E7%A0%81%E4%B8%8EUTF-8%E7%BC%96%E7%A0%81/"/>
    <id>http://www.faihung.net/2019/12/15/问题-notepadd-ANSI编码与UTF-8编码/</id>
    <published>2019-12-14T16:33:10.000Z</published>
    <updated>2019-12-14T16:36:13.899Z</updated>
    
    <content type="html"><![CDATA[<p>之前有一种见鬼的感觉，主要表现在写脚本上（写脚本主要是因为空格的原因），写程序倒是不会出现。结果导致脚本执行不成功。</p><a id="more"></a><p>使用UTF-8编码</p><p><img src="/2019/12/15/%E9%97%AE%E9%A2%98-notepadd-ANSI%E7%BC%96%E7%A0%81%E4%B8%8EUTF-8%E7%BC%96%E7%A0%81/1.png" alt="1"></p><p>使用ANSI编码</p><p><img src="/2019/12/15/%E9%97%AE%E9%A2%98-notepadd-ANSI%E7%BC%96%E7%A0%81%E4%B8%8EUTF-8%E7%BC%96%E7%A0%81/2.png" alt="2"></p><p>这种情况要记住，以后不要在这上面浪费时间了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前有一种见鬼的感觉，主要表现在写脚本上（写脚本主要是因为空格的原因），写程序倒是不会出现。结果导致脚本执行不成功。&lt;/p&gt;
    
    </summary>
    
    
      <category term="问题" scheme="http://www.faihung.net/categories/%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="notepadd" scheme="http://www.faihung.net/tags/notepadd/"/>
    
      <category term="UTF-8" scheme="http://www.faihung.net/tags/UTF-8/"/>
    
      <category term="ANSI" scheme="http://www.faihung.net/tags/ANSI/"/>
    
  </entry>
  
  <entry>
    <title>工程设计-html boa cgi上传文件</title>
    <link href="http://www.faihung.net/2019/12/15/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-html-boa-cgi%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"/>
    <id>http://www.faihung.net/2019/12/15/工程设计-html-boa-cgi上传文件/</id>
    <published>2019-12-14T16:20:25.000Z</published>
    <updated>2019-12-14T16:21:48.864Z</updated>
    
    <content type="html"><![CDATA[<p>暂略</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;暂略&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="工程设计" scheme="http://www.faihung.net/categories/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="html" scheme="http://www.faihung.net/tags/html/"/>
    
      <category term="boa" scheme="http://www.faihung.net/tags/boa/"/>
    
      <category term="cgi" scheme="http://www.faihung.net/tags/cgi/"/>
    
  </entry>
  
  <entry>
    <title>工程设计-软件升级之设备端FTP文件上传与下载(1)</title>
    <link href="http://www.faihung.net/2019/12/14/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E8%BD%AF%E4%BB%B6%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%AE%BE%E5%A4%87%E7%AB%AFFTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD-1/"/>
    <id>http://www.faihung.net/2019/12/14/工程设计-软件升级之设备端FTP文件上传与下载-1/</id>
    <published>2019-12-14T15:25:12.000Z</published>
    <updated>2019-12-29T15:50:10.674Z</updated>
    
    <content type="html"><![CDATA[<h4 id="主要目的"><a href="#主要目的" class="headerlink" title="主要目的"></a>主要目的</h4><h5 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h5><h6 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h6><p>av_streamer input_streamer output_app</p><a id="more"></a><h6 id="系统库"><a href="#系统库" class="headerlink" title="系统库"></a>系统库</h6><p>libapp_para.so<br>libntptime.so<br>libsys_commom.so<br>libsys_serial.so<br>libdevsdk.so<br>librtmp_push.so<br>libsys_httppro.so<br>libdhclient.so<br>librtsp.so<br>libsys_media.so<br>libnnie_ai.so<br>libsys_base.so<br>libsys_mp4_storage.so</p><h6 id="MCU程序"><a href="#MCU程序" class="headerlink" title="MCU程序"></a>MCU程序</h6><p>和上面类似（略）</p><h5 id="上传日志"><a href="#上传日志" class="headerlink" title="上传日志"></a>上传日志</h5><p>程序运行记录（略）</p><h4 id="第一阶段-正常环境下"><a href="#第一阶段-正常环境下" class="headerlink" title="第一阶段-正常环境下"></a>第一阶段-正常环境下</h4><p>还是直接看图比较直观。<br><img src="/2019/12/14/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E8%BD%AF%E4%BB%B6%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%AE%BE%E5%A4%87%E7%AB%AFFTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD-1/1.png" alt="1"></p><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p><a href="https://github.com/faihung/cURL" target="_blank" rel="noopener">参考代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;主要目的&quot;&gt;&lt;a href=&quot;#主要目的&quot; class=&quot;headerlink&quot; title=&quot;主要目的&quot;&gt;&lt;/a&gt;主要目的&lt;/h4&gt;&lt;h5 id=&quot;下载文件&quot;&gt;&lt;a href=&quot;#下载文件&quot; class=&quot;headerlink&quot; title=&quot;下载文件&quot;&gt;&lt;/a&gt;下载文件&lt;/h5&gt;&lt;h6 id=&quot;应用程序&quot;&gt;&lt;a href=&quot;#应用程序&quot; class=&quot;headerlink&quot; title=&quot;应用程序&quot;&gt;&lt;/a&gt;应用程序&lt;/h6&gt;&lt;p&gt;av_streamer input_streamer output_app&lt;/p&gt;
    
    </summary>
    
    
      <category term="工程设计" scheme="http://www.faihung.net/categories/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="cURL" scheme="http://www.faihung.net/tags/cURL/"/>
    
      <category term="FTP" scheme="http://www.faihung.net/tags/FTP/"/>
    
      <category term="流程图" scheme="http://www.faihung.net/tags/%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    
      <category term="http" scheme="http://www.faihung.net/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>cURL-09_使用curl库进行http通信(转)</title>
    <link href="http://www.faihung.net/2019/12/12/cURL-09-%E4%BD%BF%E7%94%A8curl%E5%BA%93%E8%BF%9B%E8%A1%8Chttp%E9%80%9A%E4%BF%A1-%E8%BD%AC/"/>
    <id>http://www.faihung.net/2019/12/12/cURL-09-使用curl库进行http通信-转/</id>
    <published>2019-12-12T07:37:14.000Z</published>
    <updated>2019-12-12T07:38:23.583Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一、LibCurl基本编程框架"><a href="#一、LibCurl基本编程框架" class="headerlink" title="一、LibCurl基本编程框架"></a>一、LibCurl基本编程框架</h5><p>关于libcurl，<a href="https://www.faihung.net/2019/11/03/cURL-01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BA%86%E8%A7%A3/">前面已经有了很多介绍</a>，这里就不详西描述了。</p><p>在基于LibCurl的程序里，主要采用callback function （回调函数）的形式完成传输任务，用户在启动传输前设置好各类参数和回调函数，当满足条件时libcurl将调用用户的回调函数实现特定功能。</p><a id="more"></a><p>下面是利用libcurl完成传输任务的流程：</p><ol><li>调用curl_global_init()初始化libcurl</li><li>调用curl_easy_init()函数得到 easy interface 型指针</li><li>调用curl_easy_setopt()设置传输选项</li><li>根据curl_easy_setopt()设置的传输选项，实现回调函数以完成用户特定任务</li><li>调用curl_easy_perform()函数完成传输任务</li><li>调用curl_easy_cleanup()释放内存</li></ol><p>在整过过程中设置curl_easy_setopt()参数是最关键的，几乎所有的libcurl程序都要使用它。</p><h5 id="二、一些基本的函数"><a href="#二、一些基本的函数" class="headerlink" title="二、一些基本的函数"></a>二、一些基本的函数</h5><h6 id="1-CURLcode-curl-global-init-long-flags"><a href="#1-CURLcode-curl-global-init-long-flags" class="headerlink" title="1.CURLcode curl_global_init(long flags);"></a>1.CURLcode curl_global_init(long flags);</h6><p>描述：<br>这个函数只能用一次。(其实在调用curl_global_cleanup 函数后仍然可再用)<br>如果这个函数在curl_easy_init函数调用时还没调用，它将由libcurl库自动调用，所以多线程下最好主动调用该函数以防止在线程中curl_easy_init时多次调用。</p><p>注意：虽然libcurl是线程安全的，但curl_global_init是不能保证线程安全的，所以不要在每个线程中都调用curl_global_init，应该将该函数的调用放在主线程中。</p><p>参数：flags</p><pre><code>CURL_GLOBAL_ALL             //初始化所有的可能的调用。CURL_GLOBAL_SSL             //初始化支持安全套接字层。CURL_GLOBAL_WIN32           //初始化win32套接字库。CURL_GLOBAL_NOTHING         //没有额外的初始化。</code></pre><h6 id="2-void-curl-global-cleanup-void"><a href="#2-void-curl-global-cleanup-void" class="headerlink" title="2 void curl_global_cleanup(void);"></a>2 void curl_global_cleanup(void);</h6><p>描述：在结束libcurl使用的时候，用来对curl_global_cleanup做的工作清理。类似于close的函数。</p><p>注意：虽然libcurl是线程安全的，但curl_global_cleanup是不能保证线程安全的，所以不要在每个线程中都调用curl_global_init，应该将该函数的调用放在主线程中。</p><h6 id="3-char-curl-version"><a href="#3-char-curl-version" class="headerlink" title="3 char *curl_version( );"></a>3 char *curl_version( );</h6><p>描述: 打印当前libcurl库的版本。</p><h6 id="4-CURL-curl-easy-init"><a href="#4-CURL-curl-easy-init" class="headerlink" title="4 CURL *curl_easy_init( );"></a>4 CURL *curl_easy_init( );</h6><p>描述:<br>curl_easy_init用来初始化一个CURL的指针(有些像返回FILE类型的指针一样). 相应的在调用结束时要用curl_easy_cleanup函数清理.<br>一般curl_easy_init意味着一个会话的开始. 它会返回一个easy_handle(CURL*对象), 一般都用在easy系列的函数中.</p><h6 id="5-void-curl-easy-cleanup-CURL-handle"><a href="#5-void-curl-easy-cleanup-CURL-handle" class="headerlink" title="5 void curl_easy_cleanup(CURL *handle);"></a>5 void curl_easy_cleanup(CURL *handle);</h6><p>描述:<br>这个调用用来结束一个会话，curl_easy_init配合着用。</p><p>参数:<br>CURL类型的指针.</p><h6 id="6-CURLcode-curl-easy-setopt-CURL-handle-CURLoption-option-parameter"><a href="#6-CURLcode-curl-easy-setopt-CURL-handle-CURLoption-option-parameter" class="headerlink" title="6 CURLcode curl_easy_setopt(CURL *handle, CURLoption option, parameter);"></a>6 CURLcode curl_easy_setopt(CURL *handle, CURLoption option, parameter);</h6><p>描述: 这个函数最重要了.几乎所有的curl程序都要频繁的使用它.它告诉curl库.程序将有如何的行为. 比如要查看一个网页的html代码等.(这个函数有些像ioctl函数)参数:</p><ol><li>CURL类型的指针。</li><li>各种CURLoption类型的选项.(都在curl.h库里有定义,man也可以查看到)</li><li>parameter 这个参数既可以是个函数的指针,也可以是某个对象的指针,也可以是个long型的变量.它用什么这取决于第二个参数。<br>CURLoption 这个参数的取值很多.具体的可以查看man手册。</li></ol><h6 id="7-CURLcode-curl-easy-perform-CURL-handle"><a href="#7-CURLcode-curl-easy-perform-CURL-handle" class="headerlink" title="7 CURLcode curl_easy_perform(CURL *handle);"></a>7 CURLcode curl_easy_perform(CURL *handle);</h6><p>描述:这个函数在初始化CURL类型的指针 以及curl_easy_setopt完成后调用.就像字面的意思所说perform就像是个舞台，让我们设置的<br>option 运作起来.</p><p>参数:<br>CURL类型的指针。</p><h5 id="三、curl-easy-setopt函数部分选项介绍"><a href="#三、curl-easy-setopt函数部分选项介绍" class="headerlink" title="三、curl_easy_setopt函数部分选项介绍"></a>三、curl_easy_setopt函数部分选项介绍</h5><p>本节主要介绍curl_easy_setopt中跟http相关的参数。该函数是curl中非常重要的函数，curl所有设置都是在该函数中完成的，该函数的设置选项众多，注意本节的阐述的只是部分常见选项。</p><h6 id="1-CURLOPT-URL"><a href="#1-CURLOPT-URL" class="headerlink" title="1.CURLOPT_URL"></a>1.CURLOPT_URL</h6><p>设置访问URL</p><h6 id="2-CURLOPT-WRITEFUNCTION，CURLOPT-WRITEDATA"><a href="#2-CURLOPT-WRITEFUNCTION，CURLOPT-WRITEDATA" class="headerlink" title="2.CURLOPT_WRITEFUNCTION，CURLOPT_WRITEDATA"></a>2.CURLOPT_WRITEFUNCTION，CURLOPT_WRITEDATA</h6><p>回调函数原型为：</p><pre><code>size_t function( void *ptr, size_t size, size_t nmemb, void *stream);</code></pre><p>函数将在libcurl接收到数据后被调用，因此函数多做数据保存的功能，如处理下载文件。</p><p>CURLOPT_WRITEDATA 用于表明CURLOPT_WRITEFUNCTION函数中的stream指针的来源。<br>如果你没有通过CURLOPT_WRITEFUNCTION属性给easy handle设置回调函数，libcurl会提供一个默认的回调函数，它只是简单的将接收到的数据打印到标准输出。你也可以通过 CURLOPT_WRITEDATA属性给默认回调函数传递一个已经打开的文件指针，用于将数据输出到文件里。</p><h6 id="3-CURLOPT-HEADERFUNCTION，CURLOPT-HEADERDATA"><a href="#3-CURLOPT-HEADERFUNCTION，CURLOPT-HEADERDATA" class="headerlink" title="3.CURLOPT_HEADERFUNCTION，CURLOPT_HEADERDATA"></a>3.CURLOPT_HEADERFUNCTION，CURLOPT_HEADERDATA</h6><p>回调函数原型为 </p><pre><code>size_t function( void *ptr, size_t size,size_t nmemb, void *stream);</code></pre><p>libcurl一旦接收到http 头部数据后将调用该函数。CURLOPT_WRITEDATA 传递指针给libcurl，该指针表明CURLOPT_HEADERFUNCTION函数的stream指针的来源。</p><h6 id="4-CURLOPT-READFUNCTION-CURLOPT-READDATA"><a href="#4-CURLOPT-READFUNCTION-CURLOPT-READDATA" class="headerlink" title="4.CURLOPT_READFUNCTION CURLOPT_READDATA"></a>4.CURLOPT_READFUNCTION CURLOPT_READDATA</h6><p>libCurl需要读取数据传递给远程主机时将调用CURLOPT_READFUNCTION指定的函数，函数原型是：</p><pre><code>size_t function(void *ptr, size_t size, size_t nmemb,void *stream)；</code></pre><p>CURLOPT_READDATA 表明CURLOPT_READFUNCTION函数原型中的stream指针来源。</p><h6 id="5-CURLOPT-NOPROGRESS，CURLOPT-PROGRESSFUNCTION，CURLOPT-PROGRESSDATA"><a href="#5-CURLOPT-NOPROGRESS，CURLOPT-PROGRESSFUNCTION，CURLOPT-PROGRESSDATA" class="headerlink" title="5.CURLOPT_NOPROGRESS，CURLOPT_PROGRESSFUNCTION，CURLOPT_PROGRESSDATA"></a>5.CURLOPT_NOPROGRESS，CURLOPT_PROGRESSFUNCTION，CURLOPT_PROGRESSDATA</h6><p>跟数据传输进度相关的参数。CURLOPT_PROGRESSFUNCTION指定的函数正常情况下每秒被libcurl调用一次，为了使CURLOPT_PROGRESSFUNCTION被调用，CURLOPT_NOPROGRESS必须被设置为false，CURLOPT_PROGRESSDATA指定的参数将作为CURLOPT_PROGRESSFUNCTION指定函数的第一个参数</p><h6 id="6-CURLOPT-TIMEOUT，CURLOPT-CONNECTIONTIMEOUT"><a href="#6-CURLOPT-TIMEOUT，CURLOPT-CONNECTIONTIMEOUT" class="headerlink" title="6.CURLOPT_TIMEOUT，CURLOPT_CONNECTIONTIMEOUT"></a>6.CURLOPT_TIMEOUT，CURLOPT_CONNECTIONTIMEOUT</h6><p>CURLOPT_TIMEOUT 由于设置传输时间，CURLOPT_CONNECTIONTIMEOUT 设置连接等待时间</p><h6 id="7-CURLOPT-FOLLOWLOCATION"><a href="#7-CURLOPT-FOLLOWLOCATION" class="headerlink" title="7.CURLOPT_FOLLOWLOCATION"></a>7.CURLOPT_FOLLOWLOCATION</h6><p>设置重定位URL</p><h6 id="8-CURLOPT-RANGE-CURLOPT-RESUME-FROM"><a href="#8-CURLOPT-RANGE-CURLOPT-RESUME-FROM" class="headerlink" title="8.CURLOPT_RANGE: CURLOPT_RESUME_FROM:"></a>8.CURLOPT_RANGE: CURLOPT_RESUME_FROM:</h6><p>断点续传相关设置。CURLOPT_RANGE 指定char *参数传递给libcurl，用于指明http域的RANGE头域，</p><p>例如：</p><pre><code>表示头500个字节：bytes=0-499表示第二个500字节：bytes=500-999表示最后500个字节：bytes=-500表示500字节以后的范围：bytes=500-第一个和最后一个字节：bytes=0-0,-1同时指定几个范围：bytes=500-600,601-999</code></pre><p>CURLOPT_RESUME_FROM 传递一个long参数给libcurl，指定你希望开始传递的偏移量。</p><h5 id="四、curl-easy-perform-函数说明（error-状态码）"><a href="#四、curl-easy-perform-函数说明（error-状态码）" class="headerlink" title="四、curl_easy_perform 函数说明（error 状态码）"></a>四、curl_easy_perform 函数说明（error 状态码）</h5><p>该函数是完成curl_easy_setopt指定的所有选项，本节重点介绍curl_easy_perform的返回值。返回0意味一切ok，非0代表错误发生。主要错误码说明：</p><pre><code>1.CURLE_OK任务完成一切都好2.CURLE_UNSUPPORTED_PROTOCOL不支持的协议，由URL的头部指定3.CURLE_COULDNT_CONNECT不能连接到remote 主机或者代理4.CURLE_REMOTE_ACCESS_DENIED访问被拒绝5.CURLE_HTTP_RETURNED_ERRORHttp返回错误6.CURLE_READ_ERROR读本地文件错误</code></pre><p>要获取详细的错误描述字符串，可以通过</p><pre><code>const char *curl_easy_strerror(CURLcode errornum ) </code></pre><p>这个函数取得。    </p><h5 id="五、libcurl使用的HTTP消息头"><a href="#五、libcurl使用的HTTP消息头" class="headerlink" title="五、libcurl使用的HTTP消息头"></a>五、libcurl使用的HTTP消息头</h5><p>当使用libcurl发送http请求时，它会自动添加一些http头。我们可以通过CURLOPT_HTTPHEADER属性手动替换、添加或删除相应 的HTTP消息头。</p><pre><code>Hosthttp1.1（大部分http1.0)版本都要求客户端请求提供这个信息头。Pragma&quot;no-cache&quot;。表示不要缓冲数据。Accept&quot;*/*&quot;。表示允许接收任何类型的数据。Expect以POST的方式向HTTP服务器提交请求时，libcurl会设置该消息头为&quot;100-continue&quot;，它要求服务器在正式处理该请求之前，返回一 个&quot;OK&quot;消息。如果POST的数据很小，libcurl可能不会设置该消息头。</code></pre><p><strong>自定义选项</strong></p><p>当前越来越多的协议都构建在HTTP协议之上（如：soap），这主要归功于HTTP的可靠性，以及被广泛使用的代理支持（可以穿透大部分防火墙）。 这些协议的使用方式与传统HTTP可能有很大的不同。对此，libcurl作了很好的支持。</p><p>自定义请求方式(CustomRequest)，<br>HTTP支持GET, HEAD或者POST提交请求。可以设置CURLOPT_CUSTOMREQUEST来设置自定义的请求方式，libcurl默认以GET方式提交请求：</p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_CUSTOMREQUEST, &quot;MYOWNREQUEST&quot;);</code></pre><p><strong>修改消息头</strong></p><p>HTTP协议提供了消息头，请求消息头用于告诉服务器如何处理请求；响应消息头则告诉浏览器如何处理接收到的数据。在libcurl中，你可以自由的添加这些消息头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct curl_slist *headers=NULL; /* init to NULL is important */</span><br><span class="line">headers = curl_slist_append(headers, &quot;Hey-server-hey: how are you?&quot;);</span><br><span class="line">headers = curl_slist_append(headers, &quot;X-silly-content: yes&quot;);</span><br><span class="line">/* pass our list of custom made headers */</span><br><span class="line">curl_easy_setopt(easyhandle, CURLOPT_HTTPHEADER, headers);</span><br><span class="line">curl_easy_perform(easyhandle); /* transfer http */</span><br><span class="line">curl_slist_free_all(headers); /* free the header list */</span><br></pre></td></tr></table></figure><p>对于已经存在的消息头，可以重新设置它的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">headers = curl_slist_append(headers, &quot;Accept: Agent-007&quot;); </span><br><span class="line">headers = curl_slist_append(headers, &quot;Host: munged.host.line&quot;);</span><br></pre></td></tr></table></figure><p><strong>删除消息头</strong></p><p>对于一个已经存在的消息头，设置它的内容为空，libcurl在发送请求时就不会同时提交该消息头：</p><pre><code>headers = curl_slist_append(headers, &quot;Accept:&quot;);</code></pre><h5 id="六、获取http应答头信息"><a href="#六、获取http应答头信息" class="headerlink" title="六、获取http应答头信息"></a>六、获取http应答头信息</h5><p>发出http请求后，服务器会返回应答头信息和应答数据，如果仅仅是打印应答头的所有内容，则直接可以通过curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, 打印函数)的方式来完成，这里需要获取的是应答头中特定的信息，比如应答码、cookies列表等，则需要通过下面这个函数：</p><pre><code>CURLcode curl_easy_getinfo(CURL *curl, CURLINFO info, ... );</code></pre><p>info参数就是我们需要获取的内容，下面是一些参数值:</p><pre><code>1.CURLINFO_RESPONSE_CODE 获取应答码2.CURLINFO_HEADER_SIZE 头大小3.CURLINFO_COOKIELIST cookies列表</code></pre><p>除了获取应答信息外，这个函数还能获取curl的一些内部信息，如请求时间、连接时间等等。</p><p>更多的参数可以参考API文档。</p><h5 id="七、多线程问题"><a href="#七、多线程问题" class="headerlink" title="七、多线程问题"></a>七、多线程问题</h5><p>首先一个基本原则就是：绝对不应该在线程之间共享同一个libcurl handle(CURL *对象)，不管是easy handle还是multi handle（本文只介绍easy_handle）。一个线程每次只能使用一个handle。</p><p>libcurl是线程安全的，但有两点例外：信号(signals)和SSL/TLS handler。 信号用于超时失效名字解析(timing out name resolves)。libcurl依赖其他的库来支持SSL/STL，所以用多线程的方式访问HTTPS或FTPS的URL时，应该满足这些库对多线程 操作的一些要求。</p><p>NSS: 宣称是多线程安全的。</p><h5 id="八、什么时候libcurl无法正常工作"><a href="#八、什么时候libcurl无法正常工作" class="headerlink" title="八、什么时候libcurl无法正常工作"></a>八、什么时候libcurl无法正常工作</h5><p>传输失败总是有原因的。你可能错误的设置了一些libcurl的属性或者没有正确的理解某些属性的含义，或者是远程主机返回一些无法被正确解析的内容。</p><p>这里有一个<strong>黄金法则</strong>来处理这些问题：</p><p>将CURLOPT_VERBOSE属性设置为1，libcurl会输出通信过程中的一些细节。如果使用的是http协议，请求头/响应头也会被输出。将CURLOPT_HEADER设为1，这些头信息将出现在消息的内容中。</p><p>当然不可否认的是，libcurl还存在bug。</p><p>如果你对相关的协议了解越多，在使用libcurl时，就越不容易犯错。</p><h5 id="九、关于密码"><a href="#九、关于密码" class="headerlink" title="九、关于密码"></a>九、关于密码</h5><p>客户端向服务器发送请求时，许多协议都要求提供用户名与密码。libcurl提供了多种方式来设置它们。</p><p>一些协议支持在URL中直接指定用户名和密码，类似于：<br>protocol://user:<a href="mailto:password@example.com" target="_blank" rel="noopener">password@example.com</a>/path/。libcurl能正确的识别这种URL中的用户名与密码并执行相应的操作。如果你提供的用户名和密码中有特殊字符，首先应该对其进行URL编码。</p><p>也可以通过CURLOPT_USERPWD属性来设置用户名与密码。参数是格式如<br>“user:password ”的字符串：</p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_USERPWD, &quot;user_name:password&quot;);</code></pre><p>有时候在访问代理服务器的时候，可能时时要求提供用户名和密码进行用户身份验证。这种情况下，libcurl提供了另一个属性CURLOPT_PROXYUSERPWD：</p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_PROXYUSERPWD, &quot;user_name:password&quot;);</code></pre><p>在UNIX平台下，访问FTP的用户名和密码可能会被保存在$HOME/.netrc文件中。libcurl支持直接从这个文件中获取用户名与密码：  </p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_NETRC, 1L);    </code></pre><p>在使用SSL时，可能需要提供一个私钥用于数据安全传输，通过CURLOPT_KEYPASSWD来设置私钥：</p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_KEYPASSWD, &quot;keypassword&quot;);</code></pre><h5 id="十、HTTP验证"><a href="#十、HTTP验证" class="headerlink" title="十、HTTP验证"></a>十、HTTP验证</h5><p>在使用HTTP协议时，客户端有很多种方式向服务器提供验证信息。默认的HTTP验证方法是”Basic”，它将用户名与密码以明文的方式、经Base64编码后保存在HTTP请求头中，发往服务器。当然这不太安全。</p><p>当前版本的libcurl支持的验证方法有：basic, Digest, NTLM, Negotiate, GSS-Negotiate and SPNEGO。（译者感叹：搞Web这么多年，尽然不知道这些Http的验证方式，实在惭愧。）可以通过CURLOPT_HTTPAUTH属性来设置具体 的验证方式：</p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_HTTPAUTH, CURLAUTH_DIGEST);</code></pre><p>向代理服务器发送验证信息时，可以通过CURLOPT_PROXYAUTH设置验证方式：</p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_PROXYAUTH, CURLAUTH_NTLM);</code></pre><p>也可以同时设置多种验证方式（通过按位与）， 使用’CURLAUTH_ANY’将允许libcurl可以选择任何它所支持的验证方式。通过CURLOPT_HTTPAUTH或 CURLOPT_PROXYAUTH属性设置的多种验证方式，libcurl会在运行时选择一种它认为是最好的方式与服务器通信：</p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_HTTPAUTH,  CURLAUTH_DIGEST|CURLAUTH_BASIC);// curl_easy_setopt(easy_handle, CURLOPT_HTTPAUTH,  CURLAUTH_ANY);</code></pre><h5 id="十一、代码示例"><a href="#十一、代码示例" class="headerlink" title="十一、代码示例"></a>十一、代码示例</h5><h6 id="1-基本的http-GET-POST操作"><a href="#1-基本的http-GET-POST操作" class="headerlink" title="1.基本的http GET/POST操作"></a>1.基本的http GET/POST操作</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line"></span><br><span class="line">bool getUrl(char *filename)</span><br><span class="line">&#123;</span><br><span class="line">    CURL *curl;</span><br><span class="line">    CURLcode res;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    if ((fp = fopen(filename, &quot;w&quot;)) == NULL)  //返回结果用文件存储</span><br><span class="line">        return false;</span><br><span class="line">    struct curl_slist *headers = NULL;</span><br><span class="line">    headers = curl_slist_append(headers, &quot;Accept: Agent-007&quot;);</span><br><span class="line">    curl = curl_easy_init();    //初始化</span><br><span class="line">    if (curl)</span><br><span class="line">    &#123;</span><br><span class="line">        //curl_easy_setopt(curl, CURLOPT_PROXY, &quot;10.99.60.201:8080&quot;);//代理</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);//改协议头</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_URL,&quot;http://www.baidu.com&quot;);</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp); //将返回的http头输出到fp指向的文件</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_HEADERDATA, fp); //将返回的html主体数据输出到fp指向的文件</span><br><span class="line">        res = curl_easy_perform(curl);   // 执行</span><br><span class="line">        if (res != 0) &#123;</span><br><span class="line"></span><br><span class="line">            curl_slist_free_all(headers);</span><br><span class="line">            curl_easy_cleanup(curl);</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool postUrl(char *filename)</span><br><span class="line">&#123;</span><br><span class="line">    CURL *curl;</span><br><span class="line">    CURLcode res;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    if ((fp = fopen(filename, &quot;w&quot;)) == NULL)</span><br><span class="line">        return false;</span><br><span class="line">    curl = curl_easy_init();</span><br><span class="line">    if (curl)</span><br><span class="line">    &#123;</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_COOKIEFILE, &quot;/mnt/hgfs/VMWARE/test/10-http/temp/cookie.txt&quot;); // 指定cookie文件</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, &quot;&amp;logintype=uid&amp;u=xieyan&amp;psw=xxx86&quot;);    // 指定post内容</span><br><span class="line">        //curl_easy_setopt(curl, CURLOPT_PROXY, &quot;10.99.60.201:8080&quot;);</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_URL, &quot; http://mail.sina.com.cn/cgi-bin/login.cgi &quot;);   // 指定url</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);</span><br><span class="line">        res = curl_easy_perform(curl);</span><br><span class="line">        curl_easy_cleanup(curl);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    getUrl(&quot;/mnt/hgfs/VMWARE/test/10-http/temp/get.html&quot;);</span><br><span class="line">    postUrl(&quot;/mnt/hgfs/VMWARE/test/10-http/temp/post.html&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令：</p><pre><code>gcc  get_post.c  -o get_post –lcurl./ get_post</code></pre><p>得到结果：<br>略</p><h6 id="2-获取html网页"><a href="#2-获取html网页" class="headerlink" title="2. 获取html网页"></a>2. 获取html网页</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    CURL *curl;             //定义CURL类型的指针</span><br><span class="line">    CURLcode res;           //定义CURLcode类型的变量，保存返回状态码</span><br><span class="line">    if(argc!=2)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Usage : file &lt;url&gt;;\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    curl = curl_easy_init();        //初始化一个CURL类型的指针</span><br><span class="line">    if(curl!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        //设置curl选项. 其中CURLOPT_URL是让用户指 定url. argv[1]中存放的命令行传进来的网址</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_URL, argv[1]);        </span><br><span class="line">        //调用curl_easy_perform 执行我们的设置.并进行相关的操作. 在这 里只在屏幕上显示出来.</span><br><span class="line">        res = curl_easy_perform(curl);</span><br><span class="line">        //清除curl操作.</span><br><span class="line">        curl_easy_cleanup(curl);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令：</p><pre><code>gcc  get_http.c  -o get_http –lcurl./get_http www.baidu.com</code></pre><h6 id="3-网页下载保存实例"><a href="#3-网页下载保存实例" class="headerlink" title="3. 网页下载保存实例"></a>3. 网页下载保存实例</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 采用CURLOPT_WRITEFUNCTION 实现网页下载保存功能</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;;</span><br><span class="line"> </span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line">#include &lt;curl/types.h&gt;</span><br><span class="line">#include &lt;curl/easy.h&gt;</span><br><span class="line"> </span><br><span class="line">FILE *fp;  //定义FILE类型指针</span><br><span class="line">//这个函数是为了符合CURLOPT_WRITEFUNCTION而构造的</span><br><span class="line">//完成数据保存功能</span><br><span class="line">size_t write_data(void *ptr, size_t size, size_t nmemb, void *stream)  </span><br><span class="line">&#123;</span><br><span class="line">    int written = fwrite(ptr, size, nmemb, (FILE *)fp);</span><br><span class="line">    return written;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    CURL *curl;</span><br><span class="line"> </span><br><span class="line">    curl_global_init(CURL_GLOBAL_ALL);  </span><br><span class="line">    curl=curl_easy_init();</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL, argv[1]);  </span><br><span class="line"> </span><br><span class="line">    if((fp=fopen(argv[2],&quot;w&quot;))==NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        curl_easy_cleanup(curl);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    ////CURLOPT_WRITEFUNCTION 将后继的动作交给write_data函数处理</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);  </span><br><span class="line">    curl_easy_perform(curl);</span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令：</p><pre><code>gcc  save_http.c  -o save_http –lcurl./ save_http www.baidu.com/tmp/baidu</code></pre><h6 id="4-进度条实例显示文件下载进度"><a href="#4-进度条实例显示文件下载进度" class="headerlink" title="4.进度条实例显示文件下载进度"></a>4.进度条实例显示文件下载进度</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">// 采用CURLOPT_NOPROGRESS， CURLOPT_PROGRESSFUNCTION    CURLOPT_PROGRESSDATA 实现文件传输进度提示功能</span><br><span class="line">//函数采用了gtk库，故编译时需指定gtk库</span><br><span class="line">//函数启动专门的线程用于显示gtk 进度条bar</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;gtk/gtk.h&gt;</span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line">#include &lt;curl/types.h&gt; /* new for v7 */</span><br><span class="line">#include &lt;curl/easy.h&gt; /* new for v7 */</span><br><span class="line"> </span><br><span class="line">GtkWidget *Bar;</span><br><span class="line">////这个函数是为了符合CURLOPT_WRITEFUNCTION而构造的</span><br><span class="line">//完成数据保存功能</span><br><span class="line">size_t my_write_func(void *ptr, size_t size, size_t nmemb, FILE *stream)</span><br><span class="line">&#123;</span><br><span class="line">  return fwrite(ptr, size, nmemb, stream);</span><br><span class="line">&#125;</span><br><span class="line">//这个函数是为了符合CURLOPT_READFUNCTION而构造的</span><br><span class="line">//数据上传时使用</span><br><span class="line">size_t my_read_func(void *ptr, size_t size, size_t nmemb, FILE *stream)</span><br><span class="line">&#123;</span><br><span class="line">  return fread(ptr, size, nmemb, stream);</span><br><span class="line">&#125;</span><br><span class="line">//这个函数是为了符合CURLOPT_PROGRESSFUNCTION而构造的</span><br><span class="line">//显示文件传输进度，t代表文件大小，d代表传 输已经完成部分</span><br><span class="line">int my_progress_func(GtkWidget *bar,</span><br><span class="line">                     double t, /* dltotal */</span><br><span class="line">                     double d, /* dlnow */</span><br><span class="line">                     double ultotal,</span><br><span class="line">                     double ulnow)</span><br><span class="line">&#123;</span><br><span class="line">/*  printf(&quot;%d / %d (%g %%)\n&quot;, d, t, d*100.0/t);*/</span><br><span class="line">  gdk_threads_enter();</span><br><span class="line">  gtk_progress_set_value(GTK_PROGRESS(bar), d*100.0/t);</span><br><span class="line">  gdk_threads_leave();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void *my_thread(void *ptr)</span><br><span class="line">&#123;</span><br><span class="line">  CURL *curl;</span><br><span class="line">  CURLcode res;</span><br><span class="line">  FILE *outfile;</span><br><span class="line">  gchar *url = ptr;</span><br><span class="line"> </span><br><span class="line">  curl = curl_easy_init();</span><br><span class="line">  if(curl)</span><br><span class="line">  &#123;</span><br><span class="line">    outfile = fopen(&quot;test.curl&quot;, &quot;w&quot;);</span><br><span class="line"> </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL, url);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEDATA, outfile);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, my_write_func);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_READFUNCTION, my_read_func);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 0L);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_PROGRESSFUNCTION, my_progress_func);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_PROGRESSDATA, Bar);</span><br><span class="line"> </span><br><span class="line">    res = curl_easy_perform(curl);</span><br><span class="line"> </span><br><span class="line">    fclose(outfile);</span><br><span class="line">    /* always cleanup */</span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">  GtkWidget *Window, *Frame, *Frame2;</span><br><span class="line">  GtkAdjustment *adj;</span><br><span class="line"> </span><br><span class="line">  /* Must initialize libcurl before any threads are started */</span><br><span class="line">  curl_global_init(CURL_GLOBAL_ALL);</span><br><span class="line"> </span><br><span class="line">  /* Init thread */</span><br><span class="line">  g_thread_init(NULL);</span><br><span class="line"> </span><br><span class="line">  gtk_init(&amp;argc, &amp;argv);</span><br><span class="line">  Window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</span><br><span class="line">  Frame = gtk_frame_new(NULL);</span><br><span class="line">  gtk_frame_set_shadow_type(GTK_FRAME(Frame), GTK_SHADOW_OUT);</span><br><span class="line">  gtk_container_add(GTK_CONTAINER(Window), Frame);</span><br><span class="line">  Frame2 = gtk_frame_new(NULL);</span><br><span class="line">  gtk_frame_set_shadow_type(GTK_FRAME(Frame2), GTK_SHADOW_IN);</span><br><span class="line">  gtk_container_add(GTK_CONTAINER(Frame), Frame2);</span><br><span class="line">  gtk_container_set_border_width(GTK_CONTAINER(Frame2), 5);</span><br><span class="line">  adj = (GtkAdjustment*)gtk_adjustment_new(0, 0, 100, 0, 0, 0);</span><br><span class="line">  Bar = gtk_progress_bar_new_with_adjustment(adj);</span><br><span class="line">  gtk_container_add(GTK_CONTAINER(Frame2), Bar);</span><br><span class="line">  gtk_widget_show_all(Window);</span><br><span class="line"> </span><br><span class="line">  if (!g_thread_create(&amp;my_thread, argv[1], FALSE, NULL) != 0)</span><br><span class="line">    g_warning(&quot;can&apos;t create the thread&quot;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  gdk_threads_enter();</span><br><span class="line">  gtk_main();</span><br><span class="line">  gdk_threads_leave();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令：</p><pre><code>export PKG_CONFIG_PATH=/usr/lib/pkgconfig/gcc progress.c –o progress ` pkg-config --libs –cflags gtk+-2..0` -lcurl –lgthread-2.0./ progress  http://software.sky-union.cn/index.asp</code></pre><h6 id="5-断点续传实例"><a href="#5-断点续传实例" class="headerlink" title="5.断点续传实例"></a>5.断点续传实例</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">//采用CURLOPT_RESUME_FROM_LARGE 实现文件断点续传功能</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line"> </span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line">//这个函数为CURLOPT_HEADERFUNCTION参数构造</span><br><span class="line">/* 从http头部获取文件size*/</span><br><span class="line">size_t getcontentlengthfunc(void *ptr, size_t size, size_t nmemb, void *stream) &#123;</span><br><span class="line">       int r;</span><br><span class="line">       long len = 0;</span><br><span class="line"> </span><br><span class="line">       /* _snscanf() is Win32 specific */</span><br><span class="line">       // r = _snscanf(ptr, size * nmemb, &quot;Content-Length: %ld\n&quot;, &amp;len);</span><br><span class="line"> r = sscanf(ptr, &quot;Content-Length: %ld\n&quot;, &amp;len);</span><br><span class="line">       if (r) /* Microsoft: we don&apos;t read the specs */</span><br><span class="line">              *((long *) stream) = len;</span><br><span class="line"> </span><br><span class="line">       return size * nmemb;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* 保存下载文件 */</span><br><span class="line">size_t wirtefunc(void *ptr, size_t size, size_t nmemb, void *stream)</span><br><span class="line">&#123;</span><br><span class="line">        return fwrite(ptr, size, nmemb, stream);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/*读取上传文件 */</span><br><span class="line">size_t readfunc(void *ptr, size_t size, size_t nmemb, void *stream)</span><br><span class="line">&#123;</span><br><span class="line">       FILE *f = stream;</span><br><span class="line">       size_t n;</span><br><span class="line"> </span><br><span class="line">       if (ferror(f))</span><br><span class="line">              return CURL_READFUNC_ABORT;</span><br><span class="line"> </span><br><span class="line">       n = fread(ptr, size, nmemb, f) * size;</span><br><span class="line"> </span><br><span class="line">       return n;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 下载 或者上传文件函数</span><br><span class="line">int download(CURL *curlhandle, const char * remotepath, const char * localpath,</span><br><span class="line">           long timeout, long tries)</span><br><span class="line">&#123;</span><br><span class="line">       FILE *f;</span><br><span class="line">       curl_off_t local_file_len = -1 ;</span><br><span class="line">       long filesize =0 ;</span><br><span class="line">       </span><br><span class="line">       CURLcode r = CURLE_GOT_NOTHING;</span><br><span class="line">       int c;</span><br><span class="line">  struct stat file_info;</span><br><span class="line">  int use_resume = 0;</span><br><span class="line">  /* 得到本地文件大小 */</span><br><span class="line">  //if(access(localpath,F_OK) ==0)</span><br><span class="line">  </span><br><span class="line">    if(stat(localpath, &amp;file_info) == 0) </span><br><span class="line">     &#123;</span><br><span class="line">        local_file_len =  file_info.st_size;</span><br><span class="line">        use_resume  = 1;</span><br><span class="line">      &#125;</span><br><span class="line">  //采用追加方式打开文件，便于实现文件断点续传工作</span><br><span class="line">       f = fopen(localpath, &quot;ab+&quot;); </span><br><span class="line">       if (f == NULL) &#123;</span><br><span class="line">              perror(NULL);</span><br><span class="line">              return 0;</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">       //curl_easy_setopt(curlhandle, CURLOPT_UPLOAD, 1L);</span><br><span class="line"> </span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_URL, remotepath);</span><br><span class="line"> </span><br><span class="line">              curl_easy_setopt(curlhandle, CURLOPT_CONNECTTIMEOUT, timeout);  // 设置连接超时，单位秒</span><br><span class="line">       //设置http 头部处理函数</span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_HEADERFUNCTION, getcontentlengthfunc);</span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_HEADERDATA, &amp;filesize);</span><br><span class="line"> // 设置文件续传的位置给libcurl</span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_RESUME_FROM_LARGE, use_resume?local_file_len:0);</span><br><span class="line"> </span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_WRITEDATA, f);</span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_WRITEFUNCTION, wirtefunc);</span><br><span class="line"> </span><br><span class="line">       //curl_easy_setopt(curlhandle, CURLOPT_READFUNCTION, readfunc);</span><br><span class="line">       //curl_easy_setopt(curlhandle, CURLOPT_READDATA, f);</span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_NOPROGRESS, 1L);</span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_VERBOSE, 1L);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  r = curl_easy_perform(curlhandle);</span><br><span class="line">       </span><br><span class="line"> </span><br><span class="line">       fclose(f);</span><br><span class="line"> </span><br><span class="line">       if (r == CURLE_OK)</span><br><span class="line"></span><br><span class="line">              return 1;</span><br><span class="line">       else &#123;</span><br><span class="line">              fprintf(stderr, &quot;%s\n&quot;, curl_easy_strerror(r));</span><br><span class="line">              return 0;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int c, char **argv) &#123;</span><br><span class="line">       CURL *curlhandle = NULL;</span><br><span class="line"> </span><br><span class="line">       curl_global_init(CURL_GLOBAL_ALL);</span><br><span class="line">       curlhandle = curl_easy_init();</span><br><span class="line"> </span><br><span class="line">       //download(curlhandle, &quot;ftp://user:pass@host/path/file&quot;, &quot;C:\\file&quot;, 0, 3);</span><br><span class="line">  download(curlhandle , &quot;http://software.sky-union.cn/index.asp&quot;,&quot;/mnt/hgfs/VMWARE/test/10-http/temp/index.asp&quot;,1,3);</span><br><span class="line">       curl_easy_cleanup(curlhandle);</span><br><span class="line">       curl_global_cleanup();</span><br><span class="line"> </span><br><span class="line">       return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令：</p><pre><code>gcc  resume.c  -o resume –lcurl./ resume  </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;一、LibCurl基本编程框架&quot;&gt;&lt;a href=&quot;#一、LibCurl基本编程框架&quot; class=&quot;headerlink&quot; title=&quot;一、LibCurl基本编程框架&quot;&gt;&lt;/a&gt;一、LibCurl基本编程框架&lt;/h5&gt;&lt;p&gt;关于libcurl，&lt;a href=&quot;https://www.faihung.net/2019/11/03/cURL-01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BA%86%E8%A7%A3/&quot;&gt;前面已经有了很多介绍&lt;/a&gt;，这里就不详西描述了。&lt;/p&gt;
&lt;p&gt;在基于LibCurl的程序里，主要采用callback function （回调函数）的形式完成传输任务，用户在启动传输前设置好各类参数和回调函数，当满足条件时libcurl将调用用户的回调函数实现特定功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="cURL" scheme="http://www.faihung.net/categories/cURL/"/>
    
    
      <category term="cURL" scheme="http://www.faihung.net/tags/cURL/"/>
    
  </entry>
  
  <entry>
    <title>cURL-08_ARM交叉编译</title>
    <link href="http://www.faihung.net/2019/12/12/cURL-08-ARM%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"/>
    <id>http://www.faihung.net/2019/12/12/cURL-08-ARM交叉编译/</id>
    <published>2019-12-12T06:24:59.000Z</published>
    <updated>2019-12-12T06:25:53.992Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.faihung.net/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/">前面</a>提到过libcurl在Ubuntu环境下的编译安装，本章主要是嵌入式环境下的ARM交叉编译</p><p>执行<a href="https://www.faihung.net/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/">前面</a>的操作之后，进行arm的交叉编译</p><pre><code>./configure --host=arm-himix200-linux CC=arm-himix200-linux-gcc CXX=arm-himix200-linux-g++ </code></pre><a id="more"></a><p>交叉编译，说实话整了好几个小时没怎么明白，不知道为什么不行。</p><p>但是，我把原有工程的的cURL模块拆分出来，修改了Makefile之后，可以交叉编译可以在设备中运行。</p><p>目前关于cURL的交叉编译就告一段落，之后有时间在研究编译。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.faihung.net/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/&quot;&gt;前面&lt;/a&gt;提到过libcurl在Ubuntu环境下的编译安装，本章主要是嵌入式环境下的ARM交叉编译&lt;/p&gt;
&lt;p&gt;执行&lt;a href=&quot;https://www.faihung.net/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/&quot;&gt;前面&lt;/a&gt;的操作之后，进行arm的交叉编译&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./configure --host=arm-himix200-linux CC=arm-himix200-linux-gcc CXX=arm-himix200-linux-g++ &lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="cURL" scheme="http://www.faihung.net/categories/cURL/"/>
    
    
      <category term="cURL" scheme="http://www.faihung.net/tags/cURL/"/>
    
  </entry>
  
  <entry>
    <title>cURL-07_Linux下使用libcurl实现FTP文件上传下载功能</title>
    <link href="http://www.faihung.net/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/"/>
    <id>http://www.faihung.net/2019/12/08/cURL-07-Linux下使用libcurl实现FTP文件上传下载功能/</id>
    <published>2019-12-08T10:24:54.000Z</published>
    <updated>2019-12-31T07:43:50.080Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Linux下使用libcurl实现FTP单个文件或者压缩包上传下载功能</p></blockquote><a id="more"></a><h5 id="一、关于FTP"><a href="#一、关于FTP" class="headerlink" title="一、关于FTP"></a>一、关于FTP</h5><p>参考：<br><a href="https://www.faihung.net/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/">在WIN10上搭建Ftp服务器</a></p><h5 id="二、FTP上传"><a href="#二、FTP上传" class="headerlink" title="二、FTP上传"></a>二、FTP上传</h5><p>该FTP上传代码为官网上的<a href="https://curl.haxx.se/libcurl/c/example.html" target="_blank" rel="noopener">demo</a>例程代码，若要为己所用，只需将宏定义修改并准备一个要上传的文件即可。当然，该函数只能上传一个文件或者压缩包至FTP服务器，若要上传多个文件，可以在此例程上进行修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#ifdef WIN32</span><br><span class="line">#include &lt;io.h&gt;</span><br><span class="line">#else</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define LOCAL_FILE      &quot;/mnt/hgfs/VMWARE/test/8-curl/1206.rar&quot; //要上传的文件</span><br><span class="line">#define UPLOAD_FILE_AS  &quot;while-uploading.txt&quot;</span><br><span class="line">#define REMOTE_URL      &quot;ftp://192.168.31.175/&quot;  UPLOAD_FILE_AS //FTP服务器地址</span><br><span class="line">#define RENAME_FILE_TO  &quot;1206.rar&quot;//最终写入到这个文件名中</span><br><span class="line"></span><br><span class="line">static size_t read_callback(void *ptr, size_t size, size_t nmemb, void *stream)</span><br><span class="line">&#123;</span><br><span class="line">  curl_off_t nread;</span><br><span class="line"></span><br><span class="line">  size_t retcode = fread(ptr, size, nmemb, stream);</span><br><span class="line"></span><br><span class="line">  nread = (curl_off_t)retcode;</span><br><span class="line"></span><br><span class="line">  fprintf(stderr, &quot; We read %&quot; CURL_FORMAT_CURL_OFF_T</span><br><span class="line">          &quot; bytes from file\n&quot;, nread);</span><br><span class="line">  return retcode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">  CURL *curl;</span><br><span class="line">  CURLcode res;</span><br><span class="line">  FILE *hd_src;</span><br><span class="line">  struct stat file_info;</span><br><span class="line">  curl_off_t fsize;</span><br><span class="line"></span><br><span class="line">  struct curl_slist *headerlist = NULL;</span><br><span class="line">  static const char buf_1 [] = &quot;RNFR &quot; UPLOAD_FILE_AS;</span><br><span class="line">  static const char buf_2 [] = &quot;RNTO &quot; RENAME_FILE_TO;</span><br><span class="line"></span><br><span class="line">  /* 获得上传文件的大小 */ </span><br><span class="line">  if(stat(LOCAL_FILE, &amp;file_info)) &#123;</span><br><span class="line">    printf(&quot;Couldn&apos;t open &apos;%s&apos;: %s\n&quot;, LOCAL_FILE, strerror(errno));</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  fsize = (curl_off_t)file_info.st_size;</span><br><span class="line"></span><br><span class="line">  printf(&quot;Local file size: %&quot; CURL_FORMAT_CURL_OFF_T &quot; bytes.\n&quot;, fsize);</span><br><span class="line"></span><br><span class="line">  /* 获得FILE类型变量 */ </span><br><span class="line">  hd_src = fopen(LOCAL_FILE, &quot;rb&quot;);</span><br><span class="line"></span><br><span class="line">  /* 初始化 */ </span><br><span class="line">  curl_global_init(CURL_GLOBAL_ALL);</span><br><span class="line"></span><br><span class="line">  /* 获得curl操作符 */ </span><br><span class="line">  curl = curl_easy_init();</span><br><span class="line">  if(curl) &#123;</span><br><span class="line">    /*建立一个传递给libcurl的命令列表 */ </span><br><span class="line">    headerlist = curl_slist_append(headerlist, buf_1);</span><br><span class="line">    headerlist = curl_slist_append(headerlist, buf_2);</span><br><span class="line"></span><br><span class="line">    /* 使用curl提供的Read功能 */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_READFUNCTION, read_callback);</span><br><span class="line"></span><br><span class="line">    /* 上传使能 */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_UPLOAD, 1L);</span><br><span class="line"></span><br><span class="line">    /* 设置特定目标 */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL, REMOTE_URL);</span><br><span class="line"></span><br><span class="line">    /* 传递最后一个FTP命令以在传输后运行 */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_POSTQUOTE, headerlist);</span><br><span class="line"></span><br><span class="line">    /*指定上传文件 */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_READDATA, hd_src);</span><br><span class="line"></span><br><span class="line">    /*设置要上传的文件的大小（可选） */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_INFILESIZE_LARGE,</span><br><span class="line">                     (curl_off_t)fsize);</span><br><span class="line"></span><br><span class="line">    /* 运行 */ </span><br><span class="line">    res = curl_easy_perform(curl);</span><br><span class="line">    /* 容错处理 */ </span><br><span class="line">    if(res != CURLE_OK)</span><br><span class="line">      fprintf(stderr, &quot;curl_easy_perform() failed: %s\n&quot;,</span><br><span class="line">              curl_easy_strerror(res));</span><br><span class="line"></span><br><span class="line">    /* 清除FTP命令列表 */ </span><br><span class="line">    curl_slist_free_all(headerlist);</span><br><span class="line"></span><br><span class="line">    /*释放所有curl资源 */ </span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(hd_src); /*关闭本地文件 */ </span><br><span class="line"></span><br><span class="line">  /*释放所有curl资源 */ </span><br><span class="line">  curl_global_cleanup();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存代码，文件名命名为“ftpupload.c”，并在/mnt/hgfs/VMWARE/test/8-curl文件夹中准备“1206.rar”文件（即代码中指定的要上传的文件名），使用gcc编译，编译指令：</p><pre><code>gcc -o ftpupload ftpupload.c -lcurl</code></pre><p>执行结果：</p><p><img src="/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/1.png" alt="1"></p><p>上传前的代码：</p><p><img src="/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/2.png" alt="2"></p><p>上传到FTP服务器之后：</p><p><img src="/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/3.png" alt="3"></p><p>至此，上传功能完成。</p><h5 id="三、FTP下载"><a href="#三、FTP下载" class="headerlink" title="三、FTP下载"></a>三、FTP下载</h5><p>同样，该FTP下载代码为官网上的<a href="https://curl.haxx.se/libcurl/c/example.html" target="_blank" rel="noopener">demo</a>例程代码，若要为己所用，只需将宏定义修改并指定一个要下载的文件即可。当然，该函数只能下载一个文件或者压缩包至FTP客户端，若要下载多个文件，可以在此例程上进行修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line"></span><br><span class="line">struct FtpFile &#123;</span><br><span class="line">  const char *filename;</span><br><span class="line">  FILE *stream;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static size_t my_fwrite(void *buffer, size_t size, size_t nmemb, void *stream)</span><br><span class="line">&#123;</span><br><span class="line">  struct FtpFile *out = (struct FtpFile *)stream;</span><br><span class="line">  if(out &amp;&amp; !out-&gt;stream) &#123;</span><br><span class="line">    /* 打开文件以进行写操作 */ </span><br><span class="line">    out-&gt;stream = fopen(out-&gt;filename, &quot;wb&quot;);</span><br><span class="line">    if(!out-&gt;stream)</span><br><span class="line">      return -1; /* failure, can&apos;t open file to write */ </span><br><span class="line">  &#125;</span><br><span class="line">  return fwrite(buffer, size, nmemb, out-&gt;stream);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">  CURL *curl;</span><br><span class="line">  CURLcode res;</span><br><span class="line">  struct FtpFile ftpfile = &#123;</span><br><span class="line">    &quot;/mnt/hgfs/VMWARE/test/8-curl/1208.rar&quot;, /* 若FTP下载成功，名命下载后的文件为&quot;curl.txt&quot; */ </span><br><span class="line">    NULL</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  curl_global_init(CURL_GLOBAL_DEFAULT);</span><br><span class="line"></span><br><span class="line">  curl = curl_easy_init();</span><br><span class="line">  if(curl) &#123;</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL,</span><br><span class="line">                     &quot;ftp://192.168.31.175/1208.rar&quot;);//下载指定的文件</span><br><span class="line">    /* 定义回调函数，以便在需要写入数据时进行调用 */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, my_fwrite);</span><br><span class="line">    /*设置一个指向我们的结构的指针传递给回调函数*/ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;ftpfile);</span><br><span class="line"></span><br><span class="line">    /* 打开完整的协议/调试输出*/ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);</span><br><span class="line"></span><br><span class="line">    res = curl_easy_perform(curl);</span><br><span class="line"></span><br><span class="line">    /* 释放所有curl资源*/ </span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line"></span><br><span class="line">    if(CURLE_OK != res) &#123;</span><br><span class="line">      /*容错处理 */ </span><br><span class="line">      fprintf(stderr, &quot;curl told us %d\n&quot;, res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(ftpfile.stream)</span><br><span class="line">    fclose(ftpfile.stream); /* 关闭本地文件 */ </span><br><span class="line"> /*释放所有curl资源*/</span><br><span class="line">  curl_global_cleanup();</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用gcc编译，编译指令：</p><pre><code>gcc -o ftpDown ftpDown.c -lcurl</code></pre><p>执行结果：</p><p><img src="/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/4.png" alt="4"></p><p>下载之前，放在FTP服务器中时：</p><p><img src="/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/5.png" alt="5"></p><p>下载之后，放在本地文件中中时：</p><p><img src="/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/6.png" alt="6"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Linux下使用libcurl实现FTP单个文件或者压缩包上传下载功能&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="cURL" scheme="http://www.faihung.net/categories/cURL/"/>
    
    
      <category term="cURL" scheme="http://www.faihung.net/tags/cURL/"/>
    
  </entry>
  
  <entry>
    <title>cURL-06_cURL和libcurl的安装的安装途径</title>
    <link href="http://www.faihung.net/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/"/>
    <id>http://www.faihung.net/2019/12/08/cURL-06-cURL和libcuel的安装的安装途径/</id>
    <published>2019-12-08T08:51:06.000Z</published>
    <updated>2019-12-16T10:02:40.128Z</updated>
    
    <content type="html"><![CDATA[<p>cURL的安装一般有三种方式:<a href="https://ec.haxx.se/" target="_blank" rel="noopener">https://ec.haxx.se/</a></p><a id="more"></a><h5 id="一、ubuntu16-04-安装curl，一般用于命令行工具操作"><a href="#一、ubuntu16-04-安装curl，一般用于命令行工具操作" class="headerlink" title="一、ubuntu16.04 安装curl，一般用于命令行工具操作"></a>一、ubuntu16.04 安装curl，一般用于命令行工具操作</h5><h6 id="1-直接安装"><a href="#1-直接安装" class="headerlink" title="1. 直接安装"></a>1. 直接安装</h6><pre><code>sudo apt install curl</code></pre><h6 id="2-或者是下载软件压缩包安装-Ubuntu下安装cURL库用于libcurl开发"><a href="#2-或者是下载软件压缩包安装-Ubuntu下安装cURL库用于libcurl开发" class="headerlink" title="2. 或者是下载软件压缩包安装-Ubuntu下安装cURL库用于libcurl开发"></a>2. 或者是下载软件压缩包安装-Ubuntu下安装cURL库用于libcurl开发</h6><p>2.1 下载curl包（可以在这个网站上找最新的版本 <a href="http://curl.haxx.se/download/）" target="_blank" rel="noopener">http://curl.haxx.se/download/）</a></p><p><img src="/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/1.png" alt="1"></p><pre><code>wget https://curl.haxx.se/download/curl-7.55.1.tar.gz</code></pre><p>2.2 解压</p><pre><code>tar -xzvf  curl-7.55.1.tar.gz</code></pre><p>2.3 覆盖安装</p><pre><code>stemp 1 cd curl-7.55.1stemp 2 ./configurestemp 3 makestemp 4 make install</code></pre><p>2.4 使用 curl –version 检查是否更新成功</p><p><img src="/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/2.png" alt="2"></p><h5 id="二、ubuntu16-04-安装libcurl-主要用于ubuntu中应用程序开发-curl和libcurl的区别"><a href="#二、ubuntu16-04-安装libcurl-主要用于ubuntu中应用程序开发-curl和libcurl的区别" class="headerlink" title="二、ubuntu16.04 安装libcurl,主要用于ubuntu中应用程序开发(curl和libcurl的区别)"></a>二、ubuntu16.04 安装libcurl,主要用于ubuntu中应用程序开发(curl和libcurl的区别)</h5><pre><code>sudo apt install libcurl4-openssl-dev</code></pre><p>可以看到-ubuntu系统中/usr/include/curl中的头文件,此操作可以作为Ubuntu虚拟程序中的&lt;curl/curl.h&gt;,一般作为Ubuntu平台模拟程序使用。</p><p>库文件：/usr/lib/x86_64-linux-gnu/libcurl.so.4</p><h5 id="三、linux下编译安装libcurl"><a href="#三、linux下编译安装libcurl" class="headerlink" title="三、linux下编译安装libcurl"></a>三、linux下编译安装libcurl</h5><h6 id="1-直接下载"><a href="#1-直接下载" class="headerlink" title="1. 直接下载"></a>1. 直接下载</h6><pre><code>git clone https://github.com/curl/curl.git </code></pre><h6 id="2-tar解压后，进入curl工程目录输入指令：-buidconf，产生configure脚本"><a href="#2-tar解压后，进入curl工程目录输入指令：-buidconf，产生configure脚本" class="headerlink" title="2.tar解压后，进入curl工程目录输入指令：./buidconf，产生configure脚本"></a>2.tar解压后，进入curl工程目录输入指令：./buidconf，产生configure脚本</h6><p>之后和第一条步骤类似</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cURL的安装一般有三种方式:&lt;a href=&quot;https://ec.haxx.se/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ec.haxx.se/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="cURL" scheme="http://www.faihung.net/categories/cURL/"/>
    
    
      <category term="cURL" scheme="http://www.faihung.net/tags/cURL/"/>
    
  </entry>
  
  <entry>
    <title>cURL-05_curl和libcurl的区别简介(转)</title>
    <link href="http://www.faihung.net/2019/12/08/cURL-05-curl%E5%92%8Clibcurl%E7%9A%84%E5%8C%BA%E5%88%AB%E7%AE%80%E4%BB%8B-%E8%BD%AC/"/>
    <id>http://www.faihung.net/2019/12/08/cURL-05-curl和libcurl的区别简介-转/</id>
    <published>2019-12-08T08:33:44.000Z</published>
    <updated>2019-12-08T08:38:47.024Z</updated>
    
    <content type="html"><![CDATA[<h5 id="curl简介"><a href="#curl简介" class="headerlink" title="curl简介"></a>curl简介</h5><p>curl是利用URL语法在命令行方式下工作的开源文件传输工具。<br>它支持很多协议：DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP。</p><p>curl同样支持SSL证书,HTTP POST, HTTP PUT,FTP上传，基于表单的HTTP上传，代理(proxies)、cookies、用户名/密码认证(Basic, Digest, NTLM等)、下载文件断点续传，上载文件断点续传(file transfer resume)，http代理服务器管道（proxy tunneling)以及其他特性。</p><p>curl是瑞典curl组织开发的,curl的官网是<a href="http://curl.haxx.se/,可以从官网获取它的源代码和相关说明。" target="_blank" rel="noopener">http://curl.haxx.se/,可以从官网获取它的源代码和相关说明。</a></p><a id="more"></a><h5 id="libcurl简介"><a href="#libcurl简介" class="headerlink" title="libcurl简介"></a>libcurl简介</h5><p>libcurl为一个免费开源的，客户端url传输库，支持DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP等协议。</p><p>同curl一样，libcurl也支持SSL证书,HTTP POST, HTTP PUT,FTP上传，基于表单的HTTP上传，代理(proxies)、cookies、用户名/密码认证(Basic, Digest, NTLM等)、下载文件断点续传，上载文件断点续传(file transfer resume)，http代理服务器管道（proxy tunneling)等。</p><p>libcurl是高度可移植的，可以工作在不同的平台上，支持Windows，Unix，Linux等。</p><p>libcurl是免费的，线程安全的，IPV6兼容的，同时它还有很多其它非常丰富的特性。libcurl已经被很多知名的大企业以及应用程序所采用。</p><h5 id="curl与libcurl对比"><a href="#curl与libcurl对比" class="headerlink" title="curl与libcurl对比"></a>curl与libcurl对比</h5><h6 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h6><p>curl和libcurl都可以利用多种多样的协议来传输文件，包括HTTP, HTTPS, FTP, FTPS, GOPHER, LDAP, DICT, TELNET and FILE等。</p><h6 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h6><ul><li>curl是命令行工具，可以通过shell或脚本来运行curl。curl底层所使用的库是libcurl。</li><li>libcurl是一个库，通常与别的程序绑定在一起使用，如命令行工具curl就是封装了libcurl库。所以我们也可以在你自己的程序或项目中使用libcurl以获得类似CURL的强大功能。接下来将要介绍的PHP扩展就是对curl的一个封装。</li></ul><h5 id="几个名词"><a href="#几个名词" class="headerlink" title="几个名词"></a>几个名词</h5><h6 id="“curl”的不同意思"><a href="#“curl”的不同意思" class="headerlink" title="“curl”的不同意思"></a>“curl”的不同意思</h6><p>1.curl指的是curl命令行工具，可以从命令行或者脚本或者批处理文件中运行curl。curl创建于1998年，并且提供了100多个选项去控制它。</p><p>2.cURL是一个软件项目的名字。该软件项目包含了上面所说的curl和libcurl，并且都是开源的。</p><p>3.cURL通常用作PHP中libcurl扩展的名字。这个扩展确保了PHP程序员在程序中可以访问libcurl库所提供的功能。</p><h6 id="curl—命令行工具"><a href="#curl—命令行工具" class="headerlink" title="curl—命令行工具"></a>curl—命令行工具</h6><ol><li>命令行工具，可以从shell或者脚本中运行该工具。</li><li>提供了130多种不同的“flags”</li><li>通常被用来模拟浏览器的行为</li><li>跨平台</li></ol><h6 id="libcurl—库"><a href="#libcurl—库" class="headerlink" title="libcurl—库"></a>libcurl—库</h6><ol><li>用作其他程序的开发库</li><li>可以与许多语言想结合，如PHP、C++</li><li>跨平台</li><li>提供了多种不同的使用它的APIs</li></ol><h5 id="PHP中使用curl和libcurl"><a href="#PHP中使用curl和libcurl" class="headerlink" title="PHP中使用curl和libcurl"></a>PHP中使用curl和libcurl</h5><h6 id="PHP中使用curl"><a href="#PHP中使用curl" class="headerlink" title="PHP中使用curl"></a>PHP中使用curl</h6><p>在PHP中使用curl非常简单，只要调用PHP中几个执行系统命令的相关函数即可。<br>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$baidu=shell_exec(&quot;/usr/bin/curl -L http://www.baidu.com&quot;); </span><br><span class="line">var_dump($baidu);</span><br></pre></td></tr></table></figure><h6 id="PHP中使用libcurl"><a href="#PHP中使用libcurl" class="headerlink" title="PHP中使用libcurl"></a>PHP中使用libcurl</h6><p>在PHP中使用libcurl，也就是我们通常所说的PHP中的“curl”。这部分的内容会在以后的文章中给出，这里只写出一个示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// FTP this script to a server</span><br><span class="line">$fp = fopen(__FILE__, &quot;r&quot;);</span><br><span class="line">$url = &quot;ftp://username:password@mydomain.com:21/path/to/newfile.php&quot;;</span><br><span class="line">$ch = curl_init();   </span><br><span class="line">curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);</span><br><span class="line">curl_setopt($ch, CURLOPT_UPLOAD, 1);</span><br><span class="line">curl_setopt($ch, CURLOPT_INFILE, $fp);</span><br><span class="line">curl_setopt($ch, CURLOPT_FTPASCII, 1);</span><br><span class="line">curl_setopt($ch, CURLOPT_INFILESIZE, filesize(__FILE__));</span><br><span class="line">$result = curl_exec($ch);</span><br><span class="line">curl_close($ch);</span><br></pre></td></tr></table></figure><h5 id="使用curl还是libcurl？"><a href="#使用curl还是libcurl？" class="headerlink" title="使用curl还是libcurl？"></a>使用curl还是libcurl？</h5><p>使用curl还是libcurl这个需要根据具体的情况而定。例如，当有一个定时脚本在远程服务器的文件改变时发送邮件或者当前PHP环境不支持libcurl时，我们应该使用curl。否则，我们使用libcurl即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;curl简介&quot;&gt;&lt;a href=&quot;#curl简介&quot; class=&quot;headerlink&quot; title=&quot;curl简介&quot;&gt;&lt;/a&gt;curl简介&lt;/h5&gt;&lt;p&gt;curl是利用URL语法在命令行方式下工作的开源文件传输工具。&lt;br&gt;它支持很多协议：DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP。&lt;/p&gt;
&lt;p&gt;curl同样支持SSL证书,HTTP POST, HTTP PUT,FTP上传，基于表单的HTTP上传，代理(proxies)、cookies、用户名/密码认证(Basic, Digest, NTLM等)、下载文件断点续传，上载文件断点续传(file transfer resume)，http代理服务器管道（proxy tunneling)以及其他特性。&lt;/p&gt;
&lt;p&gt;curl是瑞典curl组织开发的,curl的官网是&lt;a href=&quot;http://curl.haxx.se/,可以从官网获取它的源代码和相关说明。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://curl.haxx.se/,可以从官网获取它的源代码和相关说明。&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="cURL" scheme="http://www.faihung.net/categories/cURL/"/>
    
    
      <category term="cURL" scheme="http://www.faihung.net/tags/cURL/"/>
    
  </entry>
  
  <entry>
    <title>工具-虚拟机的桥接模式和NAT模式的区别</title>
    <link href="http://www.faihung.net/2019/12/08/%E5%B7%A5%E5%85%B7-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E5%92%8CNAT%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.faihung.net/2019/12/08/工具-虚拟机的桥接模式和NAT模式的区别/</id>
    <published>2019-12-08T08:09:29.000Z</published>
    <updated>2019-12-08T08:14:31.317Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-桥接模式"><a href="#1-桥接模式" class="headerlink" title="1.桥接模式"></a>1.桥接模式</h5><p>通过使用物理机的网卡，有自己的IP地址，就像在电脑上虚拟出来另一台主机，它可以访问网内任何一台主机，需要手工为其配置IP地址、子网掩码、需要和宿主机器处于同一个网段，这样虚拟机才能和宿主机器进行通信。同时，由于这个虚拟系统是局域网中的一个独立主机系统，就可以手工配置他的TCP\IP信息，实现通过局域网的网关或路由进行互联网访问。</p><a id="more"></a><p><strong>弊端:</strong></p><ol><li><p>Ip地址可能会发生变化 192.150.1.100/192.168.1.101</p></li><li><p>如果这时传递文件时需要依靠交换机/路由器</p></li></ol><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E5%92%8CNAT%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/1.png" alt="1"></p><h5 id="2-NAT模式"><a href="#2-NAT模式" class="headerlink" title="2.NAT模式"></a>2.NAT模式</h5><p>使用NAT模式，就是让虚拟系统借助NAT（网络地址的转换功能），通过宿主机器所在的网络来访问公网，也就是说使用NAT模式可以实现在虚拟系统里访问互联网，NAT模式下的虚拟系统的TCP/IP配置是由VMnet8（NAT）虚拟网络的DHCP服务器提供的，无法进行手工修改，因此虚拟系统也就无法和本局域网中的其他真是主机进行通讯。采用NAT模式的虚拟机的有点就是，想要接入互联网十分方便，只要宿主机能访问到互联网即可。</p><p><strong>特点:</strong></p><ol><li><p>NAT模式时,只能由真实的计算机连接虚拟网络空间,其他的计算机由于网络不在一个网段内,则不能通信.</p></li><li><p>NAT模式时,IP地址一般都是固定不变的.所以无论在哪里.Ip都能直接连接.</p></li></ol><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E5%92%8CNAT%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/2.png" alt="2"></p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;1-桥接模式&quot;&gt;&lt;a href=&quot;#1-桥接模式&quot; class=&quot;headerlink&quot; title=&quot;1.桥接模式&quot;&gt;&lt;/a&gt;1.桥接模式&lt;/h5&gt;&lt;p&gt;通过使用物理机的网卡，有自己的IP地址，就像在电脑上虚拟出来另一台主机，它可以访问网内任何一台主机，需要手工为其配置IP地址、子网掩码、需要和宿主机器处于同一个网段，这样虚拟机才能和宿主机器进行通信。同时，由于这个虚拟系统是局域网中的一个独立主机系统，就可以手工配置他的TCP\IP信息，实现通过局域网的网关或路由进行互联网访问。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://www.faihung.net/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="VMware" scheme="http://www.faihung.net/tags/VMware/"/>
    
      <category term="网络配置" scheme="http://www.faihung.net/tags/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>工具-如何配置Windows、虚拟机、开发板的网络</title>
    <link href="http://www.faihung.net/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/"/>
    <id>http://www.faihung.net/2019/12/08/工具-如何配置Windows、虚拟机、开发板的网络/</id>
    <published>2019-12-08T07:52:18.000Z</published>
    <updated>2019-12-08T08:00:16.400Z</updated>
    
    <content type="html"><![CDATA[<p>烧录软件和方便调试先要保证电脑windos操作系统、虚拟机linuxr操作系统<br>和开发板三者之间相互Ping通，要做到这些其实很简单：</p><a id="more"></a><h5 id="1-打开windows网络和共享中心更改适配器设置"><a href="#1-打开windows网络和共享中心更改适配器设置" class="headerlink" title="1. 打开windows网络和共享中心更改适配器设置"></a>1. 打开windows网络和共享中心更改适配器设置</h5><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/1.png" alt="1"></p><h5 id="2-打开这三个的属性，把VMware-Bridge-Protocol都勾上，如图"><a href="#2-打开这三个的属性，把VMware-Bridge-Protocol都勾上，如图" class="headerlink" title="2. 打开这三个的属性，把VMware Bridge Protocol都勾上，如图"></a>2. 打开这三个的属性，把VMware Bridge Protocol都勾上，如图</h5><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/2.png" alt="2"></p><h5 id="3-打开本地连接的属性再打开IPV4的属性选择使用手动IP如下图所示"><a href="#3-打开本地连接的属性再打开IPV4的属性选择使用手动IP如下图所示" class="headerlink" title="3. 打开本地连接的属性再打开IPV4的属性选择使用手动IP如下图所示"></a>3. 打开本地连接的属性再打开IPV4的属性选择使用手动IP如下图所示</h5><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/3.png" alt="3"></p><h5 id="4-点击VMware的虚拟机-gt-设置-网络选择桥接如下图所示"><a href="#4-点击VMware的虚拟机-gt-设置-网络选择桥接如下图所示" class="headerlink" title="4. 点击VMware的虚拟机-&gt; 设置 网络选择桥接如下图所示"></a>4. 点击VMware的虚拟机-&gt; 设置 网络选择桥接如下图所示</h5><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/4.png" alt="4"></p><p>网络选择桥接如下图所示</p><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/5.png" alt="5"></p><h5 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h5><h6 id="5-1-点击VMware的编辑-gt-虚拟网络编辑器"><a href="#5-1-点击VMware的编辑-gt-虚拟网络编辑器" class="headerlink" title="5.1 点击VMware的编辑-&gt;虚拟网络编辑器"></a>5.1 点击VMware的编辑-&gt;虚拟网络编辑器</h6><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/6.png" alt="6"></p><h6 id="5-2-点击更改设置"><a href="#5-2-点击更改设置" class="headerlink" title="5.2 点击更改设置"></a>5.2 点击更改设置</h6><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/7.png" alt="7"></p><h6 id="5-3-点击桥接模式，选择自己要桥接的网卡-网卡要记得选对"><a href="#5-3-点击桥接模式，选择自己要桥接的网卡-网卡要记得选对" class="headerlink" title="5.3 点击桥接模式，选择自己要桥接的网卡(网卡要记得选对)"></a>5.3 点击桥接模式，选择自己要桥接的网卡(网卡要记得选对)</h6><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/8.png" alt="8"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;烧录软件和方便调试先要保证电脑windos操作系统、虚拟机linuxr操作系统&lt;br&gt;和开发板三者之间相互Ping通，要做到这些其实很简单：&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://www.faihung.net/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Windows" scheme="http://www.faihung.net/tags/Windows/"/>
    
      <category term="VMware" scheme="http://www.faihung.net/tags/VMware/"/>
    
      <category term="网络配置" scheme="http://www.faihung.net/tags/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>工具-在WIN10上搭建Ftp服务器（转）</title>
    <link href="http://www.faihung.net/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/"/>
    <id>http://www.faihung.net/2019/12/07/工具-在WIN10上搭建Ftp服务器（转）/</id>
    <published>2019-12-07T09:29:44.000Z</published>
    <updated>2019-12-08T09:33:36.429Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在windows10上面搭建你的FTP服务器，     正在学服务器这门课程，刚好学到搭建Ftp服务器。所以就在自己电脑上也搭建了一个Ftp服务器。我的电脑是win10的，所以本教程也是在win10上面搭建Ftp服务器。希望能帮到有需要的同学！</p></blockquote><a id="more"></a><h5 id="一、在windows10中搭建Ftp服务器主要用的是IIS管理器管理控制台"><a href="#一、在windows10中搭建Ftp服务器主要用的是IIS管理器管理控制台" class="headerlink" title="一、在windows10中搭建Ftp服务器主要用的是IIS管理器管理控制台"></a>一、在windows10中搭建Ftp服务器主要用的是IIS管理器管理控制台</h5><h6 id="1-在控制面板里面打开程序功能里面的FTP服务器和web管理工具"><a href="#1-在控制面板里面打开程序功能里面的FTP服务器和web管理工具" class="headerlink" title="1. 在控制面板里面打开程序功能里面的FTP服务器和web管理工具"></a>1. 在控制面板里面打开程序功能里面的FTP服务器和web管理工具</h6><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/1.png" alt="1"></p><h5 id="二、打开IIS管理器平台，不知道在哪打开的可以直接搜索IIS打开"><a href="#二、打开IIS管理器平台，不知道在哪打开的可以直接搜索IIS打开" class="headerlink" title="二、打开IIS管理器平台，不知道在哪打开的可以直接搜索IIS打开"></a>二、打开IIS管理器平台，不知道在哪打开的可以直接搜索IIS打开</h5><h6 id="1-在网站那里右键“添加FTP站点”"><a href="#1-在网站那里右键“添加FTP站点”" class="headerlink" title="1.在网站那里右键“添加FTP站点”"></a>1.在网站那里右键“添加FTP站点”</h6><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/2.png" alt="2"></p><h6 id="2-输入你的站点名称和物理路径"><a href="#2-输入你的站点名称和物理路径" class="headerlink" title="2. 输入你的站点名称和物理路径"></a>2. 输入你的站点名称和物理路径</h6><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/3.png" alt="3"></p><h6 id="3-下一步绑定你的FTP服务器地址，这里的端口使用默认的21号端口。IP地址是你本机的IP地址"><a href="#3-下一步绑定你的FTP服务器地址，这里的端口使用默认的21号端口。IP地址是你本机的IP地址" class="headerlink" title="3. 下一步绑定你的FTP服务器地址，这里的端口使用默认的21号端口。IP地址是你本机的IP地址"></a>3. 下一步绑定你的FTP服务器地址，这里的端口使用默认的21号端口。IP地址是你本机的IP地址</h6><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/4.png" alt="4"></p><h6 id="4-下一步，根据需要设置身份验证和授权信息"><a href="#4-下一步，根据需要设置身份验证和授权信息" class="headerlink" title="4. 下一步，根据需要设置身份验证和授权信息"></a>4. 下一步，根据需要设置身份验证和授权信息</h6><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/5.png" alt="5"></p><p>点击完成FTP服务器就搭建好了。</p><h5 id="三、测试你的ftp服务器"><a href="#三、测试你的ftp服务器" class="headerlink" title="三、测试你的ftp服务器"></a>三、测试你的ftp服务器</h5><p>在浏览器上输入ftp://<strong>.</strong>.<strong>.</strong>（填你自己的ftp地址）。你就可以看到你ftp目录里面的东西了，浏览器打开的效果是这样子的</p><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/6.png" alt="6"></p><h5 id="四、有小伙伴私信我，服务器搭建好了，自己可以访问，但是别人访问不了，以下我总结了以下解决方法，希望对你们有效"><a href="#四、有小伙伴私信我，服务器搭建好了，自己可以访问，但是别人访问不了，以下我总结了以下解决方法，希望对你们有效" class="headerlink" title="四、有小伙伴私信我，服务器搭建好了，自己可以访问，但是别人访问不了，以下我总结了以下解决方法，希望对你们有效"></a>四、有小伙伴私信我，服务器搭建好了，自己可以访问，但是别人访问不了，以下我总结了以下解决方法，希望对你们有效</h5><h6 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h6><p>把防火墙关掉、一般别人访问不了都是防火墙限制了，直接把防火墙关掉这是最快的解决方法</p><h6 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h6><p>如果你想把防火墙开着呢，那应该怎么做？</p><p>打开防火墙设置，选择允许的应用，把ftp服务器勾选上、然后再点击允许其它应用</p><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/7.png" alt="7"></p><p>选择C:\Windows\System32目录下面的svchost.exe这个软件</p><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/8.png" alt="8"></p><p>把这个应该添加到防火墙允许的应用里面</p><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/9.png" alt="9"></p><p>做完以上步骤再试一下，别人就可以在你开启防火墙的状态依旧可以访问你的ftp服务器了</p><p>但是有的小伙伴还是不能访问，那应该怎么办呢？继续以下步骤（如果进行完以上步骤可以访问就不用进行下面的操作）</p><p>依旧是打开防火墙设置，然后选择高级设置</p><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/10.png" alt="10"></p><p>在出站规则里面选择和frp相关的规则，点击右边的启用规则就可以了</p><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/11.png" alt="11"></p><p>启用之后规则左边就会被打上勾了</p><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/12.png" alt="12"></p><p>基本上我目前遇到小伙伴私信的问题都可以通过以上的方法解决，如果还是不行的话，记得私信我，我们再一起研究研究，然后把解决方法再加上。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在windows10上面搭建你的FTP服务器，     正在学服务器这门课程，刚好学到搭建Ftp服务器。所以就在自己电脑上也搭建了一个Ftp服务器。我的电脑是win10的，所以本教程也是在win10上面搭建Ftp服务器。希望能帮到有需要的同学！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://www.faihung.net/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="FTP" scheme="http://www.faihung.net/tags/FTP/"/>
    
  </entry>
  
  <entry>
    <title>视音频-视频简介</title>
    <link href="http://www.faihung.net/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E7%AE%80%E4%BB%8B/"/>
    <id>http://www.faihung.net/2019/12/01/视音频-视频简介/</id>
    <published>2019-12-01T08:24:26.000Z</published>
    <updated>2019-12-01T08:30:46.876Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>尽管视频信号有很多类型和实现技术,但其目的只是为了实现视觉信息在不同位置之间的传送。这些视觉信息可能是来自于VCR, DVD播放器、本地广播的某个频道、有线电视,或者来自于卫星电视系统、因特网,还可能是其他各种渠道。</p></blockquote><a id="more"></a><blockquote><p>但有一点是肯定的,那就是视频信息必须从一个设备传输到另一个设备。可能是从卫星电视机顶盒或DVD播放器传输到电视机,或者在卫星电视机顶盒或电视机内部不同芯片之间传输。这看起来好像很简单,但需要满足很多不同的要求,故存在很多方式来实现这种传输。</p></blockquote><h4 id="一、模拟与数字"><a href="#一、模拟与数字" class="headerlink" title="一、模拟与数字"></a>一、模拟与数字</h4><p>几年前,大多数的视频设备还主要是为模拟视频而设计的,数字视频还仅限于视频编辑这样的专业应用领域。</p><p>目前,普通消费者在日常生活中都用上了数字视频设备,这要得益于这些数字产品价格的不断下降。这种趋势也导致相关技术的快速发展,如DVD播放机和摄像机、数字机顶盒、数字电视(DTV)、便携视频播放器和基于因特网的视频数据传输能力等</p><h4 id="二、视频数据"><a href="#二、视频数据" class="headerlink" title="二、视频数据"></a>二、视频数据</h4><p>起初,视频仅仅包含灰度(也称为黑白)信息。</p><p>在建立彩色广播电视系统的过程中,人们试图用模拟RGB (红、绿、蓝)来发送彩色视频,然而,这种技术占用的带宽是当时使用的灰度解决方案的3倍多,因此必须创建其他的替代方法,于是,人们用Y, R-Y和G-Y数据来表示颜色信息,并开发相应的技术来传输Y, R-Y和G-Y信息。这种技术只需要一个信号,而不是3个独立的信号,因此只需要与原来传输灰度视频信号相同的带宽。今天广泛使用的NTSC、 PAL和SECAM视频标准仍然是建立在这种复合视频信号(composite video signal) 基础上的。</p><p>现在,尽管有很多种表示视频的方式,但它们都要通过RGB的数学公式表示出来。</p><p>s-Video是为了将终端设备连接(目的不是为了广播)在一起而建立的。每组信号由两个模拟信号构成:一个为灰度(Y)信息,另一个是以特定格式传输的模拟R-Y和B-Y颜色信息(也称为C或色度),这种技术曾经只在S-VHS中可用,但现在大多数消费类视频产品都支持这项技术。</p><p>尽管模拟RGB视频数据一直用于专业视频市场,但为了实现与高端消费设备的连接,模拟RGB视频数据也暂时应用于普通视频市场。与S-Video一样,模拟RGB视频数据也不用于广播。Y,R-Y、G-Y视频信号的另一种形式称为YPbPr,现在通常用于将消费类视频产品连接在起。其主要优点在于能够在消费类视频产品之间传输高分辨率视频。有些制造商错误地将YPbPT连接器称为YUV, YCbC或Y (B-Y) (R-Y)。</p><h5 id="2-1-数字视频"><a href="#2-1-数字视频" class="headerlink" title="2.1 数字视频"></a>2.1 数字视频</h5><p>目前最通用的数字信号为RGB和YCbCr. RGB是模拟RGB视频信号进行简单数字化后得到的版本。 YCbCT基本上是模拟YPbPr视频信号的数字化版本,这种格式由DVD和数字电视所采用。</p><h5 id="2-2最佳连接方法"><a href="#2-2最佳连接方法" class="headerlink" title="2.2最佳连接方法"></a>2.2最佳连接方法</h5><p>设备的最佳连接方法是什么?对于DVD播放器和数字有线电视/卫星电视/地面机顶盒,按照视频质量由好到差排序,一般的顺序为：</p><p>(1) HDMI (数字YCbCr)</p><p>(2) HIDMI (数字RGB)</p><p>(3)模拟YPbPr</p><p>(4)模拟RGB</p><p>(5)模拟S-Video</p><p>(6)模拟复合视频</p><p>有些人可能不同意这个排序。但是,大多数消费类产品都是在YCbCr颜色空间进行数字视处理的。因此,使用YCbCr作为设备互连格式可以减少所需的颜色空间转换次数。数字信号的颜色空间转换仍然优先选择进行D/A (数字到模拟)转换,接着进行AD (模拟到数字)转换,所以HDMI RGB排在模拟YPbPr之前。</p><p>计算机产业已经对接入计算机显示器的模拟和数字RGB信号进行了标准化。</p><h4 id="三、视频时序"><a href="#三、视频时序" class="headerlink" title="三、视频时序"></a>三、视频时序</h4><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E7%AE%80%E4%BB%8B/1.png" alt="1"></p><p>视频画面尽管看起来好像是连续运动的,其实那是一系列静止的图像。这些图像切换得足够快,  使得画面看起来像是连续运动的,如图2-1所示  对于消费类电子产品,通常情况下为每秒50或60张图像,计算机显示器为每秒70-90张图像。一种称为场同步(vertical sync)的特定时序信息被用于指定新图像从什么时候开始显示。</p><p>每张静止图像是由扫描线(scan line)组成的即沿着显示器从上到下、一行接着一行进行显示的数据线,如图2-1所示。另一种称为行同步(horizontal sync)的时序信息用于指定新扫描线什么时候开始显示。</p><p>行同步和场同步信息通常通过以下三种方式之一进行传输:</p><p>(1)单独的行同步和场同步信号;  </p><p>(2)单独的复合同步信号；</p><p>(3)嵌入视频信号的复合同步信号。</p><p>复合同步信号是由场同步和行同步信号组合而成的。使用模拟RGB视频的计算机和消费类设备通常采用技术(1)或(2),支持复合视频或模拟YPbPr视频的消费类设备通常采用技术(3)。对于数字视频,通常要么采用技术(1),要么就是将时序编码字嵌入数字视频流中。</p><h5 id="隔行与逐行"><a href="#隔行与逐行" class="headerlink" title="隔行与逐行"></a>隔行与逐行</h5><p>由于视频是由一系列静止图像组成的,因此,简单地连续显示每幅完整的图像是有意义的,也就是一张接一张地显示每幅图像。</p><p>上面所讲的就是逐行显示(progressive) [或称为非隔行(non-interlaced)显示]的基本技术。对于将图像以逐行方式“绘制”到屏幕上的设备(如CRT),每张图像都是从显示器的左上角开始,一直向右移动,直到到达显示器的右边缘为止然后向下扫描一行,重复地从左到右进行扫描。这个过程一直持续到整个屏幕全部被刷新一次为止,如图2-2所示。<br><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E7%AE%80%E4%BB%8B/2.png" alt="2"></p><p>在电视发展的早期,采用一种称为“隔行显(interlacing)”的技术来减少每幅图像所需发送  “绘制”出每幅图像的数据量。这种方式先发送奇数行的数据,接着发送偶数行的数据(如图2-3所示),因此每次发送的数据量为一幅图像数据量的一半。<br><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E7%AE%80%E4%BB%8B/3.png" alt="3"></p><p>既然隔行显示方式有这个优点,那么为什么还要多余地使用逐行显示方式呢?</p><p>在隔行显示方式中,每个扫描线更新的频率只有同等情况下逐行显示方式的一半。所以,为了避免由于过低的帧率而导致颜色对比显著的边缘出现闪烁,要限制扫描线之间的变化,这本质上是由于在垂直方向上对图像进行了低通滤波。而逐行显示方式对线之间的变化就没有这种限制因此,逐行显示方式能够提供更高分辨率(在垂直方向上)的没有闪烁的图像。</p><p>现在,大多数广播(包括HDTV)都仍然以隔行方式发射信号。大多数基于CRT的显示器也是隔行方式显示,而LCD、等离子以及计算机显示器都是采用逐行方式。</p><h4 id="四、视频分辨率"><a href="#四、视频分辨率" class="headerlink" title="四、视频分辨率"></a>四、视频分辨率</h4><p>在现实生活中,人们对于视频分辨率的概念往往有一些模糊的认识。我们通常见到的视频分辨率为720 x 480或1920 × 1080,然而,那只是水平采样和垂直扫描线的数目,并不等于说必须具有这么多有用信息。</p><p>例如,可以以13.5MHz的频率对模拟视频信号进行采样,生成每行720个采样点。对同样的信号以27MHz的频率采样可以生成每行1440个采样点。但这仅仅是每行的采样数目不同,视频内容的分辨率并没有改变。</p><p>因此,视频质量通常用线分辨率(lines of resolution)来度量。<br>本质上是表示在显示器上可以显示多少不同的黑白垂直线。然后将这个数目归一化为1 :1显示宽高比(对于4:3的显示器,将该数除以3/4,而对于16:9的显示器则除以916),当然,对于宽屏(16:9)显示器,这会使得视频分辨率较低,与直觉不相符。</p><h5 id="4-1-标准清晰度"><a href="#4-1-标准清晰度" class="headerlink" title="4.1 标准清晰度"></a>4.1 标准清晰度</h5><p>标准清晰度(standard-definition)视频通常定义为480或576的隔行有效扫描线的视频,分别称为”480i”和”576i”。</p><p>固定像素(非CRT)、具有4:3宽高比的消费类显示器通过转换后,对应于720 x 480i或720x576i的有效分辨率。而对于16:9的宽高比,转换后的有效分辨率对应于960 x 480i或960 x 576i</p><h5 id="4-2-增强清晰度"><a href="#4-2-增强清晰度" class="headerlink" title="4.2 增强清晰度"></a>4.2 增强清晰度</h5><p>增强清晰度(enhanced-definition)视频通常定义为具有480或576逐行有效扫描线的视频,分别称为”480p”或”576p”.</p><p>固定像素(非CRT)具有4 :3宽高比的消费类显示器转换后的有效分辨率对应于720 x480p或720 x 576p。而对于16 :9的宽高比,转换后的有效分辨率对应于960 x 480p或960 x 576p.</p><p>标准清晰度和增强清晰度的差异在于,标准清晰度是隔行的,而增强清晰度是逐行的。</p><h5 id="4-3高清晰度"><a href="#4-3高清晰度" class="headerlink" title="4.3高清晰度"></a>4.3高清晰度</h5><p>高清晰度(high-definition)视频通常定义为具有720逐行(720p)或1080隔行(1080i)有效扫描线的视频。固定像素(非CRT)、具有16:9宽高比的消费类显示器转换后的有效分辨率分别为1280 x 720p或1280 × 1080i</p><p>但是, HDTV显示器在技术上定义为能够显示最少720p或1080有效扫描线。它还必须能够用至少540逐行(540p)或810隔行(810i)有效扫描线来显示16:9的视频画面。这样,在制造具有4:3宽高比、基于CRT的HDTV和具有16 :9宽高比、分辨率为1024 x 1024p, 1280 x 768p, 1024×768p的LCD/等离子等显示器时,能够降低制造费用。</p><h4 id="五、音频与视频压缩"><a href="#五、音频与视频压缩" class="headerlink" title="五、音频与视频压缩"></a>五、音频与视频压缩</h4><p>近年来,数字电视、DVD播放机和摄像机、数字视频摄像机等消费类电子产品取得了一些最新进展,这归功于音频和视频压缩标准。这些压缩标准主要有:带有Dolbyo Digital的MEPG-2.DTS, MPEG-1或MPEG-2音频。</p><p>新的音频和视频编解码器,像MPEG-4 HE-AAC、 MPEG-4.10 (H.264)和SMPTE 421M (VC1),在保持同样质量时,提供了比以往编解码方法更高的压缩效率。这些进展使得可以使用新的见频发布方式(面向消费者和家庭内部)、新的消费产品(如便携视频播放器和移动视频移动电话)和更多的有线/星电视频道。</p><h4 id="六、应用框图"><a href="#六、应用框图" class="headerlink" title="六、应用框图"></a>六、应用框图</h4><p>下面几个简化的框图有助于我们认识视频流是如何经过各种相应处理的。</p><h5 id="6-1-DVD播放器"><a href="#6-1-DVD播放器" class="headerlink" title="6.1 DVD播放器"></a>6.1 DVD播放器</h5><p>图2-4为基本DVD播放机的简化框图,其中显示的是公共模块。如今所有这些模块都集成在廉价的芯片上了。<br><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E7%AE%80%E4%BB%8B/4.png" alt="4"></p><p>除了播放DVD (基于MPEG-2视频压缩技术)外, 目前, DVD播放器还有望处理MP3和WMA音频、MPEG-4视频(DivX视频)、 JPEG图像等。同时有望具有特定的播放模式,如以各科速度慢快进和快/慢退等。对DVD音频和SACD的支持也是很流行的。</p><p>DVD播放机的一个新增功能是能够接入到家庭网络中,用于播放一些存放于PC中的媒体(音乐、视频、图像等),这些“网络化的DVD播放机”也包括播放一些准备事后浏览的内容,如来源于因特网的电影和下载到内部硬盘(HDD)中的媒体。支持对各种闪存卡中的音频、视频和图像进行播放的这类需求也在不断增长。</p><p>有些DVD播放机制造商为了快速吸引买家的注意力,对视频的频率响应进行了超频处理,使得其产品看起来与众不同。但因为这种特性通常需要长时间的激励过程,所以很容易失败或需要调试。对于观看电影来讲,很多视频爱好者都认为频率响应应该尽可能平滑。</p><p>另一个问题是模拟视频信号的量化等级。尽管很容易产生每个精确的视频量化等级,但这些等级变化得相当快。目前有些评论也指出了这个问题,因为在信号源之间切换时可能会使发生变化的亮度或灰度值具有平均作用,从而使得用户进行的任何校正或手动调整失效。</p><h5 id="6-2-数字媒体适配器"><a href="#6-2-数字媒体适配器" class="headerlink" title="6.2 数字媒体适配器"></a>6.2 数字媒体适配器</h5><p>数字媒体适配器是连接到家庭网络、用于播放存放于PC或媒体存储器中的多媒体内容(音乐、视频、图像等)的设备。这些小而廉价的盒子使得媒体内容很容易在家庭中的任意或所有电视机上欣赏。许多数字媒体适配器支持无线网络功能,这就简化了数字媒体适配器的安装过程。</p><p>图2-5是基本的数字媒体适配器的简化框图,图中显示的是公共模块。如今所有这些模块都集成在一个廉价的芯片上了。</p><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E7%AE%80%E4%BB%8B/5.png" alt="5"></p><h5 id="6-3-数字电视机顶盒"><a href="#6-3-数字电视机顶盒" class="headerlink" title="6.3 数字电视机顶盒"></a>6.3 数字电视机顶盒</h5><p>数字电视标准可以分为7大类:</p><p>(1) ATSC (美国先进电视系统委员会)</p><p>(2) DVB (数字视频广播)</p><p>(3) ARIB (日本无线工业及商贸协会)</p><p>(4) IPTV (网络电视,包括基于P的DVB和ARIB)</p><p>(5)开放数字有线标准,如OpenCable标准</p><p>(6)带版权保护的数字有线标准</p><p>(7)带版权保护的数字卫星电视标准</p><p>起初这些机顶盒都是基于MPEG-2视频和DolbyoDigital或MPEG音频, 目前的机顶盒支持新的先进音视频标准,如MPEG-4 HE-AAC音频、Dolby Digital Plus音频、MPEG-4.10 (H.264)视频和SMPTE (VC-1)视频。</p><p>图2-6是数字电视机顶盒的简化结构图,图中显示的是公共音视频处理模块。数字机顶盒用于接收数字电视广播,这些数字电视广播可能来自地面台站(空中电波)、有线或卫星。在数字电视内部就可能包含这些电路。</p><p>目前的许多电视机顶盒有两个调谐器,并具有数字视频摄像(VCR)功能。这使得在浏览个内部HDD时,还可以往另一个内部HDD中读入节目。在数字电视接收机中,有了这两个调谐器,还可以支持PIP特性(即将2个输入影像输出到同一画面上)。</p><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E7%AE%80%E4%BB%8B/6.png" alt="6"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;尽管视频信号有很多类型和实现技术,但其目的只是为了实现视觉信息在不同位置之间的传送。这些视觉信息可能是来自于VCR, DVD播放器、本地广播的某个频道、有线电视,或者来自于卫星电视系统、因特网,还可能是其他各种渠道。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="视音频" scheme="http://www.faihung.net/categories/%E8%A7%86%E9%9F%B3%E9%A2%91/"/>
    
    
  </entry>
  
</feed>
