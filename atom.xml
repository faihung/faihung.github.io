<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Faihung&#39;s blog</title>
  
  <subtitle>作者：faihung</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.faihung.net/"/>
  <updated>2019-12-22T14:51:23.692Z</updated>
  <id>http://www.faihung.net/</id>
  
  <author>
    <name>faihung</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>工程设计-设备端版本号管理(2)</title>
    <link href="http://www.faihung.net/2019/12/22/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E5%A4%87%E7%AB%AF%E7%89%88%E6%9C%AC%E5%8F%B7%E7%AE%A1%E7%90%86-2/"/>
    <id>http://www.faihung.net/2019/12/22/工程设计-设备端版本号管理-2/</id>
    <published>2019-12-22T14:44:26.000Z</published>
    <updated>2019-12-22T14:51:23.692Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于版本号管理，之前升级都是在嵌入式设备中移植一个微型服务器，然后通过web端进行升级。现在是设备作为客户端向http发送版本号，http发送下载指令，设备端再想ftp服务器请求下载文件。所以思维方式要转换一下。<br>并且预期忘版本号的管理符合git库版本管理规则。</p></blockquote><a id="more"></a><h5 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h5><p>服务器只有一个，而设备却有很多种，且分布在全国各地，各个地方情况不一样。<br>有的地方因为设备或者其它原因，软件不需要更新。<br>有的设备因为硬件与软件兼容性问题，只能升级特定的版本。<br>所以远程升级必须需要满足下面两种情况。</p><h5 id="二、远程升级满足下面两种情况"><a href="#二、远程升级满足下面两种情况" class="headerlink" title="二、远程升级满足下面两种情况"></a>二、远程升级满足下面两种情况</h5><h6 id="2-1-后台服务器的手动升级-暴力升级"><a href="#2-1-后台服务器的手动升级-暴力升级" class="headerlink" title="2.1 后台服务器的手动升级(暴力升级)"></a>2.1 后台服务器的手动升级(暴力升级)</h6><h6 id="2-2-设备端的自动升级"><a href="#2-2-设备端的自动升级" class="headerlink" title="2.2 设备端的自动升级"></a>2.2 设备端的自动升级</h6><p>参考：<img src="/2019/12/22/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E5%A4%87%E7%AB%AF%E7%89%88%E6%9C%AC%E5%8F%B7%E7%AE%A1%E7%90%86-2/1.png" alt="1"></p><h5 id="三、关于版本号管控"><a href="#三、关于版本号管控" class="headerlink" title="三、关于版本号管控"></a>三、关于版本号管控</h5><p>版本号管控或称三段式管控，形如：3.000.00000，3.100.10000,以10进制字符串的方式体现出来。（关于版本号的管控也可以按照设备发送的地方进行管控。按照时间来，按照地方来都可以。）</p><p>注意：16进制数据和字符串型数据容易混淆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HISI_APP:3.01.0001 </span><br><span class="line">16进制方式：(0x03 0x2e 0x00 0x01 0x2e 0x00 0x00 0x00 0x01) </span><br><span class="line">字符串方式：(0x33 0x2e 0x30 0x31 0x2e 0x30 0x30 0x30 0x31)</span><br></pre></td></tr></table></figure><h6 id="3-1-第3段—-00001，子功能升级-amp-BUG的修改（软件对应子功能添加-amp-BUG的修改的升级）"><a href="#3-1-第3段—-00001，子功能升级-amp-BUG的修改（软件对应子功能添加-amp-BUG的修改的升级）" class="headerlink" title="3.1 第3段—-00001，子功能升级&amp;BUG的修改（软件对应子功能添加&amp;BUG的修改的升级）"></a>3.1 第3段—-00001，子功能升级&amp;BUG的修改（软件对应子功能添加&amp;BUG的修改的升级）</h6><p>从文本文件中读取的’.’后面的第一位，为1表示该不可以升级，为0表示该段程序可以升级。</p><p>之后的4位，表示版本号的范围：0000-9999。</p><p>关于兼容性：修改bug有9999种版本完全够用，可能还没有达到这么多，就进入了系列升级。</p><h6 id="3-2-第2段—-001，产品系列的升级（软件对应硬件方面的升级）"><a href="#3-2-第2段—-001，产品系列的升级（软件对应硬件方面的升级）" class="headerlink" title="3.2 第2段—-001，产品系列的升级（软件对应硬件方面的升级）"></a>3.2 第2段—-001，产品系列的升级（软件对应硬件方面的升级）</h6><p>从文本文件中读取的’.’后面的第一位，为1表示该不可以升级，为0表示该段程序可以升级。</p><p>之后的2位，表示版本号的范围：00-99</p><p>关于兼容性：修改bug有99种版本完全够用，可能还没有达到这么多，就进入了换代升级</p><h6 id="3-3-第1段—-3，产品的换代升级（软件对应产品发布方面的升级）"><a href="#3-3-第1段—-3，产品的换代升级（软件对应产品发布方面的升级）" class="headerlink" title="3.3 第1段—-3，产品的换代升级（软件对应产品发布方面的升级）"></a>3.3 第1段—-3，产品的换代升级（软件对应产品发布方面的升级）</h6>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;关于版本号管理，之前升级都是在嵌入式设备中移植一个微型服务器，然后通过web端进行升级。现在是设备作为客户端向http发送版本号，http发送下载指令，设备端再想ftp服务器请求下载文件。所以思维方式要转换一下。&lt;br&gt;并且预期忘版本号的管理符合git库版本管理规则。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="工程设计" scheme="http://www.faihung.net/categories/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="FTP" scheme="http://www.faihung.net/tags/FTP/"/>
    
      <category term="流程图" scheme="http://www.faihung.net/tags/%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    
      <category term="http" scheme="http://www.faihung.net/tags/http/"/>
    
      <category term="版本号" scheme="http://www.faihung.net/tags/%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>C语言-函数返回局部变量的几种方式</title>
    <link href="http://www.faihung.net/2019/12/15/C%E8%AF%AD%E8%A8%80-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.faihung.net/2019/12/15/C语言-函数返回局部变量的几种方式/</id>
    <published>2019-12-15T04:46:13.000Z</published>
    <updated>2019-12-18T10:53:21.032Z</updated>
    
    <content type="html"><![CDATA[<p>一般的来说，函数是可以返回局部变量的。</p><p>局部变量的作用域只在函数内部，在函数返回后，局部变量的内存已经释放了。</p><p>因此，如果函数返回的是局部变量的值，不涉及地址，程序不会出错。</p><p>但是如果返回的是局部变量的地址(指针)的话，程序运行后会出错。</p><p>因为函数只是把指针复制后返回了，但是指针指向的内容已经被释放了，这样指针指向的内容就是不可预料的内容，调用就会出错。</p><p>准确的来说，函数不能通过返回指向栈内存的指针(注意这里指的是栈，返回指向堆内存的指针是可以的)。</p><a id="more"></a><p>下面以函数返回局部变量的指针举几个典型的例子来说明：</p><h5 id="1-字符串常量’hello-world’，存放在只读数据段"><a href="#1-字符串常量’hello-world’，存放在只读数据段" class="headerlink" title="1. 字符串常量’hello world’，存放在只读数据段"></a>1. 字符串常量’hello world’，存放在只读数据段</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;   </span><br><span class="line">char *returnStr()   </span><br><span class="line">&#123;   </span><br><span class="line">    char *p=&quot;hello world!&quot;;   </span><br><span class="line">    return p;   </span><br><span class="line">&#125;   </span><br><span class="line">int main()   </span><br><span class="line">&#123;   </span><br><span class="line">    char *str;   </span><br><span class="line">    str=returnStr();   </span><br><span class="line">    printf(&quot;%s\n&quot;, str);   </span><br><span class="line">    return 0;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个没有任何问题，因为”hello world!”是一个字符串常量，存放在只读数据段，把该字符串常量存放的只读数据段的首地址赋值给了指针，所以returnStr函数退出时，该该字符串常量所在内存不会被回收，故能够通过指针顺利无误的访问。</p><h5 id="2-局部变量’hello-world’存放在栈中"><a href="#2-局部变量’hello-world’存放在栈中" class="headerlink" title="2. 局部变量’hello world’存放在栈中"></a>2. 局部变量’hello world’存放在栈中</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;   </span><br><span class="line"></span><br><span class="line">char *returnStr()   </span><br><span class="line">&#123;   </span><br><span class="line">    char p[]=&quot;hello world!&quot;;   </span><br><span class="line">    return p;   </span><br><span class="line">&#125;   </span><br><span class="line">int main()   </span><br><span class="line">&#123;   </span><br><span class="line">    char *str;   </span><br><span class="line">    str=returnStr();   </span><br><span class="line">    printf(&quot;%s\n&quot;, str);   </span><br><span class="line">    return 0;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“hello world!”是局部变量存放在栈中。当returnStr函数退出时，栈要清空，局部变量的内存也被清空了，所以这时的函数返回的是一个已被释放的内存地址，所以有可能打印出来的是乱码。 </p><h5 id="3-局部变量（实参与型参）、地址（指针）栈（指向内存的释放）、静态变量地址（指针）的生存周期"><a href="#3-局部变量（实参与型参）、地址（指针）栈（指向内存的释放）、静态变量地址（指针）的生存周期" class="headerlink" title="3. 局部变量（实参与型参）、地址（指针）栈（指向内存的释放）、静态变量地址（指针）的生存周期"></a>3. 局部变量（实参与型参）、地址（指针）栈（指向内存的释放）、静态变量地址（指针）的生存周期</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int func()  </span><br><span class="line">&#123;  </span><br><span class="line">      int a;  </span><br><span class="line">      ....  </span><br><span class="line">      return a;    //允许  </span><br><span class="line">&#125;                     </span><br><span class="line">  </span><br><span class="line">int * func()  </span><br><span class="line">&#123;  </span><br><span class="line">      int a;  </span><br><span class="line">      ....  </span><br><span class="line">      return &amp;a;    //无意义，不应该这样做  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部变量也分局部自动变量和局部静态变量，由于a返回的是值，因此返回一个局部变量是可以的，无论自动还是静态，因为这时候返回的是这个局部变量的值。</p><p>但不应该返回指向局部自动变量的指针，因为函数调用结束后该局部自动变量<br>被抛弃，这个指针指向一个不再存在的对象，是无意义的。</p><p>但可以返回指向局部静态变量的指针，因为静态变量的生存期从定义起到程序结束。</p><h5 id="4-如果函数的返回值非要是一个局部变量的地址，那么该局部变量一定要申明为static类型。"><a href="#4-如果函数的返回值非要是一个局部变量的地址，那么该局部变量一定要申明为static类型。" class="headerlink" title="4. 如果函数的返回值非要是一个局部变量的地址，那么该局部变量一定要申明为static类型。"></a>4. 如果函数的返回值非要是一个局部变量的地址，那么该局部变量一定要申明为static类型。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;   </span><br><span class="line">char *returnStr()   </span><br><span class="line">&#123;   </span><br><span class="line">    static char p[]=&quot;hello world!&quot;;   </span><br><span class="line">    return p;   </span><br><span class="line">&#125;   </span><br><span class="line">int main()   </span><br><span class="line">&#123;   </span><br><span class="line">    char *str;   </span><br><span class="line">    str=returnStr();   </span><br><span class="line">    printf(&quot;%s\n&quot;, str);   </span><br><span class="line">  </span><br><span class="line">    return 0;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-数组是不能作为函数的返回值的，原因是编译器把数组名认为是局部变量（数组）的地址。返回一个数组一般用返回指向这个数组的指针代替，而且这个指针不能指向一个自动数组，因为函数结束后自动数组被抛弃，但可以返回一个指向静态局部数组的指针，因为静态存储期是从对象定义到程序结束的。"><a href="#5-数组是不能作为函数的返回值的，原因是编译器把数组名认为是局部变量（数组）的地址。返回一个数组一般用返回指向这个数组的指针代替，而且这个指针不能指向一个自动数组，因为函数结束后自动数组被抛弃，但可以返回一个指向静态局部数组的指针，因为静态存储期是从对象定义到程序结束的。" class="headerlink" title="5. 数组是不能作为函数的返回值的，原因是编译器把数组名认为是局部变量（数组）的地址。返回一个数组一般用返回指向这个数组的指针代替，而且这个指针不能指向一个自动数组，因为函数结束后自动数组被抛弃，但可以返回一个指向静态局部数组的指针，因为静态存储期是从对象定义到程序结束的。"></a>5. 数组是不能作为函数的返回值的，原因是编译器把数组名认为是局部变量（数组）的地址。返回一个数组一般用返回指向这个数组的指针代替，而且这个指针不能指向一个自动数组，因为函数结束后自动数组被抛弃，但可以返回一个指向静态局部数组的指针，因为静态存储期是从对象定义到程序结束的。</h5><p>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int* func( void )  </span><br><span class="line">&#123;  </span><br><span class="line">    static int a[10];  </span><br><span class="line">    ........  </span><br><span class="line">    return a;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-返回指向堆内存的指针是可以的"><a href="#6-返回指向堆内存的指针是可以的" class="headerlink" title="6. 返回指向堆内存的指针是可以的"></a>6. 返回指向堆内存的指针是可以的</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">char *GetMemory3(int num)  </span><br><span class="line">&#123;  </span><br><span class="line">    char *p = (char *)malloc(sizeof(char) * num);  </span><br><span class="line">    return p;  </span><br><span class="line">&#125;  </span><br><span class="line">void Test3(void)  </span><br><span class="line">&#123;  </span><br><span class="line">    char *str = NULL;  </span><br><span class="line">    str = GetMemory3(100);  </span><br><span class="line">    strcpy(str, &quot;hello&quot;);  </span><br><span class="line">    cout&lt;&lt; str &lt;&lt; endl;  </span><br><span class="line">    free(str);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序在运行的时候用 malloc 申请任意多少的内存,程序员自己负责在何时用 free释放内存。动态内存的生存期由程序员自己决定,使用非常灵活。</p><h5 id="7-通过局部变量在另一个函数去取值-传一个地址，用指针变量来接收，用指针来指向一个值"><a href="#7-通过局部变量在另一个函数去取值-传一个地址，用指针变量来接收，用指针来指向一个值" class="headerlink" title="7. 通过局部变量在另一个函数去取值(传一个地址，用指针变量来接收，用指针来指向一个值)"></a>7. 通过局部变量在另一个函数去取值(传一个地址，用指针变量来接收，用指针来指向一个值)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void get_value(int* Temp)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;2:0x%x\n&quot;,Temp);</span><br><span class="line">    *Temp = 6;</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    int temp;</span><br><span class="line">    printf(&quot;1:0x%x\n&quot;,&amp;temp);</span><br><span class="line">    </span><br><span class="line">    get_value(&amp;temp);</span><br><span class="line">    printf(&quot;3:%d\n&quot;,temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-通过局部变量数组在另一个函数去取值-传一个地址，用指针变量来接收，用指针来指向一个值"><a href="#8-通过局部变量数组在另一个函数去取值-传一个地址，用指针变量来接收，用指针来指向一个值" class="headerlink" title="8. 通过局部变量数组在另一个函数去取值(传一个地址，用指针变量来接收，用指针来指向一个值)"></a>8. 通过局部变量数组在另一个函数去取值(传一个地址，用指针变量来接收，用指针来指向一个值)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void get_value(char * ptemp)</span><br><span class="line">&#123;</span><br><span class="line">char i;</span><br><span class="line">    printf(&quot;2:0x%x\n&quot;,ptemp);</span><br><span class="line">    ptemp = &quot;hello world!&quot;;//这样不行，字符串常量放在只读数据段，和主函数中的temp局部数据区域有冲突</span><br><span class="line"></span><br><span class="line">printf(&quot;3:%s\n&quot;,ptemp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char temp[13]=&#123;0&#125;;</span><br><span class="line">    printf(&quot;1:0x%x\n&quot;,temp);</span><br><span class="line">    </span><br><span class="line">    get_value(temp);</span><br><span class="line"></span><br><span class="line">    printf(&quot;4:%s\n&quot;,temp);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2019/12/15/C%E8%AF%AD%E8%A8%80-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/1.png" alt="1"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void get_value(char * ptemp)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;2:0x%x\n&quot;,ptemp);</span><br><span class="line">    for(char i=0;i&lt;13;i++)//这样可以，temp和ptemp都在栈函数数据区域中，main函数调用get_value，get_value会先释放，但是temp申请的内存空间，此时并没有释放，所以可以拿到值。</span><br><span class="line">&#123;</span><br><span class="line">ptemp[i] = &apos;h&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;3:%s\n&quot;,ptemp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char temp[13]=&#123;0&#125;;</span><br><span class="line">    printf(&quot;1:0x%x\n&quot;,temp);</span><br><span class="line">    </span><br><span class="line">    get_value(temp);</span><br><span class="line"></span><br><span class="line">    printf(&quot;4:%s\n&quot;,temp);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2019/12/15/C%E8%AF%AD%E8%A8%80-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/2.png" alt="2"></p><h5 id="9-通过结构体类型的局部变量数组在另一个函数去取值-传一个结构体变量的地址，用指针变量来接收，用指针来指向一个值"><a href="#9-通过结构体类型的局部变量数组在另一个函数去取值-传一个结构体变量的地址，用指针变量来接收，用指针来指向一个值" class="headerlink" title="9. 通过结构体类型的局部变量数组在另一个函数去取值(传一个结构体变量的地址，用指针变量来接收，用指针来指向一个值)"></a>9. 通过结构体类型的局部变量数组在另一个函数去取值(传一个结构体变量的地址，用指针变量来接收，用指针来指向一个值)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">char hisi_app[9];</span><br><span class="line">char sys_lib[9];</span><br><span class="line">char mb_mcu[9];</span><br><span class="line">char mcu_4g[9];</span><br><span class="line">char mcu_1256[9];</span><br><span class="line">char device[7];</span><br><span class="line">&#125;file_ver_t;</span><br><span class="line"></span><br><span class="line">void read_file_version(file_ver_t *pfile_ver)</span><br><span class="line">&#123;</span><br><span class="line">memset(pfile_ver-&gt;hisi_app,0,9);</span><br><span class="line">memcpy(pfile_ver-&gt;hisi_app,&quot;3.01.0001&quot;,9);</span><br><span class="line">printf(&quot;%s\n&quot;, pfile_ver-&gt;hisi_app);</span><br><span class="line">memcpy(pfile_ver-&gt;sys_lib,&quot;3.01.0001&quot;,9);</span><br><span class="line">printf(&quot;%s\n&quot;, pfile_ver-&gt;sys_lib);</span><br><span class="line">memcpy(pfile_ver-&gt;mb_mcu,&quot;3.01.0001&quot;,9);</span><br><span class="line">printf(&quot;%s\n&quot;, pfile_ver-&gt;mb_mcu);</span><br><span class="line">memcpy(pfile_ver-&gt;mcu_4g,&quot;3.01.0001&quot;,9);</span><br><span class="line">printf(&quot;%s\n&quot;, pfile_ver-&gt;mcu_4g);</span><br><span class="line">memcpy(pfile_ver-&gt;mcu_1256,&quot;3.01.0001&quot;,9);</span><br><span class="line">printf(&quot;%s\n&quot;, pfile_ver-&gt;mcu_1256);</span><br><span class="line">memcpy(pfile_ver-&gt;device,&quot;1.00.00&quot;,7);</span><br><span class="line">printf(&quot;%s\n&quot;, pfile_ver-&gt;device);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">file_ver_t file_ver;</span><br><span class="line">read_file_version(&amp;file_ver);</span><br><span class="line"></span><br><span class="line">printf(&quot;%s\n&quot;, file_ver.hisi_app);</span><br><span class="line">printf(&quot;%s\n&quot;, file_ver.sys_lib);</span><br><span class="line">printf(&quot;%s\n&quot;, file_ver.mb_mcu);</span><br><span class="line">printf(&quot;%s\n&quot;, file_ver.mcu_4g);</span><br><span class="line">printf(&quot;%s\n&quot;, file_ver.mcu_1256);</span><br><span class="line">printf(&quot;%s\n&quot;, file_ver.device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2019/12/15/C%E8%AF%AD%E8%A8%80-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/3.png" alt="3"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般的来说，函数是可以返回局部变量的。&lt;/p&gt;
&lt;p&gt;局部变量的作用域只在函数内部，在函数返回后，局部变量的内存已经释放了。&lt;/p&gt;
&lt;p&gt;因此，如果函数返回的是局部变量的值，不涉及地址，程序不会出错。&lt;/p&gt;
&lt;p&gt;但是如果返回的是局部变量的地址(指针)的话，程序运行后会出错。&lt;/p&gt;
&lt;p&gt;因为函数只是把指针复制后返回了，但是指针指向的内容已经被释放了，这样指针指向的内容就是不可预料的内容，调用就会出错。&lt;/p&gt;
&lt;p&gt;准确的来说，函数不能通过返回指向栈内存的指针(注意这里指的是栈，返回指向堆内存的指针是可以的)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://www.faihung.net/categories/C/"/>
    
    
      <category term="指针" scheme="http://www.faihung.net/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="生存周期" scheme="http://www.faihung.net/tags/%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F/"/>
    
      <category term="内存分配" scheme="http://www.faihung.net/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
      <category term="局部变量" scheme="http://www.faihung.net/tags/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"/>
    
      <category term="数组取值" scheme="http://www.faihung.net/tags/%E6%95%B0%E7%BB%84%E5%8F%96%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>问题-notepadd++  ANSI编码与UTF-8编码</title>
    <link href="http://www.faihung.net/2019/12/15/%E9%97%AE%E9%A2%98-notepadd-ANSI%E7%BC%96%E7%A0%81%E4%B8%8EUTF-8%E7%BC%96%E7%A0%81/"/>
    <id>http://www.faihung.net/2019/12/15/问题-notepadd-ANSI编码与UTF-8编码/</id>
    <published>2019-12-14T16:33:10.000Z</published>
    <updated>2019-12-14T16:36:13.899Z</updated>
    
    <content type="html"><![CDATA[<p>之前有一种见鬼的感觉，主要表现在写脚本上（写脚本主要是因为空格的原因），写程序倒是不会出现。结果导致脚本执行不成功。</p><a id="more"></a><p>使用UTF-8编码</p><p><img src="/2019/12/15/%E9%97%AE%E9%A2%98-notepadd-ANSI%E7%BC%96%E7%A0%81%E4%B8%8EUTF-8%E7%BC%96%E7%A0%81/1.png" alt="1"></p><p>使用ANSI编码</p><p><img src="/2019/12/15/%E9%97%AE%E9%A2%98-notepadd-ANSI%E7%BC%96%E7%A0%81%E4%B8%8EUTF-8%E7%BC%96%E7%A0%81/2.png" alt="2"></p><p>这种情况要记住，以后不要在这上面浪费时间了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前有一种见鬼的感觉，主要表现在写脚本上（写脚本主要是因为空格的原因），写程序倒是不会出现。结果导致脚本执行不成功。&lt;/p&gt;
    
    </summary>
    
    
      <category term="问题" scheme="http://www.faihung.net/categories/%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="notepadd" scheme="http://www.faihung.net/tags/notepadd/"/>
    
      <category term="UTF-8" scheme="http://www.faihung.net/tags/UTF-8/"/>
    
      <category term="ANSI" scheme="http://www.faihung.net/tags/ANSI/"/>
    
  </entry>
  
  <entry>
    <title>工程设计-html boa cgi上传文件</title>
    <link href="http://www.faihung.net/2019/12/15/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-html-boa-cgi%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"/>
    <id>http://www.faihung.net/2019/12/15/工程设计-html-boa-cgi上传文件/</id>
    <published>2019-12-14T16:20:25.000Z</published>
    <updated>2019-12-14T16:21:48.864Z</updated>
    
    <content type="html"><![CDATA[<p>暂略</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;暂略&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="工程设计" scheme="http://www.faihung.net/categories/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="html" scheme="http://www.faihung.net/tags/html/"/>
    
      <category term="boa" scheme="http://www.faihung.net/tags/boa/"/>
    
      <category term="cgi" scheme="http://www.faihung.net/tags/cgi/"/>
    
  </entry>
  
  <entry>
    <title>工程设计-设备端FTP文件上传与下载(1)</title>
    <link href="http://www.faihung.net/2019/12/14/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E5%A4%87%E7%AB%AFFTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD-1/"/>
    <id>http://www.faihung.net/2019/12/14/工程设计-设备端FTP文件上传与下载-1/</id>
    <published>2019-12-14T15:25:12.000Z</published>
    <updated>2019-12-22T14:35:49.896Z</updated>
    
    <content type="html"><![CDATA[<h4 id="主要目的"><a href="#主要目的" class="headerlink" title="主要目的"></a>主要目的</h4><h5 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h5><h6 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h6><p>av_streamer input_streamer output_app</p><a id="more"></a><h6 id="系统库"><a href="#系统库" class="headerlink" title="系统库"></a>系统库</h6><p>libapp_para.so<br>libntptime.so<br>libsys_commom.so<br>libsys_serial.so<br>libdevsdk.so<br>librtmp_push.so<br>libsys_httppro.so<br>libdhclient.so<br>librtsp.so<br>libsys_media.so<br>libnnie_ai.so<br>libsys_base.so<br>libsys_mp4_storage.so</p><h6 id="MCU程序"><a href="#MCU程序" class="headerlink" title="MCU程序"></a>MCU程序</h6><p>和上面类似（略）</p><h5 id="上传日志"><a href="#上传日志" class="headerlink" title="上传日志"></a>上传日志</h5><p>程序运行记录（略）</p><h4 id="第一阶段-正常环境下"><a href="#第一阶段-正常环境下" class="headerlink" title="第一阶段-正常环境下"></a>第一阶段-正常环境下</h4><p>还是直接看图比较直观。<br><img src="/2019/12/14/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E5%A4%87%E7%AB%AFFTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD-1/1.png" alt="1"></p><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p><a href="https://github.com/faihung/cURL" target="_blank" rel="noopener">参考代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;主要目的&quot;&gt;&lt;a href=&quot;#主要目的&quot; class=&quot;headerlink&quot; title=&quot;主要目的&quot;&gt;&lt;/a&gt;主要目的&lt;/h4&gt;&lt;h5 id=&quot;下载文件&quot;&gt;&lt;a href=&quot;#下载文件&quot; class=&quot;headerlink&quot; title=&quot;下载文件&quot;&gt;&lt;/a&gt;下载文件&lt;/h5&gt;&lt;h6 id=&quot;应用程序&quot;&gt;&lt;a href=&quot;#应用程序&quot; class=&quot;headerlink&quot; title=&quot;应用程序&quot;&gt;&lt;/a&gt;应用程序&lt;/h6&gt;&lt;p&gt;av_streamer input_streamer output_app&lt;/p&gt;
    
    </summary>
    
    
      <category term="工程设计" scheme="http://www.faihung.net/categories/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="cURL" scheme="http://www.faihung.net/tags/cURL/"/>
    
      <category term="FTP" scheme="http://www.faihung.net/tags/FTP/"/>
    
      <category term="流程图" scheme="http://www.faihung.net/tags/%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    
      <category term="http" scheme="http://www.faihung.net/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>cURL-09_使用curl库进行http通信(转)</title>
    <link href="http://www.faihung.net/2019/12/12/cURL-09-%E4%BD%BF%E7%94%A8curl%E5%BA%93%E8%BF%9B%E8%A1%8Chttp%E9%80%9A%E4%BF%A1-%E8%BD%AC/"/>
    <id>http://www.faihung.net/2019/12/12/cURL-09-使用curl库进行http通信-转/</id>
    <published>2019-12-12T07:37:14.000Z</published>
    <updated>2019-12-12T07:38:23.583Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一、LibCurl基本编程框架"><a href="#一、LibCurl基本编程框架" class="headerlink" title="一、LibCurl基本编程框架"></a>一、LibCurl基本编程框架</h5><p>关于libcurl，<a href="https://www.faihung.net/2019/11/03/cURL-01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BA%86%E8%A7%A3/">前面已经有了很多介绍</a>，这里就不详西描述了。</p><p>在基于LibCurl的程序里，主要采用callback function （回调函数）的形式完成传输任务，用户在启动传输前设置好各类参数和回调函数，当满足条件时libcurl将调用用户的回调函数实现特定功能。</p><a id="more"></a><p>下面是利用libcurl完成传输任务的流程：</p><ol><li>调用curl_global_init()初始化libcurl</li><li>调用curl_easy_init()函数得到 easy interface 型指针</li><li>调用curl_easy_setopt()设置传输选项</li><li>根据curl_easy_setopt()设置的传输选项，实现回调函数以完成用户特定任务</li><li>调用curl_easy_perform()函数完成传输任务</li><li>调用curl_easy_cleanup()释放内存</li></ol><p>在整过过程中设置curl_easy_setopt()参数是最关键的，几乎所有的libcurl程序都要使用它。</p><h5 id="二、一些基本的函数"><a href="#二、一些基本的函数" class="headerlink" title="二、一些基本的函数"></a>二、一些基本的函数</h5><h6 id="1-CURLcode-curl-global-init-long-flags"><a href="#1-CURLcode-curl-global-init-long-flags" class="headerlink" title="1.CURLcode curl_global_init(long flags);"></a>1.CURLcode curl_global_init(long flags);</h6><p>描述：<br>这个函数只能用一次。(其实在调用curl_global_cleanup 函数后仍然可再用)<br>如果这个函数在curl_easy_init函数调用时还没调用，它将由libcurl库自动调用，所以多线程下最好主动调用该函数以防止在线程中curl_easy_init时多次调用。</p><p>注意：虽然libcurl是线程安全的，但curl_global_init是不能保证线程安全的，所以不要在每个线程中都调用curl_global_init，应该将该函数的调用放在主线程中。</p><p>参数：flags</p><pre><code>CURL_GLOBAL_ALL             //初始化所有的可能的调用。CURL_GLOBAL_SSL             //初始化支持安全套接字层。CURL_GLOBAL_WIN32           //初始化win32套接字库。CURL_GLOBAL_NOTHING         //没有额外的初始化。</code></pre><h6 id="2-void-curl-global-cleanup-void"><a href="#2-void-curl-global-cleanup-void" class="headerlink" title="2 void curl_global_cleanup(void);"></a>2 void curl_global_cleanup(void);</h6><p>描述：在结束libcurl使用的时候，用来对curl_global_cleanup做的工作清理。类似于close的函数。</p><p>注意：虽然libcurl是线程安全的，但curl_global_cleanup是不能保证线程安全的，所以不要在每个线程中都调用curl_global_init，应该将该函数的调用放在主线程中。</p><h6 id="3-char-curl-version"><a href="#3-char-curl-version" class="headerlink" title="3 char *curl_version( );"></a>3 char *curl_version( );</h6><p>描述: 打印当前libcurl库的版本。</p><h6 id="4-CURL-curl-easy-init"><a href="#4-CURL-curl-easy-init" class="headerlink" title="4 CURL *curl_easy_init( );"></a>4 CURL *curl_easy_init( );</h6><p>描述:<br>curl_easy_init用来初始化一个CURL的指针(有些像返回FILE类型的指针一样). 相应的在调用结束时要用curl_easy_cleanup函数清理.<br>一般curl_easy_init意味着一个会话的开始. 它会返回一个easy_handle(CURL*对象), 一般都用在easy系列的函数中.</p><h6 id="5-void-curl-easy-cleanup-CURL-handle"><a href="#5-void-curl-easy-cleanup-CURL-handle" class="headerlink" title="5 void curl_easy_cleanup(CURL *handle);"></a>5 void curl_easy_cleanup(CURL *handle);</h6><p>描述:<br>这个调用用来结束一个会话，curl_easy_init配合着用。</p><p>参数:<br>CURL类型的指针.</p><h6 id="6-CURLcode-curl-easy-setopt-CURL-handle-CURLoption-option-parameter"><a href="#6-CURLcode-curl-easy-setopt-CURL-handle-CURLoption-option-parameter" class="headerlink" title="6 CURLcode curl_easy_setopt(CURL *handle, CURLoption option, parameter);"></a>6 CURLcode curl_easy_setopt(CURL *handle, CURLoption option, parameter);</h6><p>描述: 这个函数最重要了.几乎所有的curl程序都要频繁的使用它.它告诉curl库.程序将有如何的行为. 比如要查看一个网页的html代码等.(这个函数有些像ioctl函数)参数:</p><ol><li>CURL类型的指针。</li><li>各种CURLoption类型的选项.(都在curl.h库里有定义,man也可以查看到)</li><li>parameter 这个参数既可以是个函数的指针,也可以是某个对象的指针,也可以是个long型的变量.它用什么这取决于第二个参数。<br>CURLoption 这个参数的取值很多.具体的可以查看man手册。</li></ol><h6 id="7-CURLcode-curl-easy-perform-CURL-handle"><a href="#7-CURLcode-curl-easy-perform-CURL-handle" class="headerlink" title="7 CURLcode curl_easy_perform(CURL *handle);"></a>7 CURLcode curl_easy_perform(CURL *handle);</h6><p>描述:这个函数在初始化CURL类型的指针 以及curl_easy_setopt完成后调用.就像字面的意思所说perform就像是个舞台，让我们设置的<br>option 运作起来.</p><p>参数:<br>CURL类型的指针。</p><h5 id="三、curl-easy-setopt函数部分选项介绍"><a href="#三、curl-easy-setopt函数部分选项介绍" class="headerlink" title="三、curl_easy_setopt函数部分选项介绍"></a>三、curl_easy_setopt函数部分选项介绍</h5><p>本节主要介绍curl_easy_setopt中跟http相关的参数。该函数是curl中非常重要的函数，curl所有设置都是在该函数中完成的，该函数的设置选项众多，注意本节的阐述的只是部分常见选项。</p><h6 id="1-CURLOPT-URL"><a href="#1-CURLOPT-URL" class="headerlink" title="1.CURLOPT_URL"></a>1.CURLOPT_URL</h6><p>设置访问URL</p><h6 id="2-CURLOPT-WRITEFUNCTION，CURLOPT-WRITEDATA"><a href="#2-CURLOPT-WRITEFUNCTION，CURLOPT-WRITEDATA" class="headerlink" title="2.CURLOPT_WRITEFUNCTION，CURLOPT_WRITEDATA"></a>2.CURLOPT_WRITEFUNCTION，CURLOPT_WRITEDATA</h6><p>回调函数原型为：</p><pre><code>size_t function( void *ptr, size_t size, size_t nmemb, void *stream);</code></pre><p>函数将在libcurl接收到数据后被调用，因此函数多做数据保存的功能，如处理下载文件。</p><p>CURLOPT_WRITEDATA 用于表明CURLOPT_WRITEFUNCTION函数中的stream指针的来源。<br>如果你没有通过CURLOPT_WRITEFUNCTION属性给easy handle设置回调函数，libcurl会提供一个默认的回调函数，它只是简单的将接收到的数据打印到标准输出。你也可以通过 CURLOPT_WRITEDATA属性给默认回调函数传递一个已经打开的文件指针，用于将数据输出到文件里。</p><h6 id="3-CURLOPT-HEADERFUNCTION，CURLOPT-HEADERDATA"><a href="#3-CURLOPT-HEADERFUNCTION，CURLOPT-HEADERDATA" class="headerlink" title="3.CURLOPT_HEADERFUNCTION，CURLOPT_HEADERDATA"></a>3.CURLOPT_HEADERFUNCTION，CURLOPT_HEADERDATA</h6><p>回调函数原型为 </p><pre><code>size_t function( void *ptr, size_t size,size_t nmemb, void *stream);</code></pre><p>libcurl一旦接收到http 头部数据后将调用该函数。CURLOPT_WRITEDATA 传递指针给libcurl，该指针表明CURLOPT_HEADERFUNCTION函数的stream指针的来源。</p><h6 id="4-CURLOPT-READFUNCTION-CURLOPT-READDATA"><a href="#4-CURLOPT-READFUNCTION-CURLOPT-READDATA" class="headerlink" title="4.CURLOPT_READFUNCTION CURLOPT_READDATA"></a>4.CURLOPT_READFUNCTION CURLOPT_READDATA</h6><p>libCurl需要读取数据传递给远程主机时将调用CURLOPT_READFUNCTION指定的函数，函数原型是：</p><pre><code>size_t function(void *ptr, size_t size, size_t nmemb,void *stream)；</code></pre><p>CURLOPT_READDATA 表明CURLOPT_READFUNCTION函数原型中的stream指针来源。</p><h6 id="5-CURLOPT-NOPROGRESS，CURLOPT-PROGRESSFUNCTION，CURLOPT-PROGRESSDATA"><a href="#5-CURLOPT-NOPROGRESS，CURLOPT-PROGRESSFUNCTION，CURLOPT-PROGRESSDATA" class="headerlink" title="5.CURLOPT_NOPROGRESS，CURLOPT_PROGRESSFUNCTION，CURLOPT_PROGRESSDATA"></a>5.CURLOPT_NOPROGRESS，CURLOPT_PROGRESSFUNCTION，CURLOPT_PROGRESSDATA</h6><p>跟数据传输进度相关的参数。CURLOPT_PROGRESSFUNCTION指定的函数正常情况下每秒被libcurl调用一次，为了使CURLOPT_PROGRESSFUNCTION被调用，CURLOPT_NOPROGRESS必须被设置为false，CURLOPT_PROGRESSDATA指定的参数将作为CURLOPT_PROGRESSFUNCTION指定函数的第一个参数</p><h6 id="6-CURLOPT-TIMEOUT，CURLOPT-CONNECTIONTIMEOUT"><a href="#6-CURLOPT-TIMEOUT，CURLOPT-CONNECTIONTIMEOUT" class="headerlink" title="6.CURLOPT_TIMEOUT，CURLOPT_CONNECTIONTIMEOUT"></a>6.CURLOPT_TIMEOUT，CURLOPT_CONNECTIONTIMEOUT</h6><p>CURLOPT_TIMEOUT 由于设置传输时间，CURLOPT_CONNECTIONTIMEOUT 设置连接等待时间</p><h6 id="7-CURLOPT-FOLLOWLOCATION"><a href="#7-CURLOPT-FOLLOWLOCATION" class="headerlink" title="7.CURLOPT_FOLLOWLOCATION"></a>7.CURLOPT_FOLLOWLOCATION</h6><p>设置重定位URL</p><h6 id="8-CURLOPT-RANGE-CURLOPT-RESUME-FROM"><a href="#8-CURLOPT-RANGE-CURLOPT-RESUME-FROM" class="headerlink" title="8.CURLOPT_RANGE: CURLOPT_RESUME_FROM:"></a>8.CURLOPT_RANGE: CURLOPT_RESUME_FROM:</h6><p>断点续传相关设置。CURLOPT_RANGE 指定char *参数传递给libcurl，用于指明http域的RANGE头域，</p><p>例如：</p><pre><code>表示头500个字节：bytes=0-499表示第二个500字节：bytes=500-999表示最后500个字节：bytes=-500表示500字节以后的范围：bytes=500-第一个和最后一个字节：bytes=0-0,-1同时指定几个范围：bytes=500-600,601-999</code></pre><p>CURLOPT_RESUME_FROM 传递一个long参数给libcurl，指定你希望开始传递的偏移量。</p><h5 id="四、curl-easy-perform-函数说明（error-状态码）"><a href="#四、curl-easy-perform-函数说明（error-状态码）" class="headerlink" title="四、curl_easy_perform 函数说明（error 状态码）"></a>四、curl_easy_perform 函数说明（error 状态码）</h5><p>该函数是完成curl_easy_setopt指定的所有选项，本节重点介绍curl_easy_perform的返回值。返回0意味一切ok，非0代表错误发生。主要错误码说明：</p><pre><code>1.CURLE_OK任务完成一切都好2.CURLE_UNSUPPORTED_PROTOCOL不支持的协议，由URL的头部指定3.CURLE_COULDNT_CONNECT不能连接到remote 主机或者代理4.CURLE_REMOTE_ACCESS_DENIED访问被拒绝5.CURLE_HTTP_RETURNED_ERRORHttp返回错误6.CURLE_READ_ERROR读本地文件错误</code></pre><p>要获取详细的错误描述字符串，可以通过</p><pre><code>const char *curl_easy_strerror(CURLcode errornum ) </code></pre><p>这个函数取得。    </p><h5 id="五、libcurl使用的HTTP消息头"><a href="#五、libcurl使用的HTTP消息头" class="headerlink" title="五、libcurl使用的HTTP消息头"></a>五、libcurl使用的HTTP消息头</h5><p>当使用libcurl发送http请求时，它会自动添加一些http头。我们可以通过CURLOPT_HTTPHEADER属性手动替换、添加或删除相应 的HTTP消息头。</p><pre><code>Hosthttp1.1（大部分http1.0)版本都要求客户端请求提供这个信息头。Pragma&quot;no-cache&quot;。表示不要缓冲数据。Accept&quot;*/*&quot;。表示允许接收任何类型的数据。Expect以POST的方式向HTTP服务器提交请求时，libcurl会设置该消息头为&quot;100-continue&quot;，它要求服务器在正式处理该请求之前，返回一 个&quot;OK&quot;消息。如果POST的数据很小，libcurl可能不会设置该消息头。</code></pre><p><strong>自定义选项</strong></p><p>当前越来越多的协议都构建在HTTP协议之上（如：soap），这主要归功于HTTP的可靠性，以及被广泛使用的代理支持（可以穿透大部分防火墙）。 这些协议的使用方式与传统HTTP可能有很大的不同。对此，libcurl作了很好的支持。</p><p>自定义请求方式(CustomRequest)，<br>HTTP支持GET, HEAD或者POST提交请求。可以设置CURLOPT_CUSTOMREQUEST来设置自定义的请求方式，libcurl默认以GET方式提交请求：</p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_CUSTOMREQUEST, &quot;MYOWNREQUEST&quot;);</code></pre><p><strong>修改消息头</strong></p><p>HTTP协议提供了消息头，请求消息头用于告诉服务器如何处理请求；响应消息头则告诉浏览器如何处理接收到的数据。在libcurl中，你可以自由的添加这些消息头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct curl_slist *headers=NULL; /* init to NULL is important */</span><br><span class="line">headers = curl_slist_append(headers, &quot;Hey-server-hey: how are you?&quot;);</span><br><span class="line">headers = curl_slist_append(headers, &quot;X-silly-content: yes&quot;);</span><br><span class="line">/* pass our list of custom made headers */</span><br><span class="line">curl_easy_setopt(easyhandle, CURLOPT_HTTPHEADER, headers);</span><br><span class="line">curl_easy_perform(easyhandle); /* transfer http */</span><br><span class="line">curl_slist_free_all(headers); /* free the header list */</span><br></pre></td></tr></table></figure><p>对于已经存在的消息头，可以重新设置它的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">headers = curl_slist_append(headers, &quot;Accept: Agent-007&quot;); </span><br><span class="line">headers = curl_slist_append(headers, &quot;Host: munged.host.line&quot;);</span><br></pre></td></tr></table></figure><p><strong>删除消息头</strong></p><p>对于一个已经存在的消息头，设置它的内容为空，libcurl在发送请求时就不会同时提交该消息头：</p><pre><code>headers = curl_slist_append(headers, &quot;Accept:&quot;);</code></pre><h5 id="六、获取http应答头信息"><a href="#六、获取http应答头信息" class="headerlink" title="六、获取http应答头信息"></a>六、获取http应答头信息</h5><p>发出http请求后，服务器会返回应答头信息和应答数据，如果仅仅是打印应答头的所有内容，则直接可以通过curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, 打印函数)的方式来完成，这里需要获取的是应答头中特定的信息，比如应答码、cookies列表等，则需要通过下面这个函数：</p><pre><code>CURLcode curl_easy_getinfo(CURL *curl, CURLINFO info, ... );</code></pre><p>info参数就是我们需要获取的内容，下面是一些参数值:</p><pre><code>1.CURLINFO_RESPONSE_CODE 获取应答码2.CURLINFO_HEADER_SIZE 头大小3.CURLINFO_COOKIELIST cookies列表</code></pre><p>除了获取应答信息外，这个函数还能获取curl的一些内部信息，如请求时间、连接时间等等。</p><p>更多的参数可以参考API文档。</p><h5 id="七、多线程问题"><a href="#七、多线程问题" class="headerlink" title="七、多线程问题"></a>七、多线程问题</h5><p>首先一个基本原则就是：绝对不应该在线程之间共享同一个libcurl handle(CURL *对象)，不管是easy handle还是multi handle（本文只介绍easy_handle）。一个线程每次只能使用一个handle。</p><p>libcurl是线程安全的，但有两点例外：信号(signals)和SSL/TLS handler。 信号用于超时失效名字解析(timing out name resolves)。libcurl依赖其他的库来支持SSL/STL，所以用多线程的方式访问HTTPS或FTPS的URL时，应该满足这些库对多线程 操作的一些要求。</p><p>NSS: 宣称是多线程安全的。</p><h5 id="八、什么时候libcurl无法正常工作"><a href="#八、什么时候libcurl无法正常工作" class="headerlink" title="八、什么时候libcurl无法正常工作"></a>八、什么时候libcurl无法正常工作</h5><p>传输失败总是有原因的。你可能错误的设置了一些libcurl的属性或者没有正确的理解某些属性的含义，或者是远程主机返回一些无法被正确解析的内容。</p><p>这里有一个<strong>黄金法则</strong>来处理这些问题：</p><p>将CURLOPT_VERBOSE属性设置为1，libcurl会输出通信过程中的一些细节。如果使用的是http协议，请求头/响应头也会被输出。将CURLOPT_HEADER设为1，这些头信息将出现在消息的内容中。</p><p>当然不可否认的是，libcurl还存在bug。</p><p>如果你对相关的协议了解越多，在使用libcurl时，就越不容易犯错。</p><h5 id="九、关于密码"><a href="#九、关于密码" class="headerlink" title="九、关于密码"></a>九、关于密码</h5><p>客户端向服务器发送请求时，许多协议都要求提供用户名与密码。libcurl提供了多种方式来设置它们。</p><p>一些协议支持在URL中直接指定用户名和密码，类似于：<br>protocol://user:<a href="mailto:password@example.com" target="_blank" rel="noopener">password@example.com</a>/path/。libcurl能正确的识别这种URL中的用户名与密码并执行相应的操作。如果你提供的用户名和密码中有特殊字符，首先应该对其进行URL编码。</p><p>也可以通过CURLOPT_USERPWD属性来设置用户名与密码。参数是格式如<br>“user:password ”的字符串：</p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_USERPWD, &quot;user_name:password&quot;);</code></pre><p>有时候在访问代理服务器的时候，可能时时要求提供用户名和密码进行用户身份验证。这种情况下，libcurl提供了另一个属性CURLOPT_PROXYUSERPWD：</p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_PROXYUSERPWD, &quot;user_name:password&quot;);</code></pre><p>在UNIX平台下，访问FTP的用户名和密码可能会被保存在$HOME/.netrc文件中。libcurl支持直接从这个文件中获取用户名与密码：  </p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_NETRC, 1L);    </code></pre><p>在使用SSL时，可能需要提供一个私钥用于数据安全传输，通过CURLOPT_KEYPASSWD来设置私钥：</p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_KEYPASSWD, &quot;keypassword&quot;);</code></pre><h5 id="十、HTTP验证"><a href="#十、HTTP验证" class="headerlink" title="十、HTTP验证"></a>十、HTTP验证</h5><p>在使用HTTP协议时，客户端有很多种方式向服务器提供验证信息。默认的HTTP验证方法是”Basic”，它将用户名与密码以明文的方式、经Base64编码后保存在HTTP请求头中，发往服务器。当然这不太安全。</p><p>当前版本的libcurl支持的验证方法有：basic, Digest, NTLM, Negotiate, GSS-Negotiate and SPNEGO。（译者感叹：搞Web这么多年，尽然不知道这些Http的验证方式，实在惭愧。）可以通过CURLOPT_HTTPAUTH属性来设置具体 的验证方式：</p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_HTTPAUTH, CURLAUTH_DIGEST);</code></pre><p>向代理服务器发送验证信息时，可以通过CURLOPT_PROXYAUTH设置验证方式：</p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_PROXYAUTH, CURLAUTH_NTLM);</code></pre><p>也可以同时设置多种验证方式（通过按位与）， 使用’CURLAUTH_ANY’将允许libcurl可以选择任何它所支持的验证方式。通过CURLOPT_HTTPAUTH或 CURLOPT_PROXYAUTH属性设置的多种验证方式，libcurl会在运行时选择一种它认为是最好的方式与服务器通信：</p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_HTTPAUTH,  CURLAUTH_DIGEST|CURLAUTH_BASIC);// curl_easy_setopt(easy_handle, CURLOPT_HTTPAUTH,  CURLAUTH_ANY);</code></pre><h5 id="十一、代码示例"><a href="#十一、代码示例" class="headerlink" title="十一、代码示例"></a>十一、代码示例</h5><h6 id="1-基本的http-GET-POST操作"><a href="#1-基本的http-GET-POST操作" class="headerlink" title="1.基本的http GET/POST操作"></a>1.基本的http GET/POST操作</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line"></span><br><span class="line">bool getUrl(char *filename)</span><br><span class="line">&#123;</span><br><span class="line">    CURL *curl;</span><br><span class="line">    CURLcode res;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    if ((fp = fopen(filename, &quot;w&quot;)) == NULL)  //返回结果用文件存储</span><br><span class="line">        return false;</span><br><span class="line">    struct curl_slist *headers = NULL;</span><br><span class="line">    headers = curl_slist_append(headers, &quot;Accept: Agent-007&quot;);</span><br><span class="line">    curl = curl_easy_init();    //初始化</span><br><span class="line">    if (curl)</span><br><span class="line">    &#123;</span><br><span class="line">        //curl_easy_setopt(curl, CURLOPT_PROXY, &quot;10.99.60.201:8080&quot;);//代理</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);//改协议头</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_URL,&quot;http://www.baidu.com&quot;);</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp); //将返回的http头输出到fp指向的文件</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_HEADERDATA, fp); //将返回的html主体数据输出到fp指向的文件</span><br><span class="line">        res = curl_easy_perform(curl);   // 执行</span><br><span class="line">        if (res != 0) &#123;</span><br><span class="line"></span><br><span class="line">            curl_slist_free_all(headers);</span><br><span class="line">            curl_easy_cleanup(curl);</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool postUrl(char *filename)</span><br><span class="line">&#123;</span><br><span class="line">    CURL *curl;</span><br><span class="line">    CURLcode res;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    if ((fp = fopen(filename, &quot;w&quot;)) == NULL)</span><br><span class="line">        return false;</span><br><span class="line">    curl = curl_easy_init();</span><br><span class="line">    if (curl)</span><br><span class="line">    &#123;</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_COOKIEFILE, &quot;/mnt/hgfs/VMWARE/test/10-http/temp/cookie.txt&quot;); // 指定cookie文件</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, &quot;&amp;logintype=uid&amp;u=xieyan&amp;psw=xxx86&quot;);    // 指定post内容</span><br><span class="line">        //curl_easy_setopt(curl, CURLOPT_PROXY, &quot;10.99.60.201:8080&quot;);</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_URL, &quot; http://mail.sina.com.cn/cgi-bin/login.cgi &quot;);   // 指定url</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);</span><br><span class="line">        res = curl_easy_perform(curl);</span><br><span class="line">        curl_easy_cleanup(curl);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    getUrl(&quot;/mnt/hgfs/VMWARE/test/10-http/temp/get.html&quot;);</span><br><span class="line">    postUrl(&quot;/mnt/hgfs/VMWARE/test/10-http/temp/post.html&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令：</p><pre><code>gcc  get_post.c  -o get_post –lcurl./ get_post</code></pre><p>得到结果：<br>略</p><h6 id="2-获取html网页"><a href="#2-获取html网页" class="headerlink" title="2. 获取html网页"></a>2. 获取html网页</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    CURL *curl;             //定义CURL类型的指针</span><br><span class="line">    CURLcode res;           //定义CURLcode类型的变量，保存返回状态码</span><br><span class="line">    if(argc!=2)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Usage : file &lt;url&gt;;\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    curl = curl_easy_init();        //初始化一个CURL类型的指针</span><br><span class="line">    if(curl!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        //设置curl选项. 其中CURLOPT_URL是让用户指 定url. argv[1]中存放的命令行传进来的网址</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_URL, argv[1]);        </span><br><span class="line">        //调用curl_easy_perform 执行我们的设置.并进行相关的操作. 在这 里只在屏幕上显示出来.</span><br><span class="line">        res = curl_easy_perform(curl);</span><br><span class="line">        //清除curl操作.</span><br><span class="line">        curl_easy_cleanup(curl);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令：</p><pre><code>gcc  get_http.c  -o get_http –lcurl./get_http www.baidu.com</code></pre><h6 id="3-网页下载保存实例"><a href="#3-网页下载保存实例" class="headerlink" title="3. 网页下载保存实例"></a>3. 网页下载保存实例</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 采用CURLOPT_WRITEFUNCTION 实现网页下载保存功能</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;;</span><br><span class="line"> </span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line">#include &lt;curl/types.h&gt;</span><br><span class="line">#include &lt;curl/easy.h&gt;</span><br><span class="line"> </span><br><span class="line">FILE *fp;  //定义FILE类型指针</span><br><span class="line">//这个函数是为了符合CURLOPT_WRITEFUNCTION而构造的</span><br><span class="line">//完成数据保存功能</span><br><span class="line">size_t write_data(void *ptr, size_t size, size_t nmemb, void *stream)  </span><br><span class="line">&#123;</span><br><span class="line">    int written = fwrite(ptr, size, nmemb, (FILE *)fp);</span><br><span class="line">    return written;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    CURL *curl;</span><br><span class="line"> </span><br><span class="line">    curl_global_init(CURL_GLOBAL_ALL);  </span><br><span class="line">    curl=curl_easy_init();</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL, argv[1]);  </span><br><span class="line"> </span><br><span class="line">    if((fp=fopen(argv[2],&quot;w&quot;))==NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        curl_easy_cleanup(curl);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    ////CURLOPT_WRITEFUNCTION 将后继的动作交给write_data函数处理</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);  </span><br><span class="line">    curl_easy_perform(curl);</span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令：</p><pre><code>gcc  save_http.c  -o save_http –lcurl./ save_http www.baidu.com/tmp/baidu</code></pre><h6 id="4-进度条实例显示文件下载进度"><a href="#4-进度条实例显示文件下载进度" class="headerlink" title="4.进度条实例显示文件下载进度"></a>4.进度条实例显示文件下载进度</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">// 采用CURLOPT_NOPROGRESS， CURLOPT_PROGRESSFUNCTION    CURLOPT_PROGRESSDATA 实现文件传输进度提示功能</span><br><span class="line">//函数采用了gtk库，故编译时需指定gtk库</span><br><span class="line">//函数启动专门的线程用于显示gtk 进度条bar</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;gtk/gtk.h&gt;</span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line">#include &lt;curl/types.h&gt; /* new for v7 */</span><br><span class="line">#include &lt;curl/easy.h&gt; /* new for v7 */</span><br><span class="line"> </span><br><span class="line">GtkWidget *Bar;</span><br><span class="line">////这个函数是为了符合CURLOPT_WRITEFUNCTION而构造的</span><br><span class="line">//完成数据保存功能</span><br><span class="line">size_t my_write_func(void *ptr, size_t size, size_t nmemb, FILE *stream)</span><br><span class="line">&#123;</span><br><span class="line">  return fwrite(ptr, size, nmemb, stream);</span><br><span class="line">&#125;</span><br><span class="line">//这个函数是为了符合CURLOPT_READFUNCTION而构造的</span><br><span class="line">//数据上传时使用</span><br><span class="line">size_t my_read_func(void *ptr, size_t size, size_t nmemb, FILE *stream)</span><br><span class="line">&#123;</span><br><span class="line">  return fread(ptr, size, nmemb, stream);</span><br><span class="line">&#125;</span><br><span class="line">//这个函数是为了符合CURLOPT_PROGRESSFUNCTION而构造的</span><br><span class="line">//显示文件传输进度，t代表文件大小，d代表传 输已经完成部分</span><br><span class="line">int my_progress_func(GtkWidget *bar,</span><br><span class="line">                     double t, /* dltotal */</span><br><span class="line">                     double d, /* dlnow */</span><br><span class="line">                     double ultotal,</span><br><span class="line">                     double ulnow)</span><br><span class="line">&#123;</span><br><span class="line">/*  printf(&quot;%d / %d (%g %%)\n&quot;, d, t, d*100.0/t);*/</span><br><span class="line">  gdk_threads_enter();</span><br><span class="line">  gtk_progress_set_value(GTK_PROGRESS(bar), d*100.0/t);</span><br><span class="line">  gdk_threads_leave();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void *my_thread(void *ptr)</span><br><span class="line">&#123;</span><br><span class="line">  CURL *curl;</span><br><span class="line">  CURLcode res;</span><br><span class="line">  FILE *outfile;</span><br><span class="line">  gchar *url = ptr;</span><br><span class="line"> </span><br><span class="line">  curl = curl_easy_init();</span><br><span class="line">  if(curl)</span><br><span class="line">  &#123;</span><br><span class="line">    outfile = fopen(&quot;test.curl&quot;, &quot;w&quot;);</span><br><span class="line"> </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL, url);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEDATA, outfile);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, my_write_func);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_READFUNCTION, my_read_func);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 0L);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_PROGRESSFUNCTION, my_progress_func);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_PROGRESSDATA, Bar);</span><br><span class="line"> </span><br><span class="line">    res = curl_easy_perform(curl);</span><br><span class="line"> </span><br><span class="line">    fclose(outfile);</span><br><span class="line">    /* always cleanup */</span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">  GtkWidget *Window, *Frame, *Frame2;</span><br><span class="line">  GtkAdjustment *adj;</span><br><span class="line"> </span><br><span class="line">  /* Must initialize libcurl before any threads are started */</span><br><span class="line">  curl_global_init(CURL_GLOBAL_ALL);</span><br><span class="line"> </span><br><span class="line">  /* Init thread */</span><br><span class="line">  g_thread_init(NULL);</span><br><span class="line"> </span><br><span class="line">  gtk_init(&amp;argc, &amp;argv);</span><br><span class="line">  Window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</span><br><span class="line">  Frame = gtk_frame_new(NULL);</span><br><span class="line">  gtk_frame_set_shadow_type(GTK_FRAME(Frame), GTK_SHADOW_OUT);</span><br><span class="line">  gtk_container_add(GTK_CONTAINER(Window), Frame);</span><br><span class="line">  Frame2 = gtk_frame_new(NULL);</span><br><span class="line">  gtk_frame_set_shadow_type(GTK_FRAME(Frame2), GTK_SHADOW_IN);</span><br><span class="line">  gtk_container_add(GTK_CONTAINER(Frame), Frame2);</span><br><span class="line">  gtk_container_set_border_width(GTK_CONTAINER(Frame2), 5);</span><br><span class="line">  adj = (GtkAdjustment*)gtk_adjustment_new(0, 0, 100, 0, 0, 0);</span><br><span class="line">  Bar = gtk_progress_bar_new_with_adjustment(adj);</span><br><span class="line">  gtk_container_add(GTK_CONTAINER(Frame2), Bar);</span><br><span class="line">  gtk_widget_show_all(Window);</span><br><span class="line"> </span><br><span class="line">  if (!g_thread_create(&amp;my_thread, argv[1], FALSE, NULL) != 0)</span><br><span class="line">    g_warning(&quot;can&apos;t create the thread&quot;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  gdk_threads_enter();</span><br><span class="line">  gtk_main();</span><br><span class="line">  gdk_threads_leave();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令：</p><pre><code>export PKG_CONFIG_PATH=/usr/lib/pkgconfig/gcc progress.c –o progress ` pkg-config --libs –cflags gtk+-2..0` -lcurl –lgthread-2.0./ progress  http://software.sky-union.cn/index.asp</code></pre><h6 id="5-断点续传实例"><a href="#5-断点续传实例" class="headerlink" title="5.断点续传实例"></a>5.断点续传实例</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">//采用CURLOPT_RESUME_FROM_LARGE 实现文件断点续传功能</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line"> </span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line">//这个函数为CURLOPT_HEADERFUNCTION参数构造</span><br><span class="line">/* 从http头部获取文件size*/</span><br><span class="line">size_t getcontentlengthfunc(void *ptr, size_t size, size_t nmemb, void *stream) &#123;</span><br><span class="line">       int r;</span><br><span class="line">       long len = 0;</span><br><span class="line"> </span><br><span class="line">       /* _snscanf() is Win32 specific */</span><br><span class="line">       // r = _snscanf(ptr, size * nmemb, &quot;Content-Length: %ld\n&quot;, &amp;len);</span><br><span class="line"> r = sscanf(ptr, &quot;Content-Length: %ld\n&quot;, &amp;len);</span><br><span class="line">       if (r) /* Microsoft: we don&apos;t read the specs */</span><br><span class="line">              *((long *) stream) = len;</span><br><span class="line"> </span><br><span class="line">       return size * nmemb;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* 保存下载文件 */</span><br><span class="line">size_t wirtefunc(void *ptr, size_t size, size_t nmemb, void *stream)</span><br><span class="line">&#123;</span><br><span class="line">        return fwrite(ptr, size, nmemb, stream);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/*读取上传文件 */</span><br><span class="line">size_t readfunc(void *ptr, size_t size, size_t nmemb, void *stream)</span><br><span class="line">&#123;</span><br><span class="line">       FILE *f = stream;</span><br><span class="line">       size_t n;</span><br><span class="line"> </span><br><span class="line">       if (ferror(f))</span><br><span class="line">              return CURL_READFUNC_ABORT;</span><br><span class="line"> </span><br><span class="line">       n = fread(ptr, size, nmemb, f) * size;</span><br><span class="line"> </span><br><span class="line">       return n;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 下载 或者上传文件函数</span><br><span class="line">int download(CURL *curlhandle, const char * remotepath, const char * localpath,</span><br><span class="line">           long timeout, long tries)</span><br><span class="line">&#123;</span><br><span class="line">       FILE *f;</span><br><span class="line">       curl_off_t local_file_len = -1 ;</span><br><span class="line">       long filesize =0 ;</span><br><span class="line">       </span><br><span class="line">       CURLcode r = CURLE_GOT_NOTHING;</span><br><span class="line">       int c;</span><br><span class="line">  struct stat file_info;</span><br><span class="line">  int use_resume = 0;</span><br><span class="line">  /* 得到本地文件大小 */</span><br><span class="line">  //if(access(localpath,F_OK) ==0)</span><br><span class="line">  </span><br><span class="line">    if(stat(localpath, &amp;file_info) == 0) </span><br><span class="line">     &#123;</span><br><span class="line">        local_file_len =  file_info.st_size;</span><br><span class="line">        use_resume  = 1;</span><br><span class="line">      &#125;</span><br><span class="line">  //采用追加方式打开文件，便于实现文件断点续传工作</span><br><span class="line">       f = fopen(localpath, &quot;ab+&quot;); </span><br><span class="line">       if (f == NULL) &#123;</span><br><span class="line">              perror(NULL);</span><br><span class="line">              return 0;</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">       //curl_easy_setopt(curlhandle, CURLOPT_UPLOAD, 1L);</span><br><span class="line"> </span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_URL, remotepath);</span><br><span class="line"> </span><br><span class="line">              curl_easy_setopt(curlhandle, CURLOPT_CONNECTTIMEOUT, timeout);  // 设置连接超时，单位秒</span><br><span class="line">       //设置http 头部处理函数</span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_HEADERFUNCTION, getcontentlengthfunc);</span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_HEADERDATA, &amp;filesize);</span><br><span class="line"> // 设置文件续传的位置给libcurl</span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_RESUME_FROM_LARGE, use_resume?local_file_len:0);</span><br><span class="line"> </span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_WRITEDATA, f);</span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_WRITEFUNCTION, wirtefunc);</span><br><span class="line"> </span><br><span class="line">       //curl_easy_setopt(curlhandle, CURLOPT_READFUNCTION, readfunc);</span><br><span class="line">       //curl_easy_setopt(curlhandle, CURLOPT_READDATA, f);</span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_NOPROGRESS, 1L);</span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_VERBOSE, 1L);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  r = curl_easy_perform(curlhandle);</span><br><span class="line">       </span><br><span class="line"> </span><br><span class="line">       fclose(f);</span><br><span class="line"> </span><br><span class="line">       if (r == CURLE_OK)</span><br><span class="line"></span><br><span class="line">              return 1;</span><br><span class="line">       else &#123;</span><br><span class="line">              fprintf(stderr, &quot;%s\n&quot;, curl_easy_strerror(r));</span><br><span class="line">              return 0;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int c, char **argv) &#123;</span><br><span class="line">       CURL *curlhandle = NULL;</span><br><span class="line"> </span><br><span class="line">       curl_global_init(CURL_GLOBAL_ALL);</span><br><span class="line">       curlhandle = curl_easy_init();</span><br><span class="line"> </span><br><span class="line">       //download(curlhandle, &quot;ftp://user:pass@host/path/file&quot;, &quot;C:\\file&quot;, 0, 3);</span><br><span class="line">  download(curlhandle , &quot;http://software.sky-union.cn/index.asp&quot;,&quot;/mnt/hgfs/VMWARE/test/10-http/temp/index.asp&quot;,1,3);</span><br><span class="line">       curl_easy_cleanup(curlhandle);</span><br><span class="line">       curl_global_cleanup();</span><br><span class="line"> </span><br><span class="line">       return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令：</p><pre><code>gcc  resume.c  -o resume –lcurl./ resume  </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;一、LibCurl基本编程框架&quot;&gt;&lt;a href=&quot;#一、LibCurl基本编程框架&quot; class=&quot;headerlink&quot; title=&quot;一、LibCurl基本编程框架&quot;&gt;&lt;/a&gt;一、LibCurl基本编程框架&lt;/h5&gt;&lt;p&gt;关于libcurl，&lt;a href=&quot;https://www.faihung.net/2019/11/03/cURL-01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BA%86%E8%A7%A3/&quot;&gt;前面已经有了很多介绍&lt;/a&gt;，这里就不详西描述了。&lt;/p&gt;
&lt;p&gt;在基于LibCurl的程序里，主要采用callback function （回调函数）的形式完成传输任务，用户在启动传输前设置好各类参数和回调函数，当满足条件时libcurl将调用用户的回调函数实现特定功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="cURL" scheme="http://www.faihung.net/categories/cURL/"/>
    
    
      <category term="cURL" scheme="http://www.faihung.net/tags/cURL/"/>
    
  </entry>
  
  <entry>
    <title>cURL-08_ARM交叉编译</title>
    <link href="http://www.faihung.net/2019/12/12/cURL-08-ARM%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"/>
    <id>http://www.faihung.net/2019/12/12/cURL-08-ARM交叉编译/</id>
    <published>2019-12-12T06:24:59.000Z</published>
    <updated>2019-12-12T06:25:53.992Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.faihung.net/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/">前面</a>提到过libcurl在Ubuntu环境下的编译安装，本章主要是嵌入式环境下的ARM交叉编译</p><p>执行<a href="https://www.faihung.net/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/">前面</a>的操作之后，进行arm的交叉编译</p><pre><code>./configure --host=arm-himix200-linux CC=arm-himix200-linux-gcc CXX=arm-himix200-linux-g++ </code></pre><a id="more"></a><p>交叉编译，说实话整了好几个小时没怎么明白，不知道为什么不行。</p><p>但是，我把原有工程的的cURL模块拆分出来，修改了Makefile之后，可以交叉编译可以在设备中运行。</p><p>目前关于cURL的交叉编译就告一段落，之后有时间在研究编译。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.faihung.net/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/&quot;&gt;前面&lt;/a&gt;提到过libcurl在Ubuntu环境下的编译安装，本章主要是嵌入式环境下的ARM交叉编译&lt;/p&gt;
&lt;p&gt;执行&lt;a href=&quot;https://www.faihung.net/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/&quot;&gt;前面&lt;/a&gt;的操作之后，进行arm的交叉编译&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./configure --host=arm-himix200-linux CC=arm-himix200-linux-gcc CXX=arm-himix200-linux-g++ &lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="cURL" scheme="http://www.faihung.net/categories/cURL/"/>
    
    
      <category term="cURL" scheme="http://www.faihung.net/tags/cURL/"/>
    
  </entry>
  
  <entry>
    <title>cURL-07_Linux下使用libcurl实现FTP文件上传下载功能</title>
    <link href="http://www.faihung.net/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/"/>
    <id>http://www.faihung.net/2019/12/08/cURL-07-Linux下使用libcurl实现FTP文件上传下载功能/</id>
    <published>2019-12-08T10:24:54.000Z</published>
    <updated>2019-12-08T10:27:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Linux下使用libcurl实现FTP单个文件或者压缩包上传下载功能</p></blockquote><a id="more"></a><h5 id="一、关于FTP"><a href="#一、关于FTP" class="headerlink" title="一、关于FTP"></a>一、关于FTP</h5><p>参考：<br><a href="https://www.faihung.net/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/">在WIN10上搭建Ftp服务器</a></p><h5 id="二、FTP上传"><a href="#二、FTP上传" class="headerlink" title="二、FTP上传"></a>二、FTP上传</h5><p>该FTP上传代码为官网上的demo例程代码，若要为己所用，只需将宏定义修改并准备一个要上传的文件即可。当然，该函数只能上传一个文件或者压缩包至FTP服务器，若要上传多个文件，可以在此例程上进行修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#ifdef WIN32</span><br><span class="line">#include &lt;io.h&gt;</span><br><span class="line">#else</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define LOCAL_FILE      &quot;/mnt/hgfs/VMWARE/test/8-curl/1206.rar&quot; //要上传的文件</span><br><span class="line">#define UPLOAD_FILE_AS  &quot;while-uploading.txt&quot;</span><br><span class="line">#define REMOTE_URL      &quot;ftp://192.168.31.175/&quot;  UPLOAD_FILE_AS //FTP服务器地址</span><br><span class="line">#define RENAME_FILE_TO  &quot;1206.rar&quot;//最终写入到这个文件名中</span><br><span class="line"></span><br><span class="line">static size_t read_callback(void *ptr, size_t size, size_t nmemb, void *stream)</span><br><span class="line">&#123;</span><br><span class="line">  curl_off_t nread;</span><br><span class="line"></span><br><span class="line">  size_t retcode = fread(ptr, size, nmemb, stream);</span><br><span class="line"></span><br><span class="line">  nread = (curl_off_t)retcode;</span><br><span class="line"></span><br><span class="line">  fprintf(stderr, &quot; We read %&quot; CURL_FORMAT_CURL_OFF_T</span><br><span class="line">          &quot; bytes from file\n&quot;, nread);</span><br><span class="line">  return retcode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">  CURL *curl;</span><br><span class="line">  CURLcode res;</span><br><span class="line">  FILE *hd_src;</span><br><span class="line">  struct stat file_info;</span><br><span class="line">  curl_off_t fsize;</span><br><span class="line"></span><br><span class="line">  struct curl_slist *headerlist = NULL;</span><br><span class="line">  static const char buf_1 [] = &quot;RNFR &quot; UPLOAD_FILE_AS;</span><br><span class="line">  static const char buf_2 [] = &quot;RNTO &quot; RENAME_FILE_TO;</span><br><span class="line"></span><br><span class="line">  /* 获得上传文件的大小 */ </span><br><span class="line">  if(stat(LOCAL_FILE, &amp;file_info)) &#123;</span><br><span class="line">    printf(&quot;Couldn&apos;t open &apos;%s&apos;: %s\n&quot;, LOCAL_FILE, strerror(errno));</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  fsize = (curl_off_t)file_info.st_size;</span><br><span class="line"></span><br><span class="line">  printf(&quot;Local file size: %&quot; CURL_FORMAT_CURL_OFF_T &quot; bytes.\n&quot;, fsize);</span><br><span class="line"></span><br><span class="line">  /* 获得FILE类型变量 */ </span><br><span class="line">  hd_src = fopen(LOCAL_FILE, &quot;rb&quot;);</span><br><span class="line"></span><br><span class="line">  /* 初始化 */ </span><br><span class="line">  curl_global_init(CURL_GLOBAL_ALL);</span><br><span class="line"></span><br><span class="line">  /* 获得curl操作符 */ </span><br><span class="line">  curl = curl_easy_init();</span><br><span class="line">  if(curl) &#123;</span><br><span class="line">    /*建立一个传递给libcurl的命令列表 */ </span><br><span class="line">    headerlist = curl_slist_append(headerlist, buf_1);</span><br><span class="line">    headerlist = curl_slist_append(headerlist, buf_2);</span><br><span class="line"></span><br><span class="line">    /* 使用curl提供的Read功能 */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_READFUNCTION, read_callback);</span><br><span class="line"></span><br><span class="line">    /* 上传使能 */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_UPLOAD, 1L);</span><br><span class="line"></span><br><span class="line">    /* 设置特定目标 */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL, REMOTE_URL);</span><br><span class="line"></span><br><span class="line">    /* 传递最后一个FTP命令以在传输后运行 */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_POSTQUOTE, headerlist);</span><br><span class="line"></span><br><span class="line">    /*指定上传文件 */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_READDATA, hd_src);</span><br><span class="line"></span><br><span class="line">    /*设置要上传的文件的大小（可选） */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_INFILESIZE_LARGE,</span><br><span class="line">                     (curl_off_t)fsize);</span><br><span class="line"></span><br><span class="line">    /* 运行 */ </span><br><span class="line">    res = curl_easy_perform(curl);</span><br><span class="line">    /* 容错处理 */ </span><br><span class="line">    if(res != CURLE_OK)</span><br><span class="line">      fprintf(stderr, &quot;curl_easy_perform() failed: %s\n&quot;,</span><br><span class="line">              curl_easy_strerror(res));</span><br><span class="line"></span><br><span class="line">    /* 清除FTP命令列表 */ </span><br><span class="line">    curl_slist_free_all(headerlist);</span><br><span class="line"></span><br><span class="line">    /*释放所有curl资源 */ </span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(hd_src); /*关闭本地文件 */ </span><br><span class="line"></span><br><span class="line">  /*释放所有curl资源 */ </span><br><span class="line">  curl_global_cleanup();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存代码，文件名命名为“ftpupload.c”，并在/mnt/hgfs/VMWARE/test/8-curl文件夹中准备“1206.rar”文件（即代码中指定的要上传的文件名），使用gcc编译，编译指令：</p><pre><code>gcc -o ftpupload ftpupload.c -lcurl</code></pre><p>执行结果：</p><p><img src="/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/1.png" alt="1"></p><p>上传前的代码：</p><p><img src="/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/2.png" alt="2"></p><p>上传到FTP服务器之后：</p><p><img src="/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/3.png" alt="3"></p><p>至此，上传功能完成。</p><h5 id="三、FTP下载"><a href="#三、FTP下载" class="headerlink" title="三、FTP下载"></a>三、FTP下载</h5><p>同样，该FTP下载代码为官网上的demo例程代码，若要为己所用，只需将宏定义修改并指定一个要下载的文件即可。当然，该函数只能下载一个文件或者压缩包至FTP客户端，若要下载多个文件，可以在此例程上进行修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line"></span><br><span class="line">struct FtpFile &#123;</span><br><span class="line">  const char *filename;</span><br><span class="line">  FILE *stream;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static size_t my_fwrite(void *buffer, size_t size, size_t nmemb, void *stream)</span><br><span class="line">&#123;</span><br><span class="line">  struct FtpFile *out = (struct FtpFile *)stream;</span><br><span class="line">  if(out &amp;&amp; !out-&gt;stream) &#123;</span><br><span class="line">    /* 打开文件以进行写操作 */ </span><br><span class="line">    out-&gt;stream = fopen(out-&gt;filename, &quot;wb&quot;);</span><br><span class="line">    if(!out-&gt;stream)</span><br><span class="line">      return -1; /* failure, can&apos;t open file to write */ </span><br><span class="line">  &#125;</span><br><span class="line">  return fwrite(buffer, size, nmemb, out-&gt;stream);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">  CURL *curl;</span><br><span class="line">  CURLcode res;</span><br><span class="line">  struct FtpFile ftpfile = &#123;</span><br><span class="line">    &quot;/mnt/hgfs/VMWARE/test/8-curl/1208.rar&quot;, /* 若FTP下载成功，名命下载后的文件为&quot;curl.txt&quot; */ </span><br><span class="line">    NULL</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  curl_global_init(CURL_GLOBAL_DEFAULT);</span><br><span class="line"></span><br><span class="line">  curl = curl_easy_init();</span><br><span class="line">  if(curl) &#123;</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL,</span><br><span class="line">                     &quot;ftp://192.168.31.175/1208.rar&quot;);//下载指定的文件</span><br><span class="line">    /* 定义回调函数，以便在需要写入数据时进行调用 */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, my_fwrite);</span><br><span class="line">    /*设置一个指向我们的结构的指针传递给回调函数*/ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;ftpfile);</span><br><span class="line"></span><br><span class="line">    /* 打开完整的协议/调试输出*/ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);</span><br><span class="line"></span><br><span class="line">    res = curl_easy_perform(curl);</span><br><span class="line"></span><br><span class="line">    /* 释放所有curl资源*/ </span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line"></span><br><span class="line">    if(CURLE_OK != res) &#123;</span><br><span class="line">      /*容错处理 */ </span><br><span class="line">      fprintf(stderr, &quot;curl told us %d\n&quot;, res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(ftpfile.stream)</span><br><span class="line">    fclose(ftpfile.stream); /* 关闭本地文件 */ </span><br><span class="line"> /*释放所有curl资源*/</span><br><span class="line">  curl_global_cleanup();</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用gcc编译，编译指令：</p><pre><code>gcc -o ftpDown ftpDown.c -lcurl</code></pre><p>执行结果：</p><p><img src="/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/4.png" alt="4"></p><p>下载之前，放在FTP服务器中时：</p><p><img src="/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/5.png" alt="5"></p><p>下载之后，放在本地文件中中时：</p><p><img src="/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/6.png" alt="6"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Linux下使用libcurl实现FTP单个文件或者压缩包上传下载功能&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="cURL" scheme="http://www.faihung.net/categories/cURL/"/>
    
    
      <category term="cURL" scheme="http://www.faihung.net/tags/cURL/"/>
    
  </entry>
  
  <entry>
    <title>cURL-06_cURL和libcurl的安装的安装途径</title>
    <link href="http://www.faihung.net/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/"/>
    <id>http://www.faihung.net/2019/12/08/cURL-06-cURL和libcuel的安装的安装途径/</id>
    <published>2019-12-08T08:51:06.000Z</published>
    <updated>2019-12-16T10:02:40.128Z</updated>
    
    <content type="html"><![CDATA[<p>cURL的安装一般有三种方式:<a href="https://ec.haxx.se/" target="_blank" rel="noopener">https://ec.haxx.se/</a></p><a id="more"></a><h5 id="一、ubuntu16-04-安装curl，一般用于命令行工具操作"><a href="#一、ubuntu16-04-安装curl，一般用于命令行工具操作" class="headerlink" title="一、ubuntu16.04 安装curl，一般用于命令行工具操作"></a>一、ubuntu16.04 安装curl，一般用于命令行工具操作</h5><h6 id="1-直接安装"><a href="#1-直接安装" class="headerlink" title="1. 直接安装"></a>1. 直接安装</h6><pre><code>sudo apt install curl</code></pre><h6 id="2-或者是下载软件压缩包安装-Ubuntu下安装cURL库用于libcurl开发"><a href="#2-或者是下载软件压缩包安装-Ubuntu下安装cURL库用于libcurl开发" class="headerlink" title="2. 或者是下载软件压缩包安装-Ubuntu下安装cURL库用于libcurl开发"></a>2. 或者是下载软件压缩包安装-Ubuntu下安装cURL库用于libcurl开发</h6><p>2.1 下载curl包（可以在这个网站上找最新的版本 <a href="http://curl.haxx.se/download/）" target="_blank" rel="noopener">http://curl.haxx.se/download/）</a></p><p><img src="/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/1.png" alt="1"></p><pre><code>wget https://curl.haxx.se/download/curl-7.55.1.tar.gz</code></pre><p>2.2 解压</p><pre><code>tar -xzvf  curl-7.55.1.tar.gz</code></pre><p>2.3 覆盖安装</p><pre><code>stemp 1 cd curl-7.55.1stemp 2 ./configurestemp 3 makestemp 4 make install</code></pre><p>2.4 使用 curl –version 检查是否更新成功</p><p><img src="/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/2.png" alt="2"></p><h5 id="二、ubuntu16-04-安装libcurl-主要用于ubuntu中应用程序开发-curl和libcurl的区别"><a href="#二、ubuntu16-04-安装libcurl-主要用于ubuntu中应用程序开发-curl和libcurl的区别" class="headerlink" title="二、ubuntu16.04 安装libcurl,主要用于ubuntu中应用程序开发(curl和libcurl的区别)"></a>二、ubuntu16.04 安装libcurl,主要用于ubuntu中应用程序开发(curl和libcurl的区别)</h5><pre><code>sudo apt install libcurl4-openssl-dev</code></pre><p>可以看到-ubuntu系统中/usr/include/curl中的头文件,此操作可以作为Ubuntu虚拟程序中的&lt;curl/curl.h&gt;,一般作为Ubuntu平台模拟程序使用。</p><p>库文件：/usr/lib/x86_64-linux-gnu/libcurl.so.4</p><h5 id="三、linux下编译安装libcurl"><a href="#三、linux下编译安装libcurl" class="headerlink" title="三、linux下编译安装libcurl"></a>三、linux下编译安装libcurl</h5><h6 id="1-直接下载"><a href="#1-直接下载" class="headerlink" title="1. 直接下载"></a>1. 直接下载</h6><pre><code>git clone https://github.com/curl/curl.git </code></pre><h6 id="2-tar解压后，进入curl工程目录输入指令：-buidconf，产生configure脚本"><a href="#2-tar解压后，进入curl工程目录输入指令：-buidconf，产生configure脚本" class="headerlink" title="2.tar解压后，进入curl工程目录输入指令：./buidconf，产生configure脚本"></a>2.tar解压后，进入curl工程目录输入指令：./buidconf，产生configure脚本</h6><p>之后和第一条步骤类似</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cURL的安装一般有三种方式:&lt;a href=&quot;https://ec.haxx.se/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ec.haxx.se/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="cURL" scheme="http://www.faihung.net/categories/cURL/"/>
    
    
      <category term="cURL" scheme="http://www.faihung.net/tags/cURL/"/>
    
  </entry>
  
  <entry>
    <title>cURL-05_curl和libcurl的区别简介(转)</title>
    <link href="http://www.faihung.net/2019/12/08/cURL-05-curl%E5%92%8Clibcurl%E7%9A%84%E5%8C%BA%E5%88%AB%E7%AE%80%E4%BB%8B-%E8%BD%AC/"/>
    <id>http://www.faihung.net/2019/12/08/cURL-05-curl和libcurl的区别简介-转/</id>
    <published>2019-12-08T08:33:44.000Z</published>
    <updated>2019-12-08T08:38:47.024Z</updated>
    
    <content type="html"><![CDATA[<h5 id="curl简介"><a href="#curl简介" class="headerlink" title="curl简介"></a>curl简介</h5><p>curl是利用URL语法在命令行方式下工作的开源文件传输工具。<br>它支持很多协议：DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP。</p><p>curl同样支持SSL证书,HTTP POST, HTTP PUT,FTP上传，基于表单的HTTP上传，代理(proxies)、cookies、用户名/密码认证(Basic, Digest, NTLM等)、下载文件断点续传，上载文件断点续传(file transfer resume)，http代理服务器管道（proxy tunneling)以及其他特性。</p><p>curl是瑞典curl组织开发的,curl的官网是<a href="http://curl.haxx.se/,可以从官网获取它的源代码和相关说明。" target="_blank" rel="noopener">http://curl.haxx.se/,可以从官网获取它的源代码和相关说明。</a></p><a id="more"></a><h5 id="libcurl简介"><a href="#libcurl简介" class="headerlink" title="libcurl简介"></a>libcurl简介</h5><p>libcurl为一个免费开源的，客户端url传输库，支持DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP等协议。</p><p>同curl一样，libcurl也支持SSL证书,HTTP POST, HTTP PUT,FTP上传，基于表单的HTTP上传，代理(proxies)、cookies、用户名/密码认证(Basic, Digest, NTLM等)、下载文件断点续传，上载文件断点续传(file transfer resume)，http代理服务器管道（proxy tunneling)等。</p><p>libcurl是高度可移植的，可以工作在不同的平台上，支持Windows，Unix，Linux等。</p><p>libcurl是免费的，线程安全的，IPV6兼容的，同时它还有很多其它非常丰富的特性。libcurl已经被很多知名的大企业以及应用程序所采用。</p><h5 id="curl与libcurl对比"><a href="#curl与libcurl对比" class="headerlink" title="curl与libcurl对比"></a>curl与libcurl对比</h5><h6 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h6><p>curl和libcurl都可以利用多种多样的协议来传输文件，包括HTTP, HTTPS, FTP, FTPS, GOPHER, LDAP, DICT, TELNET and FILE等。</p><h6 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h6><ul><li>curl是命令行工具，可以通过shell或脚本来运行curl。curl底层所使用的库是libcurl。</li><li>libcurl是一个库，通常与别的程序绑定在一起使用，如命令行工具curl就是封装了libcurl库。所以我们也可以在你自己的程序或项目中使用libcurl以获得类似CURL的强大功能。接下来将要介绍的PHP扩展就是对curl的一个封装。</li></ul><h5 id="几个名词"><a href="#几个名词" class="headerlink" title="几个名词"></a>几个名词</h5><h6 id="“curl”的不同意思"><a href="#“curl”的不同意思" class="headerlink" title="“curl”的不同意思"></a>“curl”的不同意思</h6><p>1.curl指的是curl命令行工具，可以从命令行或者脚本或者批处理文件中运行curl。curl创建于1998年，并且提供了100多个选项去控制它。</p><p>2.cURL是一个软件项目的名字。该软件项目包含了上面所说的curl和libcurl，并且都是开源的。</p><p>3.cURL通常用作PHP中libcurl扩展的名字。这个扩展确保了PHP程序员在程序中可以访问libcurl库所提供的功能。</p><h6 id="curl—命令行工具"><a href="#curl—命令行工具" class="headerlink" title="curl—命令行工具"></a>curl—命令行工具</h6><ol><li>命令行工具，可以从shell或者脚本中运行该工具。</li><li>提供了130多种不同的“flags”</li><li>通常被用来模拟浏览器的行为</li><li>跨平台</li></ol><h6 id="libcurl—库"><a href="#libcurl—库" class="headerlink" title="libcurl—库"></a>libcurl—库</h6><ol><li>用作其他程序的开发库</li><li>可以与许多语言想结合，如PHP、C++</li><li>跨平台</li><li>提供了多种不同的使用它的APIs</li></ol><h5 id="PHP中使用curl和libcurl"><a href="#PHP中使用curl和libcurl" class="headerlink" title="PHP中使用curl和libcurl"></a>PHP中使用curl和libcurl</h5><h6 id="PHP中使用curl"><a href="#PHP中使用curl" class="headerlink" title="PHP中使用curl"></a>PHP中使用curl</h6><p>在PHP中使用curl非常简单，只要调用PHP中几个执行系统命令的相关函数即可。<br>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$baidu=shell_exec(&quot;/usr/bin/curl -L http://www.baidu.com&quot;); </span><br><span class="line">var_dump($baidu);</span><br></pre></td></tr></table></figure><h6 id="PHP中使用libcurl"><a href="#PHP中使用libcurl" class="headerlink" title="PHP中使用libcurl"></a>PHP中使用libcurl</h6><p>在PHP中使用libcurl，也就是我们通常所说的PHP中的“curl”。这部分的内容会在以后的文章中给出，这里只写出一个示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// FTP this script to a server</span><br><span class="line">$fp = fopen(__FILE__, &quot;r&quot;);</span><br><span class="line">$url = &quot;ftp://username:password@mydomain.com:21/path/to/newfile.php&quot;;</span><br><span class="line">$ch = curl_init();   </span><br><span class="line">curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);</span><br><span class="line">curl_setopt($ch, CURLOPT_UPLOAD, 1);</span><br><span class="line">curl_setopt($ch, CURLOPT_INFILE, $fp);</span><br><span class="line">curl_setopt($ch, CURLOPT_FTPASCII, 1);</span><br><span class="line">curl_setopt($ch, CURLOPT_INFILESIZE, filesize(__FILE__));</span><br><span class="line">$result = curl_exec($ch);</span><br><span class="line">curl_close($ch);</span><br></pre></td></tr></table></figure><h5 id="使用curl还是libcurl？"><a href="#使用curl还是libcurl？" class="headerlink" title="使用curl还是libcurl？"></a>使用curl还是libcurl？</h5><p>使用curl还是libcurl这个需要根据具体的情况而定。例如，当有一个定时脚本在远程服务器的文件改变时发送邮件或者当前PHP环境不支持libcurl时，我们应该使用curl。否则，我们使用libcurl即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;curl简介&quot;&gt;&lt;a href=&quot;#curl简介&quot; class=&quot;headerlink&quot; title=&quot;curl简介&quot;&gt;&lt;/a&gt;curl简介&lt;/h5&gt;&lt;p&gt;curl是利用URL语法在命令行方式下工作的开源文件传输工具。&lt;br&gt;它支持很多协议：DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP。&lt;/p&gt;
&lt;p&gt;curl同样支持SSL证书,HTTP POST, HTTP PUT,FTP上传，基于表单的HTTP上传，代理(proxies)、cookies、用户名/密码认证(Basic, Digest, NTLM等)、下载文件断点续传，上载文件断点续传(file transfer resume)，http代理服务器管道（proxy tunneling)以及其他特性。&lt;/p&gt;
&lt;p&gt;curl是瑞典curl组织开发的,curl的官网是&lt;a href=&quot;http://curl.haxx.se/,可以从官网获取它的源代码和相关说明。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://curl.haxx.se/,可以从官网获取它的源代码和相关说明。&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="cURL" scheme="http://www.faihung.net/categories/cURL/"/>
    
    
      <category term="cURL" scheme="http://www.faihung.net/tags/cURL/"/>
    
  </entry>
  
  <entry>
    <title>工具-虚拟机的桥接模式和NAT模式的区别</title>
    <link href="http://www.faihung.net/2019/12/08/%E5%B7%A5%E5%85%B7-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E5%92%8CNAT%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.faihung.net/2019/12/08/工具-虚拟机的桥接模式和NAT模式的区别/</id>
    <published>2019-12-08T08:09:29.000Z</published>
    <updated>2019-12-08T08:14:31.317Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-桥接模式"><a href="#1-桥接模式" class="headerlink" title="1.桥接模式"></a>1.桥接模式</h5><p>通过使用物理机的网卡，有自己的IP地址，就像在电脑上虚拟出来另一台主机，它可以访问网内任何一台主机，需要手工为其配置IP地址、子网掩码、需要和宿主机器处于同一个网段，这样虚拟机才能和宿主机器进行通信。同时，由于这个虚拟系统是局域网中的一个独立主机系统，就可以手工配置他的TCP\IP信息，实现通过局域网的网关或路由进行互联网访问。</p><a id="more"></a><p><strong>弊端:</strong></p><ol><li><p>Ip地址可能会发生变化 192.150.1.100/192.168.1.101</p></li><li><p>如果这时传递文件时需要依靠交换机/路由器</p></li></ol><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E5%92%8CNAT%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/1.png" alt="1"></p><h5 id="2-NAT模式"><a href="#2-NAT模式" class="headerlink" title="2.NAT模式"></a>2.NAT模式</h5><p>使用NAT模式，就是让虚拟系统借助NAT（网络地址的转换功能），通过宿主机器所在的网络来访问公网，也就是说使用NAT模式可以实现在虚拟系统里访问互联网，NAT模式下的虚拟系统的TCP/IP配置是由VMnet8（NAT）虚拟网络的DHCP服务器提供的，无法进行手工修改，因此虚拟系统也就无法和本局域网中的其他真是主机进行通讯。采用NAT模式的虚拟机的有点就是，想要接入互联网十分方便，只要宿主机能访问到互联网即可。</p><p><strong>特点:</strong></p><ol><li><p>NAT模式时,只能由真实的计算机连接虚拟网络空间,其他的计算机由于网络不在一个网段内,则不能通信.</p></li><li><p>NAT模式时,IP地址一般都是固定不变的.所以无论在哪里.Ip都能直接连接.</p></li></ol><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E5%92%8CNAT%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/2.png" alt="2"></p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;1-桥接模式&quot;&gt;&lt;a href=&quot;#1-桥接模式&quot; class=&quot;headerlink&quot; title=&quot;1.桥接模式&quot;&gt;&lt;/a&gt;1.桥接模式&lt;/h5&gt;&lt;p&gt;通过使用物理机的网卡，有自己的IP地址，就像在电脑上虚拟出来另一台主机，它可以访问网内任何一台主机，需要手工为其配置IP地址、子网掩码、需要和宿主机器处于同一个网段，这样虚拟机才能和宿主机器进行通信。同时，由于这个虚拟系统是局域网中的一个独立主机系统，就可以手工配置他的TCP\IP信息，实现通过局域网的网关或路由进行互联网访问。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://www.faihung.net/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="VMware" scheme="http://www.faihung.net/tags/VMware/"/>
    
      <category term="网络配置" scheme="http://www.faihung.net/tags/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>工具-如何配置Windows、虚拟机、开发板的网络</title>
    <link href="http://www.faihung.net/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/"/>
    <id>http://www.faihung.net/2019/12/08/工具-如何配置Windows、虚拟机、开发板的网络/</id>
    <published>2019-12-08T07:52:18.000Z</published>
    <updated>2019-12-08T08:00:16.400Z</updated>
    
    <content type="html"><![CDATA[<p>烧录软件和方便调试先要保证电脑windos操作系统、虚拟机linuxr操作系统<br>和开发板三者之间相互Ping通，要做到这些其实很简单：</p><a id="more"></a><h5 id="1-打开windows网络和共享中心更改适配器设置"><a href="#1-打开windows网络和共享中心更改适配器设置" class="headerlink" title="1. 打开windows网络和共享中心更改适配器设置"></a>1. 打开windows网络和共享中心更改适配器设置</h5><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/1.png" alt="1"></p><h5 id="2-打开这三个的属性，把VMware-Bridge-Protocol都勾上，如图"><a href="#2-打开这三个的属性，把VMware-Bridge-Protocol都勾上，如图" class="headerlink" title="2. 打开这三个的属性，把VMware Bridge Protocol都勾上，如图"></a>2. 打开这三个的属性，把VMware Bridge Protocol都勾上，如图</h5><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/2.png" alt="2"></p><h5 id="3-打开本地连接的属性再打开IPV4的属性选择使用手动IP如下图所示"><a href="#3-打开本地连接的属性再打开IPV4的属性选择使用手动IP如下图所示" class="headerlink" title="3. 打开本地连接的属性再打开IPV4的属性选择使用手动IP如下图所示"></a>3. 打开本地连接的属性再打开IPV4的属性选择使用手动IP如下图所示</h5><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/3.png" alt="3"></p><h5 id="4-点击VMware的虚拟机-gt-设置-网络选择桥接如下图所示"><a href="#4-点击VMware的虚拟机-gt-设置-网络选择桥接如下图所示" class="headerlink" title="4. 点击VMware的虚拟机-&gt; 设置 网络选择桥接如下图所示"></a>4. 点击VMware的虚拟机-&gt; 设置 网络选择桥接如下图所示</h5><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/4.png" alt="4"></p><p>网络选择桥接如下图所示</p><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/5.png" alt="5"></p><h5 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h5><h6 id="5-1-点击VMware的编辑-gt-虚拟网络编辑器"><a href="#5-1-点击VMware的编辑-gt-虚拟网络编辑器" class="headerlink" title="5.1 点击VMware的编辑-&gt;虚拟网络编辑器"></a>5.1 点击VMware的编辑-&gt;虚拟网络编辑器</h6><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/6.png" alt="6"></p><h6 id="5-2-点击更改设置"><a href="#5-2-点击更改设置" class="headerlink" title="5.2 点击更改设置"></a>5.2 点击更改设置</h6><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/7.png" alt="7"></p><h6 id="5-3-点击桥接模式，选择自己要桥接的网卡-网卡要记得选对"><a href="#5-3-点击桥接模式，选择自己要桥接的网卡-网卡要记得选对" class="headerlink" title="5.3 点击桥接模式，选择自己要桥接的网卡(网卡要记得选对)"></a>5.3 点击桥接模式，选择自己要桥接的网卡(网卡要记得选对)</h6><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/8.png" alt="8"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;烧录软件和方便调试先要保证电脑windos操作系统、虚拟机linuxr操作系统&lt;br&gt;和开发板三者之间相互Ping通，要做到这些其实很简单：&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://www.faihung.net/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Windows" scheme="http://www.faihung.net/tags/Windows/"/>
    
      <category term="VMware" scheme="http://www.faihung.net/tags/VMware/"/>
    
      <category term="网络配置" scheme="http://www.faihung.net/tags/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>工具-在WIN10上搭建Ftp服务器（转）</title>
    <link href="http://www.faihung.net/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/"/>
    <id>http://www.faihung.net/2019/12/07/工具-在WIN10上搭建Ftp服务器（转）/</id>
    <published>2019-12-07T09:29:44.000Z</published>
    <updated>2019-12-08T09:33:36.429Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在windows10上面搭建你的FTP服务器，     正在学服务器这门课程，刚好学到搭建Ftp服务器。所以就在自己电脑上也搭建了一个Ftp服务器。我的电脑是win10的，所以本教程也是在win10上面搭建Ftp服务器。希望能帮到有需要的同学！</p></blockquote><a id="more"></a><h5 id="一、在windows10中搭建Ftp服务器主要用的是IIS管理器管理控制台"><a href="#一、在windows10中搭建Ftp服务器主要用的是IIS管理器管理控制台" class="headerlink" title="一、在windows10中搭建Ftp服务器主要用的是IIS管理器管理控制台"></a>一、在windows10中搭建Ftp服务器主要用的是IIS管理器管理控制台</h5><h6 id="1-在控制面板里面打开程序功能里面的FTP服务器和web管理工具"><a href="#1-在控制面板里面打开程序功能里面的FTP服务器和web管理工具" class="headerlink" title="1. 在控制面板里面打开程序功能里面的FTP服务器和web管理工具"></a>1. 在控制面板里面打开程序功能里面的FTP服务器和web管理工具</h6><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/1.png" alt="1"></p><h5 id="二、打开IIS管理器平台，不知道在哪打开的可以直接搜索IIS打开"><a href="#二、打开IIS管理器平台，不知道在哪打开的可以直接搜索IIS打开" class="headerlink" title="二、打开IIS管理器平台，不知道在哪打开的可以直接搜索IIS打开"></a>二、打开IIS管理器平台，不知道在哪打开的可以直接搜索IIS打开</h5><h6 id="1-在网站那里右键“添加FTP站点”"><a href="#1-在网站那里右键“添加FTP站点”" class="headerlink" title="1.在网站那里右键“添加FTP站点”"></a>1.在网站那里右键“添加FTP站点”</h6><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/2.png" alt="2"></p><h6 id="2-输入你的站点名称和物理路径"><a href="#2-输入你的站点名称和物理路径" class="headerlink" title="2. 输入你的站点名称和物理路径"></a>2. 输入你的站点名称和物理路径</h6><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/3.png" alt="3"></p><h6 id="3-下一步绑定你的FTP服务器地址，这里的端口使用默认的21号端口。IP地址是你本机的IP地址"><a href="#3-下一步绑定你的FTP服务器地址，这里的端口使用默认的21号端口。IP地址是你本机的IP地址" class="headerlink" title="3. 下一步绑定你的FTP服务器地址，这里的端口使用默认的21号端口。IP地址是你本机的IP地址"></a>3. 下一步绑定你的FTP服务器地址，这里的端口使用默认的21号端口。IP地址是你本机的IP地址</h6><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/4.png" alt="4"></p><h6 id="4-下一步，根据需要设置身份验证和授权信息"><a href="#4-下一步，根据需要设置身份验证和授权信息" class="headerlink" title="4. 下一步，根据需要设置身份验证和授权信息"></a>4. 下一步，根据需要设置身份验证和授权信息</h6><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/5.png" alt="5"></p><p>点击完成FTP服务器就搭建好了。</p><h5 id="三、测试你的ftp服务器"><a href="#三、测试你的ftp服务器" class="headerlink" title="三、测试你的ftp服务器"></a>三、测试你的ftp服务器</h5><p>在浏览器上输入ftp://<strong>.</strong>.<strong>.</strong>（填你自己的ftp地址）。你就可以看到你ftp目录里面的东西了，浏览器打开的效果是这样子的</p><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/6.png" alt="6"></p><h5 id="四、有小伙伴私信我，服务器搭建好了，自己可以访问，但是别人访问不了，以下我总结了以下解决方法，希望对你们有效"><a href="#四、有小伙伴私信我，服务器搭建好了，自己可以访问，但是别人访问不了，以下我总结了以下解决方法，希望对你们有效" class="headerlink" title="四、有小伙伴私信我，服务器搭建好了，自己可以访问，但是别人访问不了，以下我总结了以下解决方法，希望对你们有效"></a>四、有小伙伴私信我，服务器搭建好了，自己可以访问，但是别人访问不了，以下我总结了以下解决方法，希望对你们有效</h5><h6 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h6><p>把防火墙关掉、一般别人访问不了都是防火墙限制了，直接把防火墙关掉这是最快的解决方法</p><h6 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h6><p>如果你想把防火墙开着呢，那应该怎么做？</p><p>打开防火墙设置，选择允许的应用，把ftp服务器勾选上、然后再点击允许其它应用</p><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/7.png" alt="7"></p><p>选择C:\Windows\System32目录下面的svchost.exe这个软件</p><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/8.png" alt="8"></p><p>把这个应该添加到防火墙允许的应用里面</p><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/9.png" alt="9"></p><p>做完以上步骤再试一下，别人就可以在你开启防火墙的状态依旧可以访问你的ftp服务器了</p><p>但是有的小伙伴还是不能访问，那应该怎么办呢？继续以下步骤（如果进行完以上步骤可以访问就不用进行下面的操作）</p><p>依旧是打开防火墙设置，然后选择高级设置</p><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/10.png" alt="10"></p><p>在出站规则里面选择和frp相关的规则，点击右边的启用规则就可以了</p><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/11.png" alt="11"></p><p>启用之后规则左边就会被打上勾了</p><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/12.png" alt="12"></p><p>基本上我目前遇到小伙伴私信的问题都可以通过以上的方法解决，如果还是不行的话，记得私信我，我们再一起研究研究，然后把解决方法再加上。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在windows10上面搭建你的FTP服务器，     正在学服务器这门课程，刚好学到搭建Ftp服务器。所以就在自己电脑上也搭建了一个Ftp服务器。我的电脑是win10的，所以本教程也是在win10上面搭建Ftp服务器。希望能帮到有需要的同学！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://www.faihung.net/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="FTP" scheme="http://www.faihung.net/tags/FTP/"/>
    
  </entry>
  
  <entry>
    <title>视音频-视频简介</title>
    <link href="http://www.faihung.net/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E7%AE%80%E4%BB%8B/"/>
    <id>http://www.faihung.net/2019/12/01/视音频-视频简介/</id>
    <published>2019-12-01T08:24:26.000Z</published>
    <updated>2019-12-01T08:30:46.876Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>尽管视频信号有很多类型和实现技术,但其目的只是为了实现视觉信息在不同位置之间的传送。这些视觉信息可能是来自于VCR, DVD播放器、本地广播的某个频道、有线电视,或者来自于卫星电视系统、因特网,还可能是其他各种渠道。</p></blockquote><a id="more"></a><blockquote><p>但有一点是肯定的,那就是视频信息必须从一个设备传输到另一个设备。可能是从卫星电视机顶盒或DVD播放器传输到电视机,或者在卫星电视机顶盒或电视机内部不同芯片之间传输。这看起来好像很简单,但需要满足很多不同的要求,故存在很多方式来实现这种传输。</p></blockquote><h4 id="一、模拟与数字"><a href="#一、模拟与数字" class="headerlink" title="一、模拟与数字"></a>一、模拟与数字</h4><p>几年前,大多数的视频设备还主要是为模拟视频而设计的,数字视频还仅限于视频编辑这样的专业应用领域。</p><p>目前,普通消费者在日常生活中都用上了数字视频设备,这要得益于这些数字产品价格的不断下降。这种趋势也导致相关技术的快速发展,如DVD播放机和摄像机、数字机顶盒、数字电视(DTV)、便携视频播放器和基于因特网的视频数据传输能力等</p><h4 id="二、视频数据"><a href="#二、视频数据" class="headerlink" title="二、视频数据"></a>二、视频数据</h4><p>起初,视频仅仅包含灰度(也称为黑白)信息。</p><p>在建立彩色广播电视系统的过程中,人们试图用模拟RGB (红、绿、蓝)来发送彩色视频,然而,这种技术占用的带宽是当时使用的灰度解决方案的3倍多,因此必须创建其他的替代方法,于是,人们用Y, R-Y和G-Y数据来表示颜色信息,并开发相应的技术来传输Y, R-Y和G-Y信息。这种技术只需要一个信号,而不是3个独立的信号,因此只需要与原来传输灰度视频信号相同的带宽。今天广泛使用的NTSC、 PAL和SECAM视频标准仍然是建立在这种复合视频信号(composite video signal) 基础上的。</p><p>现在,尽管有很多种表示视频的方式,但它们都要通过RGB的数学公式表示出来。</p><p>s-Video是为了将终端设备连接(目的不是为了广播)在一起而建立的。每组信号由两个模拟信号构成:一个为灰度(Y)信息,另一个是以特定格式传输的模拟R-Y和B-Y颜色信息(也称为C或色度),这种技术曾经只在S-VHS中可用,但现在大多数消费类视频产品都支持这项技术。</p><p>尽管模拟RGB视频数据一直用于专业视频市场,但为了实现与高端消费设备的连接,模拟RGB视频数据也暂时应用于普通视频市场。与S-Video一样,模拟RGB视频数据也不用于广播。Y,R-Y、G-Y视频信号的另一种形式称为YPbPr,现在通常用于将消费类视频产品连接在起。其主要优点在于能够在消费类视频产品之间传输高分辨率视频。有些制造商错误地将YPbPT连接器称为YUV, YCbC或Y (B-Y) (R-Y)。</p><h5 id="2-1-数字视频"><a href="#2-1-数字视频" class="headerlink" title="2.1 数字视频"></a>2.1 数字视频</h5><p>目前最通用的数字信号为RGB和YCbCr. RGB是模拟RGB视频信号进行简单数字化后得到的版本。 YCbCT基本上是模拟YPbPr视频信号的数字化版本,这种格式由DVD和数字电视所采用。</p><h5 id="2-2最佳连接方法"><a href="#2-2最佳连接方法" class="headerlink" title="2.2最佳连接方法"></a>2.2最佳连接方法</h5><p>设备的最佳连接方法是什么?对于DVD播放器和数字有线电视/卫星电视/地面机顶盒,按照视频质量由好到差排序,一般的顺序为：</p><p>(1) HDMI (数字YCbCr)</p><p>(2) HIDMI (数字RGB)</p><p>(3)模拟YPbPr</p><p>(4)模拟RGB</p><p>(5)模拟S-Video</p><p>(6)模拟复合视频</p><p>有些人可能不同意这个排序。但是,大多数消费类产品都是在YCbCr颜色空间进行数字视处理的。因此,使用YCbCr作为设备互连格式可以减少所需的颜色空间转换次数。数字信号的颜色空间转换仍然优先选择进行D/A (数字到模拟)转换,接着进行AD (模拟到数字)转换,所以HDMI RGB排在模拟YPbPr之前。</p><p>计算机产业已经对接入计算机显示器的模拟和数字RGB信号进行了标准化。</p><h4 id="三、视频时序"><a href="#三、视频时序" class="headerlink" title="三、视频时序"></a>三、视频时序</h4><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E7%AE%80%E4%BB%8B/1.png" alt="1"></p><p>视频画面尽管看起来好像是连续运动的,其实那是一系列静止的图像。这些图像切换得足够快,  使得画面看起来像是连续运动的,如图2-1所示  对于消费类电子产品,通常情况下为每秒50或60张图像,计算机显示器为每秒70-90张图像。一种称为场同步(vertical sync)的特定时序信息被用于指定新图像从什么时候开始显示。</p><p>每张静止图像是由扫描线(scan line)组成的即沿着显示器从上到下、一行接着一行进行显示的数据线,如图2-1所示。另一种称为行同步(horizontal sync)的时序信息用于指定新扫描线什么时候开始显示。</p><p>行同步和场同步信息通常通过以下三种方式之一进行传输:</p><p>(1)单独的行同步和场同步信号;  </p><p>(2)单独的复合同步信号；</p><p>(3)嵌入视频信号的复合同步信号。</p><p>复合同步信号是由场同步和行同步信号组合而成的。使用模拟RGB视频的计算机和消费类设备通常采用技术(1)或(2),支持复合视频或模拟YPbPr视频的消费类设备通常采用技术(3)。对于数字视频,通常要么采用技术(1),要么就是将时序编码字嵌入数字视频流中。</p><h5 id="隔行与逐行"><a href="#隔行与逐行" class="headerlink" title="隔行与逐行"></a>隔行与逐行</h5><p>由于视频是由一系列静止图像组成的,因此,简单地连续显示每幅完整的图像是有意义的,也就是一张接一张地显示每幅图像。</p><p>上面所讲的就是逐行显示(progressive) [或称为非隔行(non-interlaced)显示]的基本技术。对于将图像以逐行方式“绘制”到屏幕上的设备(如CRT),每张图像都是从显示器的左上角开始,一直向右移动,直到到达显示器的右边缘为止然后向下扫描一行,重复地从左到右进行扫描。这个过程一直持续到整个屏幕全部被刷新一次为止,如图2-2所示。<br><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E7%AE%80%E4%BB%8B/2.png" alt="2"></p><p>在电视发展的早期,采用一种称为“隔行显(interlacing)”的技术来减少每幅图像所需发送  “绘制”出每幅图像的数据量。这种方式先发送奇数行的数据,接着发送偶数行的数据(如图2-3所示),因此每次发送的数据量为一幅图像数据量的一半。<br><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E7%AE%80%E4%BB%8B/3.png" alt="3"></p><p>既然隔行显示方式有这个优点,那么为什么还要多余地使用逐行显示方式呢?</p><p>在隔行显示方式中,每个扫描线更新的频率只有同等情况下逐行显示方式的一半。所以,为了避免由于过低的帧率而导致颜色对比显著的边缘出现闪烁,要限制扫描线之间的变化,这本质上是由于在垂直方向上对图像进行了低通滤波。而逐行显示方式对线之间的变化就没有这种限制因此,逐行显示方式能够提供更高分辨率(在垂直方向上)的没有闪烁的图像。</p><p>现在,大多数广播(包括HDTV)都仍然以隔行方式发射信号。大多数基于CRT的显示器也是隔行方式显示,而LCD、等离子以及计算机显示器都是采用逐行方式。</p><h4 id="四、视频分辨率"><a href="#四、视频分辨率" class="headerlink" title="四、视频分辨率"></a>四、视频分辨率</h4><p>在现实生活中,人们对于视频分辨率的概念往往有一些模糊的认识。我们通常见到的视频分辨率为720 x 480或1920 × 1080,然而,那只是水平采样和垂直扫描线的数目,并不等于说必须具有这么多有用信息。</p><p>例如,可以以13.5MHz的频率对模拟视频信号进行采样,生成每行720个采样点。对同样的信号以27MHz的频率采样可以生成每行1440个采样点。但这仅仅是每行的采样数目不同,视频内容的分辨率并没有改变。</p><p>因此,视频质量通常用线分辨率(lines of resolution)来度量。<br>本质上是表示在显示器上可以显示多少不同的黑白垂直线。然后将这个数目归一化为1 :1显示宽高比(对于4:3的显示器,将该数除以3/4,而对于16:9的显示器则除以916),当然,对于宽屏(16:9)显示器,这会使得视频分辨率较低,与直觉不相符。</p><h5 id="4-1-标准清晰度"><a href="#4-1-标准清晰度" class="headerlink" title="4.1 标准清晰度"></a>4.1 标准清晰度</h5><p>标准清晰度(standard-definition)视频通常定义为480或576的隔行有效扫描线的视频,分别称为”480i”和”576i”。</p><p>固定像素(非CRT)、具有4:3宽高比的消费类显示器通过转换后,对应于720 x 480i或720x576i的有效分辨率。而对于16:9的宽高比,转换后的有效分辨率对应于960 x 480i或960 x 576i</p><h5 id="4-2-增强清晰度"><a href="#4-2-增强清晰度" class="headerlink" title="4.2 增强清晰度"></a>4.2 增强清晰度</h5><p>增强清晰度(enhanced-definition)视频通常定义为具有480或576逐行有效扫描线的视频,分别称为”480p”或”576p”.</p><p>固定像素(非CRT)具有4 :3宽高比的消费类显示器转换后的有效分辨率对应于720 x480p或720 x 576p。而对于16 :9的宽高比,转换后的有效分辨率对应于960 x 480p或960 x 576p.</p><p>标准清晰度和增强清晰度的差异在于,标准清晰度是隔行的,而增强清晰度是逐行的。</p><h5 id="4-3高清晰度"><a href="#4-3高清晰度" class="headerlink" title="4.3高清晰度"></a>4.3高清晰度</h5><p>高清晰度(high-definition)视频通常定义为具有720逐行(720p)或1080隔行(1080i)有效扫描线的视频。固定像素(非CRT)、具有16:9宽高比的消费类显示器转换后的有效分辨率分别为1280 x 720p或1280 × 1080i</p><p>但是, HDTV显示器在技术上定义为能够显示最少720p或1080有效扫描线。它还必须能够用至少540逐行(540p)或810隔行(810i)有效扫描线来显示16:9的视频画面。这样,在制造具有4:3宽高比、基于CRT的HDTV和具有16 :9宽高比、分辨率为1024 x 1024p, 1280 x 768p, 1024×768p的LCD/等离子等显示器时,能够降低制造费用。</p><h4 id="五、音频与视频压缩"><a href="#五、音频与视频压缩" class="headerlink" title="五、音频与视频压缩"></a>五、音频与视频压缩</h4><p>近年来,数字电视、DVD播放机和摄像机、数字视频摄像机等消费类电子产品取得了一些最新进展,这归功于音频和视频压缩标准。这些压缩标准主要有:带有Dolbyo Digital的MEPG-2.DTS, MPEG-1或MPEG-2音频。</p><p>新的音频和视频编解码器,像MPEG-4 HE-AAC、 MPEG-4.10 (H.264)和SMPTE 421M (VC1),在保持同样质量时,提供了比以往编解码方法更高的压缩效率。这些进展使得可以使用新的见频发布方式(面向消费者和家庭内部)、新的消费产品(如便携视频播放器和移动视频移动电话)和更多的有线/星电视频道。</p><h4 id="六、应用框图"><a href="#六、应用框图" class="headerlink" title="六、应用框图"></a>六、应用框图</h4><p>下面几个简化的框图有助于我们认识视频流是如何经过各种相应处理的。</p><h5 id="6-1-DVD播放器"><a href="#6-1-DVD播放器" class="headerlink" title="6.1 DVD播放器"></a>6.1 DVD播放器</h5><p>图2-4为基本DVD播放机的简化框图,其中显示的是公共模块。如今所有这些模块都集成在廉价的芯片上了。<br><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E7%AE%80%E4%BB%8B/4.png" alt="4"></p><p>除了播放DVD (基于MPEG-2视频压缩技术)外, 目前, DVD播放器还有望处理MP3和WMA音频、MPEG-4视频(DivX视频)、 JPEG图像等。同时有望具有特定的播放模式,如以各科速度慢快进和快/慢退等。对DVD音频和SACD的支持也是很流行的。</p><p>DVD播放机的一个新增功能是能够接入到家庭网络中,用于播放一些存放于PC中的媒体(音乐、视频、图像等),这些“网络化的DVD播放机”也包括播放一些准备事后浏览的内容,如来源于因特网的电影和下载到内部硬盘(HDD)中的媒体。支持对各种闪存卡中的音频、视频和图像进行播放的这类需求也在不断增长。</p><p>有些DVD播放机制造商为了快速吸引买家的注意力,对视频的频率响应进行了超频处理,使得其产品看起来与众不同。但因为这种特性通常需要长时间的激励过程,所以很容易失败或需要调试。对于观看电影来讲,很多视频爱好者都认为频率响应应该尽可能平滑。</p><p>另一个问题是模拟视频信号的量化等级。尽管很容易产生每个精确的视频量化等级,但这些等级变化得相当快。目前有些评论也指出了这个问题,因为在信号源之间切换时可能会使发生变化的亮度或灰度值具有平均作用,从而使得用户进行的任何校正或手动调整失效。</p><h5 id="6-2-数字媒体适配器"><a href="#6-2-数字媒体适配器" class="headerlink" title="6.2 数字媒体适配器"></a>6.2 数字媒体适配器</h5><p>数字媒体适配器是连接到家庭网络、用于播放存放于PC或媒体存储器中的多媒体内容(音乐、视频、图像等)的设备。这些小而廉价的盒子使得媒体内容很容易在家庭中的任意或所有电视机上欣赏。许多数字媒体适配器支持无线网络功能,这就简化了数字媒体适配器的安装过程。</p><p>图2-5是基本的数字媒体适配器的简化框图,图中显示的是公共模块。如今所有这些模块都集成在一个廉价的芯片上了。</p><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E7%AE%80%E4%BB%8B/5.png" alt="5"></p><h5 id="6-3-数字电视机顶盒"><a href="#6-3-数字电视机顶盒" class="headerlink" title="6.3 数字电视机顶盒"></a>6.3 数字电视机顶盒</h5><p>数字电视标准可以分为7大类:</p><p>(1) ATSC (美国先进电视系统委员会)</p><p>(2) DVB (数字视频广播)</p><p>(3) ARIB (日本无线工业及商贸协会)</p><p>(4) IPTV (网络电视,包括基于P的DVB和ARIB)</p><p>(5)开放数字有线标准,如OpenCable标准</p><p>(6)带版权保护的数字有线标准</p><p>(7)带版权保护的数字卫星电视标准</p><p>起初这些机顶盒都是基于MPEG-2视频和DolbyoDigital或MPEG音频, 目前的机顶盒支持新的先进音视频标准,如MPEG-4 HE-AAC音频、Dolby Digital Plus音频、MPEG-4.10 (H.264)视频和SMPTE (VC-1)视频。</p><p>图2-6是数字电视机顶盒的简化结构图,图中显示的是公共音视频处理模块。数字机顶盒用于接收数字电视广播,这些数字电视广播可能来自地面台站(空中电波)、有线或卫星。在数字电视内部就可能包含这些电路。</p><p>目前的许多电视机顶盒有两个调谐器,并具有数字视频摄像(VCR)功能。这使得在浏览个内部HDD时,还可以往另一个内部HDD中读入节目。在数字电视接收机中,有了这两个调谐器,还可以支持PIP特性(即将2个输入影像输出到同一画面上)。</p><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E7%AE%80%E4%BB%8B/6.png" alt="6"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;尽管视频信号有很多类型和实现技术,但其目的只是为了实现视觉信息在不同位置之间的传送。这些视觉信息可能是来自于VCR, DVD播放器、本地广播的某个频道、有线电视,或者来自于卫星电视系统、因特网,还可能是其他各种渠道。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="视音频" scheme="http://www.faihung.net/categories/%E8%A7%86%E9%9F%B3%E9%A2%91/"/>
    
    
  </entry>
  
  <entry>
    <title>视音频-视频信号详解及测试-VGA</title>
    <link href="http://www.faihung.net/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95-VGA/"/>
    <id>http://www.faihung.net/2019/12/01/视音频-视频信号详解及测试-VGA/</id>
    <published>2019-12-01T04:11:15.000Z</published>
    <updated>2019-12-01T04:20:41.949Z</updated>
    
    <content type="html"><![CDATA[<h5 id="ARGB概述"><a href="#ARGB概述" class="headerlink" title="ARGB概述"></a>ARGB概述</h5><h6 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h6><p>生活中常用设备如个人电脑、视频游戏机和家庭影院等都具有视频输出，输出信号可分为模拟信号和数字信号。这主要讲述模拟视频信号（ARGB），即以VGA 物理接口传输的RGBHV 5 线信号。   VGA 接口也叫D-Sub接口</p><a id="more"></a><h6 id="VGA接口"><a href="#VGA接口" class="headerlink" title="VGA接口"></a>VGA接口</h6><p>VGA 即视频图形阵列，它是由IBM 在1987年随同PS/2 个人电脑而引入的一种图形控制器标准。</p><p>VGA物理接口是RGBHV 5 线信号，使用的是<br>700mV模拟R/G/B视频电平和TTL电平H/V同步信<br>号。</p><p>VGA物理接口一直被广泛地使用着，它为后来的图形控制器信号而保留。尽管通常把它称为“VGA 端口”，但是在今天15 针的RGBHV 输出端口中，所传送的分辨率和彩色位深的显示格式常常超出了6 4 0 × 4 8 0 VGA 标准。</p><h6 id="VGA接口定义"><a href="#VGA接口定义" class="headerlink" title="VGA接口定义"></a>VGA接口定义</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95-VGA/1.jpg" alt="image"></p><h6 id="常见ARGB接口"><a href="#常见ARGB接口" class="headerlink" title="常见ARGB接口"></a>常见ARGB接口</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95-VGA/2.png" alt="image"><br><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95-VGA/3.png" alt="image"><br><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95-VGA/4.png" alt="image"><br><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95-VGA/5.png" alt="image"></p><h6 id="支持的模拟信号分辨率"><a href="#支持的模拟信号分辨率" class="headerlink" title="支持的模拟信号分辨率"></a>支持的模拟信号分辨率</h6><p>可支持各种通用的模拟RGBHV 信号分辨率，从640×480p到2048×1536p，<br>屏幕刷新速率从60Hz 直至100Hz。</p><h5 id="ARGB信号传输（模拟信号的传输）"><a href="#ARGB信号传输（模拟信号的传输）" class="headerlink" title="ARGB信号传输（模拟信号的传输）"></a>ARGB信号传输（模拟信号的传输）</h5><p>工程中构建一个VGA信号传输、分配系统时，长距离传输是一个常见问题。 由于信号传输距离较远，传输系统的参数及周围电磁环境对信号质量产生的影响不容忽视，常见到的现象表现为：图像模糊、变暗、 拖尾和重影，以及图像显示不稳定（如：跳动或黑屏等）等。</p><p>以上现象产生的原因不同，解决的方法不同。我们将其分为四大类：</p><p>一、由于传输系统的幅频特性及群延时特性造成的图像模糊、变暗、拖尾；</p><p>二、由于设备产生自激或环境电磁干扰产生的高频干扰；</p><p>三、由于系统电源地线处理不当造成的低频干扰；</p><p>四、由于设备、传输系统或接插件等阻抗不匹配而引起的重影反射及显示不稳定. </p><p>随着工程规模的扩大，VGA信号长距离（大于100米）和超长距离（大于500米）的应用不断出现，单纯靠电缆的传输方式明显不适应使用的要求，随着技术的发展，不断有新的传输方式出现，使这类应用成为可能。 以下为目前可实用的传输方式： </p><p>模拟电缆（RGB电缆）加电缆均衡器 </p><p>网线加均衡器 </p><p>光纤传输 </p><p>在此前提下，根据不同的距离，可采用不同的传输方式：（一般建议）</p><p>50米以内：好的VGA电缆；</p><p>50~100米，电缆加EQ；</p><p>100~200米，网线加EQ（或有抗干扰等需求）；</p><p>200米以上，光纤传输。</p><h5 id="VESA介绍-视频电子标准协会"><a href="#VESA介绍-视频电子标准协会" class="headerlink" title="VESA介绍(视频电子标准协会)"></a>VESA介绍(视频电子标准协会)</h5><p>随着VGA接口的信号传输速率愈来愈高，视频电子标准协会<br>（Video Electronics Standards Association）认识到，接口性能问题则显得更加重要。VESA 于1999 年发布了不具约束力的标准，其目标是更严格地定义RGBHV接口的传输参数。该标准称为视频信号标准，即VSIS（Video Signal standard），它为RGBHV信号的大多数重要参数提供了推荐值。</p><h5 id="ARGB信号特征"><a href="#ARGB信号特征" class="headerlink" title="ARGB信号特征"></a>ARGB信号特征</h5><p>800X600@60Hz为例：<br><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95-VGA/6.png" alt="image"></p><p>VESA Monitor Timing Standard</p><pre><code>Hor Pixels = 800; // PixelsVer Pixels = 600; // LinesHor Frequency = 37.879; // KHz = 26.4 usec /lineVer Frequency = 60.317; // Hz = 16.6 msec /framePixel Clock = 40.0; // MHz = 25.0 nsec    +/-0.05%Scan Type = NONINTERLACED; Hor Sync Polarity = POSITIVE; // HBlank = 24.2% of HTotalVer Sync Polarity = POSITIVE; // VBlank = 4.5% of VTotalHor Total Time = 26.4; // (usec) =1056 PixelsHor Addr Time = 20.0; // (usec) = 800 PixelsHor Blank Start = 20.0; // (usec) = 800 PixelsHor Blank Time = 6.4; // (usec) = 256 PixelsHor Sync Start = 21; // (usec) = 840 PixelsH Right Border = 0.000; // (usec) = 0 PixelsH Front Porch = 1.0; // (usec) = 40 PixelsHor Sync Time = 3.2; // (usec) = 128 PixelsH Back Porch = 2.2; // (usec) = 88 PixelsH Left Border = 0.000; // (usec) = 0 PixelsVer Total Time = 16.579; // (msec) = 628 lines Ver Addr Time  = 15.84; // (msec) = 600 linesVer Blank Start = 15.84; // (msec) = 600 linesVer Blank Time = 0.739; // (msec) = 28 linesVer Sync Start = 15. 866; // (msec) = 601 linesV Bottom Border = 0.000; // (msec) = 0 linesV Front Porch = 0.026; // (msec) = 1 linesVer Sync Time  = 0.106; // (msec) = 4 linesV Back Porch = 0.607; // (msec) = 23 lines V Top Border = 0.000; // (msec) = 0 lines</code></pre><h5 id="VESA测试内容"><a href="#VESA测试内容" class="headerlink" title="VESA测试内容"></a>VESA测试内容</h5><p>在2002年VESA 对VSIS 作了补充，增加了测试规范部分。测试规范的名称简称为“测试规范－模拟显示器件图形子系统的评估”，每项测试均给出了测试需要的设备、测试图案、测试步骤和必要的分析。</p><p>如果您打算执行 VSIS 测试，那么“测试规范－模拟显示器件图形子系统的评估”，是一个重要文件。这个文件有助于理解VSIS规范及其意义。</p><p>可以通过VESA得到VSIS文件及其相应的测试规程。这两个文件为评测VGA接口性能提供了一种有效的方法。</p><h6 id="信号测试项目"><a href="#信号测试项目" class="headerlink" title="信号测试项目"></a>信号测试项目</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95-VGA/7.png" alt="image"></p><h6 id="信号测试环境"><a href="#信号测试环境" class="headerlink" title="信号测试环境"></a>信号测试环境</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95-VGA/8.png" alt="image"><br>H/V负载电阻：2.2K 电阻，R/G/B负载电阻： 75 欧电阻</p><p>注：电阻精密度为0.1%。</p><h6 id="测试图"><a href="#测试图" class="headerlink" title="测试图"></a>测试图</h6><p>推荐使用三种静态测试图案用于VSIS测量。利用这三种测试图案激励DUT以产生RGVHV信号。图案如：<br><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95-VGA/9.png" alt="image"></p><p>一种称为“垂直栅格”的黑白垂直条纹交替图案，由 RGB ＝ FFh 的100 个像素和随后的RGB ＝ 00h 的100个像素组成并重复这一组合。这种栅格图案用于<br>RGB 视频幅度和瞬态响应测量。</p><ul><li>视频最大/最小亮度电压值</li><li>视频信号上升/下降时间</li><li>视频稳定建立时间</li><li>视频信号过冲/下冲</li><li>视频通道间时延</li></ul><p>水平显示的、从全黑到全白的灰度渐变斜坡或台阶信号。斜坡信号用于RGB线性和通道间失配测量。</p><ul><li>视频积分线性误差</li><li>视频微分线性误差</li><li>视频通道间失配</li></ul><p>全白平场信号或窗口信号，用于RGB视频噪声测量。</p><ul><li>视频噪声注入比</li></ul><h6 id="同步测量"><a href="#同步测量" class="headerlink" title="同步测量"></a>同步测量</h6><p>H 同步抖动</p><p>行同步功能是用来正确地规定每一图像显示行的位置。在理想情况下，从一个H同步脉冲到下一个H同步脉冲的时间应当是恒定的。如果H同步定时发生变化，那么在一帧中的图像部分就会发生水平位移。这种同步定时的变化称为抖动。对于一些重要的内容，漂移0.02％的图像宽度就会被察觉。</p><p>VSIS规定H同步抖动的最大峰峰值为像素周期的30％。这就是说，对于800×600格式，H 同步抖动的最大峰峰值为图像宽度的0.038％，而对于2048 × 1536 格式，其值为图像宽度的0.015％。</p><p>H 和V 定时</p><p>H定时和V定时测量是将同步位置与有源RGB视频进行比较，从而有助于确定显示器能否正确居中以及是否有正确的可寻址行数。</p><p>如果1024 × 768 屏幕格式的V 定时结果只有764显示行是因为上方和下方的边界不正确。这样上方2行和下方2行的任何信息将会被丢失。</p><p>H同步和V同步是测量同步脉冲的幅度、脉冲保真度和同步定时。如果这些测量参数超出容限，那么显示器的锁定可能是不可靠的。</p><h6 id="视频测量"><a href="#视频测量" class="headerlink" title="视频测量"></a>视频测量</h6><p>视频测量是用来评测模拟RGB信号的特性，包括电平、瞬变特性和噪声等。假定同步正确，那么RGB 视频特性将决定显示器的保真度。</p><p>这些测量可以划分为：<br>亮度电平、通道间失配、视频瞬变、线性、通道间畸变和噪声抑制比。</p><p><strong>亮度电平</strong></p><p>亮度电平测量用来测定DUT输出全白（其值为FFh）和黑图像信号 (其值为00h) 时的RGB 电压电平值。就理想状况而言，白电平应是700mV 而黑电平应是0mV。这些数值是绝对测量值，是以RGB信号的返回线 (接地端) 作为参考。</p><p>适当的电平对于显示器的正确亮度和对比度是重要的。</p><p><strong>通道间的失配</strong></p><p>通道间的失配用来比较RGB通道间的幅度匹配状况。测试是在黑(00h) 白 (FFh) 之间32个等间距的电平上进行的，使用的是阶梯波测试信号。对于阶梯波中的每一个台阶，均相对于该通道的行后肩电平以测量RGB电压。然后来比较通道间的电压（G&amp;B…）。</p><p>即使不考虑VSIS的规定，通道间失配的允许程度与应用也是密切相关的。通道间的失配会影响到重现的环境亮度、重现的亮度和对比度设置等</p><p><strong>视频瞬变特性</strong></p><p>视频瞬变特性是用来评估RGB通道中黑白电平跳变时的保真度。这项测量使用的是垂直栅格测试图案，由黑到白的过渡时间是一个像素的时间。每个通道均按10％至90％白电平幅度测量上升时间和下降时间、过冲(正向跳变) 、下冲(负向跳变) 和恢复稳定所需时间(settling time)。</p><p><strong>视频瞬变</strong></p><p>对于具有精密细节或锐利边界变化的任一图像而言，良好的过渡响应是非常重要的。例如，如果上升时间或下降时间过于缓慢，将会使图像的变化模糊而不清晰。过度的振铃会使图像素材在跳变之后出现亮/暗交替变化的现象。过冲和下冲是较为次要的问题，除非过渡到稳定建立需要很长的时间。事实上，某些过冲/ 下冲可能会增强图像信号跳变清晰度的感觉，许多显示器件有意地引入受控的预冲和过冲。</p><p><strong>线性</strong></p><p>线性是用来检查DUT在黑白之间的变化特性。在理想情况下，如果斜率恒定的黑白之间的斜坡测试信号加在DUT的输入端，其输出也应当是斜率恒定的斜坡。一般而言，DUT的输出斜坡会给出某种斜率的变化。这种变化表示出现了线性误差。</p><p>线性对于再现正确的灰度级别是重要的。如果单个RGB通道之间的线性差比较大，那么黑白之间的灰度级图案可能会在某些位置出现轻微的彩色。</p><p>VSIS定义了两种类型的线性测试方法。</p><p>第一种方法是积分非线性(INL)，它可以检查黑色和某些其它点之间的整个斜率误差。</p><p>第二种方法是微分非线性 (DNL)，它用来评测两个相邻点之间的斜率误差。</p><p>测试信号使用的一种黑白斜坡信号实际上是一连串的台阶信号。如果系统使用10比特系统就有1024 级台阶。</p><p><strong>噪声抑制比</strong></p><p>这是一项单个RGB通道中的噪声测量。VSIS规定峰至峰噪声测量是在白色图案上进行的，带宽在500MHz以上。峰至峰噪声值不应超过白色电压的5％。</p><p>VSIS规定在2秒的测量间隔内使用100000个噪声样值。</p><h5 id="什么参数对用户最重要？"><a href="#什么参数对用户最重要？" class="headerlink" title="什么参数对用户最重要？"></a>什么参数对用户最重要？</h5><p>如果互操作性－即信源在多种显示器件中均能正常工作－是最重要的，那么应当关注H和V同步测量、RGB亮度电平测量以及彩条测量。这些参数有助于建立正确的同步、正确的白/黑电平，并能使所有的RGB信号有效。</p><p>对于同步测量，特别要重视以下信号损伤：</p><ul><li>不正确的极性</li><li>频率错误</li><li>过度的过冲/ 下冲(特别是当偏离进入到0.5V 至2.4V范围时)</li><li>非单调性地上升或下降</li></ul><p>如果显示系统的灰度级性能非常重要（例如诸如彩色匹配之类的应用），那么就应当特别关注通道间的失配、线性以及RGB亮度电平测量。</p><p>通道间的失配测量将提供整个视频范围内各个通道相互间的跟踪是否接近的信息。</p><p>线性测量提供了每个通道中黑白电平转换的有关信息。</p><p>RGB亮度电平测量为整个700mV视频范围是否得到充分使用而提供了验证，因为这对于图像的对比度是否合适是很重要的。</p><p>对于图像绘制应用，例如PC视频应用，应当注重噪声、瞬态响应、RGB 亮度电平、通道间的匹配（包括通道间的幅度匹配和时间对准）以及H同步抖动等项目的测量，这对图像绘制应用是十分有利的。</p><p>需要注意的是，VSIS 测试没有检测运动相关图像的失真。但是，如果图像的随机噪声和抖动都很小，一般说来，尽管压缩也只会产生较低的失真。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;ARGB概述&quot;&gt;&lt;a href=&quot;#ARGB概述&quot; class=&quot;headerlink&quot; title=&quot;ARGB概述&quot;&gt;&lt;/a&gt;ARGB概述&lt;/h5&gt;&lt;h6 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h6&gt;&lt;p&gt;生活中常用设备如个人电脑、视频游戏机和家庭影院等都具有视频输出，输出信号可分为模拟信号和数字信号。这主要讲述模拟视频信号（ARGB），即以VGA 物理接口传输的RGBHV 5 线信号。   VGA 接口也叫D-Sub接口&lt;/p&gt;
    
    </summary>
    
    
      <category term="视音频" scheme="http://www.faihung.net/categories/%E8%A7%86%E9%9F%B3%E9%A2%91/"/>
    
    
      <category term="视频信号" scheme="http://www.faihung.net/tags/%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7/"/>
    
      <category term="VESA" scheme="http://www.faihung.net/tags/VESA/"/>
    
      <category term="ARGB" scheme="http://www.faihung.net/tags/ARGB/"/>
    
      <category term="VSIS" scheme="http://www.faihung.net/tags/VSIS/"/>
    
      <category term="VGA" scheme="http://www.faihung.net/tags/VGA/"/>
    
  </entry>
  
  <entry>
    <title>视音频-常用视频信号配图介绍</title>
    <link href="http://www.faihung.net/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/"/>
    <id>http://www.faihung.net/2019/12/01/视音频-常用视频信号配图介绍/</id>
    <published>2019-11-30T16:18:49.000Z</published>
    <updated>2019-11-30T16:28:59.942Z</updated>
    
    <content type="html"><![CDATA[<h5 id="常用视频信号介绍"><a href="#常用视频信号介绍" class="headerlink" title="常用视频信号介绍"></a>常用视频信号介绍</h5><a id="more"></a><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/1.png" alt="image">)<img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/2.png" alt="image">)<img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/3.png" alt="image"></p><p>这里主要介绍可能用到的测试视频信号。<br>一般来讲，客户经常会用到灰阶、彩条这些测试信号，来测试画面显示是否正常。<br>例如每一阶能不能正常显示，过渡是否自然。<br>Color bar显示有没有偏色，Y/C 分离处理得好不好。<br>下面的资料可以参考一下。</p><h5 id="测试信号的类别"><a href="#测试信号的类别" class="headerlink" title="测试信号的类别"></a>测试信号的类别</h5><p>Gray Scale &amp; Levels (灰度和灰阶)</p><p>Geometry &amp; Convergence(几何特性和会聚)</p><p>Letterbox Geometry(4:3显示比例下的几何特性)</p><p>Wide Screen Enhanced(16:9显示比例显示特性)</p><p>Resolution(解析度)</p><p>Color Adjustment(色彩调整)</p><p>Special Test(包括Y/C delay,color decoder等)</p><h5 id="几种典型视频信号"><a href="#几种典型视频信号" class="headerlink" title="几种典型视频信号"></a>几种典型视频信号</h5><h6 id="Vertical-10-IRE-steps-灰阶信号）"><a href="#Vertical-10-IRE-steps-灰阶信号）" class="headerlink" title="Vertical 10 IRE steps(灰阶信号）"></a>Vertical 10 IRE steps(灰阶信号）</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/4.png" alt="image"></p><p>由左到右亮度值分别为100(white),90,80,70,60,50,40,30,20,10,7.5 IRE(black)</p><p>观察重点</p><p>1)每阶都能正常显示</p><p>2)阶与阶之间层次分明,宽度相同</p><p>3)从一阶到另一阶之间不应该有颜色变化</p><h6 id="Cross-Hatch"><a href="#Cross-Hatch" class="headerlink" title="Cross Hatch"></a>Cross Hatch</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/5.png" alt="image"></p><p>主要用来设置显示的尺寸,几何特性和会聚</p><p>这个画面由大小相同的水平和垂直的直线组成</p><p>正常的情况下,所有的方格应该大小相同,没有扭曲</p><p>边缘的标记用来设置显示的尺寸和中心</p><h6 id="MultiBurst-with-label"><a href="#MultiBurst-with-label" class="headerlink" title="MultiBurst with label"></a>MultiBurst with label</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/6.png" alt="image"></p><p>主要用来检查频率响应和设置Sharpness</p><p>该画面由几组频率相同的信号组成(其中3.58MHz是NTSC色负载波的频率,4.18MHz是广播频率的上限).上半部分的背景是50%的亮度,正常情况下下半部分的亮度<br>和信号的亮度相同</p><p>Sharpness设置合适时,所有的信号应该有相同的亮度,且没有边缘锐化的现象</p><h6 id="Resolution-200-TVL"><a href="#Resolution-200-TVL" class="headerlink" title="Resolution 200 TVL"></a>Resolution 200 TVL</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/7.png" alt="image"></p><p>用来测量水平和垂直方向的解析度,水平方向的解析度测量范围是200-540 TV line,垂直方向的解析度是200-480TV line.</p><p>周围的四个圆圈的频率分别是3.0,3.58,4.18和6.75MHz,可以作为解析度测试的补充</p><h6 id="Sharpness"><a href="#Sharpness" class="headerlink" title="Sharpness"></a>Sharpness</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/8.png" alt="image"></p><p>用来调整Sharpness和Vertical aperture</p><p>该画面由四部分组成</p><p>1)水平方向的信号用来设置频率响应</p><p>2)垂直方向的信号用来设置vertical aperture</p><p>3)其中的线和曲线用来侦测边缘的缺陷</p><p>4)垂直和水平的线段用来侦测模糊现象</p><h6 id="75-Split-Color-Bars"><a href="#75-Split-Color-Bars" class="headerlink" title="75% Split Color Bars"></a>75% Split Color Bars</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/9.png" alt="image"></p><p>主要用来校正色彩和色调</p><p>校正方法:</p><p>1)使灰阶信号和蓝色信号对齐来设置色度(理论上来讲,只要蓝色成分得到正确的校正,其他颜色应该可以正常的显示,因为蓝色成分经历了最多的编码)</p><p>2)使洋红和青色对准来调整色调</p><p>Note: 75% color bars接近广播信号中色彩显示的上限且满足FCC信号接口标准,所以经常被用来校正显示</p><h6 id="Y-C-Delay"><a href="#Y-C-Delay" class="headerlink" title="Y/C Delay"></a>Y/C Delay</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/10.png" alt="image"></p><p>用来测量Y/C Delay error</p><p>左边的部分用来测量Y/C Delay error;右边的部分用来观察是否存在Y/C delay error.正常情况下,红色竖条边缘应该没有扭曲</p><p>Y/C delay正常的情况下,R,G,B方块应与其对应的灰色方块在0度时对齐</p><h6 id="Color-Decoder"><a href="#Color-Decoder" class="headerlink" title="Color Decoder"></a>Color Decoder</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/11.png" alt="image"></p><p>用来测量RGB解码的准确度</p><p>该画面包含77 IRE的灰色背景和色度范围从+25%到-25%的R,G,B色块</p><p>测量时,需要只打开R,G,B中的一种颜色,然后看在0%位置,该颜色是否与其对应的背景颜色是否一致</p><h6 id="Overscan"><a href="#Overscan" class="headerlink" title="Overscan"></a>Overscan</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/12.png" alt="image"></p><p>用来测量屏幕隐藏的部分的百分比,也可以用来调整显示的区域和使屏幕置中</p><p>边缘的数字表示当前显示隐藏的图象的百分比.品质比较好的显示最多允许存在3%到5%隐藏比例</p><p>另外可以用该画面来调整水平和垂直的位置,使上下左右有同样的隐藏比例,从而保证画面位于屏幕的中央</p><h6 id="Gamma"><a href="#Gamma" class="headerlink" title="Gamma"></a>Gamma</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/13.png" alt="image"></p><p>用来测量显示设备的gamma值</p><p>该画面由六组标有gamma值的灰色方块组成</p><p>测量时,找出与背景颜色最接近的方块,该方块的数值就是显示设备的gamma值</p><h6 id="Center-Cross"><a href="#Center-Cross" class="headerlink" title="Center Cross"></a>Center Cross</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/14.png" alt="image"></p><p>主要用来设置R,G,B CRT电子枪的静会聚(static convergence).</p><p>十字线周围的短线指明了显示的安全区域,显示的区域至少应该短线包含的范围内</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;常用视频信号介绍&quot;&gt;&lt;a href=&quot;#常用视频信号介绍&quot; class=&quot;headerlink&quot; title=&quot;常用视频信号介绍&quot;&gt;&lt;/a&gt;常用视频信号介绍&lt;/h5&gt;
    
    </summary>
    
    
      <category term="视音频" scheme="http://www.faihung.net/categories/%E8%A7%86%E9%9F%B3%E9%A2%91/"/>
    
    
      <category term="视频信号" scheme="http://www.faihung.net/tags/%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>视音频中ES PS TS 等流的区别</title>
    <link href="http://www.faihung.net/2019/11/25/%E8%A7%86%E9%9F%B3%E9%A2%91%E4%B8%ADES-PS-TS-%E7%AD%89%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.faihung.net/2019/11/25/视音频中ES-PS-TS-等流的区别/</id>
    <published>2019-11-24T16:11:55.000Z</published>
    <updated>2019-11-30T15:11:08.167Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h4><h5 id="1-ES"><a href="#1-ES" class="headerlink" title="1. ES"></a>1. ES</h5><p>ES–Elementary  Streams  (原始流)是直接从编码器出来的数据流，可以是编码过的视频数据流（H.264,MJPEG等），音频数据流（AAC），或其他编码数据流的统称。ES流经过PES打包器之后，被转换成PES包。</p><a id="more"></a><p>ES是只包含一种内容的数据流，如只含视频或只含音频等，打包之后的PES也是只含一种性质的ES,如只含视频ES的PES,只含音频ES的PES等。每个ES都由若干个存取单元（AU）组成，每个视频AU或音频AU都是由头部和编码数据两部分组成，1个AU相当于编码的1幅视频图像或1个音频帧，也可以说，每个AU实际上是编码数据流的显示单元，即相当于解码的1幅视频图像或1个音频帧的取样。</p><h5 id="2-PES"><a href="#2-PES" class="headerlink" title="2. PES"></a>2. PES</h5><p>PES–Packetized  Elementary Streams  (分组的ES)，ES形成的分组称为PES分组，是用来传递ES的一种数据结构。PES流是ES流经过PES打包器处理后形成的数据流，在这个过程中完成了将ES流分组、打包、加入包头信息等操作（对ES流的第一次打包）。PES流的基本单位是PES包。PES包由包头和payload组成。</p><h5 id="3-PTS、DTS"><a href="#3-PTS、DTS" class="headerlink" title="3. PTS、DTS"></a>3. PTS、DTS</h5><p>PTS–PresentationTime Stamp（显示时间标记）表示显示单元出现在系统目标解码器（H.264、MJPEG等）的时间。</p><p>DTS–Decoding Time Stamp（解码时间标记）表示将存取单元全部字节从解码缓存器移走的时间。</p><p>PTS/DTS是打在PES包的包头里面的，这两个参数是解决音视频同步显示，防止解码器输入缓存上溢或下溢的关键。每一个I（关键帧）、P（预测帧）、B（双向预测 帧）帧的包头都有一个PTS和DTS，但PTS与DTS对于B帧不一样，无需标出B帧的DTS，对于I帧和P帧，显示前一定要存储于视频解码器的重新排序缓存器中，经过延迟（重新排序）后再显示，所以一定要分别标明PTS和DTS。</p><h5 id="4-PS"><a href="#4-PS" class="headerlink" title="4. PS"></a>4. PS</h5><p>PS–Program Stream(节目流)PS流由PS包组成，而一个PS包又由若干个PES包组成（到这里，ES经过了两层的封装）。PS包的包头中包含了同步信息与时钟恢复信息。一个PS包最多可包含具有同一时钟基准的16个视频PES包和32个音频PES包。</p><h5 id="5-TS"><a href="#5-TS" class="headerlink" title="5. TS"></a>5. TS</h5><p>TS–Transport Stream（传输流）由定长的TS包组成（188字节），而TS包是对PES包的一个重新封装（到这里，ES也经过了两层的封装）。PES包的包头信息依然存在于TS包中。</p><h5 id="6-TS流与PS流的区别"><a href="#6-TS流与PS流的区别" class="headerlink" title="6. TS流与PS流的区别"></a>6. TS流与PS流的区别</h5><p>TS流与PS流的区别在于TS流的包结构是固定长度的,而PS流的包结构是可变长度的。PS包由于长度是变化的,一旦丢失某一PS包的同步信息,接收机就会进入失步状态,从而导致严重的信息丢失事件。而TS码流由于采用了固定长度的包结构,当传输误码破坏了某一TS包的同步信息时,接收机可在固定的位置检测它后面包中的同步信息,从而恢复同步,避免了信息丢失。因此在信道环境较为恶劣、传输误码较高时一般采用TS码流,而在信环境较好、传输误码较低时一般采用PS码流。</p><h5 id="7-TS单一码流、混合码流"><a href="#7-TS单一码流、混合码流" class="headerlink" title="7.TS单一码流、混合码流"></a>7.TS单一码流、混合码流</h5><p>单一性：TS流的基本组成单位是长度为188字节的TS包。</p><p>混合性： TS流由多种数据组合而成，一个TS包中的数据可以是视频数据，音频数据，填充数据，PSI/SI表格数据等（唯一的PID对应）。</p><h5 id="8-封装"><a href="#8-封装" class="headerlink" title="8. 封装"></a>8. 封装</h5><p>封装，就是捆绑打包, 将画面视频文件和音轨文件打包在一起,并按照一定规则建立排序和索引, 便于播放器或播放软件来索引播放. 包括AVI / PS(Program Stream)/ TS（Transport Stream）/ MKV（Matroska）等.</p><h4 id="二、基本流程"><a href="#二、基本流程" class="headerlink" title="二、基本流程"></a>二、基本流程</h4><p><img src="/2019/11/25/%E8%A7%86%E9%9F%B3%E9%A2%91%E4%B8%ADES-PS-TS-%E7%AD%89%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB/1.jpg" alt="1"></p><ol><li>A/D转换后，通过MPEG-2压缩编码得到的ES基本流。这个数据流很大，并且只是I，P，B的这些视频帧或音频取样信息</li><li>通过PES打包器，打包并在每个帧中插入 PTS/DTS标志，变成PES。原来是流的格式，现在成了数据包的分割形式。</li><li>PES根据需要打包成PS或TS包进行存储（DVD）或传输(DVB)。因每路音/视频只包含一路的编码数据流，所以每路PES也只包含相应的数据流。</li></ol><p><img src="/2019/11/25/%E8%A7%86%E9%9F%B3%E9%A2%91%E4%B8%ADES-PS-TS-%E7%AD%89%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB/2.jpg" alt="2"></p><h4 id="三、推理过程"><a href="#三、推理过程" class="headerlink" title="三、推理过程"></a>三、推理过程</h4><h5 id="3-1-TS流的解码过程：ES-PES-DTS-PTS-PCR"><a href="#3-1-TS流的解码过程：ES-PES-DTS-PTS-PCR" class="headerlink" title="3.1 TS流的解码过程：ES-PES-DTS-PTS-PCR"></a>3.1 TS流的解码过程：ES-PES-DTS-PTS-PCR</h5><ol><li>获取TS中的PAT</li><li>获取TS中的PMT</li><li>根据PMT可以知道当前网络中传输的视频（音频）类型（H264），相应的PID，PCR的PID等信息。</li><li>设置demux 模块的视频Filter 为相应视频的PID和stream type等。</li><li>从视频Demux Filter 后得到的TS数据包中的payload 数据就是 one piece of PES，在TS header中有一些关于此 payload属于哪个PES的第多少个数据包。 因此软件中应该将此payload中的数据copy到PES的buffer中，用于拼接一个PES包。</li><li>拼接好的PES包的包头会有PTS，DTS信息，去掉PES的header就是ES。</li><li>直接将被拔掉PES包头的ES包送给decoder就可以进行解码。解码出来的数据就是一帧一帧的视频数据，这些数据至少应当与PES中的PTS关联一下，以便进行视音频同步。</li><li>I，B，B，P 信息是在ES中的。</li></ol><h5 id="3-2-具体描述"><a href="#3-2-具体描述" class="headerlink" title="3.2 具体描述"></a>3.2 具体描述</h5><p>ES 是直接从编码器出来的数据流，可以是编码过的视频数据流，音频数据流，或其他编码数据流的统称。 ES 流经过 PES 打包器之后，被转换成 PES 包。 PES 包由包头和 payload 组成。</p><p>在 PES 层，主要是在 PES 包头信息中加入 PTS( 显示时间标签 ) 和 DTS （解码时间标签）用于视频、音频同步。 其实， Mpeg-2 用于视音频同步以及系统时钟恢复的时间标签分别在 ES ， PES 和 TS 这 3 个层次中。</p><p>在 ES 层，与同步有关的主要是视频缓冲验证 VBV （ Video Buffer Verifier ），用以防止解码器的缓冲器出现上溢或下溢；在 PES 层，主要是在 PES 头信息里出现的显示时间标签 PTS （ Presentation Time Stamp ）和解码时间标签 DTS （ Decoding Time Stamp ）；</p><p>在 TS 层中， TS 头信息包含了节目时钟参考 PCR （ Program Clock Reference ），用于恢复出与编码端一致的系统时序时钟 STC （ System Time Clock ）。</p><p>基本流程如下：</p><p>首先 MPEG-2 压缩编码得到的 ES 基本流，这个数据流很大，并且只是 I ， P ， B 的这些视频帧或音频取样信息， 然后加入一些同步信息，打包成长度可变长度的数据包 PES ，原来是流的格式，现在成了数据包的分割形式。</p><p>同时要注意的是， ES 是只包含一种内容的数据流，如只含视频，或只含音频等，打包之后的 PES 也是只含一种性质的 ES, 如只含视频 ES 的 PES, 只含音频 ES 的 PES 等。</p><p>可以知道， ES 是编码视频数据流或音频数据流，每个 ES 都由若干个存取单元（ AU ）组成，每个视频 AU 或音频 AU 都是由头部和编码数据两部分组成， 1 个 AU 相当于编码的 1 幅视频图像或 1 个音频帧，也可以说，每个 AU 实际上是编码数据流的显示单元，即相当于解码的 1 幅视频图像或 1 个音频帧的取样。 </p><p>PEG-2 对视频的压缩产生 I 帧、 P 帧、 B 帧。把帧顺序 I1,P4,B2,B3,P7,B5,B6 帧的编码 ES ，通过打包并在每个帧中插入 PTS/DTS 标志，变成 PES 。</p><p>在插入 PTS/DTS 标志时，由于在 B 帧 PTS 和 DTS 相等，所以无须在 B 帧多插入 DTS 。</p><p>而对于 I 帧 和 P 帧，由于经过复用后数据包的顺序会发生变化，显示前一定要存储于视频解码器的从新排序缓存器中，经过从新排序后再显示，所以一定要同时插入 PTS 和 DTS 作为从新排序的依据。</p><p>其中，有否 PTS/DTS 标志，是解决视音频同步显示、防止解码器输入缓存器上溢或下溢的关键所在。 </p><p>PTS 表明显示单元出现在系统目标解码器（ STD- System Target Decoder ）的时间 , DTS 表明将存取单元全部字节从 STD 的 ES 解码缓存器移走的时刻。</p><p>视频编码图像帧次序为 I1,P4,B2,B3,P7,B5,B6,I10,B8,B9 的 ES ，加入 PTS/DTS 后，打包成一个个视频 PES 包。</p><p>每个 PES 包都有一个包头，用于定义 PES 内的数据内容，提供定时资料。</p><p>每个 I 、 P 、 B帧的包头都有一个 PTS 和 DTS ，但 PTS 与 DTS 对 B 帧都是一样的，无须标出 B 帧的 DTS 。</p><p>对 I 帧和 P 帧，显示前一定要存储于视频解码器的重新排序缓存器中，经过延迟（重新排序）后再显示，一定要分别标明 PTS 和 DTS 。</p><p>例如，解码器输入的图像帧次序为 I1,P4,B2,B3,P7,B5,B6,I10,B8,B9 ，依解码器输出的帧次序，应该 P4 比 B2 、 B3 在先，但显示时 P4 一定要比 B2 、 B3 在后，即 P4 要在提前插入数据流中的时间标志指引下，经过缓存器重新排序，以重建编码前视频帧次序 I1,B2,B3,P4,B5,B6,P7,B8,B9,I10 。</p><p>显然， PTS/DTS 标志表明对确定事件或确定信息解码的专用时标的存在，依靠专用时标解码器，可知道该确定事件或确定信息开始解码或显示的时刻。</p><p>例如， PTS/DTS 标志可用于确定编码、多路复用、解码、重建的时间。</p><p>PCR<br>PCR 是 TS 里面的，即 TS packet 的 header 里面可能会有，他用来指定所期望的该 ts packet 到达 decoder 的时间，他的作用于 SCR 类似。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、基本概念&quot;&gt;&lt;a href=&quot;#一、基本概念&quot; class=&quot;headerlink&quot; title=&quot;一、基本概念&quot;&gt;&lt;/a&gt;一、基本概念&lt;/h4&gt;&lt;h5 id=&quot;1-ES&quot;&gt;&lt;a href=&quot;#1-ES&quot; class=&quot;headerlink&quot; title=&quot;1. ES&quot;&gt;&lt;/a&gt;1. ES&lt;/h5&gt;&lt;p&gt;ES–Elementary  Streams  (原始流)是直接从编码器出来的数据流，可以是编码过的视频数据流（H.264,MJPEG等），音频数据流（AAC），或其他编码数据流的统称。ES流经过PES打包器之后，被转换成PES包。&lt;/p&gt;
    
    </summary>
    
    
      <category term="视音频" scheme="http://www.faihung.net/categories/%E8%A7%86%E9%9F%B3%E9%A2%91/"/>
    
    
      <category term="AVFormat" scheme="http://www.faihung.net/tags/AVFormat/"/>
    
      <category term="ES" scheme="http://www.faihung.net/tags/ES/"/>
    
      <category term="PS" scheme="http://www.faihung.net/tags/PS/"/>
    
      <category term="TS" scheme="http://www.faihung.net/tags/TS/"/>
    
  </entry>
  
  <entry>
    <title>Video Timing 解释说明</title>
    <link href="http://www.faihung.net/2019/11/24/Video-Timing-%E8%A7%A3%E9%87%8A%E8%AF%B4%E6%98%8E/"/>
    <id>http://www.faihung.net/2019/11/24/Video-Timing-解释说明/</id>
    <published>2019-11-24T15:25:24.000Z</published>
    <updated>2019-11-24T15:36:09.647Z</updated>
    
    <content type="html"><![CDATA[<h6 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h6><p>大家应该都知道，视频看起来是持续动态的，但是实际上是由一系列的静态画面，在很短的时间内更替,在人眼上就产生视觉残留，以至于你的眼睛感觉是动态画面。大家看到的视频中大多数是每秒闪过50-60幅画面，对于电脑画面大概是每秒闪过70-80幅画面。</p><a id="more"></a><p>要说timing是什么，先说下一般的图像是怎么显示在屏幕上的。</p><p>视频源发出的一幅幅的画面，送到屏幕后，屏幕将每一幅画面从上到下逐行的扫描每个像素显示在屏幕上，不间断的重复，直到一段视频数据结束。</p><p>而视频数据是连续的，怎么就知道哪段数据是显示一个画面？</p><p>怎么知道一个画面中哪一段数据又是显示这一行的？</p><p>Timing 就是解决这两问题的。</p><pre><code>Video timing 包含两个信号：水平同步Hs（horizontal sync）和垂直同步Vs（vertical sync）Vertical sync --&gt;用来标识什么时候开始送出一幅新画面Horizontal sync --&gt;用来标识什么时候开始新一行的图像扫描</code></pre><h6 id="Vertical-sync-和-Horizontal-sync-信号有三种传送方式："><a href="#Vertical-sync-和-Horizontal-sync-信号有三种传送方式：" class="headerlink" title="Vertical sync 和 Horizontal sync 信号有三种传送方式："></a>Vertical sync 和 Horizontal sync 信号有三种传送方式：</h6><ol><li>单独传送vertical sync 和 Horizontal sync两路信号，如电脑上用的VGA信号，HDMI高清数字视频信号；</li><li>将vertical sync和horizontal sync信号复合在一路单独传送，如S-Video型号（其timing信号时复合在其Y信号中）；</li><li>将vertical sync和horizontal sync复合在一起的信号又再复合进视频信号中一起传送，如CVBS信号；</li></ol><h6 id="举个例子说明timing中包含了哪些信息："><a href="#举个例子说明timing中包含了哪些信息：" class="headerlink" title="举个例子说明timing中包含了哪些信息："></a>举个例子说明timing中包含了哪些信息：</h6><p>如一个视频信号timing为（1024x768@60），1024x768表示是SVGA分辨率（其中1024表示一幅图像的列数，因每一个象素点有R/G/B三点组成，故共有1024*3列；768表示一幅图像的行数，共768行），60Hz表示的就是vertical sync（即每一个画面的显示时间为1/60s=16.67ms），由于每一幅画面要扫描768行，所以每一行的扫描时间即为16.67ms/768=21.7us，即可得出horizontal sync。</p>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h6&gt;&lt;p&gt;大家应该都知道，视频看起来是持续动态的，但是实际上是由一系列的静态画面，在很短的时间内更替,在人眼上就产生视觉残留，以至于你的眼睛感觉是动态画面。大家看到的视频中大多数是每秒闪过50-60幅画面，对于电脑画面大概是每秒闪过70-80幅画面。&lt;/p&gt;
    
    </summary>
    
    
      <category term="视音频" scheme="http://www.faihung.net/categories/%E8%A7%86%E9%9F%B3%E9%A2%91/"/>
    
    
      <category term="Timing" scheme="http://www.faihung.net/tags/Timing/"/>
    
      <category term="Vertical sync" scheme="http://www.faihung.net/tags/Vertical-sync/"/>
    
      <category term="Horizontal sync" scheme="http://www.faihung.net/tags/Horizontal-sync/"/>
    
  </entry>
  
  <entry>
    <title>工程设计-CAN转以太网</title>
    <link href="http://www.faihung.net/2019/11/24/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-CAN%E8%BD%AC%E4%BB%A5%E5%A4%AA%E7%BD%91/"/>
    <id>http://www.faihung.net/2019/11/24/工程设计-CAN转以太网/</id>
    <published>2019-11-24T15:04:43.000Z</published>
    <updated>2019-12-14T15:27:07.420Z</updated>
    
    <content type="html"><![CDATA[<p>暂略</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;暂略&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="工程设计" scheme="http://www.faihung.net/categories/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>工程设计-Hdmi转以太网</title>
    <link href="http://www.faihung.net/2019/11/24/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-Hdmi%E8%BD%AC%E4%BB%A5%E5%A4%AA%E7%BD%91/"/>
    <id>http://www.faihung.net/2019/11/24/工程设计-Hdmi转以太网/</id>
    <published>2019-11-24T15:04:21.000Z</published>
    <updated>2019-12-14T15:26:45.637Z</updated>
    
    <content type="html"><![CDATA[<p>暂略</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;暂略&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="工程设计" scheme="http://www.faihung.net/categories/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
</feed>
