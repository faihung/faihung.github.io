<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Faihung&#39;s blog</title>
  
  <subtitle>作者：faihung</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.faihung.net/"/>
  <updated>2019-11-16T07:59:53.317Z</updated>
  <id>http://www.faihung.net/</id>
  
  <author>
    <name>faihung</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C语言-数组强制转换成结构体类型存储(2)</title>
    <link href="http://www.faihung.net/2019/11/16/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8-2/"/>
    <id>http://www.faihung.net/2019/11/16/C语言-数组强制转换成结构体类型存储-2/</id>
    <published>2019-11-16T07:56:50.000Z</published>
    <updated>2019-11-16T07:59:53.317Z</updated>
    
    <content type="html"><![CDATA[<p>废话不多说，直接上代码</p><a id="more"></a><h5 id="1-没有-pragma-pack-1"><a href="#1-没有-pragma-pack-1" class="headerlink" title="1. 没有#pragma   pack(1)"></a>1. 没有#pragma   pack(1)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;      /*标准输入输出定义*/</span><br><span class="line">#include &lt;stdlib.h&gt;     /*标准函数库定义*/</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;      /*文件控制定义*/</span><br><span class="line">#include &lt;termios.h&gt;    /*PPSIX 终端控制定义*/</span><br><span class="line">#include &lt;unistd.h&gt;     /*Unix 标准函数定义*/</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line"></span><br><span class="line">#define UI_PARAM_FILE &quot;/mnt/hgfs/VMWARE/test/config/2.txt&quot;</span><br><span class="line"></span><br><span class="line">unsigned char appWritePara(unsigned char* Para, unsigned int paraSize, char *fileName)</span><br><span class="line">&#123;</span><br><span class="line">int fd = 0;</span><br><span class="line"></span><br><span class="line">fd = open(fileName,O_RDWR, 0644); //O_SYNC O_DIRECT</span><br><span class="line">if (-1 == fd)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;open file:%s\n&quot;, fileName);</span><br><span class="line">close(fd);</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;Open %s success\n&quot;, fileName);</span><br><span class="line">write(fd,Para,paraSize);</span><br><span class="line">printf(&quot;-----------write----------\n&quot;);</span><br><span class="line">close(fd);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char ch[12] = &#123;&#125;;</span><br><span class="line">typedef struct arr_s</span><br><span class="line">&#123;</span><br><span class="line">char i;</span><br><span class="line">short j;</span><br><span class="line">char l;</span><br><span class="line"></span><br><span class="line">&#125;arr_t;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">char * filename = UI_PARAM_FILE;</span><br><span class="line">arr_t* p = (arr_t*)ch;</span><br><span class="line">p-&gt;i = 0x30;</span><br><span class="line">p-&gt;j = 0x3132;</span><br><span class="line">p-&gt;l = 0x33;</span><br><span class="line">printf(&quot;%X, %X, %X\n&quot;,p-&gt;i,p-&gt;j,p-&gt;l);</span><br><span class="line"></span><br><span class="line">appWritePara(ch,sizeof(ch),filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果演示：</p><p><img src="/2019/11/16/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8-2/1.jpg" alt="1"></p><p><img src="/2019/11/16/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8-2/2.jpg" alt="2"></p><p>可以看到文本文件中保持12个字节大小的数据。其中i类型之后是填空补充的。<br>这说明数据是4个字节数据，结构体是6个字节数据。</p><h5 id="2-有-pragma-pack-1"><a href="#2-有-pragma-pack-1" class="headerlink" title="2. 有#pragma   pack(1)"></a>2. 有#pragma   pack(1)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;      /*标准输入输出定义*/</span><br><span class="line">#include &lt;stdlib.h&gt;     /*标准函数库定义*/</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;      /*文件控制定义*/</span><br><span class="line">#include &lt;termios.h&gt;    /*PPSIX 终端控制定义*/</span><br><span class="line">#include &lt;unistd.h&gt;     /*Unix 标准函数定义*/</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line"></span><br><span class="line">#define UI_PARAM_FILE &quot;/mnt/hgfs/VMWARE/test/config/2.txt&quot;</span><br><span class="line"></span><br><span class="line">unsigned char appWritePara(unsigned char* Para, unsigned int paraSize, char *fileName)</span><br><span class="line">&#123;</span><br><span class="line">int fd = 0;</span><br><span class="line"></span><br><span class="line">fd = open(fileName,O_RDWR, 0644); //O_SYNC O_DIRECT</span><br><span class="line">if (-1 == fd)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;open file:%s\n&quot;, fileName);</span><br><span class="line">close(fd);</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;Open %s success\n&quot;, fileName);</span><br><span class="line">write(fd,Para,paraSize);</span><br><span class="line">printf(&quot;-----------write----------\n&quot;);</span><br><span class="line">close(fd);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char ch[12] = &#123;&#125;;</span><br><span class="line">#pragma   pack(1) //强制连续存放,对齐边界为 1</span><br><span class="line">typedef struct arr_s</span><br><span class="line">&#123;</span><br><span class="line">char i;</span><br><span class="line">short j;</span><br><span class="line">char l;</span><br><span class="line"></span><br><span class="line">&#125;arr_t;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">char * filename = UI_PARAM_FILE;</span><br><span class="line">arr_t* p = (arr_t*)ch;</span><br><span class="line">p-&gt;i = 0x30;</span><br><span class="line">p-&gt;j = 0x3132;</span><br><span class="line">p-&gt;l = 0x33;</span><br><span class="line">printf(&quot;%X, %X, %X\n&quot;,p-&gt;i,p-&gt;j,p-&gt;l);</span><br><span class="line"></span><br><span class="line">appWritePara(ch,sizeof(ch),filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果演示:</p><p><img src="/2019/11/16/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8-2/3.jpg" alt="3"></p><p><img src="/2019/11/16/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8-2/4.jpg" alt="4"></p><p>这说明数据是4个字节数据，结构体是4个字节数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;废话不多说，直接上代码&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://www.faihung.net/categories/C/"/>
    
    
      <category term="数组" scheme="http://www.faihung.net/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="结构体" scheme="http://www.faihung.net/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
      <category term="强制转换" scheme="http://www.faihung.net/tags/%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
      <category term="字节对齐" scheme="http://www.faihung.net/tags/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/"/>
    
      <category term="大小端" scheme="http://www.faihung.net/tags/%E5%A4%A7%E5%B0%8F%E7%AB%AF/"/>
    
      <category term="pragma pack()" scheme="http://www.faihung.net/tags/pragma-pack/"/>
    
      <category term="配置文件" scheme="http://www.faihung.net/tags/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
      <category term="文本保存" scheme="http://www.faihung.net/tags/%E6%96%87%E6%9C%AC%E4%BF%9D%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>C语言-数组强制转换成结构体类型存储(1)</title>
    <link href="http://www.faihung.net/2019/11/16/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8/"/>
    <id>http://www.faihung.net/2019/11/16/C语言-数组强制转换成结构体类型存储/</id>
    <published>2019-11-16T07:37:48.000Z</published>
    <updated>2019-11-16T07:47:32.722Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-数组强制转换成结构类型-数组类型和结构体成员类型一致"><a href="#1-数组强制转换成结构类型-数组类型和结构体成员类型一致" class="headerlink" title="1. 数组强制转换成结构类型,数组类型和结构体成员类型一致"></a>1. 数组强制转换成结构类型,数组类型和结构体成员类型一致</h5><p>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;      /*标准输入输出定义*/</span><br><span class="line">#include &lt;stdlib.h&gt;     /*标准函数库定义*/</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;      /*文件控制定义*/</span><br><span class="line">#include &lt;termios.h&gt;    /*PPSIX 终端控制定义*/</span><br><span class="line">#include &lt;unistd.h&gt;     /*Unix 标准函数定义*/</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">/*</span><br><span class="line">字节对齐问题，一个数组强制转换成结构体类型</span><br><span class="line">*/</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">int ch[] = &#123;0x12, 0x34, 0x56, 0x78&#125;;</span><br><span class="line">typedef struct arr_s</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">int j;</span><br><span class="line">&#125;arr_t;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">arr_t* p = (arr_t*)ch;</span><br><span class="line">printf(&quot;数组强制转换成结构类型,数组类型和结构体成员类型一致:0x%X, 0x%X\n&quot;,p-&gt;i,p-&gt;j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组是int类型，结构体成员也是int类型。</p><p>演示效果：</p><p><img src="/2019/11/16/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8/1.jpg" alt="1"></p><h5 id="2-数组强制转换成结构类型-数组类型和结构体成员类型不一致"><a href="#2-数组强制转换成结构类型-数组类型和结构体成员类型不一致" class="headerlink" title="2.  数组强制转换成结构类型,数组类型和结构体成员类型不一致"></a>2.  数组强制转换成结构类型,数组类型和结构体成员类型不一致</h5><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;      /*标准输入输出定义*/</span><br><span class="line">#include &lt;stdlib.h&gt;     /*标准函数库定义*/</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;      /*文件控制定义*/</span><br><span class="line">#include &lt;termios.h&gt;    /*PPSIX 终端控制定义*/</span><br><span class="line">#include &lt;unistd.h&gt;     /*Unix 标准函数定义*/</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line"></span><br><span class="line">char ch[] = &#123;0x12, 0x34, 0x56, 0x78&#125;;</span><br><span class="line">typedef struct arr_s</span><br><span class="line">&#123;</span><br><span class="line">char i;</span><br><span class="line">short j;</span><br><span class="line">char l;</span><br><span class="line"></span><br><span class="line">&#125;arr_t;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">arr_t* p = (arr_t*)ch;</span><br><span class="line">printf(&quot;数组大小:%d\n&quot;,sizeof(ch));</span><br><span class="line">printf(&quot;结构体成员大小:%d\n&quot;,sizeof(arr_t));</span><br><span class="line">printf(&quot;数组强制转换成结构类型,数组类型和结构体成员类型不一致:%X, %X, %X\n&quot;,p-&gt;i,p-&gt;j,p-&gt;l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果演示：</p><p><img src="/2019/11/16/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8/2.jpg" alt="2"></p><p>数组为char型，结构体成员为依次char型，short型，char型。其中数组有四个字节，结构体成员因为对齐的原因有6个字节。</p><p>可以看到，i的类型因为j的类型的原因，补充了一个字节，所以当数组强制转换成结构体类型之后，0x34会漏掉。 0x56 0x78 因为小端的原因，排序成0x7856</p><p>但是如果稍微将j和l位置替换一下，结果又不一样，请看示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;      /*标准输入输出定义*/</span><br><span class="line">#include &lt;stdlib.h&gt;     /*标准函数库定义*/</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;      /*文件控制定义*/</span><br><span class="line">#include &lt;termios.h&gt;    /*PPSIX 终端控制定义*/</span><br><span class="line">#include &lt;unistd.h&gt;     /*Unix 标准函数定义*/</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line"></span><br><span class="line">char ch[] = &#123;0x12, 0x34, 0x56, 0x78&#125;;</span><br><span class="line">typedef struct arr_s</span><br><span class="line">&#123;</span><br><span class="line">char i;</span><br><span class="line">char l;</span><br><span class="line">short j;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;arr_t;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">arr_t* p = (arr_t*)ch;</span><br><span class="line">printf(&quot;数组大小:%d\n&quot;,sizeof(ch));</span><br><span class="line">printf(&quot;结构体成员大小:%d\n&quot;,sizeof(arr_t));</span><br><span class="line">printf(&quot;数组强制转换成结构类型,数组类型和结构体成员类型不一致:%X, %X, %X\n&quot;,p-&gt;i,p-&gt;j,p-&gt;l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果演示：</p><p><img src="/2019/11/16/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8/3.jpg" alt="3"></p><p>看到没有，此时数组的大小和结构体大小一致。那么此时打印出来的数据也是一样的。</p><p>其实还可以这样，加一个</p><pre><code>#pragma   pack(1)</code></pre><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;      /*标准输入输出定义*/</span><br><span class="line">#include &lt;stdlib.h&gt;     /*标准函数库定义*/</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;      /*文件控制定义*/</span><br><span class="line">#include &lt;termios.h&gt;    /*PPSIX 终端控制定义*/</span><br><span class="line">#include &lt;unistd.h&gt;     /*Unix 标准函数定义*/</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line"></span><br><span class="line">char ch[] = &#123;0x12, 0x34, 0x56, 0x78&#125;;</span><br><span class="line">#pragma   pack(1) //强制连续存放,对齐边界为 1</span><br><span class="line">typedef struct arr_s</span><br><span class="line">&#123;</span><br><span class="line">char i;</span><br><span class="line">short j;</span><br><span class="line">char l;</span><br><span class="line">&#125;arr_t;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">arr_t* p = (arr_t*)ch;</span><br><span class="line">printf(&quot;数组大小:%d\n&quot;,sizeof(ch));</span><br><span class="line">printf(&quot;结构体成员大小:%d\n&quot;,sizeof(arr_t));</span><br><span class="line">printf(&quot;数组强制转换成结构类型,数组类型和结构体成员类型不一致:%X, %X, %X\n&quot;,p-&gt;i,p-&gt;j,p-&gt;l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果演示：</p><p><img src="/2019/11/16/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8/4.jpg" alt="4"></p><p>由此可以看到，其实结构体的存储和数组的存储其实本质上是一样的，不同的是数组只能有一种数据类型，结构体可以有多种数据类型，他们之间强制转换时，要考虑到字节对齐、大小端问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;1-数组强制转换成结构类型-数组类型和结构体成员类型一致&quot;&gt;&lt;a href=&quot;#1-数组强制转换成结构类型-数组类型和结构体成员类型一致&quot; class=&quot;headerlink&quot; title=&quot;1. 数组强制转换成结构类型,数组类型和结构体成员类型一致&quot;&gt;&lt;/a&gt;1
      
    
    </summary>
    
    
      <category term="C" scheme="http://www.faihung.net/categories/C/"/>
    
    
      <category term="数组" scheme="http://www.faihung.net/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="结构体" scheme="http://www.faihung.net/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
      <category term="强制转换" scheme="http://www.faihung.net/tags/%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
      <category term="字节对齐" scheme="http://www.faihung.net/tags/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/"/>
    
      <category term="大小端" scheme="http://www.faihung.net/tags/%E5%A4%A7%E5%B0%8F%E7%AB%AF/"/>
    
      <category term="pragma pack()" scheme="http://www.faihung.net/tags/pragma-pack/"/>
    
  </entry>
  
  <entry>
    <title>C语言-字符串拼接</title>
    <link href="http://www.faihung.net/2019/11/16/C%E8%AF%AD%E8%A8%80-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5/"/>
    <id>http://www.faihung.net/2019/11/16/C语言-字符串拼接/</id>
    <published>2019-11-16T06:51:13.000Z</published>
    <updated>2019-11-16T06:57:08.083Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>工作中我们经常用到字符串相关操作，前面讲到对字符串拆分的、格式转换的sscanf()函数，现在讲一下字符串拼接相关函数。</p></blockquote><a id="more"></a><h5 id="一、利用strcat-函数函数"><a href="#一、利用strcat-函数函数" class="headerlink" title="一、利用strcat()函数函数"></a>一、利用strcat()函数函数</h5><p>strcat() 函数用来将两个字符串连接（拼接）起来</p><p>头文件：string.h</p><p>语法/原型：</p><pre><code>char*strcat(char* strDestination, const char* strSource);</code></pre><p>参数说明：</p><pre><code>strDestination：目的字符串；strSource：源字符串。</code></pre><p>strcat() 函数把 strSource 所指向的字符串追加到 strDestination 所指向的字符串的结尾，所以必须要保证 strDestination 有足够的内存空间来容纳两个字符串，否则会导致溢出错误。</p><p>注意：<br>strDestination 末尾的\0会被覆盖，strSource 末尾的\0会一起被复制过去，最终的字符串只有一个\0。</p><p>返回值：<br>指向 strDestination 的指针。</p><p>事例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char str1[101] = &#123; 0 &#125;;</span><br><span class="line">    char str2[50] = &#123; 0 &#125;;</span><br><span class="line">    gets(str1);</span><br><span class="line">    gets(str2);</span><br><span class="line">    strcat(str1, str2);</span><br><span class="line">    puts(str1);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="/2019/11/16/C%E8%AF%AD%E8%A8%80-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5/1.jpg" alt="1"></p><h5 id="二、利用sprintf-函数"><a href="#二、利用sprintf-函数" class="headerlink" title="二、利用sprintf()函数"></a>二、利用sprintf()函数</h5><blockquote><p>sprintf函数不光可以用来做字符串格式转换，还可以用来做字符串拼接，简单又实用。</p></blockquote><p>直接看代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">char rtmppush_URL[35] = &quot;rtmp://&quot;;</span><br><span class="line">char ip[20] = &quot;121.199.24.64&quot;;</span><br><span class="line">char Strmedia_No = 23;</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">sprintf(rtmppush_URL,&quot;%s%s%s%s%s%d&quot;,&quot;rtmp://&quot;,ip,&quot;:&quot;,&quot;10990&quot;,&quot;/myapp&quot;,Strmedia_No);</span><br><span class="line">printf(&quot;rtmppush_URL=%s\n&quot;,rtmppush_URL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：看sprintf中的格式转换，可以将字符、整数、进制统统转换成字符类型，然后打印到内存中去。这个功能很强大。</p><p>效果：</p><p><img src="/2019/11/16/C%E8%AF%AD%E8%A8%80-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5/2.jpg" alt="2"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;工作中我们经常用到字符串相关操作，前面讲到对字符串拆分的、格式转换的sscanf()函数，现在讲一下字符串拼接相关函数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://www.faihung.net/categories/C/"/>
    
    
      <category term="字符串拼接" scheme="http://www.faihung.net/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5/"/>
    
      <category term="strcat" scheme="http://www.faihung.net/tags/strcat/"/>
    
      <category term="sprintf" scheme="http://www.faihung.net/tags/sprintf/"/>
    
  </entry>
  
  <entry>
    <title>C语言-整数与字符串的相互转换</title>
    <link href="http://www.faihung.net/2019/11/10/C%E8%AF%AD%E8%A8%80-%E6%95%B4%E6%95%B0%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"/>
    <id>http://www.faihung.net/2019/11/10/C语言-整数与字符串的相互转换/</id>
    <published>2019-11-10T07:28:29.000Z</published>
    <updated>2019-11-16T06:41:11.763Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h4><p>C语言中整数与字符串的相互转换，有广泛应用的拓展函数(非标准库)，也可以自己尝试简单的实现。</p><a id="more"></a><h4 id="二、整数转字符串"><a href="#二、整数转字符串" class="headerlink" title="二、整数转字符串"></a>二、整数转字符串</h4><h5 id="1-拓展函数itoa"><a href="#1-拓展函数itoa" class="headerlink" title="1. 拓展函数itoa"></a>1. 拓展函数itoa</h5><pre><code>itoa (表示 integer to alphanumeric)是把整型数转换成字符串的一个函数。</code></pre><p>windows环境下，在&lt;stdlib.h&gt;头文件中有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char* itoa(int value,char*string,int radix);</span><br></pre></td></tr></table></figure><p>参数：value，要转换的整数，string， 转换后的字符串,radix， 转换进制数，如2,8,10,16 进制等。</p><p>返回值：函数返回一个指向 str，无错误返回。</p><p>功能：将整数value 转换成字符串存入string 指向的内存空间 ,radix 为转换时所用基数(保存到字符串中的数据的进制基数)。</p><p>注意：itoa不是一个标准的c函数，他是windows特有的，跨平台写程序，要用sprintf。</p><h6 id="函数源码："><a href="#函数源码：" class="headerlink" title="函数源码："></a>函数源码：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">char* itoa(int num,char* str,int radix)</span><br><span class="line">&#123;</span><br><span class="line">char index[]=&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;//索引表</span><br><span class="line">unsigned unum;//存放要转换的整数的绝对值,转换的整数可能是负数</span><br><span class="line">int i=0,j,k;//i用来指示设置字符串相应位，转换之后i其实就是字符串的长度；转换后顺序是逆序的，有正负的情况，k用来指示调整顺序的开始位置;j用来指示调整顺序时的交换。</span><br><span class="line"> </span><br><span class="line">//获取要转换的整数的绝对值</span><br><span class="line">if(radix==10&amp;&amp;num&lt;0)//要转换成十进制数并且是负数</span><br><span class="line">&#123;</span><br><span class="line">unum=(unsigned)-num;//将num的绝对值赋给unum</span><br><span class="line">str[i++]=&apos;-&apos;;//在字符串最前面设置为&apos;-&apos;号，并且索引加1</span><br><span class="line">&#125;</span><br><span class="line">else unum=(unsigned)num;//若是num为正，直接赋值给unum</span><br><span class="line"> </span><br><span class="line">//转换部分，注意转换后是逆序的</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">str[i++]=index[unum%(unsigned)radix];//取unum的最后一位，并设置为str对应位，指示索引加1</span><br><span class="line">unum/=radix;//unum去掉最后一位</span><br><span class="line"> </span><br><span class="line">&#125;while(unum);//直至unum为0退出循环</span><br><span class="line"> </span><br><span class="line">str[i]=&apos;\0&apos;;//在字符串最后添加&apos;\0&apos;字符，c语言字符串以&apos;\0&apos;结束。</span><br><span class="line"> </span><br><span class="line">//将顺序调整过来</span><br><span class="line">if(str[0]==&apos;-&apos;) k=1;//如果是负数，符号不用调整，从符号后面开始调整</span><br><span class="line">else k=0;//不是负数，全部都要调整</span><br><span class="line"> </span><br><span class="line">char temp;//临时变量，交换两个值时用到</span><br><span class="line">for(j=k;j&lt;=(i-1)/2;j++)//头尾一一对称交换，i其实就是字符串的长度，索引最大值比长度少1</span><br><span class="line">&#123;</span><br><span class="line">temp=str[j];//头部赋值给临时变量</span><br><span class="line">str[j]=str[i-1+k-j];//尾部赋值给头部</span><br><span class="line">str[i-1+k-j]=temp;//将临时变量的值(其实就是之前的头部值)赋给尾部</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">return str;//返回转换后的字符串</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="示例程序："><a href="#示例程序：" class="headerlink" title="示例程序："></a>示例程序：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int number1 = 123456;</span><br><span class="line">int number2 = -123456;</span><br><span class="line">char string[16] = &#123;0&#125;;</span><br><span class="line">itoa(number1,string,10);</span><br><span class="line">printf(&quot;数字：%d 转换后的字符串为：%s\n&quot;,number1,string);</span><br><span class="line">itoa(number2,string,10);</span><br><span class="line">printf(&quot;数字：%d 转换后的字符串为：%s\n&quot;,number2,string);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行代码如下：(linux环境下略)</p><h5 id="2-自己简单实现"><a href="#2-自己简单实现" class="headerlink" title="2. 自己简单实现"></a>2. 自己简单实现</h5><h6 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">char* Int2String(int num,char *str);//函数声明 </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int number1 = 123456;</span><br><span class="line">int number2 = -123456;</span><br><span class="line">char string[16] = &#123;0&#125;;</span><br><span class="line">Int2String(number1,string);</span><br><span class="line">printf(&quot;数字：%d 转换后的字符串为：%s\n&quot;,number1,string);</span><br><span class="line">Int2String(number2,string);</span><br><span class="line">printf(&quot;数字：%d 转换后的字符串为：%s\n&quot;,number2,string);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">char* Int2String(int num,char *str)//10进制 </span><br><span class="line">&#123;</span><br><span class="line">int i = 0;//指示填充str </span><br><span class="line">if(num&lt;0)//如果num为负数，将num变正 </span><br><span class="line">&#123;</span><br><span class="line">num = -num;</span><br><span class="line">str[i++] = &apos;-&apos;;</span><br><span class="line">&#125; </span><br><span class="line">//转换 </span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">str[i++] = num%10+48;//取num最低位 字符0~9的ASCII码是48~57；简单来说数字0+48=48，ASCII码对应字符&apos;0&apos; </span><br><span class="line">num /= 10;//去掉最低位</span><br><span class="line">&#125;while(num);//num不为0继续循环</span><br><span class="line"></span><br><span class="line">str[i] = &apos;\0&apos;;</span><br><span class="line"></span><br><span class="line">//确定开始调整的位置 </span><br><span class="line">int j = 0;</span><br><span class="line">if(str[0]==&apos;-&apos;)//如果有负号，负号不用调整 </span><br><span class="line">&#123;</span><br><span class="line">j = 1;//从第二位开始调整 </span><br><span class="line">++i;//由于有负号，所以交换的对称轴也要后移1位 </span><br><span class="line">&#125;</span><br><span class="line">//对称交换 </span><br><span class="line">for(;j&lt;i/2;j++)</span><br><span class="line">&#123;</span><br><span class="line">//对称交换两端的值 其实就是省下中间变量交换a+b的值：a=a+b;b=a-b;a=a-b; </span><br><span class="line">str[j] = str[j] + str[i-1-j];</span><br><span class="line">str[i-1-j] = str[j] - str[i-1-j];</span><br><span class="line">str[j] = str[j] - str[i-1-j];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">return str;//返回转换后的值 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="执行代码如下："><a href="#执行代码如下：" class="headerlink" title="执行代码如下："></a>执行代码如下：</h6><p><img src="/2019/11/10/C%E8%AF%AD%E8%A8%80-%E6%95%B4%E6%95%B0%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/1.jpg" alt="1"></p><h4 id="三、字符串转整数"><a href="#三、字符串转整数" class="headerlink" title="三、字符串转整数"></a>三、字符串转整数</h4><h5 id="1-拓展函数"><a href="#1-拓展函数" class="headerlink" title="1.拓展函数"></a>1.拓展函数</h5><pre><code>atoi (表示 alphanumeric to integer)是把字符串转换成整型数的一个函数。</code></pre><p>windows环境下，在&lt;stdlib.h&gt;头文件中</p><pre><code>int  atoi(const char *nptr);//字符串转整数函数，nptr: 要转换的字符串</code></pre><h6 id="实现源码"><a href="#实现源码" class="headerlink" title="实现源码"></a>实现源码</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">int  atoi(const char *nptr)</span><br><span class="line">&#123;</span><br><span class="line">        return (int)atol(nptr);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">long  atol(const char *nptr)</span><br><span class="line">&#123;</span><br><span class="line">        int c;              /* 当前要转换的字符(一个一个字符转换成数字) */</span><br><span class="line">        long total;         /* 当前转换结果 */</span><br><span class="line">        int sign;           /* 标志转换结果是否带负号*/</span><br><span class="line"> </span><br><span class="line">        /*跳过空格，空格不进行转换*/</span><br><span class="line">        while ( isspace((int)(unsigned char)*nptr) )</span><br><span class="line">            ++nptr;</span><br><span class="line"> </span><br><span class="line">        c = (int)(unsigned char)*nptr++;//获取一个字符准备转换 </span><br><span class="line">        sign = c;           /*保存符号标示*/</span><br><span class="line">        if (c == &apos;-&apos; || c == &apos;+&apos;)</span><br><span class="line">            c = (int)(unsigned char)*nptr++;    /*跳过&apos;+&apos;、&apos;-&apos;号，不进行转换*/</span><br><span class="line"> </span><br><span class="line">        total = 0;//设置转换结果为0 </span><br><span class="line"> </span><br><span class="line">        while (isdigit(c)) &#123;//如果字符是数字 </span><br><span class="line">            total = 10 * total + (c - &apos;0&apos;);     /* 根据ASCII码将字符转换为对应的数字，并且乘10累积到结果 */</span><br><span class="line">            c = (int)(unsigned char)*nptr++;    /* 取下一个字符 */</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"> //根据符号指示返回是否带负号的结果 </span><br><span class="line">        if (sign == &apos;-&apos;)</span><br><span class="line">            return -total;</span><br><span class="line">        else</span><br><span class="line">            return total;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="示例程序：-1"><a href="#示例程序：-1" class="headerlink" title="示例程序："></a>示例程序：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt; </span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;字符串\&quot;123456\&quot;转换为数字：%d\n&quot;,atoi(&quot;123456&quot;));</span><br><span class="line">printf(&quot;字符串\&quot;-123456\&quot;转换为数字：%d\n&quot;,atoi(&quot;-123456&quot;));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行代码如下：</p><p><img src="/2019/11/10/C%E8%AF%AD%E8%A8%80-%E6%95%B4%E6%95%B0%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/2.jpg" alt="2"></p><h5 id="2-自己简单实现-1"><a href="#2-自己简单实现-1" class="headerlink" title="2.自己简单实现"></a>2.自己简单实现</h5><h6 id="实现源码-1"><a href="#实现源码-1" class="headerlink" title="实现源码-1"></a>实现源码-1</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int String2Int(char *str);//函数声明 </span><br><span class="line"></span><br><span class="line">int String2Int(char *str)//字符串转数字 </span><br><span class="line">&#123;</span><br><span class="line">char flag = &apos;+&apos;;//指示结果是否带符号 </span><br><span class="line">long res = 0;</span><br><span class="line"></span><br><span class="line">if(*str==&apos;-&apos;)//字符串带负号 </span><br><span class="line">&#123;</span><br><span class="line">++str;//指向下一个字符 </span><br><span class="line">flag = &apos;-&apos;;//将标志设为负号 </span><br><span class="line">&#125; </span><br><span class="line">//逐个字符转换，并累加到结果res </span><br><span class="line">while(*str&gt;=48 &amp;&amp; *str&lt;57)//如果是数字才进行转换，数字0~9的ASCII码：48~57 </span><br><span class="line">&#123;</span><br><span class="line">res = 10*res+  *str++-48;//字符&apos;0&apos;的ASCII码为48,48-48=0刚好转化为数字0 </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">    if(flag == &apos;-&apos;)//处理是负数的情况</span><br><span class="line">&#123;</span><br><span class="line">res = -res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">return (int)res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;字符串\&quot;123456\&quot;转换为数字：%d\n&quot;,String2Int(&quot;123456&quot;));</span><br><span class="line">printf(&quot;字符串\&quot;-123456\&quot;转换为数字：%d\n&quot;,String2Int(&quot;-123456&quot;));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行代码如下：</p><p><img src="/2019/11/10/C%E8%AF%AD%E8%A8%80-%E6%95%B4%E6%95%B0%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/3.jpg" alt="3"></p><h6 id="实现源码-2"><a href="#实现源码-2" class="headerlink" title="实现源码-2"></a>实现源码-2</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int ASCIItoINT(char s[])  </span><br><span class="line">&#123;  </span><br><span class="line">    int i;  </span><br><span class="line">    int n = 0;  </span><br><span class="line">    for (i = 0; s[i] &gt;= &apos;0&apos; &amp;&amp; s[i] &lt;= &apos;9&apos;; ++i)  </span><br><span class="line">    &#123;  </span><br><span class="line">        n = 10 * n + (s[i] - &apos;0&apos;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return n;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">char *str = &quot;1234&quot;;</span><br><span class="line">printf(&quot;整数:%d\n&quot;,ASCIItoINT(str));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="执行代码如下：-1"><a href="#执行代码如下：-1" class="headerlink" title="执行代码如下："></a>执行代码如下：</h6><p><img src="/2019/11/10/C%E8%AF%AD%E8%A8%80-%E6%95%B4%E6%95%B0%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/4.jpg" alt="4"></p><h4 id="四、利用sprintf-函数和sscanf-函数"><a href="#四、利用sprintf-函数和sscanf-函数" class="headerlink" title="四、利用sprintf()函数和sscanf()函数"></a>四、利用sprintf()函数和sscanf()函数</h4><h5 id="整数转字符串"><a href="#整数转字符串" class="headerlink" title="整数转字符串"></a>整数转字符串</h5><h6 id="测试代码："><a href="#测试代码：" class="headerlink" title="测试代码："></a>测试代码：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">char* Int2String(int num,char *str);//函数声明 </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int number1 = 123456;</span><br><span class="line">int number2 = -123456;</span><br><span class="line">char string[16] = &#123;0&#125;;</span><br><span class="line">Int2String(number1,string);</span><br><span class="line">printf(&quot;数字：%d 转换后的字符串为：%s\n&quot;,number1,string);</span><br><span class="line">Int2String(number2,string);</span><br><span class="line">printf(&quot;数字：%d 转换后的字符串为：%s\n&quot;,number2,string);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">char* Int2String(int num,char *str)</span><br><span class="line">&#123;</span><br><span class="line">sprintf(str, &quot;%d&quot;, num);</span><br><span class="line"> </span><br><span class="line">return str;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="执行代码如下：-2"><a href="#执行代码如下：-2" class="headerlink" title="执行代码如下："></a>执行代码如下：</h6><p><img src="/2019/11/10/C%E8%AF%AD%E8%A8%80-%E6%95%B4%E6%95%B0%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/5.jpg" alt="5"></p><h5 id="字符串转整数"><a href="#字符串转整数" class="headerlink" title="字符串转整数"></a>字符串转整数</h5><h6 id="测试代码：-1"><a href="#测试代码：-1" class="headerlink" title="测试代码："></a>测试代码：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int String2Int(char *str);//函数声明 </span><br><span class="line"></span><br><span class="line">int String2Int(char *str)//字符串转数字 </span><br><span class="line">&#123;</span><br><span class="line">char flag = &apos;+&apos;;//指示结果是否带符号 </span><br><span class="line">long res = 0;</span><br><span class="line"></span><br><span class="line">if(*str==&apos;-&apos;)//字符串带负号 </span><br><span class="line">&#123;</span><br><span class="line">++str;//指向下一个字符 </span><br><span class="line">flag = &apos;-&apos;;//将标志设为负号 </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">sscanf(str, &quot;%ld&quot;, &amp;res);</span><br><span class="line">if(flag == &apos;-&apos;)</span><br><span class="line">&#123;</span><br><span class="line">res = -res;</span><br><span class="line">&#125;</span><br><span class="line">return (int)res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;字符串\&quot;123456\&quot;转换为数字：%d\n&quot;,String2Int(&quot;123456&quot;));</span><br><span class="line">printf(&quot;字符串\&quot;-123456\&quot;转换为数字：%d\n&quot;,String2Int(&quot;-123456&quot;));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="执行代码如下：-3"><a href="#执行代码如下：-3" class="headerlink" title="执行代码如下："></a>执行代码如下：</h6><p><img src="/2019/11/10/C%E8%AF%AD%E8%A8%80-%E6%95%B4%E6%95%B0%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/6.jpg" alt="6"></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、简述&quot;&gt;&lt;a href=&quot;#一、简述&quot; class=&quot;headerlink&quot; title=&quot;一、简述&quot;&gt;&lt;/a&gt;一、简述&lt;/h4&gt;&lt;p&gt;C语言中整数与字符串的相互转换，有广泛应用的拓展函数(非标准库)，也可以自己尝试简单的实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://www.faihung.net/categories/C/"/>
    
    
      <category term="sprintf" scheme="http://www.faihung.net/tags/sprintf/"/>
    
      <category term="sscanf" scheme="http://www.faihung.net/tags/sscanf/"/>
    
      <category term="整数转字符串" scheme="http://www.faihung.net/tags/%E6%95%B4%E6%95%B0%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="字符串转整数" scheme="http://www.faihung.net/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C语言-10进制与16进制的互转</title>
    <link href="http://www.faihung.net/2019/11/10/C%E8%AF%AD%E8%A8%80-10%E8%BF%9B%E5%88%B6%E4%B8%8E16%E8%BF%9B%E5%88%B6%E7%9A%84%E4%BA%92%E8%BD%AC/"/>
    <id>http://www.faihung.net/2019/11/10/C语言-10进制与16进制的互转/</id>
    <published>2019-11-10T03:57:01.000Z</published>
    <updated>2019-11-16T06:38:04.983Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>所谓的10进制数据和16进制数据本质上都是2进制数据，下面的显示大多最终还是以字符串的形式显示出来的。</p></blockquote><h4 id="16进制转10进制"><a href="#16进制转10进制" class="headerlink" title="16进制转10进制"></a>16进制转10进制</h4><h5 id="16进制转10进制-大端数组显示"><a href="#16进制转10进制-大端数组显示" class="headerlink" title="16进制转10进制-大端数组显示"></a>16进制转10进制-大端数组显示</h5><a id="more"></a><h6 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h6><p>先描述一个16进制转10进制的，即通过网络传输，大端显示的一个16进制的数组。</p><h6 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h6><ol><li>先对16进制数组Port中的每一个元素的高四位和低四位进行拆分，分别放到对应的数组port中。</li><li>调用pow函数,如pow(x,y)，即为求x的y次方。</li><li>编译执行即可，注意编译时要加 -lm。</li></ol><h6 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;math.h&gt; </span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">unsigned char Port[2] = &#123;0x2A,0xEE&#125;;</span><br><span class="line">unsigned char port[4];</span><br><span class="line">short port_Num = 0x2AEE;</span><br><span class="line">unsigned int port_num,port_num1,port_num2;</span><br><span class="line"></span><br><span class="line">port[0] = Port[0]&gt;&gt;4;</span><br><span class="line">    port[1] = Port[0]&amp;0x0F;</span><br><span class="line">    port[2] = Port[1]&gt;&gt;4;</span><br><span class="line">    port[3] = Port[1]&amp;0x0F;</span><br><span class="line"></span><br><span class="line">//第一种情况</span><br><span class="line">port_num = port[0]*16*16*16 + port[1]*16*16+port[2]*16 + port[3];</span><br><span class="line">printf(&quot;port_num1:%d\n&quot;,port_num);</span><br><span class="line"></span><br><span class="line">//第二种情况</span><br><span class="line">port_num1 = port[0]*pow(16,3) + port[1]*pow(16,2) + port[2]*pow(16,1) + port[3]*pow(16,0);</span><br><span class="line">printf(&quot;port_num1:%d\n&quot;,port_num1);</span><br><span class="line"></span><br><span class="line">//第三种情况</span><br><span class="line">for(i=3;i&gt;=0;i--)</span><br><span class="line">&#123;</span><br><span class="line">port_num2 += port[3-i]*pow(16,i);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;port_num2:%d\n&quot;,port_num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="执行代码如下：（-lm）"><a href="#执行代码如下：（-lm）" class="headerlink" title="执行代码如下：（-lm）"></a>执行代码如下：（-lm）</h6><p><img src="/2019/11/10/C%E8%AF%AD%E8%A8%80-10%E8%BF%9B%E5%88%B6%E4%B8%8E16%E8%BF%9B%E5%88%B6%E7%9A%84%E4%BA%92%E8%BD%AC/1.jpg" alt="1"></p><h5 id="16进制转换为十进制-指针字符串显示"><a href="#16进制转换为十进制-指针字符串显示" class="headerlink" title="16进制转换为十进制-指针字符串显示"></a>16进制转换为十进制-指针字符串显示</h5><h6 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a>应用场景：</h6><p>16进制的数据，以字符串的形式体现出来（可以带0x，可以不带）。</p><h6 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h6><ol><li>通过指针变量得到一个16进制的字符串</li><li>获取16进制字符串的长度</li><li>逆序从最后一个字符的数据获取10进制的整数</li><li>通过16进制权重从低位到高位累加。</li></ol><h6 id="代码如下：-1"><a href="#代码如下：-1" class="headerlink" title="代码如下："></a>代码如下：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">/* 十六进制数转换为十进制数 */</span><br><span class="line">long hexToDec(char *source);</span><br><span class="line"> </span><br><span class="line">/* 返回ch字符在sign数组中的序号 */</span><br><span class="line">int getIndexOfSigns(char ch);</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char *hex = &quot;75BCD15&quot;;</span><br><span class="line"> </span><br><span class="line">    printf(&quot;16进制数：\t%s\n&quot;, hex);</span><br><span class="line">    printf(&quot;10进制数：\t%ld\n&quot;, hexToDec(hex));</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* 十六进制数转换为十进制数 */</span><br><span class="line">long hexToDec(char *source)</span><br><span class="line">&#123;</span><br><span class="line">    long sum = 0;</span><br><span class="line">    long t = 1;</span><br><span class="line">    int i, len;</span><br><span class="line"> </span><br><span class="line">    len = strlen(source);</span><br><span class="line">    for(i=len-1; i&gt;=0; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += t * getIndexOfSigns(*(source + i));</span><br><span class="line">        t *= 16;</span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* 返回ch字符在sign数组中的序号 */</span><br><span class="line">int getIndexOfSigns(char ch)</span><br><span class="line">&#123;</span><br><span class="line">    if(ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        return ch - &apos;0&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ch &gt;= &apos;A&apos; &amp;&amp; ch &lt;=&apos;F&apos;) </span><br><span class="line">    &#123;</span><br><span class="line">        return ch - &apos;A&apos; + 10;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ch &gt;= &apos;a&apos; &amp;&amp; ch &lt;= &apos;f&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        return ch - &apos;a&apos; + 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="执行代码如下："><a href="#执行代码如下：" class="headerlink" title="执行代码如下："></a>执行代码如下：</h6><p><img src="/2019/11/10/C%E8%AF%AD%E8%A8%80-10%E8%BF%9B%E5%88%B6%E4%B8%8E16%E8%BF%9B%E5%88%B6%E7%9A%84%E4%BA%92%E8%BD%AC/2.jpg" alt="2"></p><h5 id="16进制转10进制-使用sscanf函数显示10进制数"><a href="#16进制转10进制-使用sscanf函数显示10进制数" class="headerlink" title="16进制转10进制-使用sscanf函数显示10进制数"></a>16进制转10进制-使用sscanf函数显示10进制数</h5><blockquote><p>sscanf函数的用法与printf函数很像，都是以格式化的形式进行操作，例如如下的例子中，sscanf(“A23CD”, “%x”, &amp;a);<br>“%x”是将字符串A23CD以十六进制形式输入a中，如果将”%x”换成为”%d”的话，就是将字符串A23CD以十进制形式输入a中，这显然是错误的，因为将A23CD转换为十进制的时候，无法解析A，CD等字符，所以得出的结果就是错误的。</p></blockquote><h6 id="使用场景（略）"><a href="#使用场景（略）" class="headerlink" title="使用场景（略）"></a>使用场景（略）</h6><h6 id="步骤：-2"><a href="#步骤：-2" class="headerlink" title="步骤："></a>步骤：</h6><ol><li>将以字符串形式的十六进制数转换为整型的十六进制。</li><li><del>再将16进制数据以16进制的权重类加起来</del>。</li><li>这里因为获取的16进制数据已经存放在整型变量当中了，所以没必要通过通过16进制权重进行累加计算。</li></ol><h6 id="代码如下：-2"><a href="#代码如下：-2" class="headerlink" title="代码如下："></a>代码如下：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">int a;</span><br><span class="line">sscanf(&quot;A23CD&quot;, &quot;%x&quot;, &amp;a);</span><br><span class="line">printf(&quot;%x\n&quot;,a);</span><br><span class="line">printf(&quot;%d\n&quot;,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="执行代码如下：-1"><a href="#执行代码如下：-1" class="headerlink" title="执行代码如下："></a>执行代码如下：</h6><p><img src="/2019/11/10/C%E8%AF%AD%E8%A8%80-10%E8%BF%9B%E5%88%B6%E4%B8%8E16%E8%BF%9B%E5%88%B6%E7%9A%84%E4%BA%92%E8%BD%AC/3.jpg" alt="3"></p><h5 id="16进制转10进制-使用sprintf函数最终显示10进制数据字符串"><a href="#16进制转10进制-使用sprintf函数最终显示10进制数据字符串" class="headerlink" title="16进制转10进制-使用sprintf函数最终显示10进制数据字符串"></a>16进制转10进制-使用sprintf函数最终显示10进制数据字符串</h5><h6 id="应用场景：-2"><a href="#应用场景：-2" class="headerlink" title="应用场景："></a>应用场景：</h6><p>16进制数据转10进制，最终得到的是一个10进制的字符串，很简单，不需要再经过itoa转换了。</p><h6 id="步骤：-3"><a href="#步骤：-3" class="headerlink" title="步骤："></a>步骤：</h6><p>直接利用sprintf函数进行格式化转换，然后打印到内存中即可</p><h6 id="代码如下：-3"><a href="#代码如下：-3" class="headerlink" title="代码如下："></a>代码如下：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">short port_Num = 0x2AEE;</span><br><span class="line">char str[6] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">sprintf(str, &quot;%d&quot;, port_Num);</span><br><span class="line">printf(&quot;10进制数据字符串:%s\n&quot;,str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="执行代码如下：-2"><a href="#执行代码如下：-2" class="headerlink" title="执行代码如下："></a>执行代码如下：</h6><p><img src="/2019/11/10/C%E8%AF%AD%E8%A8%80-10%E8%BF%9B%E5%88%B6%E4%B8%8E16%E8%BF%9B%E5%88%B6%E7%9A%84%E4%BA%92%E8%BD%AC/4.jpg" alt="4"></p><h4 id="10进制转16进制"><a href="#10进制转16进制" class="headerlink" title="10进制转16进制"></a>10进制转16进制</h4><h5 id="10进制转16进制-sprintf函数最终显示16进制数据字符串"><a href="#10进制转16进制-sprintf函数最终显示16进制数据字符串" class="headerlink" title="10进制转16进制- sprintf函数最终显示16进制数据字符串"></a>10进制转16进制- sprintf函数最终显示16进制数据字符串</h5><h6 id="应用场景：-3"><a href="#应用场景：-3" class="headerlink" title="应用场景："></a>应用场景：</h6><p>10进制数据转换成16进制数据，而且是一个16进制的字符串</p><h6 id="步骤：-4"><a href="#步骤：-4" class="headerlink" title="步骤："></a>步骤：</h6><ol><li>定义一个char型数组，用于存放16进制的字符串</li><li>利用sprintf函数将得到的10进制整型数，进行16进制格式化<h6 id="代码如下：-4"><a href="#代码如下：-4" class="headerlink" title="代码如下："></a>代码如下：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">char buffer[33];//用于存放转换好的16进制字符串，可根据需要定义长度</span><br><span class="line">char* int2hex(int NUM)</span><br><span class="line">&#123;</span><br><span class="line">sprintf(buffer,&quot;%X&quot;, NUM);</span><br><span class="line">return(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int num;</span><br><span class="line">char* hex_str;</span><br><span class="line">printf(&quot;Enter a number:&quot;);</span><br><span class="line">scanf(&quot;%d&quot;,&amp;num);</span><br><span class="line">hex_str = int2hex(num);</span><br><span class="line">printf(&quot;Hexadecimal number:0x%s\n&quot;,hex_str);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="执行代码如下：-3"><a href="#执行代码如下：-3" class="headerlink" title="执行代码如下："></a>执行代码如下：</h6><img src="/2019/11/10/C%E8%AF%AD%E8%A8%80-10%E8%BF%9B%E5%88%B6%E4%B8%8E16%E8%BF%9B%E5%88%B6%E7%9A%84%E4%BA%92%E8%BD%AC/5.jpg" alt="5"></li></ol><h5 id="10进制转16进制-自己编写"><a href="#10进制转16进制-自己编写" class="headerlink" title="10进制转16进制-自己编写"></a>10进制转16进制-自己编写</h5><h6 id="应用场景：-4"><a href="#应用场景：-4" class="headerlink" title="应用场景："></a>应用场景：</h6><h6 id="步骤：-5"><a href="#步骤：-5" class="headerlink" title="步骤："></a>步骤：</h6><ol><li>先将输入的十进制数除以16得到商和余数。</li><li>再将得到的商继续除以16得到商和余数，以此类推直到商为0为止。</li><li>然后将所得余数顺序存入一个数组，再将这个数组倒序通过switch语句依次转成十六进制数存入一个字符串数组，最后顺序输出即可。<h6 id="代码如下：-5"><a href="#代码如下：-5" class="headerlink" title="代码如下："></a>代码如下：</h6></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;                  //输入的十进制数</span><br><span class="line">    int i;</span><br><span class="line">    int index = 0;          //记录输入的十进制数的长度</span><br><span class="line">    int len = 0;            //记录十六进制数组的长度</span><br><span class="line">    int remainder[200];     //存储余数</span><br><span class="line">    char sixteen[200];      //存储转换后的十六进制数</span><br><span class="line">printf(&quot;输入一个10进制数:&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    if(n == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        remainder[0] = 0;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        for(i = 0; n &gt; 0; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            remainder[i] = n % 16;</span><br><span class="line">            n /= 16;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i = index - 1; i &gt;= 0; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        switch(remainder[i])</span><br><span class="line">        &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                sixteen[len++] = &apos;0&apos;;</span><br><span class="line">            break;</span><br><span class="line">            case 1:</span><br><span class="line">                sixteen[len++] = &apos;1&apos;;</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                sixteen[len++] = &apos;2&apos;;</span><br><span class="line">                break;</span><br><span class="line">            case 3:</span><br><span class="line">                sixteen[len++] = &apos;3&apos;;</span><br><span class="line">                break;</span><br><span class="line">            case 4:</span><br><span class="line">                sixteen[len++] = &apos;4&apos;;</span><br><span class="line">                break;</span><br><span class="line">            case 5:</span><br><span class="line">                sixteen[len++] = &apos;5&apos;;</span><br><span class="line">                break;</span><br><span class="line">            case 6:</span><br><span class="line">                sixteen[len++] = &apos;6&apos;;</span><br><span class="line">                break;</span><br><span class="line">            case 7:</span><br><span class="line">                sixteen[len++] = &apos;7&apos;;</span><br><span class="line">                break;</span><br><span class="line">            case 8:</span><br><span class="line">                sixteen[len++] = &apos;8&apos;;</span><br><span class="line">                break;</span><br><span class="line">            case 9:</span><br><span class="line">                sixteen[len++] = &apos;9&apos;;</span><br><span class="line">                break;</span><br><span class="line">            case 10:</span><br><span class="line">                sixteen[len++] = &apos;A&apos;;</span><br><span class="line">                break;</span><br><span class="line">            case 11:</span><br><span class="line">                sixteen[len++] = &apos;B&apos;;</span><br><span class="line">                break;</span><br><span class="line">            case 12:</span><br><span class="line">                sixteen[len++] = &apos;C&apos;;</span><br><span class="line">                break;</span><br><span class="line">            case 13:</span><br><span class="line">                sixteen[len++] = &apos;D&apos;;</span><br><span class="line">                break;</span><br><span class="line">            case 14:</span><br><span class="line">                sixteen[len++] = &apos;E&apos;;</span><br><span class="line">                break;</span><br><span class="line">            case 15:</span><br><span class="line">                sixteen[len++] = &apos;F&apos;;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;16进制字符串:&quot;);</span><br><span class="line">    for(i = 0; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%c&quot;,sixteen[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="执行代码如下：-4"><a href="#执行代码如下：-4" class="headerlink" title="执行代码如下："></a>执行代码如下：</h6><p><img src="/2019/11/10/C%E8%AF%AD%E8%A8%80-10%E8%BF%9B%E5%88%B6%E4%B8%8E16%E8%BF%9B%E5%88%B6%E7%9A%84%E4%BA%92%E8%BD%AC/6.jpg" alt="6"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;所谓的10进制数据和16进制数据本质上都是2进制数据，下面的显示大多最终还是以字符串的形式显示出来的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;16进制转10进制&quot;&gt;&lt;a href=&quot;#16进制转10进制&quot; class=&quot;headerlink&quot; title=&quot;16进制转10进制&quot;&gt;&lt;/a&gt;16进制转10进制&lt;/h4&gt;&lt;h5 id=&quot;16进制转10进制-大端数组显示&quot;&gt;&lt;a href=&quot;#16进制转10进制-大端数组显示&quot; class=&quot;headerlink&quot; title=&quot;16进制转10进制-大端数组显示&quot;&gt;&lt;/a&gt;16进制转10进制-大端数组显示&lt;/h5&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://www.faihung.net/categories/C/"/>
    
    
      <category term="sprintf" scheme="http://www.faihung.net/tags/sprintf/"/>
    
      <category term="16进制转10进制" scheme="http://www.faihung.net/tags/16%E8%BF%9B%E5%88%B6%E8%BD%AC10%E8%BF%9B%E5%88%B6/"/>
    
      <category term="10进制转16进制" scheme="http://www.faihung.net/tags/10%E8%BF%9B%E5%88%B6%E8%BD%AC16%E8%BF%9B%E5%88%B6/"/>
    
      <category term="sscanf" scheme="http://www.faihung.net/tags/sscanf/"/>
    
  </entry>
  
  <entry>
    <title>Camera-摄像头工作原理（转载）</title>
    <link href="http://www.faihung.net/2019/11/09/Camera-%E6%91%84%E5%83%8F%E5%A4%B4%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
    <id>http://www.faihung.net/2019/11/09/Camera-摄像头工作原理（转载）/</id>
    <published>2019-11-09T13:13:43.000Z</published>
    <updated>2019-11-09T13:18:18.675Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>回想这工作的这几年，尝尽社会的辛酸艰难，从一开始什么都没有到30万，从30万到200万，从200万到1300万，不是炫耀，我只是想通过我自己的经历告诉我的朋友们「手机像素越高，拍的照片越清晰」</p></blockquote><a id="more"></a><h5 id="摄像头结构"><a href="#摄像头结构" class="headerlink" title="摄像头结构"></a>摄像头结构</h5><p><img src="/2019/11/09/Camera-%E6%91%84%E5%83%8F%E5%A4%B4%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/1.png" alt="1"></p><p><img src="/2019/11/09/Camera-%E6%91%84%E5%83%8F%E5%A4%B4%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/2.png" alt="2"></p><p>我初中的时候，有一次我考了年级第7名，学校奖励了 200块钱，我当时非常开心，第一时间就想去买一个照相机，我想把自己那时看到的画面都记录下来，可惜的是，我看上那个最便宜的也要两百多，然后我妈跟我说先把钱存她那里，等过阵子有钱了再给我买，然后，你可能想知道然后怎么了，然后就没有然后了，我最开始的照相机就是大学的时候，我哥给我买的那个大块头手机，铃声一响起来，一头熟睡的母猪都能被吵醒。</p><p>最开始的照相机是那种手动对焦的，就是转动马达让感光芯片能接收到最好的信号，俗称对焦。</p><p><img src="/2019/11/09/Camera-%E6%91%84%E5%83%8F%E5%A4%B4%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/3.png" alt="3"></p><h5 id="最原始的Camera成像原理"><a href="#最原始的Camera成像原理" class="headerlink" title="最原始的Camera成像原理"></a>最原始的Camera成像原理</h5><p>说起成像原理，我们不得不说小孔成像，就是有了小孔成像，我们才有了相机这么神奇的东西。</p><p>小孔成像是是比较古老的方式了，随着现在技术的发展，已经使用了新的方式替代小孔成像，因为小孔成像的孔很小，也造成了拍摄存在很多局限性。</p><p><img src="/2019/11/09/Camera-%E6%91%84%E5%83%8F%E5%A4%B4%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/4.png" alt="4"></p><h5 id="现代Camera-工作原理"><a href="#现代Camera-工作原理" class="headerlink" title="现代Camera 工作原理"></a>现代Camera 工作原理</h5><p>camera工作原理是外部光线穿过 lens 后， 经过 color filter 滤波后照射到 Sensor 面上， Sensor 将从 lens 上传导过来的光线转换为电信号，再通过内部的 AD 转换为数字信号。如果 Sensor 没有集 成 DSP，则通过 DVP 的方式传输到baseband，此时的数据格式是 RAW DATA。如果集成 了 DSP， RAW DATA 数据经过 AWB、 则 color matrix、 lens shading、 gamma、 sharpness、 AE 和 de-noise 处理（手机一般在cpu isp端做），后输出 YUV 或者 RGB 格式的数据。最后会由 CPU 送到 framebuffer 中进行显示，这样我们就看到 camera 拍摄到的景象了。</p><p><img src="/2019/11/09/Camera-%E6%91%84%E5%83%8F%E5%A4%B4%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/5.png" alt="5"></p><p>我们先用眼睛通过目镜确定当前拍摄的这个人是不是一个靓仔，然后呢，让这个靓仔做一个比较帅点的姿势，然后按下快门就，挡光板抬起，把光线照到感光器上，感光器是一个模拟图片，通过ADC转换数字信号，存储到存储芯片上。</p><p><img src="/2019/11/09/Camera-%E6%91%84%E5%83%8F%E5%A4%B4%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/6.png" alt="6"></p><h5 id="Camera硬件原理图"><a href="#Camera硬件原理图" class="headerlink" title="Camera硬件原理图"></a>Camera硬件原理图</h5><p>硬件原理图分析</p><p><img src="/2019/11/09/Camera-%E6%91%84%E5%83%8F%E5%A4%B4%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/7.png" alt="7"></p><p><strong>POWER:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VDD_CAMA28   ----2.8v   camera的模拟电压</span><br><span class="line">VDD_CAMD28   ----1.5v   camera的工作电压</span><br><span class="line">VDD_CAMIO28  ----2.8v   camera的GPIO口数字电压</span><br></pre></td></tr></table></figure><p><strong>OUTPUT:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CAM_DATA: camera的数据管脚。此数据脚可以输出的格式有YUV、RGB、JPEG</span><br><span class="line"></span><br><span class="line">CAM_VSYNC: camera的帧同步信号管脚。一个VYSNC信号结束表示一帧（即一个画面）的数据已经输出完毕</span><br><span class="line"></span><br><span class="line">CAM_HSYNC: camera行同步信号管脚。一个HSYNC信号结束表示一行的数据已经输出完毕</span><br><span class="line"></span><br><span class="line">CAM_PCLK: 像素同步信号管脚。一个PCLK信号结束表示一个数据已经输出完毕</span><br></pre></td></tr></table></figure><p><strong>INPUT:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CAM_PWDN:  camera的使能管脚，当camera处于PWDN模式时，一切对camera的操作都是无效的，因此，在RST之前，一定要将PWDN管脚置为normal模式</span><br><span class="line"></span><br><span class="line">CAM_RST:  camera的复位管脚。此方式为硬复位模式，一般管脚置为低，camera处于硬复位状态，camera的各个IO口恢复到出厂默认状态。只有在XCLK开启后，将RESET置为低，硬复位才有效，否则复位无效。</span><br><span class="line"></span><br><span class="line">CAM_MCLK:  camera工作时钟管脚。此管脚为主控提供camera的工作时钟</span><br><span class="line"></span><br><span class="line">CAM_I2C:  camera与主控的通信管脚 Camera主要的通信接口是i2c，数据传输是mipi</span><br></pre></td></tr></table></figure><p><strong>我们在软件调试时，camera大致流程：</strong></p><p>第一步，给sensor进行上电和输出时钟信号；</p><p>第二步，然后通过i2c进行通信，通过发送地址，cpu查找camera；</p><p>第三步，在打开camera时，通过i2c下发，对sensor寄存器进行适配和准备工作；</p><p>第四步，camera数据输出，通过mipi给到cpu端进行采集；</p><h5 id="Sensor类型"><a href="#Sensor类型" class="headerlink" title="Sensor类型"></a>Sensor类型</h5><h6 id="1-常见的摄像头传感器类型主要有两种"><a href="#1-常见的摄像头传感器类型主要有两种" class="headerlink" title="1. 常见的摄像头传感器类型主要有两种"></a>1. 常见的摄像头传感器类型主要有两种</h6><p><strong>CCD（Chagre Couled Device）</strong>，即电荷耦合器，目前被广泛应用于大部分数码相机上，这是一种特殊的半导体材料，它由大量独立的光敏元件组成，这些光敏元件通常按矩阵排列。光线透过镜头照射到CCD上，并转换成电荷，每个元件上的电荷量取决于其受到的光照强度。当摄影者按动快门时，CCD可将各个元件的信息传送到模/数转换器上，然后将模拟电信号转变为数字信号，数字信号再以一定的格式压缩后存入缓存内，这样就完成了数码相片的整个拍摄。</p><p><strong>CMOS（Complementary Metal-Oxide-Semiconductor）</strong>，即互补金属氧化物半导体，它在微处理器和闪存等半导体技术上占有重要的地位，也是一种可用来感受光线变化的半导体，其组成元素主要是硅和锗，通过CMOS上带负电和带正电的晶体管来实现基本功能。这两个互补效应所产生的电流即可被处理芯片记录和解读成影像。由于CMOS结构相对简单，与现有的大规模集成电路生产工艺相同，从而生产成本可以降低，理论上讲，CMOS的信号是以点为单位的电荷信号，CCD是以行为单位的电流信号，相比较而言，前者更为敏感、速度更快、更为省电。目前CMOS技术发展还不成熟，这种高质量的CMOS还只应用于一些专业的数码相机上，而在一些低档数码相机上常使用廉价低档的CMOS，成像质量一般比较差。所以目前要购买消费级数码相机的话，建议用户最好选择以CCD为影像传感器的产品</p><h6 id="2-图像采集数据的模式有两种"><a href="#2-图像采集数据的模式有两种" class="headerlink" title="2. 图像采集数据的模式有两种"></a>2. 图像采集数据的模式有两种</h6><p>Color Filter Array—CFA 图像传感器都采用一定的模式来采集图像数据，常用的有 BGR 模式和 CFA 模式。</p><p><strong>BGR 模式：</strong><br>BGR 模式是一种可直接进行显示和压缩等处理的图像数据模式，它由 R( 红)、G( 绿) 、B( 蓝) 三原色值来共同确定 1 个像素点，例如富士数码相机采用的 SUPER CCD 图像传感器就采用这种模式，其优点是图像传感器产生的图像数据无需插值就可直接进行显示等后续处理，图像效果最好，但是成本高，常用于专业相机中。</p><p><strong>CFA 模式：</strong><br>为了减少成本，缩小体积，市场上的数码相机大多采用 CFA 模式，即在像素阵列的表面覆盖一层彩色滤波阵列（Color Filter Array，CFA），彩色滤波阵列有多种，现在应用最广泛的是 Bayer 格式滤波阵列，满足 GRBG 规律，绿色像素数是红色或蓝色像素数的两倍，这是因为人眼对可见光光谱敏感度的峰值位于中波段，这正好对应着绿色光谱成分。在该模式下图像数据只用R, G, B三个值中的一个值来表示一个像素点，而缺失另外两个颜色值，这时得到的是一副马赛克图片，为了得到全彩色的图像，需要使用其周围像素点的色彩信息来估计缺失的另外两种颜色，这种处理叫做色彩插值。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;回想这工作的这几年，尝尽社会的辛酸艰难，从一开始什么都没有到30万，从30万到200万，从200万到1300万，不是炫耀，我只是想通过我自己的经历告诉我的朋友们「手机像素越高，拍的照片越清晰」&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Camera" scheme="http://www.faihung.net/categories/Camera/"/>
    
    
      <category term="摄像头" scheme="http://www.faihung.net/tags/%E6%91%84%E5%83%8F%E5%A4%B4/"/>
    
  </entry>
  
  <entry>
    <title>cURL-04_基于libcurl库的开发</title>
    <link href="http://www.faihung.net/2019/11/06/cURL-04-%E5%9F%BA%E4%BA%8Elibcurl%E5%BA%93%E7%9A%84%E5%BC%80%E5%8F%91/"/>
    <id>http://www.faihung.net/2019/11/06/cURL-04-基于libcurl库的开发/</id>
    <published>2019-11-06T14:36:01.000Z</published>
    <updated>2019-11-06T14:37:30.283Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>libcurl是一个简单易用的基于URL传输的客户端开发库，支持多种平台以及三十多种开发语言绑定。libcurl是线程安全的，兼容IPv6，功能强大且运行效率高，很多知名公司如Google、Adobe的产品都应用过libcurl。</p></blockquote><p>做libcurl开发，需要将静态库文件加到编译链接环境中，并且要dll动态运行库支持。</p><a id="more"></a><h5 id="1-关于curl-global-init-和curl-global-cleanup"><a href="#1-关于curl-global-init-和curl-global-cleanup" class="headerlink" title="1. 关于curl_global_init()和curl_global_cleanup()"></a>1. 关于curl_global_init()和curl_global_cleanup()</h5><p>libcurl提供了一组C语言API函数直接调用。首先需要提到的两个函数就是curl_global_init()和curl_global_cleanup()。</p><p>libcurl要用到一系列的全局常量，curl_global_init()函数就是初始化这些变量，并分配一些全局资源；curl_global_cleanup()则负责释放这些资源。因此一般情况下，在调用libcurl函数之前，先用curl_global_init(CURL_GLOBAL_ALL)做初始化，在调用完毕后，用curl_global_cleanup()退出。</p><p>需要注意的是，这些全局变量和资源并不是线程安全的，因此，在多线程应用的环境中，最好不要多次调用curl_global_init()和curl_global_cleanup()，调用其他函数并不会改变这些全局变量和资源。</p><h5 id="2-调用方式"><a href="#2-调用方式" class="headerlink" title="2. 调用方式"></a>2. 调用方式</h5><p>libcurl支持3种不同的接口调用方式，分别是”easy”、”multi”和”share”模式。</p><p>libcurl-easy是一组同步接口，函数都是curl_easy_*形式，这种模式调用curl_easy_perform()函数进行URL数据传输，直到传输完成函数才返回；</p><p>libcurl-multi是一组异步接口，函数都是curl_multi_*形式，调用curl_multi_perform()函数进行传输，但是每次调用只传一片数据，我们可以用select()函数控制多个下载任务进行同步下载，来实现在一个线程中同时下载多个文件；</p><p>libcurl-share允许在多线程中操作共享数据。下面以libcurl-easy为例讲一下libcurl的函数。</p><h6 id="1-CURL-curl-easy-init"><a href="#1-CURL-curl-easy-init" class="headerlink" title="1. CURL *curl_easy_init()"></a>1. CURL *curl_easy_init()</h6><blockquote><p>此函数需要最先被调用，返回CRUL easy句柄；后续其他函数调用都要用到这个句柄。如果没有调用curl_global_init()，该函数自动调用，但是考虑到线程安全的问题，最好自己调用curl_global_init()。</p></blockquote><h6 id="2-CURLcode-curl-easy-setopt-CURL-handle-CURLoption-option-parameter"><a href="#2-CURLcode-curl-easy-setopt-CURL-handle-CURLoption-option-parameter" class="headerlink" title="2. CURLcode curl_easy_setopt(CURL *handle, CURLoption option, parameter)"></a>2. CURLcode curl_easy_setopt(CURL *handle, CURLoption option, parameter)</h6><blockquote><p>所有参数和选项设置都是通过这个函数完成的，它告诉libcurl怎样去进行传输。参数handle即为curl_easy_init()返回的句柄，后面根据option的类型，设置相应的parameter值，该函数每次调用只能设置一个选项。</p></blockquote><p>这里只总结一下与下载有关的常用选项设置。</p><pre><code>CURLOPT_URL</code></pre><p>字符串类型，该选项设置要处理的URL地址，该选项是进行curl_easy_perform之前唯一必须要设置的选项。</p><pre><code>CURLOPT_COOKIE</code></pre><p>字符串类型，设置http头中的cookie信息。</p><pre><code>CURLOPT_COOKIEFILE</code></pre><p>字符串类型，同CURLOPT_COOKIE，不过cookie信息从文件中读取。</p><pre><code>CURLOPT_FOLLOWLOCATION  </code></pre><p>布尔值类型，该参数设置为非零值表示follow服务器返回的重定向信息。</p><pre><code>CURLOPT_POSTFIELDS</code></pre><p>字符串类型，提交http的post操作字符串数据。</p><pre><code>CURLOPT_TIMEOUT</code></pre><p>long数值类型，设置函数执行的最长时间，时间单位为s。</p><pre><code>CURLOPT_CONNECTTIMEOUT</code></pre><p>long数值类型，设置连接服务器最长时间，时间单位为s；当置为0时表示无限长。</p><pre><code>CURLOPT_MAX_RECV_SPEED_LARGE</code></pre><p>curl_off_t类型数据，指定下载过程中最大速度，单位bytes/s。</p><pre><code>CURLOPT_HEADERFUNCTION</code></pre><p>函数指针类型，该选项设置一个处理接收到的header数据的回调函数，函数原型为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_t function( void *ptr, size_t size, size_t nmemb, void *stream)；</span><br></pre></td></tr></table></figure><p>其中，ptr指向接收到的header头数据，数据大小为size*nmemb，stream指向调用CURLOPT_WRITEHEADER选项设置的参数。该回调函数应返回实际处理的数据量大小，或者出错返回-1。</p><pre><code>CURLOPT_WRITEFUNCTION</code></pre><p>函数指针类型，该选项设置一个处理接收到的下载数据的回调函数，函数原型为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_t function( void *ptr, size_t size, size_t nmemb, void *stream);</span><br></pre></td></tr></table></figure><p>其中，ptr指向接收到的数据，数据大小为size*nmemb，stream指向调用CURLOPT_WRITEDATA选项设置的参数。</p><p>如果函数指针置为NULL，则会调用默认的函数，将数据写入到由CURLOPT_WRITEDATA指定的FILE*中。</p><pre><code>CURLOPT_HTTPHEADER</code></pre><p>curl_slist结构体类型，该选项自定义请求头信息。</p><pre><code>CURLOPT_NOPROGRESS</code></pre><p>布尔值类型，设置该值为非零值关闭PHP为CRUL传输显示的进度条。</p><h6 id="3-void-curl-easy-reset-CURL-handle"><a href="#3-void-curl-easy-reset-CURL-handle" class="headerlink" title="3. void curl_easy_reset(CURL *handle )"></a>3. void curl_easy_reset(CURL *handle )</h6><p>重新初始化CURL句柄的选项设置。</p><h6 id="4-CURLcode-curl-easy-getinfo-CURL-curl-CURLINFO-info-…"><a href="#4-CURLcode-curl-easy-getinfo-CURL-curl-CURLINFO-info-…" class="headerlink" title="4. CURLcode curl_easy_getinfo(CURL *curl, CURLINFO info, … )"></a>4. CURLcode curl_easy_getinfo(CURL *curl, CURLINFO info, … )</h6><p>查询CRUL会话的内部信息，具体说明请参考curl自带文档。</p><h6 id="5-void-curl-easy-cleanup-CURL-handle"><a href="#5-void-curl-easy-cleanup-CURL-handle" class="headerlink" title="5. void curl_easy_cleanup(CURL * handle )"></a>5. void curl_easy_cleanup(CURL * handle )</h6><p>该函数与curl_easy_init函数成对出现，handle即为调用curl_easy_init返回的句柄。该函数在CURL会话结束退出时调用，之后handle无效。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;libcurl是一个简单易用的基于URL传输的客户端开发库，支持多种平台以及三十多种开发语言绑定。libcurl是线程安全的，兼容IPv6，功能强大且运行效率高，很多知名公司如Google、Adobe的产品都应用过libcurl。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;做libcurl开发，需要将静态库文件加到编译链接环境中，并且要dll动态运行库支持。&lt;/p&gt;
    
    </summary>
    
    
      <category term="cURL" scheme="http://www.faihung.net/categories/cURL/"/>
    
    
      <category term="cURL" scheme="http://www.faihung.net/tags/cURL/"/>
    
  </entry>
  
  <entry>
    <title>cURL-02_在命令行中使用cURL</title>
    <link href="http://www.faihung.net/2019/11/03/cURL-02-%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E4%BD%BF%E7%94%A8cURL/"/>
    <id>http://www.faihung.net/2019/11/03/cURL-02-在命令行中使用cURL/</id>
    <published>2019-11-03T15:38:29.000Z</published>
    <updated>2019-11-03T15:40:24.521Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、获取和安装-cURL-libcurl"><a href="#一、获取和安装-cURL-libcurl" class="headerlink" title="一、获取和安装 cURL/libcurl"></a>一、获取和安装 cURL/libcurl</h4><p>获取和安装 libcurl 非常简单，取决于您所运行的 Linux 发行版。如果运行的是 Ubuntu，您可以使用 apt-get轻松安装这些包。以下行演示了如何为 libcurl 安装 libcurl 和 Python 绑定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libcurl3</span><br><span class="line">$ sudo apt-get install python-pycurl</span><br></pre></td></tr></table></figure><blockquote><p>apt-get实用工具确保该过程满足所有的依赖关系。</p></blockquote><a id="more"></a><h4 id="二、相对简单的用法"><a href="#二、相对简单的用法" class="headerlink" title="二、相对简单的用法"></a>二、相对简单的用法</h4><h5 id="1-从百度的网页服务器上获得该网站的主页："><a href="#1-从百度的网页服务器上获得该网站的主页：" class="headerlink" title="1. 从百度的网页服务器上获得该网站的主页："></a>1. 从百度的网页服务器上获得该网站的主页：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://www.baidu.com/</span><br></pre></td></tr></table></figure><p>如果要把这个网页保存下来，可以使用<code>-o</code>参数，这就相当于使用wget命令了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -o [文件名] www.baidu.com</span><br></pre></td></tr></table></figure><h5 id="2-自动跳转"><a href="#2-自动跳转" class="headerlink" title="2. 自动跳转"></a>2. 自动跳转</h5><p>有的网址是自动跳转的。使用<code>-L</code>参数，curl就会跳转到新的网址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L www.baidu.com</span><br></pre></td></tr></table></figure><p>输入上面的命令，结果就自动跳转为<a href="http://www.baidu.com。" target="_blank" rel="noopener">www.baidu.com。</a></p><h5 id="3-显示头信息"><a href="#3-显示头信息" class="headerlink" title="3. 显示头信息"></a>3. 显示头信息</h5><p><code>-i</code>参数可以显示http response的头信息，连同网页代码一起。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i www.baidu.com</span><br></pre></td></tr></table></figure><p><code>-I</code>参数则是只显示http response的头信息。</p><h5 id="4-显示通信过程"><a href="#4-显示通信过程" class="headerlink" title="4. 显示通信过程"></a>4. 显示通信过程</h5><p><code>-v</code>参数可以显示一次http通信的整个过程，包括端口连接和http request头信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -v www.baidu.com</span><br></pre></td></tr></table></figure><p>如果你觉得上面的信息还不够，那么下面的命令可以查看更详细的通信过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --trace output.txt www.baidu.com</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --trace-ascii output.txt www.baidu.com</span><br></pre></td></tr></table></figure><p>运行后，请打开output.txt文件查看。</p><h5 id="5-发送表单信息"><a href="#5-发送表单信息" class="headerlink" title="5. 发送表单信息"></a>5. 发送表单信息</h5><p>发送表单信息有GET和POST两种方法。GET方法相对简单，只要把数据附在网址后面就行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl example.com/form.cgi?data=xxx</span><br></pre></td></tr></table></figure><p>POST方法必须把数据和网址分开，curl就要用到–data参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X POST --data &quot;data=xxx&quot; example.com/form.cgi</span><br></pre></td></tr></table></figure><p>如果你的数据没有经过表单编码，还可以让curl为你编码，参数是<code>--data-urlencode</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X POST--data-urlencode &quot;date=April 1&quot; example.com/form.cgi</span><br></pre></td></tr></table></figure><h5 id="6-HTTP动词"><a href="#6-HTTP动词" class="headerlink" title="6. HTTP动词"></a>6. HTTP动词</h5><p>curl默认的HTTP动词是GET，使用<code>-X</code>参数可以支持其他动词。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X POST www.example.com</span><br><span class="line">$ curl -X DELETE www.example.com</span><br></pre></td></tr></table></figure><h5 id="7-文件上传"><a href="#7-文件上传" class="headerlink" title="7. 文件上传"></a>7. 文件上传</h5><p>假定文件上传的表单是下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=&quot;POST&quot; enctype=&apos;multipart/form-data&apos; action=&quot;upload.cgi&quot;&gt;</span><br><span class="line">&lt;input type=file name=upload&gt;</span><br><span class="line">&lt;input type=submit name=press value=&quot;OK&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>你可以用curl这样上传文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --form upload=@localfilename --form press=OK [URL]</span><br></pre></td></tr></table></figure><h5 id="8-Referer字段"><a href="#8-Referer字段" class="headerlink" title="8. Referer字段"></a>8. Referer字段</h5><p>有时你需要在http request头信息中，提供一个referer字段，表示你是从哪里跳转过来的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --referer http://www.example.com http://www.example.com</span><br></pre></td></tr></table></figure><h5 id="9-User-Agent字段"><a href="#9-User-Agent字段" class="headerlink" title="9. User Agent字段"></a>9. User Agent字段</h5><p>这个字段是用来表示客户端的设备信息。服务器有时会根据这个字段，针对不同设备，返回不同格式的网页，比如手机版和桌面版。</p><p>iPhone4的User Agent是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_0 like Mac OS X; en-us) AppleWebKit/532.9 (KHTML, like Gecko) Version/4.0.5 Mobile/8A293 Safari/6531.22.7</span><br></pre></td></tr></table></figure><p>curl可以这样模拟：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --user-agent &quot;[User Agent]&quot; [URL]</span><br></pre></td></tr></table></figure><h5 id="10-cookie"><a href="#10-cookie" class="headerlink" title="10. cookie"></a>10. cookie</h5><p>使用<code>--cookie</code>参数，可以让curl发送cookie。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --cookie &quot;name=xxx&quot; www.example.com</span><br></pre></td></tr></table></figure><p>至于具体的cookie的值，可以从http response头信息的<code>Set-Cookie</code>字段中得到。</p><p><code>-c cookie-file</code>可以保存服务器返回的cookie到文件，<code>-b cookie-file</code>可以使用这个文件作为cookie信息，进行后续的请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -c cookies http://example.com</span><br><span class="line">$ curl -b cookies http://example.com</span><br></pre></td></tr></table></figure><h5 id="11-增加头信息"><a href="#11-增加头信息" class="headerlink" title="11. 增加头信息"></a>11. 增加头信息</h5><p>有时需要在http request之中，自行增加一个头信息。<code>--header</code>参数就可以起到这个作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --header &quot;Content-Type:application/json&quot; http://example.com</span><br></pre></td></tr></table></figure><h5 id="12-HTTP认证"><a href="#12-HTTP认证" class="headerlink" title="12. HTTP认证"></a>12. HTTP认证</h5><p>有些网域需要HTTP认证，这时curl需要用到<code>--user</code>参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --user name:password example.com</span><br></pre></td></tr></table></figure><h5 id="13-cURL还有很多命令行操作，这里就不作陈诉了。"><a href="#13-cURL还有很多命令行操作，这里就不作陈诉了。" class="headerlink" title="13. cURL还有很多命令行操作，这里就不作陈诉了。"></a>13. cURL还有很多命令行操作，这里就不作陈诉了。</h5>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、获取和安装-cURL-libcurl&quot;&gt;&lt;a href=&quot;#一、获取和安装-cURL-libcurl&quot; class=&quot;headerlink&quot; title=&quot;一、获取和安装 cURL/libcurl&quot;&gt;&lt;/a&gt;一、获取和安装 cURL/libcurl&lt;/h4&gt;&lt;p&gt;获取和安装 libcurl 非常简单，取决于您所运行的 Linux 发行版。如果运行的是 Ubuntu，您可以使用 apt-get轻松安装这些包。以下行演示了如何为 libcurl 安装 libcurl 和 Python 绑定：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo apt-get install libcurl3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo apt-get install python-pycurl&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;apt-get实用工具确保该过程满足所有的依赖关系。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="cURL" scheme="http://www.faihung.net/categories/cURL/"/>
    
    
      <category term="cURL" scheme="http://www.faihung.net/tags/cURL/"/>
    
  </entry>
  
  <entry>
    <title>cURL-03-cURL的几种语言支持</title>
    <link href="http://www.faihung.net/2019/11/03/cURL-03-cURL%E7%9A%84%E5%87%A0%E7%A7%8D%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81/"/>
    <id>http://www.faihung.net/2019/11/03/cURL-03-cURL的几种语言支持/</id>
    <published>2019-11-03T15:38:29.000Z</published>
    <updated>2019-11-05T15:39:18.469Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一、基于-C-的-HTTP-客户端"><a href="#一、基于-C-的-HTTP-客户端" class="headerlink" title="一、基于 C 的 HTTP 客户端"></a>一、基于 C 的 HTTP 客户端</h5><p>C API 在 libcurl 功能上提供了两个 API。easy 接口是一个简单的同步 API（意味着当您使用请求调用 libcurl 时，将能够满足您的请求，直到完成或发生错误）。多接口可以进一步控制 libcurl，您的应用程序可以执行多个同步传输，并控制 libcurl 何时何地移动数据。</p><p>该示例使用 easy 接口。该 API 还能控制数据移动过程（使用回调），但正如其名称所示，使用起来非常简单。下面请看HTTP 的 C 语言示例,使用 libcurl easy 接口的 C HTTP 客户端。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">#include &lt;string.h&gt; </span><br><span class="line">#include &lt;curl/curl.h&gt; </span><br><span class="line"> </span><br><span class="line">#define MAX_BUF     65536 </span><br><span class="line"> </span><br><span class="line">char wr_buf[MAX_BUF+1]; </span><br><span class="line">int  wr_index; </span><br><span class="line"> </span><br><span class="line">/* </span><br><span class="line">* Write data callback function (called within the context of </span><br><span class="line">* curl_easy_perform. </span><br><span class="line">*/ </span><br><span class="line">size_t write_data( void *buffer, size_t size, size_t nmemb, void *userp ) </span><br><span class="line">&#123; </span><br><span class="line"> int segsize = size * nmemb; </span><br><span class="line"> </span><br><span class="line"> /* Check to see if this data exceeds the size of our buffer. If so, </span><br><span class="line">  * set the user-defined context value and return 0 to indicate a </span><br><span class="line">  * problem to curl. </span><br><span class="line">  */ </span><br><span class="line"> if ( wr_index + segsize &gt; MAX_BUF ) &#123; </span><br><span class="line">   *(int *)userp = 1; </span><br><span class="line">   return 0; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> /* Copy the data from the curl buffer into our buffer */ </span><br><span class="line"> memcpy( (void *)&amp;wr_buf[wr_index], buffer, (size_t)segsize ); </span><br><span class="line"> </span><br><span class="line"> /* Update the write index */ </span><br><span class="line"> wr_index += segsize; </span><br><span class="line"> </span><br><span class="line"> /* Null terminate the buffer */ </span><br><span class="line"> wr_buf[wr_index] = 0; </span><br><span class="line"> </span><br><span class="line"> /* Return the number of bytes received, indicating to curl that all is okay */ </span><br><span class="line"> return segsize; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/* </span><br><span class="line">* Simple curl application to read the index.html file from a Web site. </span><br><span class="line">*/ </span><br><span class="line">int main( void ) </span><br><span class="line">&#123; </span><br><span class="line"> CURL *curl; </span><br><span class="line"> CURLcode ret; </span><br><span class="line"> int  wr_error; </span><br><span class="line"> </span><br><span class="line"> wr_error = 0; </span><br><span class="line"> wr_index = 0; </span><br><span class="line"> </span><br><span class="line"> /* First step, init curl */ </span><br><span class="line"> curl = curl_easy_init(); </span><br><span class="line"> if (!curl) &#123; </span><br><span class="line">   printf(&quot;couldn&apos;t init curl\n&quot;); </span><br><span class="line">   return 0; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> /* Tell curl the URL of the file we&apos;re going to retrieve */ </span><br><span class="line"> curl_easy_setopt( curl, CURLOPT_URL, &quot;www.exampledomain.com&quot; ); </span><br><span class="line"> </span><br><span class="line"> /* Tell curl that we&apos;ll receive data to the function write_data, and </span><br><span class="line">  * also provide it with a context pointer for our error return. </span><br><span class="line">  */ </span><br><span class="line"> curl_easy_setopt( curl, CURLOPT_WRITEDATA, (void *)&amp;wr_error ); </span><br><span class="line"> curl_easy_setopt( curl, CURLOPT_WRITEFUNCTION, write_data ); </span><br><span class="line"> </span><br><span class="line"> /* Allow curl to perform the action */ </span><br><span class="line"> ret = curl_easy_perform( curl ); </span><br><span class="line"> </span><br><span class="line"> printf( &quot;ret = %d (write_error = %d)\n&quot;, ret, wr_error ); </span><br><span class="line"> </span><br><span class="line"> /* Emit the page if curl indicates that no errors occurred */ </span><br><span class="line"> if ( ret == 0 ) printf( &quot;%s\n&quot;, wr_buf ); </span><br><span class="line"> </span><br><span class="line"> curl_easy_cleanup( curl ); </span><br><span class="line"> </span><br><span class="line"> return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最上方是必需的 include文件，包括 cURL 根文件。接下来，定义了两个用于传输的变量。第一个变量是 wr_buf，表示将在其中写入传入数据的缓冲区。wr_index表示缓冲区的当前写入索引。</p><p>转到 main函数，该函数使用 easy API 进行设置。所有 cURL 调用都通过维护特定请求状态的句柄进行操作。这称为 CURL指针引用。本例还创建一个特殊的返回码，称为 CURLcode。在使用任何 libcurl 函数之前，您需要调用 curl_easy_init获取 CURL句柄。接下来，注意 curl_easy_setopt调用的数量。它们为特定的操作配置句柄。对于这些调用，您提供句柄、命令和选项。首先，本例使用 CURLOPT_URL指定要获取的 URL。然后，它使用 CURL_WRITEDATA提供一个上下文变量（在本例中，它是内部的 write 错误变量）。最后，它使用 CURLOPT_WRITEFUNCTION指定数据可用时应该调用的函数。在启动 API 之后，API 将使用它读取的数据多次调用该函数。</p><p>要开始传输，调用 curl_easy_perform。它的工作是根据之前的配置执行传输。调用该函数时，在完成传输或发生错误之前该函数不会返回。main的最后一步是提交返回状态，提交页面读取，最后使用 curl_easy_cleanup清除（当使用句柄执行完操作后）。</p><p>现在看看 write_data函数。该函数是针对特定操作收到数据时调用的回调。注意，当您从网站读取数据时，将写入该数据（write_data）。将向回调提供一个缓冲区（包含可用数据）、成员数量和大小（缓冲中可用数据总量）、上下文指针。第一个任务是确保缓冲区（wr_buf）的空间足以写入数据。如果不够，它将设置上下文指针并返回 0，表示出现问题。否则，它将 cURL 缓冲区的数据复制到您的缓冲区，并增加索引，指向要写入的下一个位置。本例还终止字符串，稍后可以对其使用 printf。最后，它返回 libcurl 操作的字节数量。这将告诉 libcurl 数据被提取，它也可以丢弃该数据。这就是从网站将文件读取到内存的相对简单的方法。</p><h5 id="二、基于-Python-的-HTTP-客户端"><a href="#二、基于-Python-的-HTTP-客户端" class="headerlink" title="二、基于 Python 的 HTTP 客户端"></a>二、基于 Python 的 HTTP 客户端</h5><p>Python 是一种非常有用的面向对象的脚本语言，在原型化和构建生产软件方面非常突出。示例假设您较熟悉 Python，但使用不多，因此不要期望过高。</p><p>这个简单的 Python HTTP 客户端使用 pycurl，如下：</p><p>使用 libcurl 的 pycurl接口的 Python HTTP 客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import sys </span><br><span class="line">import pycurl </span><br><span class="line"> </span><br><span class="line">wr_buf = &apos;&apos;</span><br><span class="line"> </span><br><span class="line">def write_data( buf ): </span><br><span class="line">    global wr_buf </span><br><span class="line">    wr_buf += buf </span><br><span class="line"> </span><br><span class="line">def main(): </span><br><span class="line">    c = pycurl.Curl() </span><br><span class="line">    c.setopt( pycurl.URL, &apos;http://www.exampledomain.com&apos; ) </span><br><span class="line">    c.setopt( pycurl.WRITEFUNCTION, write_data ) </span><br><span class="line"> </span><br><span class="line">    c.perform() </span><br><span class="line"> </span><br><span class="line">    c.close() </span><br><span class="line"> </span><br><span class="line">main() </span><br><span class="line">sys.stdout.write(wr_buf)</span><br></pre></td></tr></table></figure><p>这比 C 语言版本简单的多。它首先导入必需的模块（用于标准系统的 sys和 pycurl模块）。接下来，它定义 write 缓冲区（wr_buf）。像 C 程序中一样，声明一个 write_data函数。注意，该函数只有一个参数：从 HTTP 服务器中读取的数据缓冲区。我将该缓冲区连接到全局 write 缓冲区。main函数首先创建一个 Curl句柄，然后使用 setopt方法为传输定义 URL和 WRITEFUNCTION。它调用 perform方法启动传输并关闭句柄。最后，它调用 main函数，并将 write 缓冲区提交到 stdout。注意，在这种情况下，不需要错误上下文指针，因为使用了 Python 字符串连接，这就是说您不会使用大小固定的字符串。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;一、基于-C-的-HTTP-客户端&quot;&gt;&lt;a href=&quot;#一、基于-C-的-HTTP-客户端&quot; class=&quot;headerlink&quot; title=&quot;一、基于 C 的 HTTP 客户端&quot;&gt;&lt;/a&gt;一、基于 C 的 HTTP 客户端&lt;/h5&gt;&lt;p&gt;C API 在 libcurl 功能上提供了两个 API。easy 接口是一个简单的同步 API（意味着当您使用请求调用 libcurl 时，将能够满足您的请求，直到完成或发生错误）。多接口可以进一步控制 libcurl，您的应用程序可以执行多个同步传输，并控制 libcurl 何时何地移动数据。&lt;/p&gt;
&lt;p&gt;该示例使用 easy 接口。该 API 还能控制数据移动过程（使用回调），但正如其名称所示，使用起来非常简单。下面请看HTTP 的 C 语言示例,使用 libcurl easy 接口的 C HTTP 客户端。&lt;/p&gt;
    
    </summary>
    
    
      <category term="cURL" scheme="http://www.faihung.net/categories/cURL/"/>
    
    
      <category term="cURL" scheme="http://www.faihung.net/tags/cURL/"/>
    
  </entry>
  
  <entry>
    <title>sscanf()函数使用详解</title>
    <link href="http://www.faihung.net/2019/11/03/sscanf-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.faihung.net/2019/11/03/sscanf-函数使用详解/</id>
    <published>2019-11-03T10:47:58.000Z</published>
    <updated>2019-11-16T06:56:07.077Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、描述："><a href="#一、描述：" class="headerlink" title="一、描述："></a>一、描述：</h4><p>sscanf通常被用来解析并转换字符串，其格式定义灵活多变，可以实现很强大的字符串解析功能。</p><p>sscanf的原型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int sscanf(const char *str, const char *format, ...);</span><br></pre></td></tr></table></figure><a id="more"></a><p>str:待解析的字符串;</p><p>format:字符串格式描述;</p><p>其后是一序列数目不定的指针参数，存储解析后的数据.</p><h4 id="二、示例用法："><a href="#二、示例用法：" class="headerlink" title="二、示例用法："></a>二、示例用法：</h4><h5 id="sscanf的基本用法"><a href="#sscanf的基本用法" class="headerlink" title="sscanf的基本用法"></a>sscanf的基本用法</h5><h6 id="整形数转换"><a href="#整形数转换" class="headerlink" title="整形数转换"></a>整形数转换</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int year, month, day;</span><br><span class="line"></span><br><span class="line">int converted = sscanf(&quot;20191103&quot;, &quot;%04d%02d%02d&quot;, &amp;year, &amp;month, &amp;day);</span><br><span class="line">printf(&quot;converted=%d, year=%d, month=%d, day=%d/n&quot;, converted, year, month, day);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">converted=3, year=2019, month=11, day=03</span><br></pre></td></tr></table></figure><p>“%04d%02d%02d”是用来解析字符串的格式，%表示格式转换的开始，d表示转换为一个整数，04作为d的修饰，表示这是一个长度为4位的整数，不足4位时以0补齐。</p><p>例子返回结果等于3，表示有3个数据成功转换，转换成功数目同时取决于被解析的字符串以及其转换格式，如果我们把例子中的格式改为”%04d%02d”，那么sscanf将只返回2，day的数值不会被sscanf更改。</p><h6 id="浮点数转换"><a href="#浮点数转换" class="headerlink" title="浮点数转换"></a>浮点数转换</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double longitude, latitude;</span><br><span class="line">int converted = sscanf(&quot;113.123456789 31.123456789&quot;, &quot;%lf %lf&quot;, &amp;longitude, &amp;latitude);</span><br><span class="line">printf(&quot;converted=%d, longitude=%.9lf, latitude=%lf/n&quot;, converted, longitude, latitude);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">converted=2, longitude=113.123456789, latitude=31.123457</span><br></pre></td></tr></table></figure><p>sscanf的格式字符串中，f表示这是一个浮点数，其修饰词l表示这是一个double的浮点数。</p><h5 id="sscanf的高级用法"><a href="#sscanf的高级用法" class="headerlink" title="sscanf的高级用法"></a>sscanf的高级用法</h5><h6 id="数字-字符串"><a href="#数字-字符串" class="headerlink" title="数字+字符串"></a>数字+字符串</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char str[32] = &quot;&quot;;</span><br><span class="line">sscanf(&quot;123456abcdedf&quot;, &quot;%31[0-9]&quot;, str);</span><br><span class="line">printf(&quot;str=%s/n&quot;, str);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str=123456</span><br></pre></td></tr></table></figure><p>上面的格式中，[0-9]表示这是一个仅包含0-9这几个字符的字符串，==前面使用数字31修饰词表示这个字符串缓冲区的最大长度(这也是sscanf最为人诟病的地方，很容易出现缓冲区溢出错误，实际上sscanf是可以避免出现缓冲区溢出的，只要在书写任何字符串解析的格式时，注意加上其缓冲区尺寸的限制)。==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char str[32] = &quot;&quot;;</span><br><span class="line">sscanf(&quot;123456abcdedf&quot;, &quot;%31[0-9a-z]&quot;, str);</span><br><span class="line">printf(&quot;str=%s/n&quot;, str);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str=123456abcdedf</span><br></pre></td></tr></table></figure><p>在格式[]中增加了a-z的描述。</p><h6 id="使用-示例："><a href="#使用-示例：" class="headerlink" title="使用^示例："></a>使用^示例：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char str[32] = &quot;&quot;;</span><br><span class="line">sscanf(&quot;123456abcdedf&quot;, &quot;%31[^a-z]&quot;, str);</span><br><span class="line">printf(&quot;str=%s/n&quot;, str);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str=123456</span><br></pre></td></tr></table></figure><p>在[]中增加^表示相反的意思，上面的[^a-z]表示一个不包含任何a-z之间的字符串。</p><h6 id="使用-的例子："><a href="#使用-的例子：" class="headerlink" title="使用*的例子："></a>使用*的例子：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char str[32] = &quot;&quot;;</span><br><span class="line">int ret = sscanf(&quot;123456abcdedf&quot;, &quot;%*[0-9]%31[a-z]&quot;, str);</span><br><span class="line">printf(&quot;ret=%d, str=%s/n&quot;,ret, str);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret=1, str=abcdedf</span><br></pre></td></tr></table></figure><p>加上*修饰表示一个被忽略的数据，同时也不需要为它准备空间存放解析结果。如上面的例子中，我们就只使用了str一个参数存放%31[a-z]的解析结果，而sscanf也只返回1，表示只解析了一个数据。</p><p>掌握了[], ^, *如何使用后，我们会发现sscanf原来是一个如此强大的工具，很多我们原先认为必须使用正则表达式的地方，很可能使用sscanf就可以实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、描述：&quot;&gt;&lt;a href=&quot;#一、描述：&quot; class=&quot;headerlink&quot; title=&quot;一、描述：&quot;&gt;&lt;/a&gt;一、描述：&lt;/h4&gt;&lt;p&gt;sscanf通常被用来解析并转换字符串，其格式定义灵活多变，可以实现很强大的字符串解析功能。&lt;/p&gt;
&lt;p&gt;sscanf的原型&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int sscanf(const char *str, const char *format, ...);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://www.faihung.net/categories/C/"/>
    
    
      <category term="sscanf" scheme="http://www.faihung.net/tags/sscanf/"/>
    
      <category term="字符串拆分" scheme="http://www.faihung.net/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%86%E5%88%86/"/>
    
      <category term="格式转换" scheme="http://www.faihung.net/tags/%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>linux 通过系统函数设置系统时间</title>
    <link href="http://www.faihung.net/2019/11/03/linux-%E9%80%9A%E8%BF%87%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/"/>
    <id>http://www.faihung.net/2019/11/03/linux-通过系统函数设置系统时间/</id>
    <published>2019-11-03T09:06:09.000Z</published>
    <updated>2019-11-03T09:09:54.432Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一、描述："><a href="#一、描述：" class="headerlink" title="一、描述："></a>一、描述：</h5><p>通过settimeofday()函数来设置系统时间，这个函数设置的精度可以精确到微秒。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">int settimeofday(const struct timeval *tv , const struct timezone *tz);</span><br><span class="line"></span><br><span class="line">struct timeval &#123;</span><br><span class="line">    time_t      tv_sec;     /* seconds */</span><br><span class="line">    suseconds_t tv_usec;    /* microseconds */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct timezone &#123;</span><br><span class="line">    int tz_minuteswest;     /* minutes west of Greenwich */</span><br><span class="line">    int tz_dsttime;         /* type of DST correction */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>tz参数为时区，时区结构中tz_dsttime在linux中不支持，应该置为0，通常将参数tz设置为NULL，表示使用当前系统的时区。该函数是glib中的，但在mingw中没有实现。</p></blockquote><a id="more"></a><h5 id="二、代码演示："><a href="#二、代码演示：" class="headerlink" title="二、代码演示："></a>二、代码演示：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/time.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int SetSystemTime(char *dt)</span><br><span class="line">&#123;</span><br><span class="line">    struct tm rtc_time;</span><br><span class="line">    struct tm _tm;</span><br><span class="line">    struct timeval tv;</span><br><span class="line">    time_t timep;</span><br><span class="line">    sscanf(dt, &quot;%d-%d-%d %d:%d:%d&quot;, &amp;rtc_time.tm_year,</span><br><span class="line">&amp;rtc_time.tm_mon, &amp;rtc_time.tm_mday,&amp;rtc_time.tm_hour,</span><br><span class="line">        &amp;rtc_time.tm_min, &amp;rtc_time.tm_sec);</span><br><span class="line">    _tm.tm_sec = rtc_time.tm_sec;</span><br><span class="line">    _tm.tm_min = rtc_time.tm_min;</span><br><span class="line">    _tm.tm_hour = rtc_time.tm_hour;</span><br><span class="line">    _tm.tm_mday = rtc_time.tm_mday;</span><br><span class="line">    _tm.tm_mon = rtc_time.tm_mon - 1;</span><br><span class="line">    _tm.tm_year = rtc_time.tm_year - 1900;</span><br><span class="line"> </span><br><span class="line">    timep = mktime(&amp;_tm);</span><br><span class="line">    tv.tv_sec = timep;</span><br><span class="line">    tv.tv_usec = 0;</span><br><span class="line">    // if(settimeofday (&amp;tv, (struct timezone *) 0) &lt; 0)</span><br><span class="line">if(settimeofday (&amp;tv, NULL) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">printf(&quot;Set system datatime error!\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;现在的时间是:&quot;);</span><br><span class="line">fflush(stdout);</span><br><span class="line">system(&quot;date&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  SetSystemTime(&quot;2019-11-03 16:30:30&quot;);//2019-11-01 21:19:05  </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="三、效果如下："><a href="#三、效果如下：" class="headerlink" title="三、效果如下："></a>三、效果如下：</h5><p><img src="/2019/11/03/linux-%E9%80%9A%E8%BF%87%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/1.jpg" alt="1"><br>注意：</p><ol><li>调用settimeofday函数时必须要在root权限下执行。</li><li>设置时间之前最好把虚拟机网络断开。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;一、描述：&quot;&gt;&lt;a href=&quot;#一、描述：&quot; class=&quot;headerlink&quot; title=&quot;一、描述：&quot;&gt;&lt;/a&gt;一、描述：&lt;/h5&gt;&lt;p&gt;通过settimeofday()函数来设置系统时间，这个函数设置的精度可以精确到微秒。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;time.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int settimeofday(const struct timeval *tv , const struct timezone *tz);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct timeval &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    time_t      tv_sec;     /* seconds */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    suseconds_t tv_usec;    /* microseconds */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct timezone &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int tz_minuteswest;     /* minutes west of Greenwich */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int tz_dsttime;         /* type of DST correction */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;tz参数为时区，时区结构中tz_dsttime在linux中不支持，应该置为0，通常将参数tz设置为NULL，表示使用当前系统的时区。该函数是glib中的，但在mingw中没有实现。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="系统函数&amp;库函数" scheme="http://www.faihung.net/categories/%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0-%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="系统时间" scheme="http://www.faihung.net/tags/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>cURL-01_基本概念与了解</title>
    <link href="http://www.faihung.net/2019/11/03/cURL-01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BA%86%E8%A7%A3/"/>
    <id>http://www.faihung.net/2019/11/03/cURL-01-基本概念与了解/</id>
    <published>2019-11-03T03:59:28.000Z</published>
    <updated>2019-11-03T14:58:32.291Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h5><p>cURL（Client URL Library Functions）is a command line tool for transfering data with URL syntax（使用 URL 语法传输数据的命令行工具），即客户端向服务器请求资源的工具。</p><p><img src="/2019/11/03/cURL-01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BA%86%E8%A7%A3/1.png" alt="1"></p><a id="more"></a><p>curl库是C语言封装的一个强大的库，使用curl比封装socket更加方便。</p><p>cURL 最初的设计初衷是使用不同的协议（比如 FTP、HTTP、SCP 等）在端点之间移动文件。它最初是一个命令行实用工具，但现在也是一个绑定了 30 多种语言的库。因此，现在不仅可以通过 shell 使用 cURL，您还可以构建合并了这个重要功能的应用程序。libcurl 库也是可以移植的，支持 Linux®、IBM®AIX®操作系统、BSD、Solaris 以及许多其他 UNIX®变体。</p><p>cURL是一个命令行工具和库，实现了各种客户端协议。它支持 12 种以上的协议，包括 FTP、HTTP、Telnet 以及其他安全变体。许多平台上都能找到 cURL，包括 Linux、AIX、BSD 和 Solaris，它支持 30 多种语言。</p><p>PycURL是 libcurl API 之上的一个薄层，PycURL 速度非常快。使用 PycURL，您可以使用 libcurl 库开发 Python 应用程序。</p><p>关于cURL,<a href="https://curl.haxx.se/" target="_blank" rel="noopener">这里</a>有更详细的介绍。</p><h5 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h5><p>1.网页资源（例如编写网页爬虫）</p><p>2.WebService 数据接口资源（比如动态获取接口数据，比如天气、号码归属地等）</p><p>3.FTP 服务器里的文件资源（下载 FTP 服务器里面的文件）</p><p>4.其他资源（所有网络上的资源都可以使用 cURL 访问和下载到）</p><h5 id="三、延伸-为什么要用cURL"><a href="#三、延伸-为什么要用cURL" class="headerlink" title="三、延伸(为什么要用cURL)"></a>三、延伸(为什么要用cURL)</h5><p>开发 HTTP 和 FTP 之类依赖于应用层协议的应用程序并不复杂，但也不简单。进一步讲，这不是应用程序的重点，因为大部分情况下，协议之上的内容才是真正重要的内容。因此，libcurl 引起了许多人的兴趣，因为它的重点是应用程序而不是开发的各个方面。注意，很少有应用程序开发自己的 TCP/IP 堆栈，所以老话重提：尽可能重用以最小化开发安排并提高应用程序的可靠性。</p><h6 id="关于Web-协议"><a href="#关于Web-协议" class="headerlink" title="关于Web 协议"></a>关于Web 协议</h6><p>如今构建应用程序已与过去大不相同。现在的应用程序需要能够通过网络或 Internet 进行通讯（提供人类可用的网络 API 或接口），还要能支持用户脚本化以提高灵活性。现代应用程序通常使用 HTTP 公开 Web 接口，并通过 Simple Mail Transport Protocol (SMTP) 提供警告通知。这些协议允许您将 Web 浏览器指向设备以获得配置或状态信息，并从设备或常用的电子邮件客户端接收标准电子邮件（分别通过 HTTP 和 SMTP）。</p><p>这些 Web 服务通常构建在网络堆栈的套接字层上（见图 1）。套接字层实现一个最先出现在 Berkeley Software Distribution (BSD) 操作系统上的 API，并提取底层传输和网络层协议的详细信息。</p><p>图 1. 网络堆栈和 libcurl</p><p><img src="/2019/11/03/cURL-01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BA%86%E8%A7%A3/2.gif" alt="2"></p><p>Web 服务发生在客户端和服务器之间的协议对话中。在 HTTP 上下文中，服务器是终端设备，客户端是位于端点上的浏览器。对于 SMTP，服务器是邮件网关或端点用户，客户端是终端设备。在某些情况下，协议对话发生在两个步骤（请求和响应）中，但另一些情况下，需要协商和通讯的通信量更多。这种协商可能增加了大量复杂性，这可以通过 API 进行抽象，比如 libcurl。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;一、基本概念&quot;&gt;&lt;a href=&quot;#一、基本概念&quot; class=&quot;headerlink&quot; title=&quot;一、基本概念&quot;&gt;&lt;/a&gt;一、基本概念&lt;/h5&gt;&lt;p&gt;cURL（Client URL Library Functions）is a command line tool for transfering data with URL syntax（使用 URL 语法传输数据的命令行工具），即客户端向服务器请求资源的工具。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/11/03/cURL-01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BA%86%E8%A7%A3/1.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="cURL" scheme="http://www.faihung.net/categories/cURL/"/>
    
    
      <category term="cURL" scheme="http://www.faihung.net/tags/cURL/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机VMware与Windows主机共享文件介绍</title>
    <link href="http://www.faihung.net/2019/11/03/%E8%99%9A%E6%8B%9F%E6%9C%BAVMware%E4%B8%8EWindows%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/"/>
    <id>http://www.faihung.net/2019/11/03/虚拟机VMware与Windows主机共享文件介绍/</id>
    <published>2019-11-03T03:07:48.000Z</published>
    <updated>2019-11-03T03:12:10.814Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一、设置共享文件夹功能"><a href="#一、设置共享文件夹功能" class="headerlink" title="一、设置共享文件夹功能"></a>一、设置共享文件夹功能</h5><p>虚拟机VMware提供了在宿主机与虚拟机系统之间交换文件的共享文件夹（Shared Folder）功能。不管虚拟机操作系统是Linux还是Windows都可用。你可以通过设置（ Settings）&gt;共享文件夹（Shared Folder）来设置。但是此功能选项必须要安装虚拟机工具（VMware Tools），否则如下所示，否则该功能选项不可用。</p><p><img src="/2019/11/03/%E8%99%9A%E6%8B%9F%E6%9C%BAVMware%E4%B8%8EWindows%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/1.jpg" alt="1"></p><a id="more"></a><h5 id="二、安装虚拟机工具步骤如下所示："><a href="#二、安装虚拟机工具步骤如下所示：" class="headerlink" title="二、安装虚拟机工具步骤如下所示："></a>二、安装虚拟机工具步骤如下所示：</h5><h6 id="1-在对应虚拟机的设置选项（Settings-下，为虚拟机光驱指定虚拟机系统的镜像文件。"><a href="#1-在对应虚拟机的设置选项（Settings-下，为虚拟机光驱指定虚拟机系统的镜像文件。" class="headerlink" title="1. 在对应虚拟机的设置选项（Settings)下，为虚拟机光驱指定虚拟机系统的镜像文件。"></a>1. 在对应虚拟机的设置选项（Settings)下，为虚拟机光驱指定虚拟机系统的镜像文件。</h6><p>注意：在执行下面步骤前，必须确保虚拟机的电源开启、虚拟机系统正在运行。</p><p><img src="/2019/11/03/%E8%99%9A%E6%8B%9F%E6%9C%BAVMware%E4%B8%8EWindows%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/2.png" alt="2"></p><h6 id="2-在VM下选择”Install-VMware-Tools”"><a href="#2-在VM下选择”Install-VMware-Tools”" class="headerlink" title="2. 在VM下选择”Install VMware Tools”."></a>2. 在VM下选择”Install VMware Tools”.</h6><p><img src="/2019/11/03/%E8%99%9A%E6%8B%9F%E6%9C%BAVMware%E4%B8%8EWindows%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/3.png" alt="3"></p><ol start="3"><li>然后安装虚拟机组件工具，详细步骤如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@DB-Server ~]# cd /mnt</span><br><span class="line">[root@DB-Server mnt]# mkdir cdrom</span><br><span class="line">[root@DB-Server mnt]# mount /dev/cdrom  /mnt/cdrom</span><br><span class="line">[root@DB-Server mnt]# cd /mnt/cdrom</span><br><span class="line">[root@DB-Server cdrom]# cp  VMwareTools-8.8.2-590212.tar.gz /tmp</span><br><span class="line">[root@DB-Server cdrom]#tar xz</span><br><span class="line">[root@DB-Server tmp]# ls</span><br><span class="line">gconfd-root     orbit-root           VMwareTools-8.8.2-590212.tar.gz</span><br><span class="line">keyring-qO15Cg  ssh-EWUeHQ4064       vmware-tools-distrib</span><br><span class="line">mapping-root    virtual-root.9mZzaq</span><br><span class="line">[root@DB-Server tmp]# cd vmware-tools-distrib/</span><br><span class="line">[root@DB-Server vmware-tools-distrib]# ls</span><br><span class="line">bin  doc  etc  FILES  INSTALL  installer  lib  vmware-install.pl</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[root@DB-Server vmware-tools-distrib]# ./vmware-install.pl </span><br><span class="line">A previous installation of VMware Tools has been detected.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">之后直接安装即可。</span><br></pre></td></tr></table></figure>安装完成后重启虚拟机</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;一、设置共享文件夹功能&quot;&gt;&lt;a href=&quot;#一、设置共享文件夹功能&quot; class=&quot;headerlink&quot; title=&quot;一、设置共享文件夹功能&quot;&gt;&lt;/a&gt;一、设置共享文件夹功能&lt;/h5&gt;&lt;p&gt;虚拟机VMware提供了在宿主机与虚拟机系统之间交换文件的共享文件夹（Shared Folder）功能。不管虚拟机操作系统是Linux还是Windows都可用。你可以通过设置（ Settings）&amp;gt;共享文件夹（Shared Folder）来设置。但是此功能选项必须要安装虚拟机工具（VMware Tools），否则如下所示，否则该功能选项不可用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/11/03/%E8%99%9A%E6%8B%9F%E6%9C%BAVMware%E4%B8%8EWindows%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/1.jpg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://www.faihung.net/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="ubuntu" scheme="http://www.faihung.net/tags/ubuntu/"/>
    
      <category term="VMware" scheme="http://www.faihung.net/tags/VMware/"/>
    
  </entry>
  
  <entry>
    <title>Source Insight 使用技巧整理</title>
    <link href="http://www.faihung.net/2019/11/03/Source-Insight-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    <id>http://www.faihung.net/2019/11/03/Source-Insight-使用技巧整理/</id>
    <published>2019-11-02T16:17:01.000Z</published>
    <updated>2019-11-06T14:53:34.273Z</updated>
    
    <content type="html"><![CDATA[<h4 id="通用设置"><a href="#通用设置" class="headerlink" title="通用设置"></a>通用设置</h4><p>Options - File Type Options:</p><ul><li>显示行号：勾选Show line mumbers</li><li>选中自动高亮：勾选Hightlight references to selected sysmbol</li><li>转换tab成空格：勾选Expand tabs to spaces，设置Tab width：4<br><img src="/2019/11/03/Source-Insight-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/1.png" alt="1"></li></ul><a id="more"></a><p><strong>高亮选中符号：</strong><br>F8</p><p><strong>代码折叠：</strong><br>View –&gt; Show Outlining </p><p><strong>代码默认字体大小：</strong><br>Ctrl + 滑动鼠标滑轮，可以增大缩小代码字体大小</p><blockquote><p>对所有代码文件字体都生效，步骤如：<br>Preferences –&gt; File Type Options -&gt; Screen Font<br>Preferences –&gt; Languages –&gt; File Types –&gt; Screen Font</p></blockquote><p><strong>只为主界面导入配色方案（不是全局，全局在Options-&gt;Load Configuration..）</strong></p><ol><li>Options –&gt; Style properties -&gt; Load</li><li>背景色修改： Options –&gt; Preferences –&gt;  Colors –&gt; Window Background </li><li>字体修改：在需要修改的词处点击，选择style Properties 会自动对应到需要修改的词语类型，然后直接修改颜色即可。</li></ol><p><strong>替换：</strong><br>Ctrl + h<br><strong>查找：</strong><br>Ctrl + f<br><strong>全局查找：</strong><br>Ctrl + /<br><strong>向上搜索</strong><br>Ctrl + F3<br><strong>向下搜索</strong><br>Ctrl + F4<br><strong>跳转到行：</strong><br>F5<br><strong>跳转到定义：</strong><br>Ctrl + 鼠标左键</p><h4 id="显示中文乱码"><a href="#显示中文乱码" class="headerlink" title="显示中文乱码"></a>显示中文乱码</h4><p>File - Reload As Encoding - GB2312</p><p><img src="/2019/11/03/Source-Insight-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/2.png" alt="2"></p><h4 id="添加注释快捷键"><a href="#添加注释快捷键" class="headerlink" title="添加注释快捷键"></a>添加注释快捷键</h4><blockquote><p>添加一些配置文件宏，比如：注释掉代码：单行注释、多行注释，将选中内容注释掉；在一行代码的前、后添加注释性文字等。</p></blockquote><h5 id="操作步骤："><a href="#操作步骤：" class="headerlink" title="操作步骤："></a>操作步骤：</h5><p>打开Projcet-&gt;Open project，选择base，可以看到utils.em文件，将下列宏添加到该文件中，并在其他工程里加入该文件，在上面介绍的快捷键添加方式里找到该宏并自定义快捷键。</p><h5 id="单行、多行注释："><a href="#单行、多行注释：" class="headerlink" title="单行、多行注释："></a>单行、多行注释：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">macro MultiLineComment()  </span><br><span class="line">&#123;  </span><br><span class="line">    hwnd = GetCurrentWnd()  </span><br><span class="line">    selection = GetWndSel(hwnd)  </span><br><span class="line">    LnFirst = GetWndSelLnFirst(hwnd)      //取首行行号  </span><br><span class="line">    LnLast = GetWndSelLnLast(hwnd)      //取末行行号  </span><br><span class="line">    hbuf = GetCurrentBuf()  </span><br><span class="line">   </span><br><span class="line">    if(GetBufLine(hbuf, 0) == &quot;//magic-number:tph85666031&quot;)&#123;  </span><br><span class="line">        stop  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    Ln = Lnfirst  </span><br><span class="line">    buf = GetBufLine(hbuf, Ln)  </span><br><span class="line">    len = strlen(buf)  </span><br><span class="line">   </span><br><span class="line">    while(Ln &lt;= Lnlast) &#123;  </span><br><span class="line">        buf = GetBufLine(hbuf, Ln)  //取Ln对应的行  </span><br><span class="line">        if(buf == &quot;&quot;)&#123;                    //跳过空行  </span><br><span class="line">            Ln = Ln + 1  </span><br><span class="line">            continue  </span><br><span class="line">        &#125;  </span><br><span class="line">   </span><br><span class="line">        if(StrMid(buf, 0, 1) == &quot;/&quot;) &#123;       //需要取消注释,防止只有单字符的行  </span><br><span class="line">            if(StrMid(buf, 1, 2) == &quot;/&quot;)&#123;  </span><br><span class="line">                PutBufLine(hbuf, Ln, StrMid(buf, 2, Strlen(buf)))  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">   </span><br><span class="line">        if(StrMid(buf,0,1) != &quot;/&quot;)&#123;          //需要添加注释  </span><br><span class="line">            PutBufLine(hbuf, Ln, Cat(&quot;//&quot;, buf))  </span><br><span class="line">        &#125;  </span><br><span class="line">        Ln = Ln + 1  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    SetWndSel(hwnd, selection)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码保存到utils.em文件，打开source insight，将该文件添加到工程中，然后在Options-&gt;Key Assignments中你就可以看到这个宏了，宏的名字是MultiLineComments，然后我们为它分配快捷键“Ctrl + /”，然后就可以了。</p><p>添加“#ifdef 0”和“#endif”的宏代码，定义快捷键为Ctrl+/+Shift：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">macro AddMacroComment()  </span><br><span class="line">&#123;  </span><br><span class="line">    hwnd=GetCurrentWnd()  </span><br><span class="line">    sel=GetWndSel(hwnd)  </span><br><span class="line">    lnFirst=GetWndSelLnFirst(hwnd)  </span><br><span class="line">    lnLast=GetWndSelLnLast(hwnd)  </span><br><span class="line">    hbuf=GetCurrentBuf()  </span><br><span class="line">   </span><br><span class="line">    if(LnFirst == 0) &#123;  </span><br><span class="line">            szIfStart = &quot;&quot;  </span><br><span class="line">    &#125;else&#123;  </span><br><span class="line">            szIfStart = GetBufLine(hbuf, LnFirst-1)  </span><br><span class="line">    &#125;  </span><br><span class="line">    szIfEnd = GetBufLine(hbuf, lnLast+1)  </span><br><span class="line">    if(szIfStart == &quot;#if 0&quot; &amp;&amp; szIfEnd == &quot;#endif&quot;) &#123;  </span><br><span class="line">            DelBufLine(hbuf, lnLast+1)  </span><br><span class="line">            DelBufLine(hbuf, lnFirst-1)  </span><br><span class="line">            sel.lnFirst = sel.lnFirst – 1  </span><br><span class="line">            sel.lnLast = sel.lnLast – 1  </span><br><span class="line">    &#125;else&#123;  </span><br><span class="line">            InsBufLine(hbuf, lnFirst, &quot;#if 0&quot;)  </span><br><span class="line">            InsBufLine(hbuf, lnLast+2, &quot;#endif&quot;)  </span><br><span class="line">            sel.lnFirst = sel.lnFirst + 1  </span><br><span class="line">            sel.lnLast = sel.lnLast + 1  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    SetWndSel( hwnd, sel )  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作和上面类似</p><h4 id="添加快捷键，快速打开当前文件所在文件夹"><a href="#添加快捷键，快速打开当前文件所在文件夹" class="headerlink" title="添加快捷键，快速打开当前文件所在文件夹"></a>添加快捷键，快速打开当前文件所在文件夹</h4><ol><li><p>选择【Tools】-&gt;【custom commands】，在add -&gt;【Command】输入名字：Explorer Project</p></li><li><p>在【Run：】中输入： ShellExecute open explorer /e,/select,%f 或 ShellExecute open explorer /select,%f 或  explorer %d 或 explorer /select,%f<br>注意中间的逗号:ShellExecute open explorer /select,%f</p></li><li><p>在点击【Keys…】，点击【Assign New Key…】，设置快捷键 Ctrl+Alt+O</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;通用设置&quot;&gt;&lt;a href=&quot;#通用设置&quot; class=&quot;headerlink&quot; title=&quot;通用设置&quot;&gt;&lt;/a&gt;通用设置&lt;/h4&gt;&lt;p&gt;Options - File Type Options:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;显示行号：勾选Show line mumbers&lt;/li&gt;
&lt;li&gt;选中自动高亮：勾选Hightlight references to selected sysmbol&lt;/li&gt;
&lt;li&gt;转换tab成空格：勾选Expand tabs to spaces，设置Tab width：4&lt;br&gt;&lt;img src=&quot;/2019/11/03/Source-Insight-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/1.png&quot; alt=&quot;1&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://www.faihung.net/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Source Insight" scheme="http://www.faihung.net/tags/Source-Insight/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu配置NFS及其挂载设备</title>
    <link href="http://www.faihung.net/2019/11/02/Ubuntu%E9%85%8D%E7%BD%AENFS%E5%8F%8A%E5%85%B6%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87/"/>
    <id>http://www.faihung.net/2019/11/02/Ubuntu配置NFS及其挂载设备/</id>
    <published>2019-11-01T16:00:00.000Z</published>
    <updated>2019-11-03T02:31:52.620Z</updated>
    
    <content type="html"><![CDATA[<h5 id="在Ubuntu系统中安装NFS"><a href="#在Ubuntu系统中安装NFS" class="headerlink" title="在Ubuntu系统中安装NFS"></a>在Ubuntu系统中安装NFS</h5><p>执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nfs-kernel-server</span><br></pre></td></tr></table></figure><blockquote><p>同时会有两个软件包nfs-common和portmap被安装上，如果没有安装成功多安装几次。</p></blockquote><a id="more"></a><h5 id="在Ubuntu系统中的-mnt下建立共享项目nfs-shared"><a href="#在Ubuntu系统中的-mnt下建立共享项目nfs-shared" class="headerlink" title="在Ubuntu系统中的/mnt下建立共享项目nfs_shared"></a>在Ubuntu系统中的/mnt下建立共享项目nfs_shared</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mkdir nfs_shared </span><br><span class="line"># chmod 777 -R nfs_shared/</span><br></pre></td></tr></table></figure><p>保证使用者都能够读、写、执行。如图</p><p><img src="/2019/11/02/Ubuntu%E9%85%8D%E7%BD%AENFS%E5%8F%8A%E5%85%B6%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87/1.png" alt="1"></p><h5 id="在Ubuntu系统中修改NFS配置文件"><a href="#在Ubuntu系统中修改NFS配置文件" class="headerlink" title="在Ubuntu系统中修改NFS配置文件"></a>在Ubuntu系统中修改NFS配置文件</h5><p>执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/exports</span><br></pre></td></tr></table></figure><p>在exports最后一行添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/mnt/nfs_shared 192.168.0.*(rw,sync,no_root_squash,no_subtree_check)</span><br><span class="line">其中，</span><br><span class="line">/mnt/nfs_shared  ---要共享的目录</span><br><span class="line">192.168.0.*---允许访问的网段，也可以是ip地址、主机名（能够被服务器解析）、</span><br><span class="line">     *（所有人都能访问）</span><br><span class="line">(rw,sync,no_root_squash,no_subtree_check)---</span><br><span class="line">rw:读/写权限</span><br><span class="line">sync:数据同步写入内存和硬盘</span><br><span class="line">no_root_squash:服务器允许远程系统以root特权存取该目录</span><br><span class="line">no_subtree_check:关闭子树检查</span><br></pre></td></tr></table></figure><p><img src="/2019/11/02/Ubuntu%E9%85%8D%E7%BD%AENFS%E5%8F%8A%E5%85%B6%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87/2.png" alt="2"></p><h5 id="在Ubuntu系统中启动服务"><a href="#在Ubuntu系统中启动服务" class="headerlink" title="在Ubuntu系统中启动服务"></a>在Ubuntu系统中启动服务</h5><p>依次执行下列命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo service rpcbind restart</span><br><span class="line">sudo service rpcbind restart</span><br></pre></td></tr></table></figure><p><img src="/2019/11/02/Ubuntu%E9%85%8D%E7%BD%AENFS%E5%8F%8A%E5%85%B6%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87/3.png" alt="3"></p><h5 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h5><h6 id="测试Ubuntu-nfs"><a href="#测试Ubuntu-nfs" class="headerlink" title="测试Ubuntu nfs"></a>测试Ubuntu nfs</h6><p>执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$showmount -e</span><br></pre></td></tr></table></figure><p><img src="/2019/11/02/Ubuntu%E9%85%8D%E7%BD%AENFS%E5%8F%8A%E5%85%B6%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87/4.png" alt="4"></p><h6 id="设备挂载"><a href="#设备挂载" class="headerlink" title="设备挂载"></a>设备挂载</h6><p>在《Hi3519AV100 SDK 安装及升级使用说明.pdf》中4.2 使用 NFS 文件系统进行开发可以看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t nfs -o nolock -o tcp -o rsize=32768,wsize=32768 xx.xx.xx.xx:/your-nfs-path /mnt</span><br></pre></td></tr></table></figure><p>改为：（在设备中挂载）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t nfs -o nolock -o tcp -o rsize=32768,wsize=32768 192.168.0.180:/mnt/</span><br></pre></td></tr></table></figure><p>之后就可以在设备的/mnt下面查看Ubuntu/mnt/nfs_shared的文件了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;在Ubuntu系统中安装NFS&quot;&gt;&lt;a href=&quot;#在Ubuntu系统中安装NFS&quot; class=&quot;headerlink&quot; title=&quot;在Ubuntu系统中安装NFS&quot;&gt;&lt;/a&gt;在Ubuntu系统中安装NFS&lt;/h5&gt;&lt;p&gt;执行命令：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install nfs-kernel-server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;同时会有两个软件包nfs-common和portmap被安装上，如果没有安装成功多安装几次。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://www.faihung.net/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="nfs" scheme="http://www.faihung.net/tags/nfs/"/>
    
      <category term="ubuntu" scheme="http://www.faihung.net/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.faihung.net/2019/11/02/%E7%AE%80%E5%8D%95%E7%9A%84rtsp%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/"/>
    <id>http://www.faihung.net/2019/11/02/简单的rtsp交互过程/</id>
    <published>2019-11-01T16:00:00.000Z</published>
    <updated>2019-11-02T11:06:44.334Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里C表示rtsp客户端,S表示rtsp服务端。 </p></blockquote><h6 id="C-gt-发送流媒体数据前的准备"><a href="#C-gt-发送流媒体数据前的准备" class="headerlink" title="C-&gt;:发送流媒体数据前的准备"></a>C-&gt;:发送流媒体数据前的准备</h6><ul><li>C-&gt;S:OPTION request  //询问S有哪些方法可用 </li><li>S-&gt;C:OPTION response //S回应信息中包括提供的所有可用方法 </li></ul><ul><li>C-&gt;S:DESCRIBE request //要求得到S提供的媒体初始化描述信息 </li><li>S-&gt;C:DESCRIBE response //S回应媒体初始化描述信息，主要是sdp </li></ul><ul><li>C-&gt;S:SETUP request //设置会话的属性，以及传输模式，提醒S建立会话 </li><li>S-&gt;C:SETUP response //S建立会话，返回会话标识符，以及会话相关信息 </li></ul><ul><li>C-&gt;S:PLAY request //C请求播放 </li><li>S-&gt;C:PLAY response //S回应该请求的信息 </li></ul><h6 id="S-gt-C-发送流媒体数据"><a href="#S-gt-C-发送流媒体数据" class="headerlink" title="S-&gt;C:发送流媒体数据"></a>S-&gt;C:发送流媒体数据</h6><ul><li>C-&gt;S:TEARDOWN request //C请求关闭会话 </li><li>S-&gt;C:TEARDOWN response //S回应该请求</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这里C表示rtsp客户端,S表示rtsp服务端。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&quot;C-gt-发送流媒体数据前的准备&quot;&gt;&lt;a href=&quot;#C-gt-发送流媒体数据前的准备&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
    
      <category term="流媒体" scheme="http://www.faihung.net/categories/%E6%B5%81%E5%AA%92%E4%BD%93/"/>
    
    
  </entry>
  
</feed>
