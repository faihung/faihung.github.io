<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Faihung&#39;s blog</title>
  
  <subtitle>作者：faihung</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.faihung.net/"/>
  <updated>2019-12-08T08:57:07.048Z</updated>
  <id>http://www.faihung.net/</id>
  
  <author>
    <name>faihung</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cURL-06_cURL和libcuel的安装的安装途径</title>
    <link href="http://www.faihung.net/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/"/>
    <id>http://www.faihung.net/2019/12/08/cURL-06-cURL和libcuel的安装的安装途径/</id>
    <published>2019-12-08T08:51:06.000Z</published>
    <updated>2019-12-08T08:57:07.048Z</updated>
    
    <content type="html"><![CDATA[<p>cURL的安装一般有三种方式:<a href="https://ec.haxx.se/" target="_blank" rel="noopener">https://ec.haxx.se/</a></p><h5 id="一、ubuntu16-04-安装curl，一般用于命令行工具操作"><a href="#一、ubuntu16-04-安装curl，一般用于命令行工具操作" class="headerlink" title="一、ubuntu16.04 安装curl，一般用于命令行工具操作"></a>一、ubuntu16.04 安装curl，一般用于命令行工具操作</h5><h6 id="1-直接安装"><a href="#1-直接安装" class="headerlink" title="1. 直接安装"></a>1. 直接安装</h6><pre><code>sudo apt install curl</code></pre><h6 id="2-或者是下载软件压缩包安装-Ubuntu下安装cURL库用于libcurl开发"><a href="#2-或者是下载软件压缩包安装-Ubuntu下安装cURL库用于libcurl开发" class="headerlink" title="2. 或者是下载软件压缩包安装-Ubuntu下安装cURL库用于libcurl开发"></a>2. 或者是下载软件压缩包安装-Ubuntu下安装cURL库用于libcurl开发</h6><p>2.1 下载curl包（可以在这个网站上找最新的版本 <a href="http://curl.haxx.se/download/）" target="_blank" rel="noopener">http://curl.haxx.se/download/）</a></p><p><img src="/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/1.png" alt="1"></p><pre><code>wget https://curl.haxx.se/download/curl-7.55.1.tar.gz</code></pre><p>2.2 解压</p><pre><code>tar -xzvf  curl-7.55.1.tar.gz</code></pre><p>2.3 覆盖安装</p><pre><code>stemp 1 cd curl-7.55.1stemp 2 ./configurestemp 3 makestemp 4 make install</code></pre><p>2.4 使用 curl –version 检查是否更新成功</p><p><img src="/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/2.png" alt="2"></p><h5 id="二、ubuntu16-04-安装libcurl-主要用于ubuntu中应用程序开发-curl和libcurl的区别"><a href="#二、ubuntu16-04-安装libcurl-主要用于ubuntu中应用程序开发-curl和libcurl的区别" class="headerlink" title="二、ubuntu16.04 安装libcurl,主要用于ubuntu中应用程序开发(curl和libcurl的区别)"></a>二、ubuntu16.04 安装libcurl,主要用于ubuntu中应用程序开发(curl和libcurl的区别)</h5><pre><code>sudo apt install libcurl4-openssl-dev</code></pre><p>可以看到-ubuntu系统中/usr/include/curl中的头文件</p><p>库文件：/usr/lib/x86_64-linux-gnu/libcurl.so.4</p><h5 id="三、linux下编译安装libcurl"><a href="#三、linux下编译安装libcurl" class="headerlink" title="三、linux下编译安装libcurl"></a>三、linux下编译安装libcurl</h5><h6 id="1-直接下载"><a href="#1-直接下载" class="headerlink" title="1. 直接下载"></a>1. 直接下载</h6><pre><code>git clone https://github.com/curl/curl.git </code></pre><h6 id="2-tar解压后，进入curl工程目录输入指令：-buidconf，产生configure脚本"><a href="#2-tar解压后，进入curl工程目录输入指令：-buidconf，产生configure脚本" class="headerlink" title="2.tar解压后，进入curl工程目录输入指令：./buidconf，产生configure脚本"></a>2.tar解压后，进入curl工程目录输入指令：./buidconf，产生configure脚本</h6><p>之后和第一条步骤类似</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;cURL的安装一般有三种方式:&lt;a href=&quot;https://ec.haxx.se/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ec.haxx.se/&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;一、ubuntu16-04-安装curl，一般用于
      
    
    </summary>
    
    
      <category term="cURL" scheme="http://www.faihung.net/categories/cURL/"/>
    
    
      <category term="cURL" scheme="http://www.faihung.net/tags/cURL/"/>
    
  </entry>
  
  <entry>
    <title>cURL-05_curl和libcurl的区别简介(转)</title>
    <link href="http://www.faihung.net/2019/12/08/cURL-05-curl%E5%92%8Clibcurl%E7%9A%84%E5%8C%BA%E5%88%AB%E7%AE%80%E4%BB%8B-%E8%BD%AC/"/>
    <id>http://www.faihung.net/2019/12/08/cURL-05-curl和libcurl的区别简介-转/</id>
    <published>2019-12-08T08:33:44.000Z</published>
    <updated>2019-12-08T08:38:47.024Z</updated>
    
    <content type="html"><![CDATA[<h5 id="curl简介"><a href="#curl简介" class="headerlink" title="curl简介"></a>curl简介</h5><p>curl是利用URL语法在命令行方式下工作的开源文件传输工具。<br>它支持很多协议：DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP。</p><p>curl同样支持SSL证书,HTTP POST, HTTP PUT,FTP上传，基于表单的HTTP上传，代理(proxies)、cookies、用户名/密码认证(Basic, Digest, NTLM等)、下载文件断点续传，上载文件断点续传(file transfer resume)，http代理服务器管道（proxy tunneling)以及其他特性。</p><p>curl是瑞典curl组织开发的,curl的官网是<a href="http://curl.haxx.se/,可以从官网获取它的源代码和相关说明。" target="_blank" rel="noopener">http://curl.haxx.se/,可以从官网获取它的源代码和相关说明。</a></p><a id="more"></a><h5 id="libcurl简介"><a href="#libcurl简介" class="headerlink" title="libcurl简介"></a>libcurl简介</h5><p>libcurl为一个免费开源的，客户端url传输库，支持DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP等协议。</p><p>同curl一样，libcurl也支持SSL证书,HTTP POST, HTTP PUT,FTP上传，基于表单的HTTP上传，代理(proxies)、cookies、用户名/密码认证(Basic, Digest, NTLM等)、下载文件断点续传，上载文件断点续传(file transfer resume)，http代理服务器管道（proxy tunneling)等。</p><p>libcurl是高度可移植的，可以工作在不同的平台上，支持Windows，Unix，Linux等。</p><p>libcurl是免费的，线程安全的，IPV6兼容的，同时它还有很多其它非常丰富的特性。libcurl已经被很多知名的大企业以及应用程序所采用。</p><h5 id="curl与libcurl对比"><a href="#curl与libcurl对比" class="headerlink" title="curl与libcurl对比"></a>curl与libcurl对比</h5><h6 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h6><p>curl和libcurl都可以利用多种多样的协议来传输文件，包括HTTP, HTTPS, FTP, FTPS, GOPHER, LDAP, DICT, TELNET and FILE等。</p><h6 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h6><ul><li>curl是命令行工具，可以通过shell或脚本来运行curl。curl底层所使用的库是libcurl。</li><li>libcurl是一个库，通常与别的程序绑定在一起使用，如命令行工具curl就是封装了libcurl库。所以我们也可以在你自己的程序或项目中使用libcurl以获得类似CURL的强大功能。接下来将要介绍的PHP扩展就是对curl的一个封装。</li></ul><h5 id="几个名词"><a href="#几个名词" class="headerlink" title="几个名词"></a>几个名词</h5><h6 id="“curl”的不同意思"><a href="#“curl”的不同意思" class="headerlink" title="“curl”的不同意思"></a>“curl”的不同意思</h6><p>1.curl指的是curl命令行工具，可以从命令行或者脚本或者批处理文件中运行curl。curl创建于1998年，并且提供了100多个选项去控制它。</p><p>2.cURL是一个软件项目的名字。该软件项目包含了上面所说的curl和libcurl，并且都是开源的。</p><p>3.cURL通常用作PHP中libcurl扩展的名字。这个扩展确保了PHP程序员在程序中可以访问libcurl库所提供的功能。</p><h6 id="curl—命令行工具"><a href="#curl—命令行工具" class="headerlink" title="curl—命令行工具"></a>curl—命令行工具</h6><ol><li>命令行工具，可以从shell或者脚本中运行该工具。</li><li>提供了130多种不同的“flags”</li><li>通常被用来模拟浏览器的行为</li><li>跨平台</li></ol><h6 id="libcurl—库"><a href="#libcurl—库" class="headerlink" title="libcurl—库"></a>libcurl—库</h6><ol><li>用作其他程序的开发库</li><li>可以与许多语言想结合，如PHP、C++</li><li>跨平台</li><li>提供了多种不同的使用它的APIs</li></ol><h5 id="PHP中使用curl和libcurl"><a href="#PHP中使用curl和libcurl" class="headerlink" title="PHP中使用curl和libcurl"></a>PHP中使用curl和libcurl</h5><h6 id="PHP中使用curl"><a href="#PHP中使用curl" class="headerlink" title="PHP中使用curl"></a>PHP中使用curl</h6><p>在PHP中使用curl非常简单，只要调用PHP中几个执行系统命令的相关函数即可。<br>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$baidu=shell_exec(&quot;/usr/bin/curl -L http://www.baidu.com&quot;); </span><br><span class="line">var_dump($baidu);</span><br></pre></td></tr></table></figure><h6 id="PHP中使用libcurl"><a href="#PHP中使用libcurl" class="headerlink" title="PHP中使用libcurl"></a>PHP中使用libcurl</h6><p>在PHP中使用libcurl，也就是我们通常所说的PHP中的“curl”。这部分的内容会在以后的文章中给出，这里只写出一个示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// FTP this script to a server</span><br><span class="line">$fp = fopen(__FILE__, &quot;r&quot;);</span><br><span class="line">$url = &quot;ftp://username:password@mydomain.com:21/path/to/newfile.php&quot;;</span><br><span class="line">$ch = curl_init();   </span><br><span class="line">curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);</span><br><span class="line">curl_setopt($ch, CURLOPT_UPLOAD, 1);</span><br><span class="line">curl_setopt($ch, CURLOPT_INFILE, $fp);</span><br><span class="line">curl_setopt($ch, CURLOPT_FTPASCII, 1);</span><br><span class="line">curl_setopt($ch, CURLOPT_INFILESIZE, filesize(__FILE__));</span><br><span class="line">$result = curl_exec($ch);</span><br><span class="line">curl_close($ch);</span><br></pre></td></tr></table></figure><h5 id="使用curl还是libcurl？"><a href="#使用curl还是libcurl？" class="headerlink" title="使用curl还是libcurl？"></a>使用curl还是libcurl？</h5><p>使用curl还是libcurl这个需要根据具体的情况而定。例如，当有一个定时脚本在远程服务器的文件改变时发送邮件或者当前PHP环境不支持libcurl时，我们应该使用curl。否则，我们使用libcurl即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;curl简介&quot;&gt;&lt;a href=&quot;#curl简介&quot; class=&quot;headerlink&quot; title=&quot;curl简介&quot;&gt;&lt;/a&gt;curl简介&lt;/h5&gt;&lt;p&gt;curl是利用URL语法在命令行方式下工作的开源文件传输工具。&lt;br&gt;它支持很多协议：DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP。&lt;/p&gt;
&lt;p&gt;curl同样支持SSL证书,HTTP POST, HTTP PUT,FTP上传，基于表单的HTTP上传，代理(proxies)、cookies、用户名/密码认证(Basic, Digest, NTLM等)、下载文件断点续传，上载文件断点续传(file transfer resume)，http代理服务器管道（proxy tunneling)以及其他特性。&lt;/p&gt;
&lt;p&gt;curl是瑞典curl组织开发的,curl的官网是&lt;a href=&quot;http://curl.haxx.se/,可以从官网获取它的源代码和相关说明。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://curl.haxx.se/,可以从官网获取它的源代码和相关说明。&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="cURL" scheme="http://www.faihung.net/categories/cURL/"/>
    
    
      <category term="cURL" scheme="http://www.faihung.net/tags/cURL/"/>
    
  </entry>
  
  <entry>
    <title>工具-虚拟机的桥接模式和NAT模式的区别</title>
    <link href="http://www.faihung.net/2019/12/08/%E5%B7%A5%E5%85%B7-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E5%92%8CNAT%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.faihung.net/2019/12/08/工具-虚拟机的桥接模式和NAT模式的区别/</id>
    <published>2019-12-08T08:09:29.000Z</published>
    <updated>2019-12-08T08:14:31.317Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-桥接模式"><a href="#1-桥接模式" class="headerlink" title="1.桥接模式"></a>1.桥接模式</h5><p>通过使用物理机的网卡，有自己的IP地址，就像在电脑上虚拟出来另一台主机，它可以访问网内任何一台主机，需要手工为其配置IP地址、子网掩码、需要和宿主机器处于同一个网段，这样虚拟机才能和宿主机器进行通信。同时，由于这个虚拟系统是局域网中的一个独立主机系统，就可以手工配置他的TCP\IP信息，实现通过局域网的网关或路由进行互联网访问。</p><a id="more"></a><p><strong>弊端:</strong></p><ol><li><p>Ip地址可能会发生变化 192.150.1.100/192.168.1.101</p></li><li><p>如果这时传递文件时需要依靠交换机/路由器</p></li></ol><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E5%92%8CNAT%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/1.png" alt="1"></p><h5 id="2-NAT模式"><a href="#2-NAT模式" class="headerlink" title="2.NAT模式"></a>2.NAT模式</h5><p>使用NAT模式，就是让虚拟系统借助NAT（网络地址的转换功能），通过宿主机器所在的网络来访问公网，也就是说使用NAT模式可以实现在虚拟系统里访问互联网，NAT模式下的虚拟系统的TCP/IP配置是由VMnet8（NAT）虚拟网络的DHCP服务器提供的，无法进行手工修改，因此虚拟系统也就无法和本局域网中的其他真是主机进行通讯。采用NAT模式的虚拟机的有点就是，想要接入互联网十分方便，只要宿主机能访问到互联网即可。</p><p><strong>特点:</strong></p><ol><li><p>NAT模式时,只能由真实的计算机连接虚拟网络空间,其他的计算机由于网络不在一个网段内,则不能通信.</p></li><li><p>NAT模式时,IP地址一般都是固定不变的.所以无论在哪里.Ip都能直接连接.</p></li></ol><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E5%92%8CNAT%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/2.png" alt="2"></p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;1-桥接模式&quot;&gt;&lt;a href=&quot;#1-桥接模式&quot; class=&quot;headerlink&quot; title=&quot;1.桥接模式&quot;&gt;&lt;/a&gt;1.桥接模式&lt;/h5&gt;&lt;p&gt;通过使用物理机的网卡，有自己的IP地址，就像在电脑上虚拟出来另一台主机，它可以访问网内任何一台主机，需要手工为其配置IP地址、子网掩码、需要和宿主机器处于同一个网段，这样虚拟机才能和宿主机器进行通信。同时，由于这个虚拟系统是局域网中的一个独立主机系统，就可以手工配置他的TCP\IP信息，实现通过局域网的网关或路由进行互联网访问。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://www.faihung.net/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="VMware" scheme="http://www.faihung.net/tags/VMware/"/>
    
      <category term="网络配置" scheme="http://www.faihung.net/tags/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>工具-如何配置Windows、虚拟机、开发板的网络</title>
    <link href="http://www.faihung.net/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/"/>
    <id>http://www.faihung.net/2019/12/08/工具-如何配置Windows、虚拟机、开发板的网络/</id>
    <published>2019-12-08T07:52:18.000Z</published>
    <updated>2019-12-08T08:00:16.400Z</updated>
    
    <content type="html"><![CDATA[<p>烧录软件和方便调试先要保证电脑windos操作系统、虚拟机linuxr操作系统<br>和开发板三者之间相互Ping通，要做到这些其实很简单：</p><a id="more"></a><h5 id="1-打开windows网络和共享中心更改适配器设置"><a href="#1-打开windows网络和共享中心更改适配器设置" class="headerlink" title="1. 打开windows网络和共享中心更改适配器设置"></a>1. 打开windows网络和共享中心更改适配器设置</h5><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/1.png" alt="1"></p><h5 id="2-打开这三个的属性，把VMware-Bridge-Protocol都勾上，如图"><a href="#2-打开这三个的属性，把VMware-Bridge-Protocol都勾上，如图" class="headerlink" title="2. 打开这三个的属性，把VMware Bridge Protocol都勾上，如图"></a>2. 打开这三个的属性，把VMware Bridge Protocol都勾上，如图</h5><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/2.png" alt="2"></p><h5 id="3-打开本地连接的属性再打开IPV4的属性选择使用手动IP如下图所示"><a href="#3-打开本地连接的属性再打开IPV4的属性选择使用手动IP如下图所示" class="headerlink" title="3. 打开本地连接的属性再打开IPV4的属性选择使用手动IP如下图所示"></a>3. 打开本地连接的属性再打开IPV4的属性选择使用手动IP如下图所示</h5><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/3.png" alt="3"></p><h5 id="4-点击VMware的虚拟机-gt-设置-网络选择桥接如下图所示"><a href="#4-点击VMware的虚拟机-gt-设置-网络选择桥接如下图所示" class="headerlink" title="4. 点击VMware的虚拟机-&gt; 设置 网络选择桥接如下图所示"></a>4. 点击VMware的虚拟机-&gt; 设置 网络选择桥接如下图所示</h5><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/4.png" alt="4"></p><p>网络选择桥接如下图所示</p><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/5.png" alt="5"></p><h5 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h5><h6 id="5-1-点击VMware的编辑-gt-虚拟网络编辑器"><a href="#5-1-点击VMware的编辑-gt-虚拟网络编辑器" class="headerlink" title="5.1 点击VMware的编辑-&gt;虚拟网络编辑器"></a>5.1 点击VMware的编辑-&gt;虚拟网络编辑器</h6><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/6.png" alt="6"></p><h6 id="5-2-点击更改设置"><a href="#5-2-点击更改设置" class="headerlink" title="5.2 点击更改设置"></a>5.2 点击更改设置</h6><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/7.png" alt="7"></p><h6 id="5-3-点击桥接模式，选择自己要桥接的网卡-网卡要记得选对"><a href="#5-3-点击桥接模式，选择自己要桥接的网卡-网卡要记得选对" class="headerlink" title="5.3 点击桥接模式，选择自己要桥接的网卡(网卡要记得选对)"></a>5.3 点击桥接模式，选择自己要桥接的网卡(网卡要记得选对)</h6><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEWindows%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%BD%91%E7%BB%9C/8.png" alt="8"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;烧录软件和方便调试先要保证电脑windos操作系统、虚拟机linuxr操作系统&lt;br&gt;和开发板三者之间相互Ping通，要做到这些其实很简单：&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://www.faihung.net/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Windows" scheme="http://www.faihung.net/tags/Windows/"/>
    
      <category term="VMware" scheme="http://www.faihung.net/tags/VMware/"/>
    
      <category term="网络配置" scheme="http://www.faihung.net/tags/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>工具-在WIN10上搭建Ftp服务器（转）</title>
    <link href="http://www.faihung.net/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/"/>
    <id>http://www.faihung.net/2019/12/07/工具-在WIN10上搭建Ftp服务器（转）/</id>
    <published>2019-12-07T09:29:44.000Z</published>
    <updated>2019-12-08T09:33:36.429Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在windows10上面搭建你的FTP服务器，     正在学服务器这门课程，刚好学到搭建Ftp服务器。所以就在自己电脑上也搭建了一个Ftp服务器。我的电脑是win10的，所以本教程也是在win10上面搭建Ftp服务器。希望能帮到有需要的同学！</p></blockquote><a id="more"></a><h5 id="一、在windows10中搭建Ftp服务器主要用的是IIS管理器管理控制台"><a href="#一、在windows10中搭建Ftp服务器主要用的是IIS管理器管理控制台" class="headerlink" title="一、在windows10中搭建Ftp服务器主要用的是IIS管理器管理控制台"></a>一、在windows10中搭建Ftp服务器主要用的是IIS管理器管理控制台</h5><h6 id="1-在控制面板里面打开程序功能里面的FTP服务器和web管理工具"><a href="#1-在控制面板里面打开程序功能里面的FTP服务器和web管理工具" class="headerlink" title="1. 在控制面板里面打开程序功能里面的FTP服务器和web管理工具"></a>1. 在控制面板里面打开程序功能里面的FTP服务器和web管理工具</h6><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/1.png" alt="1"></p><h5 id="二、打开IIS管理器平台，不知道在哪打开的可以直接搜索IIS打开"><a href="#二、打开IIS管理器平台，不知道在哪打开的可以直接搜索IIS打开" class="headerlink" title="二、打开IIS管理器平台，不知道在哪打开的可以直接搜索IIS打开"></a>二、打开IIS管理器平台，不知道在哪打开的可以直接搜索IIS打开</h5><h6 id="1-在网站那里右键“添加FTP站点”"><a href="#1-在网站那里右键“添加FTP站点”" class="headerlink" title="1.在网站那里右键“添加FTP站点”"></a>1.在网站那里右键“添加FTP站点”</h6><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/2.png" alt="2"></p><h6 id="2-输入你的站点名称和物理路径"><a href="#2-输入你的站点名称和物理路径" class="headerlink" title="2. 输入你的站点名称和物理路径"></a>2. 输入你的站点名称和物理路径</h6><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/3.png" alt="3"></p><h6 id="3-下一步绑定你的FTP服务器地址，这里的端口使用默认的21号端口。IP地址是你本机的IP地址"><a href="#3-下一步绑定你的FTP服务器地址，这里的端口使用默认的21号端口。IP地址是你本机的IP地址" class="headerlink" title="3. 下一步绑定你的FTP服务器地址，这里的端口使用默认的21号端口。IP地址是你本机的IP地址"></a>3. 下一步绑定你的FTP服务器地址，这里的端口使用默认的21号端口。IP地址是你本机的IP地址</h6><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/4.png" alt="4"></p><h6 id="4-下一步，根据需要设置身份验证和授权信息"><a href="#4-下一步，根据需要设置身份验证和授权信息" class="headerlink" title="4. 下一步，根据需要设置身份验证和授权信息"></a>4. 下一步，根据需要设置身份验证和授权信息</h6><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/5.png" alt="5"></p><p>点击完成FTP服务器就搭建好了。</p><h5 id="三、测试你的ftp服务器"><a href="#三、测试你的ftp服务器" class="headerlink" title="三、测试你的ftp服务器"></a>三、测试你的ftp服务器</h5><p>在浏览器上输入ftp://<strong>.</strong>.<strong>.</strong>（填你自己的ftp地址）。你就可以看到你ftp目录里面的东西了，浏览器打开的效果是这样子的</p><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/6.png" alt="6"></p><h5 id="四、有小伙伴私信我，服务器搭建好了，自己可以访问，但是别人访问不了，以下我总结了以下解决方法，希望对你们有效"><a href="#四、有小伙伴私信我，服务器搭建好了，自己可以访问，但是别人访问不了，以下我总结了以下解决方法，希望对你们有效" class="headerlink" title="四、有小伙伴私信我，服务器搭建好了，自己可以访问，但是别人访问不了，以下我总结了以下解决方法，希望对你们有效"></a>四、有小伙伴私信我，服务器搭建好了，自己可以访问，但是别人访问不了，以下我总结了以下解决方法，希望对你们有效</h5><h6 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h6><p>把防火墙关掉、一般别人访问不了都是防火墙限制了，直接把防火墙关掉这是最快的解决方法</p><h6 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h6><p>如果你想把防火墙开着呢，那应该怎么做？</p><p>打开防火墙设置，选择允许的应用，把ftp服务器勾选上、然后再点击允许其它应用</p><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/7.png" alt="7"></p><p>选择C:\Windows\System32目录下面的svchost.exe这个软件</p><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/8.png" alt="8"></p><p>把这个应该添加到防火墙允许的应用里面</p><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/9.png" alt="9"></p><p>做完以上步骤再试一下，别人就可以在你开启防火墙的状态依旧可以访问你的ftp服务器了</p><p>但是有的小伙伴还是不能访问，那应该怎么办呢？继续以下步骤（如果进行完以上步骤可以访问就不用进行下面的操作）</p><p>依旧是打开防火墙设置，然后选择高级设置</p><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/10.png" alt="10"></p><p>在出站规则里面选择和frp相关的规则，点击右边的启用规则就可以了</p><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/11.png" alt="11"></p><p>启用之后规则左边就会被打上勾了</p><p><img src="/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/12.png" alt="12"></p><p>基本上我目前遇到小伙伴私信的问题都可以通过以上的方法解决，如果还是不行的话，记得私信我，我们再一起研究研究，然后把解决方法再加上。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在windows10上面搭建你的FTP服务器，     正在学服务器这门课程，刚好学到搭建Ftp服务器。所以就在自己电脑上也搭建了一个Ftp服务器。我的电脑是win10的，所以本教程也是在win10上面搭建Ftp服务器。希望能帮到有需要的同学！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://www.faihung.net/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="FTP" scheme="http://www.faihung.net/tags/FTP/"/>
    
  </entry>
  
  <entry>
    <title>视音频-视频简介</title>
    <link href="http://www.faihung.net/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E7%AE%80%E4%BB%8B/"/>
    <id>http://www.faihung.net/2019/12/01/视音频-视频简介/</id>
    <published>2019-12-01T08:24:26.000Z</published>
    <updated>2019-12-01T08:30:46.876Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>尽管视频信号有很多类型和实现技术,但其目的只是为了实现视觉信息在不同位置之间的传送。这些视觉信息可能是来自于VCR, DVD播放器、本地广播的某个频道、有线电视,或者来自于卫星电视系统、因特网,还可能是其他各种渠道。</p></blockquote><a id="more"></a><blockquote><p>但有一点是肯定的,那就是视频信息必须从一个设备传输到另一个设备。可能是从卫星电视机顶盒或DVD播放器传输到电视机,或者在卫星电视机顶盒或电视机内部不同芯片之间传输。这看起来好像很简单,但需要满足很多不同的要求,故存在很多方式来实现这种传输。</p></blockquote><h4 id="一、模拟与数字"><a href="#一、模拟与数字" class="headerlink" title="一、模拟与数字"></a>一、模拟与数字</h4><p>几年前,大多数的视频设备还主要是为模拟视频而设计的,数字视频还仅限于视频编辑这样的专业应用领域。</p><p>目前,普通消费者在日常生活中都用上了数字视频设备,这要得益于这些数字产品价格的不断下降。这种趋势也导致相关技术的快速发展,如DVD播放机和摄像机、数字机顶盒、数字电视(DTV)、便携视频播放器和基于因特网的视频数据传输能力等</p><h4 id="二、视频数据"><a href="#二、视频数据" class="headerlink" title="二、视频数据"></a>二、视频数据</h4><p>起初,视频仅仅包含灰度(也称为黑白)信息。</p><p>在建立彩色广播电视系统的过程中,人们试图用模拟RGB (红、绿、蓝)来发送彩色视频,然而,这种技术占用的带宽是当时使用的灰度解决方案的3倍多,因此必须创建其他的替代方法,于是,人们用Y, R-Y和G-Y数据来表示颜色信息,并开发相应的技术来传输Y, R-Y和G-Y信息。这种技术只需要一个信号,而不是3个独立的信号,因此只需要与原来传输灰度视频信号相同的带宽。今天广泛使用的NTSC、 PAL和SECAM视频标准仍然是建立在这种复合视频信号(composite video signal) 基础上的。</p><p>现在,尽管有很多种表示视频的方式,但它们都要通过RGB的数学公式表示出来。</p><p>s-Video是为了将终端设备连接(目的不是为了广播)在一起而建立的。每组信号由两个模拟信号构成:一个为灰度(Y)信息,另一个是以特定格式传输的模拟R-Y和B-Y颜色信息(也称为C或色度),这种技术曾经只在S-VHS中可用,但现在大多数消费类视频产品都支持这项技术。</p><p>尽管模拟RGB视频数据一直用于专业视频市场,但为了实现与高端消费设备的连接,模拟RGB视频数据也暂时应用于普通视频市场。与S-Video一样,模拟RGB视频数据也不用于广播。Y,R-Y、G-Y视频信号的另一种形式称为YPbPr,现在通常用于将消费类视频产品连接在起。其主要优点在于能够在消费类视频产品之间传输高分辨率视频。有些制造商错误地将YPbPT连接器称为YUV, YCbC或Y (B-Y) (R-Y)。</p><h5 id="2-1-数字视频"><a href="#2-1-数字视频" class="headerlink" title="2.1 数字视频"></a>2.1 数字视频</h5><p>目前最通用的数字信号为RGB和YCbCr. RGB是模拟RGB视频信号进行简单数字化后得到的版本。 YCbCT基本上是模拟YPbPr视频信号的数字化版本,这种格式由DVD和数字电视所采用。</p><h5 id="2-2最佳连接方法"><a href="#2-2最佳连接方法" class="headerlink" title="2.2最佳连接方法"></a>2.2最佳连接方法</h5><p>设备的最佳连接方法是什么?对于DVD播放器和数字有线电视/卫星电视/地面机顶盒,按照视频质量由好到差排序,一般的顺序为：</p><p>(1) HDMI (数字YCbCr)</p><p>(2) HIDMI (数字RGB)</p><p>(3)模拟YPbPr</p><p>(4)模拟RGB</p><p>(5)模拟S-Video</p><p>(6)模拟复合视频</p><p>有些人可能不同意这个排序。但是,大多数消费类产品都是在YCbCr颜色空间进行数字视处理的。因此,使用YCbCr作为设备互连格式可以减少所需的颜色空间转换次数。数字信号的颜色空间转换仍然优先选择进行D/A (数字到模拟)转换,接着进行AD (模拟到数字)转换,所以HDMI RGB排在模拟YPbPr之前。</p><p>计算机产业已经对接入计算机显示器的模拟和数字RGB信号进行了标准化。</p><h4 id="三、视频时序"><a href="#三、视频时序" class="headerlink" title="三、视频时序"></a>三、视频时序</h4><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E7%AE%80%E4%BB%8B/1.png" alt="1"></p><p>视频画面尽管看起来好像是连续运动的,其实那是一系列静止的图像。这些图像切换得足够快,  使得画面看起来像是连续运动的,如图2-1所示  对于消费类电子产品,通常情况下为每秒50或60张图像,计算机显示器为每秒70-90张图像。一种称为场同步(vertical sync)的特定时序信息被用于指定新图像从什么时候开始显示。</p><p>每张静止图像是由扫描线(scan line)组成的即沿着显示器从上到下、一行接着一行进行显示的数据线,如图2-1所示。另一种称为行同步(horizontal sync)的时序信息用于指定新扫描线什么时候开始显示。</p><p>行同步和场同步信息通常通过以下三种方式之一进行传输:</p><p>(1)单独的行同步和场同步信号;  </p><p>(2)单独的复合同步信号；</p><p>(3)嵌入视频信号的复合同步信号。</p><p>复合同步信号是由场同步和行同步信号组合而成的。使用模拟RGB视频的计算机和消费类设备通常采用技术(1)或(2),支持复合视频或模拟YPbPr视频的消费类设备通常采用技术(3)。对于数字视频,通常要么采用技术(1),要么就是将时序编码字嵌入数字视频流中。</p><h5 id="隔行与逐行"><a href="#隔行与逐行" class="headerlink" title="隔行与逐行"></a>隔行与逐行</h5><p>由于视频是由一系列静止图像组成的,因此,简单地连续显示每幅完整的图像是有意义的,也就是一张接一张地显示每幅图像。</p><p>上面所讲的就是逐行显示(progressive) [或称为非隔行(non-interlaced)显示]的基本技术。对于将图像以逐行方式“绘制”到屏幕上的设备(如CRT),每张图像都是从显示器的左上角开始,一直向右移动,直到到达显示器的右边缘为止然后向下扫描一行,重复地从左到右进行扫描。这个过程一直持续到整个屏幕全部被刷新一次为止,如图2-2所示。<br><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E7%AE%80%E4%BB%8B/2.png" alt="2"></p><p>在电视发展的早期,采用一种称为“隔行显(interlacing)”的技术来减少每幅图像所需发送  “绘制”出每幅图像的数据量。这种方式先发送奇数行的数据,接着发送偶数行的数据(如图2-3所示),因此每次发送的数据量为一幅图像数据量的一半。<br><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E7%AE%80%E4%BB%8B/3.png" alt="3"></p><p>既然隔行显示方式有这个优点,那么为什么还要多余地使用逐行显示方式呢?</p><p>在隔行显示方式中,每个扫描线更新的频率只有同等情况下逐行显示方式的一半。所以,为了避免由于过低的帧率而导致颜色对比显著的边缘出现闪烁,要限制扫描线之间的变化,这本质上是由于在垂直方向上对图像进行了低通滤波。而逐行显示方式对线之间的变化就没有这种限制因此,逐行显示方式能够提供更高分辨率(在垂直方向上)的没有闪烁的图像。</p><p>现在,大多数广播(包括HDTV)都仍然以隔行方式发射信号。大多数基于CRT的显示器也是隔行方式显示,而LCD、等离子以及计算机显示器都是采用逐行方式。</p><h4 id="四、视频分辨率"><a href="#四、视频分辨率" class="headerlink" title="四、视频分辨率"></a>四、视频分辨率</h4><p>在现实生活中,人们对于视频分辨率的概念往往有一些模糊的认识。我们通常见到的视频分辨率为720 x 480或1920 × 1080,然而,那只是水平采样和垂直扫描线的数目,并不等于说必须具有这么多有用信息。</p><p>例如,可以以13.5MHz的频率对模拟视频信号进行采样,生成每行720个采样点。对同样的信号以27MHz的频率采样可以生成每行1440个采样点。但这仅仅是每行的采样数目不同,视频内容的分辨率并没有改变。</p><p>因此,视频质量通常用线分辨率(lines of resolution)来度量。<br>本质上是表示在显示器上可以显示多少不同的黑白垂直线。然后将这个数目归一化为1 :1显示宽高比(对于4:3的显示器,将该数除以3/4,而对于16:9的显示器则除以916),当然,对于宽屏(16:9)显示器,这会使得视频分辨率较低,与直觉不相符。</p><h5 id="4-1-标准清晰度"><a href="#4-1-标准清晰度" class="headerlink" title="4.1 标准清晰度"></a>4.1 标准清晰度</h5><p>标准清晰度(standard-definition)视频通常定义为480或576的隔行有效扫描线的视频,分别称为”480i”和”576i”。</p><p>固定像素(非CRT)、具有4:3宽高比的消费类显示器通过转换后,对应于720 x 480i或720x576i的有效分辨率。而对于16:9的宽高比,转换后的有效分辨率对应于960 x 480i或960 x 576i</p><h5 id="4-2-增强清晰度"><a href="#4-2-增强清晰度" class="headerlink" title="4.2 增强清晰度"></a>4.2 增强清晰度</h5><p>增强清晰度(enhanced-definition)视频通常定义为具有480或576逐行有效扫描线的视频,分别称为”480p”或”576p”.</p><p>固定像素(非CRT)具有4 :3宽高比的消费类显示器转换后的有效分辨率对应于720 x480p或720 x 576p。而对于16 :9的宽高比,转换后的有效分辨率对应于960 x 480p或960 x 576p.</p><p>标准清晰度和增强清晰度的差异在于,标准清晰度是隔行的,而增强清晰度是逐行的。</p><h5 id="4-3高清晰度"><a href="#4-3高清晰度" class="headerlink" title="4.3高清晰度"></a>4.3高清晰度</h5><p>高清晰度(high-definition)视频通常定义为具有720逐行(720p)或1080隔行(1080i)有效扫描线的视频。固定像素(非CRT)、具有16:9宽高比的消费类显示器转换后的有效分辨率分别为1280 x 720p或1280 × 1080i</p><p>但是, HDTV显示器在技术上定义为能够显示最少720p或1080有效扫描线。它还必须能够用至少540逐行(540p)或810隔行(810i)有效扫描线来显示16:9的视频画面。这样,在制造具有4:3宽高比、基于CRT的HDTV和具有16 :9宽高比、分辨率为1024 x 1024p, 1280 x 768p, 1024×768p的LCD/等离子等显示器时,能够降低制造费用。</p><h4 id="五、音频与视频压缩"><a href="#五、音频与视频压缩" class="headerlink" title="五、音频与视频压缩"></a>五、音频与视频压缩</h4><p>近年来,数字电视、DVD播放机和摄像机、数字视频摄像机等消费类电子产品取得了一些最新进展,这归功于音频和视频压缩标准。这些压缩标准主要有:带有Dolbyo Digital的MEPG-2.DTS, MPEG-1或MPEG-2音频。</p><p>新的音频和视频编解码器,像MPEG-4 HE-AAC、 MPEG-4.10 (H.264)和SMPTE 421M (VC1),在保持同样质量时,提供了比以往编解码方法更高的压缩效率。这些进展使得可以使用新的见频发布方式(面向消费者和家庭内部)、新的消费产品(如便携视频播放器和移动视频移动电话)和更多的有线/星电视频道。</p><h4 id="六、应用框图"><a href="#六、应用框图" class="headerlink" title="六、应用框图"></a>六、应用框图</h4><p>下面几个简化的框图有助于我们认识视频流是如何经过各种相应处理的。</p><h5 id="6-1-DVD播放器"><a href="#6-1-DVD播放器" class="headerlink" title="6.1 DVD播放器"></a>6.1 DVD播放器</h5><p>图2-4为基本DVD播放机的简化框图,其中显示的是公共模块。如今所有这些模块都集成在廉价的芯片上了。<br><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E7%AE%80%E4%BB%8B/4.png" alt="4"></p><p>除了播放DVD (基于MPEG-2视频压缩技术)外, 目前, DVD播放器还有望处理MP3和WMA音频、MPEG-4视频(DivX视频)、 JPEG图像等。同时有望具有特定的播放模式,如以各科速度慢快进和快/慢退等。对DVD音频和SACD的支持也是很流行的。</p><p>DVD播放机的一个新增功能是能够接入到家庭网络中,用于播放一些存放于PC中的媒体(音乐、视频、图像等),这些“网络化的DVD播放机”也包括播放一些准备事后浏览的内容,如来源于因特网的电影和下载到内部硬盘(HDD)中的媒体。支持对各种闪存卡中的音频、视频和图像进行播放的这类需求也在不断增长。</p><p>有些DVD播放机制造商为了快速吸引买家的注意力,对视频的频率响应进行了超频处理,使得其产品看起来与众不同。但因为这种特性通常需要长时间的激励过程,所以很容易失败或需要调试。对于观看电影来讲,很多视频爱好者都认为频率响应应该尽可能平滑。</p><p>另一个问题是模拟视频信号的量化等级。尽管很容易产生每个精确的视频量化等级,但这些等级变化得相当快。目前有些评论也指出了这个问题,因为在信号源之间切换时可能会使发生变化的亮度或灰度值具有平均作用,从而使得用户进行的任何校正或手动调整失效。</p><h5 id="6-2-数字媒体适配器"><a href="#6-2-数字媒体适配器" class="headerlink" title="6.2 数字媒体适配器"></a>6.2 数字媒体适配器</h5><p>数字媒体适配器是连接到家庭网络、用于播放存放于PC或媒体存储器中的多媒体内容(音乐、视频、图像等)的设备。这些小而廉价的盒子使得媒体内容很容易在家庭中的任意或所有电视机上欣赏。许多数字媒体适配器支持无线网络功能,这就简化了数字媒体适配器的安装过程。</p><p>图2-5是基本的数字媒体适配器的简化框图,图中显示的是公共模块。如今所有这些模块都集成在一个廉价的芯片上了。</p><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E7%AE%80%E4%BB%8B/5.png" alt="5"></p><h5 id="6-3-数字电视机顶盒"><a href="#6-3-数字电视机顶盒" class="headerlink" title="6.3 数字电视机顶盒"></a>6.3 数字电视机顶盒</h5><p>数字电视标准可以分为7大类:</p><p>(1) ATSC (美国先进电视系统委员会)</p><p>(2) DVB (数字视频广播)</p><p>(3) ARIB (日本无线工业及商贸协会)</p><p>(4) IPTV (网络电视,包括基于P的DVB和ARIB)</p><p>(5)开放数字有线标准,如OpenCable标准</p><p>(6)带版权保护的数字有线标准</p><p>(7)带版权保护的数字卫星电视标准</p><p>起初这些机顶盒都是基于MPEG-2视频和DolbyoDigital或MPEG音频, 目前的机顶盒支持新的先进音视频标准,如MPEG-4 HE-AAC音频、Dolby Digital Plus音频、MPEG-4.10 (H.264)视频和SMPTE (VC-1)视频。</p><p>图2-6是数字电视机顶盒的简化结构图,图中显示的是公共音视频处理模块。数字机顶盒用于接收数字电视广播,这些数字电视广播可能来自地面台站(空中电波)、有线或卫星。在数字电视内部就可能包含这些电路。</p><p>目前的许多电视机顶盒有两个调谐器,并具有数字视频摄像(VCR)功能。这使得在浏览个内部HDD时,还可以往另一个内部HDD中读入节目。在数字电视接收机中,有了这两个调谐器,还可以支持PIP特性(即将2个输入影像输出到同一画面上)。</p><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E7%AE%80%E4%BB%8B/6.png" alt="6"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;尽管视频信号有很多类型和实现技术,但其目的只是为了实现视觉信息在不同位置之间的传送。这些视觉信息可能是来自于VCR, DVD播放器、本地广播的某个频道、有线电视,或者来自于卫星电视系统、因特网,还可能是其他各种渠道。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="视音频" scheme="http://www.faihung.net/categories/%E8%A7%86%E9%9F%B3%E9%A2%91/"/>
    
    
  </entry>
  
  <entry>
    <title>视音频-视频信号详解及测试-VGA</title>
    <link href="http://www.faihung.net/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95-VGA/"/>
    <id>http://www.faihung.net/2019/12/01/视音频-视频信号详解及测试-VGA/</id>
    <published>2019-12-01T04:11:15.000Z</published>
    <updated>2019-12-01T04:20:41.949Z</updated>
    
    <content type="html"><![CDATA[<h5 id="ARGB概述"><a href="#ARGB概述" class="headerlink" title="ARGB概述"></a>ARGB概述</h5><h6 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h6><p>生活中常用设备如个人电脑、视频游戏机和家庭影院等都具有视频输出，输出信号可分为模拟信号和数字信号。这主要讲述模拟视频信号（ARGB），即以VGA 物理接口传输的RGBHV 5 线信号。   VGA 接口也叫D-Sub接口</p><a id="more"></a><h6 id="VGA接口"><a href="#VGA接口" class="headerlink" title="VGA接口"></a>VGA接口</h6><p>VGA 即视频图形阵列，它是由IBM 在1987年随同PS/2 个人电脑而引入的一种图形控制器标准。</p><p>VGA物理接口是RGBHV 5 线信号，使用的是<br>700mV模拟R/G/B视频电平和TTL电平H/V同步信<br>号。</p><p>VGA物理接口一直被广泛地使用着，它为后来的图形控制器信号而保留。尽管通常把它称为“VGA 端口”，但是在今天15 针的RGBHV 输出端口中，所传送的分辨率和彩色位深的显示格式常常超出了6 4 0 × 4 8 0 VGA 标准。</p><h6 id="VGA接口定义"><a href="#VGA接口定义" class="headerlink" title="VGA接口定义"></a>VGA接口定义</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95-VGA/1.jpg" alt="image"></p><h6 id="常见ARGB接口"><a href="#常见ARGB接口" class="headerlink" title="常见ARGB接口"></a>常见ARGB接口</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95-VGA/2.png" alt="image"><br><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95-VGA/3.png" alt="image"><br><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95-VGA/4.png" alt="image"><br><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95-VGA/5.png" alt="image"></p><h6 id="支持的模拟信号分辨率"><a href="#支持的模拟信号分辨率" class="headerlink" title="支持的模拟信号分辨率"></a>支持的模拟信号分辨率</h6><p>可支持各种通用的模拟RGBHV 信号分辨率，从640×480p到2048×1536p，<br>屏幕刷新速率从60Hz 直至100Hz。</p><h5 id="ARGB信号传输（模拟信号的传输）"><a href="#ARGB信号传输（模拟信号的传输）" class="headerlink" title="ARGB信号传输（模拟信号的传输）"></a>ARGB信号传输（模拟信号的传输）</h5><p>工程中构建一个VGA信号传输、分配系统时，长距离传输是一个常见问题。 由于信号传输距离较远，传输系统的参数及周围电磁环境对信号质量产生的影响不容忽视，常见到的现象表现为：图像模糊、变暗、 拖尾和重影，以及图像显示不稳定（如：跳动或黑屏等）等。</p><p>以上现象产生的原因不同，解决的方法不同。我们将其分为四大类：</p><p>一、由于传输系统的幅频特性及群延时特性造成的图像模糊、变暗、拖尾；</p><p>二、由于设备产生自激或环境电磁干扰产生的高频干扰；</p><p>三、由于系统电源地线处理不当造成的低频干扰；</p><p>四、由于设备、传输系统或接插件等阻抗不匹配而引起的重影反射及显示不稳定. </p><p>随着工程规模的扩大，VGA信号长距离（大于100米）和超长距离（大于500米）的应用不断出现，单纯靠电缆的传输方式明显不适应使用的要求，随着技术的发展，不断有新的传输方式出现，使这类应用成为可能。 以下为目前可实用的传输方式： </p><p>模拟电缆（RGB电缆）加电缆均衡器 </p><p>网线加均衡器 </p><p>光纤传输 </p><p>在此前提下，根据不同的距离，可采用不同的传输方式：（一般建议）</p><p>50米以内：好的VGA电缆；</p><p>50~100米，电缆加EQ；</p><p>100~200米，网线加EQ（或有抗干扰等需求）；</p><p>200米以上，光纤传输。</p><h5 id="VESA介绍-视频电子标准协会"><a href="#VESA介绍-视频电子标准协会" class="headerlink" title="VESA介绍(视频电子标准协会)"></a>VESA介绍(视频电子标准协会)</h5><p>随着VGA接口的信号传输速率愈来愈高，视频电子标准协会<br>（Video Electronics Standards Association）认识到，接口性能问题则显得更加重要。VESA 于1999 年发布了不具约束力的标准，其目标是更严格地定义RGBHV接口的传输参数。该标准称为视频信号标准，即VSIS（Video Signal standard），它为RGBHV信号的大多数重要参数提供了推荐值。</p><h5 id="ARGB信号特征"><a href="#ARGB信号特征" class="headerlink" title="ARGB信号特征"></a>ARGB信号特征</h5><p>800X600@60Hz为例：<br><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95-VGA/6.png" alt="image"></p><p>VESA Monitor Timing Standard</p><pre><code>Hor Pixels = 800; // PixelsVer Pixels = 600; // LinesHor Frequency = 37.879; // KHz = 26.4 usec /lineVer Frequency = 60.317; // Hz = 16.6 msec /framePixel Clock = 40.0; // MHz = 25.0 nsec    +/-0.05%Scan Type = NONINTERLACED; Hor Sync Polarity = POSITIVE; // HBlank = 24.2% of HTotalVer Sync Polarity = POSITIVE; // VBlank = 4.5% of VTotalHor Total Time = 26.4; // (usec) =1056 PixelsHor Addr Time = 20.0; // (usec) = 800 PixelsHor Blank Start = 20.0; // (usec) = 800 PixelsHor Blank Time = 6.4; // (usec) = 256 PixelsHor Sync Start = 21; // (usec) = 840 PixelsH Right Border = 0.000; // (usec) = 0 PixelsH Front Porch = 1.0; // (usec) = 40 PixelsHor Sync Time = 3.2; // (usec) = 128 PixelsH Back Porch = 2.2; // (usec) = 88 PixelsH Left Border = 0.000; // (usec) = 0 PixelsVer Total Time = 16.579; // (msec) = 628 lines Ver Addr Time  = 15.84; // (msec) = 600 linesVer Blank Start = 15.84; // (msec) = 600 linesVer Blank Time = 0.739; // (msec) = 28 linesVer Sync Start = 15. 866; // (msec) = 601 linesV Bottom Border = 0.000; // (msec) = 0 linesV Front Porch = 0.026; // (msec) = 1 linesVer Sync Time  = 0.106; // (msec) = 4 linesV Back Porch = 0.607; // (msec) = 23 lines V Top Border = 0.000; // (msec) = 0 lines</code></pre><h5 id="VESA测试内容"><a href="#VESA测试内容" class="headerlink" title="VESA测试内容"></a>VESA测试内容</h5><p>在2002年VESA 对VSIS 作了补充，增加了测试规范部分。测试规范的名称简称为“测试规范－模拟显示器件图形子系统的评估”，每项测试均给出了测试需要的设备、测试图案、测试步骤和必要的分析。</p><p>如果您打算执行 VSIS 测试，那么“测试规范－模拟显示器件图形子系统的评估”，是一个重要文件。这个文件有助于理解VSIS规范及其意义。</p><p>可以通过VESA得到VSIS文件及其相应的测试规程。这两个文件为评测VGA接口性能提供了一种有效的方法。</p><h6 id="信号测试项目"><a href="#信号测试项目" class="headerlink" title="信号测试项目"></a>信号测试项目</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95-VGA/7.png" alt="image"></p><h6 id="信号测试环境"><a href="#信号测试环境" class="headerlink" title="信号测试环境"></a>信号测试环境</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95-VGA/8.png" alt="image"><br>H/V负载电阻：2.2K 电阻，R/G/B负载电阻： 75 欧电阻</p><p>注：电阻精密度为0.1%。</p><h6 id="测试图"><a href="#测试图" class="headerlink" title="测试图"></a>测试图</h6><p>推荐使用三种静态测试图案用于VSIS测量。利用这三种测试图案激励DUT以产生RGVHV信号。图案如：<br><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%B5%8B%E8%AF%95-VGA/9.png" alt="image"></p><p>一种称为“垂直栅格”的黑白垂直条纹交替图案，由 RGB ＝ FFh 的100 个像素和随后的RGB ＝ 00h 的100个像素组成并重复这一组合。这种栅格图案用于<br>RGB 视频幅度和瞬态响应测量。</p><ul><li>视频最大/最小亮度电压值</li><li>视频信号上升/下降时间</li><li>视频稳定建立时间</li><li>视频信号过冲/下冲</li><li>视频通道间时延</li></ul><p>水平显示的、从全黑到全白的灰度渐变斜坡或台阶信号。斜坡信号用于RGB线性和通道间失配测量。</p><ul><li>视频积分线性误差</li><li>视频微分线性误差</li><li>视频通道间失配</li></ul><p>全白平场信号或窗口信号，用于RGB视频噪声测量。</p><ul><li>视频噪声注入比</li></ul><h6 id="同步测量"><a href="#同步测量" class="headerlink" title="同步测量"></a>同步测量</h6><p>H 同步抖动</p><p>行同步功能是用来正确地规定每一图像显示行的位置。在理想情况下，从一个H同步脉冲到下一个H同步脉冲的时间应当是恒定的。如果H同步定时发生变化，那么在一帧中的图像部分就会发生水平位移。这种同步定时的变化称为抖动。对于一些重要的内容，漂移0.02％的图像宽度就会被察觉。</p><p>VSIS规定H同步抖动的最大峰峰值为像素周期的30％。这就是说，对于800×600格式，H 同步抖动的最大峰峰值为图像宽度的0.038％，而对于2048 × 1536 格式，其值为图像宽度的0.015％。</p><p>H 和V 定时</p><p>H定时和V定时测量是将同步位置与有源RGB视频进行比较，从而有助于确定显示器能否正确居中以及是否有正确的可寻址行数。</p><p>如果1024 × 768 屏幕格式的V 定时结果只有764显示行是因为上方和下方的边界不正确。这样上方2行和下方2行的任何信息将会被丢失。</p><p>H同步和V同步是测量同步脉冲的幅度、脉冲保真度和同步定时。如果这些测量参数超出容限，那么显示器的锁定可能是不可靠的。</p><h6 id="视频测量"><a href="#视频测量" class="headerlink" title="视频测量"></a>视频测量</h6><p>视频测量是用来评测模拟RGB信号的特性，包括电平、瞬变特性和噪声等。假定同步正确，那么RGB 视频特性将决定显示器的保真度。</p><p>这些测量可以划分为：<br>亮度电平、通道间失配、视频瞬变、线性、通道间畸变和噪声抑制比。</p><p><strong>亮度电平</strong></p><p>亮度电平测量用来测定DUT输出全白（其值为FFh）和黑图像信号 (其值为00h) 时的RGB 电压电平值。就理想状况而言，白电平应是700mV 而黑电平应是0mV。这些数值是绝对测量值，是以RGB信号的返回线 (接地端) 作为参考。</p><p>适当的电平对于显示器的正确亮度和对比度是重要的。</p><p><strong>通道间的失配</strong></p><p>通道间的失配用来比较RGB通道间的幅度匹配状况。测试是在黑(00h) 白 (FFh) 之间32个等间距的电平上进行的，使用的是阶梯波测试信号。对于阶梯波中的每一个台阶，均相对于该通道的行后肩电平以测量RGB电压。然后来比较通道间的电压（G&amp;B…）。</p><p>即使不考虑VSIS的规定，通道间失配的允许程度与应用也是密切相关的。通道间的失配会影响到重现的环境亮度、重现的亮度和对比度设置等</p><p><strong>视频瞬变特性</strong></p><p>视频瞬变特性是用来评估RGB通道中黑白电平跳变时的保真度。这项测量使用的是垂直栅格测试图案，由黑到白的过渡时间是一个像素的时间。每个通道均按10％至90％白电平幅度测量上升时间和下降时间、过冲(正向跳变) 、下冲(负向跳变) 和恢复稳定所需时间(settling time)。</p><p><strong>视频瞬变</strong></p><p>对于具有精密细节或锐利边界变化的任一图像而言，良好的过渡响应是非常重要的。例如，如果上升时间或下降时间过于缓慢，将会使图像的变化模糊而不清晰。过度的振铃会使图像素材在跳变之后出现亮/暗交替变化的现象。过冲和下冲是较为次要的问题，除非过渡到稳定建立需要很长的时间。事实上，某些过冲/ 下冲可能会增强图像信号跳变清晰度的感觉，许多显示器件有意地引入受控的预冲和过冲。</p><p><strong>线性</strong></p><p>线性是用来检查DUT在黑白之间的变化特性。在理想情况下，如果斜率恒定的黑白之间的斜坡测试信号加在DUT的输入端，其输出也应当是斜率恒定的斜坡。一般而言，DUT的输出斜坡会给出某种斜率的变化。这种变化表示出现了线性误差。</p><p>线性对于再现正确的灰度级别是重要的。如果单个RGB通道之间的线性差比较大，那么黑白之间的灰度级图案可能会在某些位置出现轻微的彩色。</p><p>VSIS定义了两种类型的线性测试方法。</p><p>第一种方法是积分非线性(INL)，它可以检查黑色和某些其它点之间的整个斜率误差。</p><p>第二种方法是微分非线性 (DNL)，它用来评测两个相邻点之间的斜率误差。</p><p>测试信号使用的一种黑白斜坡信号实际上是一连串的台阶信号。如果系统使用10比特系统就有1024 级台阶。</p><p><strong>噪声抑制比</strong></p><p>这是一项单个RGB通道中的噪声测量。VSIS规定峰至峰噪声测量是在白色图案上进行的，带宽在500MHz以上。峰至峰噪声值不应超过白色电压的5％。</p><p>VSIS规定在2秒的测量间隔内使用100000个噪声样值。</p><h5 id="什么参数对用户最重要？"><a href="#什么参数对用户最重要？" class="headerlink" title="什么参数对用户最重要？"></a>什么参数对用户最重要？</h5><p>如果互操作性－即信源在多种显示器件中均能正常工作－是最重要的，那么应当关注H和V同步测量、RGB亮度电平测量以及彩条测量。这些参数有助于建立正确的同步、正确的白/黑电平，并能使所有的RGB信号有效。</p><p>对于同步测量，特别要重视以下信号损伤：</p><ul><li>不正确的极性</li><li>频率错误</li><li>过度的过冲/ 下冲(特别是当偏离进入到0.5V 至2.4V范围时)</li><li>非单调性地上升或下降</li></ul><p>如果显示系统的灰度级性能非常重要（例如诸如彩色匹配之类的应用），那么就应当特别关注通道间的失配、线性以及RGB亮度电平测量。</p><p>通道间的失配测量将提供整个视频范围内各个通道相互间的跟踪是否接近的信息。</p><p>线性测量提供了每个通道中黑白电平转换的有关信息。</p><p>RGB亮度电平测量为整个700mV视频范围是否得到充分使用而提供了验证，因为这对于图像的对比度是否合适是很重要的。</p><p>对于图像绘制应用，例如PC视频应用，应当注重噪声、瞬态响应、RGB 亮度电平、通道间的匹配（包括通道间的幅度匹配和时间对准）以及H同步抖动等项目的测量，这对图像绘制应用是十分有利的。</p><p>需要注意的是，VSIS 测试没有检测运动相关图像的失真。但是，如果图像的随机噪声和抖动都很小，一般说来，尽管压缩也只会产生较低的失真。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;ARGB概述&quot;&gt;&lt;a href=&quot;#ARGB概述&quot; class=&quot;headerlink&quot; title=&quot;ARGB概述&quot;&gt;&lt;/a&gt;ARGB概述&lt;/h5&gt;&lt;h6 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h6&gt;&lt;p&gt;生活中常用设备如个人电脑、视频游戏机和家庭影院等都具有视频输出，输出信号可分为模拟信号和数字信号。这主要讲述模拟视频信号（ARGB），即以VGA 物理接口传输的RGBHV 5 线信号。   VGA 接口也叫D-Sub接口&lt;/p&gt;
    
    </summary>
    
    
      <category term="视音频" scheme="http://www.faihung.net/categories/%E8%A7%86%E9%9F%B3%E9%A2%91/"/>
    
    
      <category term="视频信号" scheme="http://www.faihung.net/tags/%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7/"/>
    
      <category term="VESA" scheme="http://www.faihung.net/tags/VESA/"/>
    
      <category term="ARGB" scheme="http://www.faihung.net/tags/ARGB/"/>
    
      <category term="VSIS" scheme="http://www.faihung.net/tags/VSIS/"/>
    
      <category term="VGA" scheme="http://www.faihung.net/tags/VGA/"/>
    
  </entry>
  
  <entry>
    <title>视音频-常用视频信号配图介绍</title>
    <link href="http://www.faihung.net/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/"/>
    <id>http://www.faihung.net/2019/12/01/视音频-常用视频信号配图介绍/</id>
    <published>2019-11-30T16:18:49.000Z</published>
    <updated>2019-11-30T16:28:59.942Z</updated>
    
    <content type="html"><![CDATA[<h5 id="常用视频信号介绍"><a href="#常用视频信号介绍" class="headerlink" title="常用视频信号介绍"></a>常用视频信号介绍</h5><a id="more"></a><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/1.png" alt="image">)<img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/2.png" alt="image">)<img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/3.png" alt="image"></p><p>这里主要介绍可能用到的测试视频信号。<br>一般来讲，客户经常会用到灰阶、彩条这些测试信号，来测试画面显示是否正常。<br>例如每一阶能不能正常显示，过渡是否自然。<br>Color bar显示有没有偏色，Y/C 分离处理得好不好。<br>下面的资料可以参考一下。</p><h5 id="测试信号的类别"><a href="#测试信号的类别" class="headerlink" title="测试信号的类别"></a>测试信号的类别</h5><p>Gray Scale &amp; Levels (灰度和灰阶)</p><p>Geometry &amp; Convergence(几何特性和会聚)</p><p>Letterbox Geometry(4:3显示比例下的几何特性)</p><p>Wide Screen Enhanced(16:9显示比例显示特性)</p><p>Resolution(解析度)</p><p>Color Adjustment(色彩调整)</p><p>Special Test(包括Y/C delay,color decoder等)</p><h5 id="几种典型视频信号"><a href="#几种典型视频信号" class="headerlink" title="几种典型视频信号"></a>几种典型视频信号</h5><h6 id="Vertical-10-IRE-steps-灰阶信号）"><a href="#Vertical-10-IRE-steps-灰阶信号）" class="headerlink" title="Vertical 10 IRE steps(灰阶信号）"></a>Vertical 10 IRE steps(灰阶信号）</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/4.png" alt="image"></p><p>由左到右亮度值分别为100(white),90,80,70,60,50,40,30,20,10,7.5 IRE(black)</p><p>观察重点</p><p>1)每阶都能正常显示</p><p>2)阶与阶之间层次分明,宽度相同</p><p>3)从一阶到另一阶之间不应该有颜色变化</p><h6 id="Cross-Hatch"><a href="#Cross-Hatch" class="headerlink" title="Cross Hatch"></a>Cross Hatch</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/5.png" alt="image"></p><p>主要用来设置显示的尺寸,几何特性和会聚</p><p>这个画面由大小相同的水平和垂直的直线组成</p><p>正常的情况下,所有的方格应该大小相同,没有扭曲</p><p>边缘的标记用来设置显示的尺寸和中心</p><h6 id="MultiBurst-with-label"><a href="#MultiBurst-with-label" class="headerlink" title="MultiBurst with label"></a>MultiBurst with label</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/6.png" alt="image"></p><p>主要用来检查频率响应和设置Sharpness</p><p>该画面由几组频率相同的信号组成(其中3.58MHz是NTSC色负载波的频率,4.18MHz是广播频率的上限).上半部分的背景是50%的亮度,正常情况下下半部分的亮度<br>和信号的亮度相同</p><p>Sharpness设置合适时,所有的信号应该有相同的亮度,且没有边缘锐化的现象</p><h6 id="Resolution-200-TVL"><a href="#Resolution-200-TVL" class="headerlink" title="Resolution 200 TVL"></a>Resolution 200 TVL</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/7.png" alt="image"></p><p>用来测量水平和垂直方向的解析度,水平方向的解析度测量范围是200-540 TV line,垂直方向的解析度是200-480TV line.</p><p>周围的四个圆圈的频率分别是3.0,3.58,4.18和6.75MHz,可以作为解析度测试的补充</p><h6 id="Sharpness"><a href="#Sharpness" class="headerlink" title="Sharpness"></a>Sharpness</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/8.png" alt="image"></p><p>用来调整Sharpness和Vertical aperture</p><p>该画面由四部分组成</p><p>1)水平方向的信号用来设置频率响应</p><p>2)垂直方向的信号用来设置vertical aperture</p><p>3)其中的线和曲线用来侦测边缘的缺陷</p><p>4)垂直和水平的线段用来侦测模糊现象</p><h6 id="75-Split-Color-Bars"><a href="#75-Split-Color-Bars" class="headerlink" title="75% Split Color Bars"></a>75% Split Color Bars</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/9.png" alt="image"></p><p>主要用来校正色彩和色调</p><p>校正方法:</p><p>1)使灰阶信号和蓝色信号对齐来设置色度(理论上来讲,只要蓝色成分得到正确的校正,其他颜色应该可以正常的显示,因为蓝色成分经历了最多的编码)</p><p>2)使洋红和青色对准来调整色调</p><p>Note: 75% color bars接近广播信号中色彩显示的上限且满足FCC信号接口标准,所以经常被用来校正显示</p><h6 id="Y-C-Delay"><a href="#Y-C-Delay" class="headerlink" title="Y/C Delay"></a>Y/C Delay</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/10.png" alt="image"></p><p>用来测量Y/C Delay error</p><p>左边的部分用来测量Y/C Delay error;右边的部分用来观察是否存在Y/C delay error.正常情况下,红色竖条边缘应该没有扭曲</p><p>Y/C delay正常的情况下,R,G,B方块应与其对应的灰色方块在0度时对齐</p><h6 id="Color-Decoder"><a href="#Color-Decoder" class="headerlink" title="Color Decoder"></a>Color Decoder</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/11.png" alt="image"></p><p>用来测量RGB解码的准确度</p><p>该画面包含77 IRE的灰色背景和色度范围从+25%到-25%的R,G,B色块</p><p>测量时,需要只打开R,G,B中的一种颜色,然后看在0%位置,该颜色是否与其对应的背景颜色是否一致</p><h6 id="Overscan"><a href="#Overscan" class="headerlink" title="Overscan"></a>Overscan</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/12.png" alt="image"></p><p>用来测量屏幕隐藏的部分的百分比,也可以用来调整显示的区域和使屏幕置中</p><p>边缘的数字表示当前显示隐藏的图象的百分比.品质比较好的显示最多允许存在3%到5%隐藏比例</p><p>另外可以用该画面来调整水平和垂直的位置,使上下左右有同样的隐藏比例,从而保证画面位于屏幕的中央</p><h6 id="Gamma"><a href="#Gamma" class="headerlink" title="Gamma"></a>Gamma</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/13.png" alt="image"></p><p>用来测量显示设备的gamma值</p><p>该画面由六组标有gamma值的灰色方块组成</p><p>测量时,找出与背景颜色最接近的方块,该方块的数值就是显示设备的gamma值</p><h6 id="Center-Cross"><a href="#Center-Cross" class="headerlink" title="Center Cross"></a>Center Cross</h6><p><img src="/2019/12/01/%E8%A7%86%E9%9F%B3%E9%A2%91-%E5%B8%B8%E7%94%A8%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7%E9%85%8D%E5%9B%BE%E4%BB%8B%E7%BB%8D/14.png" alt="image"></p><p>主要用来设置R,G,B CRT电子枪的静会聚(static convergence).</p><p>十字线周围的短线指明了显示的安全区域,显示的区域至少应该短线包含的范围内</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;常用视频信号介绍&quot;&gt;&lt;a href=&quot;#常用视频信号介绍&quot; class=&quot;headerlink&quot; title=&quot;常用视频信号介绍&quot;&gt;&lt;/a&gt;常用视频信号介绍&lt;/h5&gt;
    
    </summary>
    
    
      <category term="视音频" scheme="http://www.faihung.net/categories/%E8%A7%86%E9%9F%B3%E9%A2%91/"/>
    
    
      <category term="视频信号" scheme="http://www.faihung.net/tags/%E8%A7%86%E9%A2%91%E4%BF%A1%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>视音频中ES PS TS 等流的区别</title>
    <link href="http://www.faihung.net/2019/11/25/%E8%A7%86%E9%9F%B3%E9%A2%91%E4%B8%ADES-PS-TS-%E7%AD%89%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.faihung.net/2019/11/25/视音频中ES-PS-TS-等流的区别/</id>
    <published>2019-11-24T16:11:55.000Z</published>
    <updated>2019-11-30T15:11:08.167Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h4><h5 id="1-ES"><a href="#1-ES" class="headerlink" title="1. ES"></a>1. ES</h5><p>ES–Elementary  Streams  (原始流)是直接从编码器出来的数据流，可以是编码过的视频数据流（H.264,MJPEG等），音频数据流（AAC），或其他编码数据流的统称。ES流经过PES打包器之后，被转换成PES包。</p><a id="more"></a><p>ES是只包含一种内容的数据流，如只含视频或只含音频等，打包之后的PES也是只含一种性质的ES,如只含视频ES的PES,只含音频ES的PES等。每个ES都由若干个存取单元（AU）组成，每个视频AU或音频AU都是由头部和编码数据两部分组成，1个AU相当于编码的1幅视频图像或1个音频帧，也可以说，每个AU实际上是编码数据流的显示单元，即相当于解码的1幅视频图像或1个音频帧的取样。</p><h5 id="2-PES"><a href="#2-PES" class="headerlink" title="2. PES"></a>2. PES</h5><p>PES–Packetized  Elementary Streams  (分组的ES)，ES形成的分组称为PES分组，是用来传递ES的一种数据结构。PES流是ES流经过PES打包器处理后形成的数据流，在这个过程中完成了将ES流分组、打包、加入包头信息等操作（对ES流的第一次打包）。PES流的基本单位是PES包。PES包由包头和payload组成。</p><h5 id="3-PTS、DTS"><a href="#3-PTS、DTS" class="headerlink" title="3. PTS、DTS"></a>3. PTS、DTS</h5><p>PTS–PresentationTime Stamp（显示时间标记）表示显示单元出现在系统目标解码器（H.264、MJPEG等）的时间。</p><p>DTS–Decoding Time Stamp（解码时间标记）表示将存取单元全部字节从解码缓存器移走的时间。</p><p>PTS/DTS是打在PES包的包头里面的，这两个参数是解决音视频同步显示，防止解码器输入缓存上溢或下溢的关键。每一个I（关键帧）、P（预测帧）、B（双向预测 帧）帧的包头都有一个PTS和DTS，但PTS与DTS对于B帧不一样，无需标出B帧的DTS，对于I帧和P帧，显示前一定要存储于视频解码器的重新排序缓存器中，经过延迟（重新排序）后再显示，所以一定要分别标明PTS和DTS。</p><h5 id="4-PS"><a href="#4-PS" class="headerlink" title="4. PS"></a>4. PS</h5><p>PS–Program Stream(节目流)PS流由PS包组成，而一个PS包又由若干个PES包组成（到这里，ES经过了两层的封装）。PS包的包头中包含了同步信息与时钟恢复信息。一个PS包最多可包含具有同一时钟基准的16个视频PES包和32个音频PES包。</p><h5 id="5-TS"><a href="#5-TS" class="headerlink" title="5. TS"></a>5. TS</h5><p>TS–Transport Stream（传输流）由定长的TS包组成（188字节），而TS包是对PES包的一个重新封装（到这里，ES也经过了两层的封装）。PES包的包头信息依然存在于TS包中。</p><h5 id="6-TS流与PS流的区别"><a href="#6-TS流与PS流的区别" class="headerlink" title="6. TS流与PS流的区别"></a>6. TS流与PS流的区别</h5><p>TS流与PS流的区别在于TS流的包结构是固定长度的,而PS流的包结构是可变长度的。PS包由于长度是变化的,一旦丢失某一PS包的同步信息,接收机就会进入失步状态,从而导致严重的信息丢失事件。而TS码流由于采用了固定长度的包结构,当传输误码破坏了某一TS包的同步信息时,接收机可在固定的位置检测它后面包中的同步信息,从而恢复同步,避免了信息丢失。因此在信道环境较为恶劣、传输误码较高时一般采用TS码流,而在信环境较好、传输误码较低时一般采用PS码流。</p><h5 id="7-TS单一码流、混合码流"><a href="#7-TS单一码流、混合码流" class="headerlink" title="7.TS单一码流、混合码流"></a>7.TS单一码流、混合码流</h5><p>单一性：TS流的基本组成单位是长度为188字节的TS包。</p><p>混合性： TS流由多种数据组合而成，一个TS包中的数据可以是视频数据，音频数据，填充数据，PSI/SI表格数据等（唯一的PID对应）。</p><h5 id="8-封装"><a href="#8-封装" class="headerlink" title="8. 封装"></a>8. 封装</h5><p>封装，就是捆绑打包, 将画面视频文件和音轨文件打包在一起,并按照一定规则建立排序和索引, 便于播放器或播放软件来索引播放. 包括AVI / PS(Program Stream)/ TS（Transport Stream）/ MKV（Matroska）等.</p><h4 id="二、基本流程"><a href="#二、基本流程" class="headerlink" title="二、基本流程"></a>二、基本流程</h4><p><img src="/2019/11/25/%E8%A7%86%E9%9F%B3%E9%A2%91%E4%B8%ADES-PS-TS-%E7%AD%89%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB/1.jpg" alt="1"></p><ol><li>A/D转换后，通过MPEG-2压缩编码得到的ES基本流。这个数据流很大，并且只是I，P，B的这些视频帧或音频取样信息</li><li>通过PES打包器，打包并在每个帧中插入 PTS/DTS标志，变成PES。原来是流的格式，现在成了数据包的分割形式。</li><li>PES根据需要打包成PS或TS包进行存储（DVD）或传输(DVB)。因每路音/视频只包含一路的编码数据流，所以每路PES也只包含相应的数据流。</li></ol><p><img src="/2019/11/25/%E8%A7%86%E9%9F%B3%E9%A2%91%E4%B8%ADES-PS-TS-%E7%AD%89%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB/2.jpg" alt="2"></p><h4 id="三、推理过程"><a href="#三、推理过程" class="headerlink" title="三、推理过程"></a>三、推理过程</h4><h5 id="3-1-TS流的解码过程：ES-PES-DTS-PTS-PCR"><a href="#3-1-TS流的解码过程：ES-PES-DTS-PTS-PCR" class="headerlink" title="3.1 TS流的解码过程：ES-PES-DTS-PTS-PCR"></a>3.1 TS流的解码过程：ES-PES-DTS-PTS-PCR</h5><ol><li>获取TS中的PAT</li><li>获取TS中的PMT</li><li>根据PMT可以知道当前网络中传输的视频（音频）类型（H264），相应的PID，PCR的PID等信息。</li><li>设置demux 模块的视频Filter 为相应视频的PID和stream type等。</li><li>从视频Demux Filter 后得到的TS数据包中的payload 数据就是 one piece of PES，在TS header中有一些关于此 payload属于哪个PES的第多少个数据包。 因此软件中应该将此payload中的数据copy到PES的buffer中，用于拼接一个PES包。</li><li>拼接好的PES包的包头会有PTS，DTS信息，去掉PES的header就是ES。</li><li>直接将被拔掉PES包头的ES包送给decoder就可以进行解码。解码出来的数据就是一帧一帧的视频数据，这些数据至少应当与PES中的PTS关联一下，以便进行视音频同步。</li><li>I，B，B，P 信息是在ES中的。</li></ol><h5 id="3-2-具体描述"><a href="#3-2-具体描述" class="headerlink" title="3.2 具体描述"></a>3.2 具体描述</h5><p>ES 是直接从编码器出来的数据流，可以是编码过的视频数据流，音频数据流，或其他编码数据流的统称。 ES 流经过 PES 打包器之后，被转换成 PES 包。 PES 包由包头和 payload 组成。</p><p>在 PES 层，主要是在 PES 包头信息中加入 PTS( 显示时间标签 ) 和 DTS （解码时间标签）用于视频、音频同步。 其实， Mpeg-2 用于视音频同步以及系统时钟恢复的时间标签分别在 ES ， PES 和 TS 这 3 个层次中。</p><p>在 ES 层，与同步有关的主要是视频缓冲验证 VBV （ Video Buffer Verifier ），用以防止解码器的缓冲器出现上溢或下溢；在 PES 层，主要是在 PES 头信息里出现的显示时间标签 PTS （ Presentation Time Stamp ）和解码时间标签 DTS （ Decoding Time Stamp ）；</p><p>在 TS 层中， TS 头信息包含了节目时钟参考 PCR （ Program Clock Reference ），用于恢复出与编码端一致的系统时序时钟 STC （ System Time Clock ）。</p><p>基本流程如下：</p><p>首先 MPEG-2 压缩编码得到的 ES 基本流，这个数据流很大，并且只是 I ， P ， B 的这些视频帧或音频取样信息， 然后加入一些同步信息，打包成长度可变长度的数据包 PES ，原来是流的格式，现在成了数据包的分割形式。</p><p>同时要注意的是， ES 是只包含一种内容的数据流，如只含视频，或只含音频等，打包之后的 PES 也是只含一种性质的 ES, 如只含视频 ES 的 PES, 只含音频 ES 的 PES 等。</p><p>可以知道， ES 是编码视频数据流或音频数据流，每个 ES 都由若干个存取单元（ AU ）组成，每个视频 AU 或音频 AU 都是由头部和编码数据两部分组成， 1 个 AU 相当于编码的 1 幅视频图像或 1 个音频帧，也可以说，每个 AU 实际上是编码数据流的显示单元，即相当于解码的 1 幅视频图像或 1 个音频帧的取样。 </p><p>PEG-2 对视频的压缩产生 I 帧、 P 帧、 B 帧。把帧顺序 I1,P4,B2,B3,P7,B5,B6 帧的编码 ES ，通过打包并在每个帧中插入 PTS/DTS 标志，变成 PES 。</p><p>在插入 PTS/DTS 标志时，由于在 B 帧 PTS 和 DTS 相等，所以无须在 B 帧多插入 DTS 。</p><p>而对于 I 帧 和 P 帧，由于经过复用后数据包的顺序会发生变化，显示前一定要存储于视频解码器的从新排序缓存器中，经过从新排序后再显示，所以一定要同时插入 PTS 和 DTS 作为从新排序的依据。</p><p>其中，有否 PTS/DTS 标志，是解决视音频同步显示、防止解码器输入缓存器上溢或下溢的关键所在。 </p><p>PTS 表明显示单元出现在系统目标解码器（ STD- System Target Decoder ）的时间 , DTS 表明将存取单元全部字节从 STD 的 ES 解码缓存器移走的时刻。</p><p>视频编码图像帧次序为 I1,P4,B2,B3,P7,B5,B6,I10,B8,B9 的 ES ，加入 PTS/DTS 后，打包成一个个视频 PES 包。</p><p>每个 PES 包都有一个包头，用于定义 PES 内的数据内容，提供定时资料。</p><p>每个 I 、 P 、 B帧的包头都有一个 PTS 和 DTS ，但 PTS 与 DTS 对 B 帧都是一样的，无须标出 B 帧的 DTS 。</p><p>对 I 帧和 P 帧，显示前一定要存储于视频解码器的重新排序缓存器中，经过延迟（重新排序）后再显示，一定要分别标明 PTS 和 DTS 。</p><p>例如，解码器输入的图像帧次序为 I1,P4,B2,B3,P7,B5,B6,I10,B8,B9 ，依解码器输出的帧次序，应该 P4 比 B2 、 B3 在先，但显示时 P4 一定要比 B2 、 B3 在后，即 P4 要在提前插入数据流中的时间标志指引下，经过缓存器重新排序，以重建编码前视频帧次序 I1,B2,B3,P4,B5,B6,P7,B8,B9,I10 。</p><p>显然， PTS/DTS 标志表明对确定事件或确定信息解码的专用时标的存在，依靠专用时标解码器，可知道该确定事件或确定信息开始解码或显示的时刻。</p><p>例如， PTS/DTS 标志可用于确定编码、多路复用、解码、重建的时间。</p><p>PCR<br>PCR 是 TS 里面的，即 TS packet 的 header 里面可能会有，他用来指定所期望的该 ts packet 到达 decoder 的时间，他的作用于 SCR 类似。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、基本概念&quot;&gt;&lt;a href=&quot;#一、基本概念&quot; class=&quot;headerlink&quot; title=&quot;一、基本概念&quot;&gt;&lt;/a&gt;一、基本概念&lt;/h4&gt;&lt;h5 id=&quot;1-ES&quot;&gt;&lt;a href=&quot;#1-ES&quot; class=&quot;headerlink&quot; title=&quot;1. ES&quot;&gt;&lt;/a&gt;1. ES&lt;/h5&gt;&lt;p&gt;ES–Elementary  Streams  (原始流)是直接从编码器出来的数据流，可以是编码过的视频数据流（H.264,MJPEG等），音频数据流（AAC），或其他编码数据流的统称。ES流经过PES打包器之后，被转换成PES包。&lt;/p&gt;
    
    </summary>
    
    
      <category term="视音频" scheme="http://www.faihung.net/categories/%E8%A7%86%E9%9F%B3%E9%A2%91/"/>
    
    
      <category term="AVFormat" scheme="http://www.faihung.net/tags/AVFormat/"/>
    
      <category term="ES" scheme="http://www.faihung.net/tags/ES/"/>
    
      <category term="PS" scheme="http://www.faihung.net/tags/PS/"/>
    
      <category term="TS" scheme="http://www.faihung.net/tags/TS/"/>
    
  </entry>
  
  <entry>
    <title>Video Timing 解释说明</title>
    <link href="http://www.faihung.net/2019/11/24/Video-Timing-%E8%A7%A3%E9%87%8A%E8%AF%B4%E6%98%8E/"/>
    <id>http://www.faihung.net/2019/11/24/Video-Timing-解释说明/</id>
    <published>2019-11-24T15:25:24.000Z</published>
    <updated>2019-11-24T15:36:09.647Z</updated>
    
    <content type="html"><![CDATA[<h6 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h6><p>大家应该都知道，视频看起来是持续动态的，但是实际上是由一系列的静态画面，在很短的时间内更替,在人眼上就产生视觉残留，以至于你的眼睛感觉是动态画面。大家看到的视频中大多数是每秒闪过50-60幅画面，对于电脑画面大概是每秒闪过70-80幅画面。</p><a id="more"></a><p>要说timing是什么，先说下一般的图像是怎么显示在屏幕上的。</p><p>视频源发出的一幅幅的画面，送到屏幕后，屏幕将每一幅画面从上到下逐行的扫描每个像素显示在屏幕上，不间断的重复，直到一段视频数据结束。</p><p>而视频数据是连续的，怎么就知道哪段数据是显示一个画面？</p><p>怎么知道一个画面中哪一段数据又是显示这一行的？</p><p>Timing 就是解决这两问题的。</p><pre><code>Video timing 包含两个信号：水平同步Hs（horizontal sync）和垂直同步Vs（vertical sync）Vertical sync --&gt;用来标识什么时候开始送出一幅新画面Horizontal sync --&gt;用来标识什么时候开始新一行的图像扫描</code></pre><h6 id="Vertical-sync-和-Horizontal-sync-信号有三种传送方式："><a href="#Vertical-sync-和-Horizontal-sync-信号有三种传送方式：" class="headerlink" title="Vertical sync 和 Horizontal sync 信号有三种传送方式："></a>Vertical sync 和 Horizontal sync 信号有三种传送方式：</h6><ol><li>单独传送vertical sync 和 Horizontal sync两路信号，如电脑上用的VGA信号，HDMI高清数字视频信号；</li><li>将vertical sync和horizontal sync信号复合在一路单独传送，如S-Video型号（其timing信号时复合在其Y信号中）；</li><li>将vertical sync和horizontal sync复合在一起的信号又再复合进视频信号中一起传送，如CVBS信号；</li></ol><h6 id="举个例子说明timing中包含了哪些信息："><a href="#举个例子说明timing中包含了哪些信息：" class="headerlink" title="举个例子说明timing中包含了哪些信息："></a>举个例子说明timing中包含了哪些信息：</h6><p>如一个视频信号timing为（1024x768@60），1024x768表示是SVGA分辨率（其中1024表示一幅图像的列数，因每一个象素点有R/G/B三点组成，故共有1024*3列；768表示一幅图像的行数，共768行），60Hz表示的就是vertical sync（即每一个画面的显示时间为1/60s=16.67ms），由于每一幅画面要扫描768行，所以每一行的扫描时间即为16.67ms/768=21.7us，即可得出horizontal sync。</p>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h6&gt;&lt;p&gt;大家应该都知道，视频看起来是持续动态的，但是实际上是由一系列的静态画面，在很短的时间内更替,在人眼上就产生视觉残留，以至于你的眼睛感觉是动态画面。大家看到的视频中大多数是每秒闪过50-60幅画面，对于电脑画面大概是每秒闪过70-80幅画面。&lt;/p&gt;
    
    </summary>
    
    
      <category term="视音频" scheme="http://www.faihung.net/categories/%E8%A7%86%E9%9F%B3%E9%A2%91/"/>
    
    
      <category term="Timing" scheme="http://www.faihung.net/tags/Timing/"/>
    
      <category term="Vertical sync" scheme="http://www.faihung.net/tags/Vertical-sync/"/>
    
      <category term="Horizontal sync" scheme="http://www.faihung.net/tags/Horizontal-sync/"/>
    
  </entry>
  
  <entry>
    <title>CAN转以太网</title>
    <link href="http://www.faihung.net/2019/11/24/CAN%E8%BD%AC%E4%BB%A5%E5%A4%AA%E7%BD%91/"/>
    <id>http://www.faihung.net/2019/11/24/CAN转以太网/</id>
    <published>2019-11-24T15:04:43.000Z</published>
    <updated>2019-12-08T07:25:53.642Z</updated>
    
    <content type="html"><![CDATA[<p>暂略</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;暂略&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="工程设计" scheme="http://www.faihung.net/categories/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>Hdmi转以太网</title>
    <link href="http://www.faihung.net/2019/11/24/Hdmi%E8%BD%AC%E4%BB%A5%E5%A4%AA%E7%BD%91/"/>
    <id>http://www.faihung.net/2019/11/24/Hdmi转以太网/</id>
    <published>2019-11-24T15:04:21.000Z</published>
    <updated>2019-12-08T07:26:16.206Z</updated>
    
    <content type="html"><![CDATA[<p>暂略</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;暂略&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="工程设计" scheme="http://www.faihung.net/categories/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>C语言-ip地址合法性判断</title>
    <link href="http://www.faihung.net/2019/11/23/C%E8%AF%AD%E8%A8%80-ip%E5%9C%B0%E5%9D%80%E5%90%88%E6%B3%95%E6%80%A7%E5%88%A4%E6%96%AD/"/>
    <id>http://www.faihung.net/2019/11/23/C语言-ip地址合法性判断/</id>
    <published>2019-11-23T08:44:35.000Z</published>
    <updated>2019-11-23T08:48:05.437Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h5><p>工作中我们有时候处理一些IP地址和端口号。这些东西需要保存到配置文件中，所以在保存之前，必须要进行合法性判断。</p><h6 id="1-对于IP地址"><a href="#1-对于IP地址" class="headerlink" title="1. 对于IP地址"></a>1. 对于IP地址</h6><p>输入一个字符串，判断是否是合法的IPV4地址<br>首先，IPV4 地址满足3个条件</p><ul><li>三个点 “ . ”</li><li>四部分整数，0~255 之间</li><li>前导数不能是0，例如 012.1.1.1 非法<a id="more"></a><h6 id="2-对于端口号"><a href="#2-对于端口号" class="headerlink" title="2. 对于端口号"></a>2. 对于端口号</h6>满足0-65535的十进制整数即可</li></ul><h5 id="二、代码如下"><a href="#二、代码如下" class="headerlink" title="二、代码如下"></a>二、代码如下</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    1、只有三个点 , 四部分，每个数都在 0 ~ 255 </span><br><span class="line">    2、数字不能是 0开头 如：012.1.1.1 </span><br><span class="line">*/</span><br><span class="line">bool IsIpv4(char*str)</span><br><span class="line">&#123;</span><br><span class="line">    char* ptr;</span><br><span class="line">static char ptrip[20];</span><br><span class="line">    int count = 0;</span><br><span class="line">    const char *p = str;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    1.判断是不是三个 ‘.’</span><br><span class="line">    2.判断是不是四部分数,每个数都在 0 ~ 255</span><br><span class="line">    3.判断是不是先导0,如:012.1.1.1 </span><br><span class="line">    */</span><br><span class="line">printf(&quot;输入的 ip %s\n&quot;,str);</span><br><span class="line">printf(&quot;未切割str&apos; Adress is 0x%X\n&quot;,str);</span><br><span class="line"></span><br><span class="line">#if 1</span><br><span class="line">    while(*p !=&apos;\0&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*p == &apos;.&apos;)</span><br><span class="line">        count++;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(count != 3)  return false;</span><br><span class="line">    count = 0;</span><br><span class="line">    ptr = strtok(str,&quot;.&quot;);</span><br><span class="line">memset(ptrip, 0, sizeof(ptrip));</span><br><span class="line">strcpy(ptrip,ptr);</span><br><span class="line">    while(ptr != NULL)</span><br><span class="line">    &#123;   </span><br><span class="line">        count++;</span><br><span class="line">        if(ptr[0] == &apos;0&apos; &amp;&amp; isdigit(ptr[1])) return false;</span><br><span class="line">        int a = atoi(ptr);</span><br><span class="line">        if(count == 1 &amp;&amp; a == 0) return false;</span><br><span class="line">        if(a&lt;0 || a&gt;255) return false;</span><br><span class="line">        ptr = strtok(NULL,&quot;.&quot;);</span><br><span class="line">if(ptr != NULL)</span><br><span class="line">&#123;</span><br><span class="line">strcat(ptrip,&quot;.&quot;);</span><br><span class="line">strcat(ptrip,ptr);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(count == 4)  </span><br><span class="line">&#123;</span><br><span class="line">//str = ptrip;//改变指针指向与内存拷贝的区别?ptrip也有一块静态存储空间的</span><br><span class="line">memcpy(str,ptrip,strlen(ptrip));</span><br><span class="line">printf(&quot;return ip=%s\n&quot;,str);</span><br><span class="line">printf(&quot;str&apos;s Adress is 0x%X\n&quot;,str);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">    else&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;  </span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//格式是0-65535的10进制整数</span><br><span class="line">bool Isport(unsigned int port)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;port=%d\n&quot;,port);</span><br><span class="line">if(port&lt;=65535)</span><br><span class="line">&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char buf[100];</span><br><span class="line">short port = 0xFFFF;</span><br><span class="line"></span><br><span class="line">#if 1</span><br><span class="line">while(cin&gt;&gt;buf,buf[0] != &apos;#&apos;)</span><br><span class="line">    &#123;   </span><br><span class="line">        if(IsIpv4(buf))</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;合法&quot;&lt;&lt;endl; </span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;非法&quot;&lt;&lt;endl; </span><br><span class="line">        &#125;</span><br><span class="line">printf(&quot;输入buf的IP is %s\n&quot;,buf);</span><br><span class="line">printf(&quot;buf Adress is 0x%X\n&quot;,buf);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if 0</span><br><span class="line">if(Isport(port))</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;合法&quot;&lt;&lt;endl; </span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;非法&quot;&lt;&lt;endl; </span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="三、执行效果"><a href="#三、执行效果" class="headerlink" title="三、执行效果"></a>三、执行效果</h5><p><img src="/2019/11/23/C%E8%AF%AD%E8%A8%80-ip%E5%9C%B0%E5%9D%80%E5%90%88%E6%B3%95%E6%80%A7%E5%88%A4%E6%96%AD/1.jpg" alt="1"></p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;一、应用场景&quot;&gt;&lt;a href=&quot;#一、应用场景&quot; class=&quot;headerlink&quot; title=&quot;一、应用场景&quot;&gt;&lt;/a&gt;一、应用场景&lt;/h5&gt;&lt;p&gt;工作中我们有时候处理一些IP地址和端口号。这些东西需要保存到配置文件中，所以在保存之前，必须要进行合法性判断。&lt;/p&gt;
&lt;h6 id=&quot;1-对于IP地址&quot;&gt;&lt;a href=&quot;#1-对于IP地址&quot; class=&quot;headerlink&quot; title=&quot;1. 对于IP地址&quot;&gt;&lt;/a&gt;1. 对于IP地址&lt;/h6&gt;&lt;p&gt;输入一个字符串，判断是否是合法的IPV4地址&lt;br&gt;首先，IPV4 地址满足3个条件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三个点 “ . ”&lt;/li&gt;
&lt;li&gt;四部分整数，0~255 之间&lt;/li&gt;
&lt;li&gt;前导数不能是0，例如 012.1.1.1 非法&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://www.faihung.net/categories/C/"/>
    
    
      <category term="指针" scheme="http://www.faihung.net/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="ip地址" scheme="http://www.faihung.net/tags/ip%E5%9C%B0%E5%9D%80/"/>
    
      <category term="strcat" scheme="http://www.faihung.net/tags/strcat/"/>
    
      <category term="strtok" scheme="http://www.faihung.net/tags/strtok/"/>
    
  </entry>
  
  <entry>
    <title>C语言-从一包数据中提取有效的数据帧</title>
    <link href="http://www.faihung.net/2019/11/23/C%E8%AF%AD%E8%A8%80-%E4%BB%8E%E4%B8%80%E5%8C%85%E6%95%B0%E6%8D%AE%E4%B8%AD%E6%8F%90%E5%8F%96%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E6%8D%AE%E5%B8%A7/"/>
    <id>http://www.faihung.net/2019/11/23/C语言-从一包数据中提取有效的数据帧/</id>
    <published>2019-11-23T08:15:51.000Z</published>
    <updated>2019-11-23T08:22:29.296Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h5><p>有的时候我们一次接收数据可能是20个byte,需要在这20个byte中并不都是我们想要的。</p><h6 id="具体要求："><a href="#具体要求：" class="headerlink" title="具体要求："></a>具体要求：</h6><ol><li>这个有效长度必须满足收尾都是0x64</li><li>这个有效长度最短长度不得少于8个byte</li><li>这个有效长度的数据必须符合校验和的计算方式</li><li>满足上面3条即可提取这个数据帧</li><li>注意:在真正想要的数据帧之间是没有0x64的,这种情况先假设它不存在(后面会根据校验和的方式来处理)<a id="more"></a><h5 id="二、代码如下"><a href="#二、代码如下" class="headerlink" title="二、代码如下"></a>二、代码如下</h5></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">//校验和之前所有字节累加取和之后，对累加和最低字节取反。</span><br><span class="line">UINT8 checksum(ComFrameData *pData, int len)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i,sum=0;</span><br><span class="line">    UINT8 ccsum=0;  </span><br><span class="line">UINT8 *pdata;</span><br><span class="line">pdata = (UINT8 *)pData;//将结构体类型强制转换成char类型</span><br><span class="line"></span><br><span class="line">    for(i=0;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        #if 1</span><br><span class="line">        printf(&quot;%X\n&quot;,*pdata);</span><br><span class="line">        #endif</span><br><span class="line">        sum += *(pdata++); </span><br><span class="line">    &#125;</span><br><span class="line">    ccsum = ~(sum&amp;0xFF);  </span><br><span class="line"></span><br><span class="line">#if 1</span><br><span class="line">    printf(&quot;累加和:0x%X\n&quot;,sum);</span><br><span class="line">    printf(&quot;校验和:0x%X\n&quot;,ccsum);</span><br><span class="line">#endif</span><br><span class="line">    return ccsum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void exception_handling_extract(UINT8 *fraBuf, UINT8 buflen, UINT8 **prealBUF, UINT8 *preallen)</span><br><span class="line">&#123;</span><br><span class="line">UINT8 len = 0;//n = 0,</span><br><span class="line">UINT8 *pcur,*p;//*pBuf,</span><br><span class="line"></span><br><span class="line">printf(&quot;接收到的数据的长度是:%d\n&quot;,buflen);</span><br><span class="line">p = fraBuf;</span><br><span class="line">while(buflen--)</span><br><span class="line">&#123;</span><br><span class="line">if(*p == 0x64)</span><br><span class="line">&#123;</span><br><span class="line">pcur = p;</span><br><span class="line">while(buflen--)</span><br><span class="line">&#123;</span><br><span class="line">p++;</span><br><span class="line">if(*p == 0x64)</span><br><span class="line">&#123;</span><br><span class="line">len = p-pcur;</span><br><span class="line">printf(&quot;两个0x64之间的数据长度:%d\n&quot;,len);</span><br><span class="line">if(len&gt;=8)</span><br><span class="line">&#123;</span><br><span class="line">//进行相应的校验和计算</span><br><span class="line">if(*(p-1) == checksum((ComFrameData*)pcur,len-1))</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;这个真实帧的校验和满足条件!\n&quot;);</span><br><span class="line">//开始提取这个有效的数据帧</span><br><span class="line">*preallen = len+1;</span><br><span class="line">*prealBUF = pcur;</span><br><span class="line">printf(&quot;prealBuf-4:%X\n&quot;,*prealBUF);</span><br><span class="line">break;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">printf(&quot;这个真实帧的校验和不满足条件!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;else&#123;</span><br><span class="line">//说明真正想要的数据帧帧头不是前面的一个0x64,可能是这一个,或者是下一个。之后继续对p进行遍历</span><br><span class="line">pcur = p;</span><br><span class="line">len = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;此时N2的长度是:%d\n&quot;,buflen);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">p++;</span><br><span class="line">printf(&quot;此时N1的长度是:%d\n&quot;,buflen);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UINT8 ReceiveBuf[20] = &#123;</span><br><span class="line">0x00, 0x64, 0x00, 0x64, 0x01, 0x04, 0x00, 0x08, </span><br><span class="line">0x55, 0x07, 0xE2, 0x01, 0x06, 0x01, 0x1C, 0x18, </span><br><span class="line">0x14, 0x64, 0x30, 0x11&#125;;//模拟接收到的MCU响应的时间</span><br><span class="line"></span><br><span class="line">//实际接收的数据</span><br><span class="line">//0x64, 0x01, 0x04, 0x00, 0x08, 0x55, 0x07, 0xE2, 0x01, 0x06, 0x01, 0x1C,0x18, 0x14, 0x64</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">UINT8 i,buflen,reallen;</span><br><span class="line">UINT8 Buf[64]; </span><br><span class="line">UINT8 *prealBuf;//UINT8 realBuf[32];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#if 0//这里暂时不需要对prealBuf分配内存空间,因为ReceiveBuf数组是已经假设是全局变量了。prealBuf指向就是ReceiveBuf[3],位置其实是不会变的。</span><br><span class="line">UINT8 *prealBuf = (UINT8 *)malloc(sizeof(UINT8 *)*32);//定义一个全局realBuf[32];之后memset</span><br><span class="line"></span><br><span class="line">if(prealBuf == NULL)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;prealBuf malloc is failed\n&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">free(prealBuf);</span><br><span class="line">prealBuf=NULL;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//数据帧的异常处理,接收到的一帧数据可能是20byte,提取自己想要的。</span><br><span class="line">buflen = 20;//接收数据帧的长度是一个byte一个byte的接收,还是？</span><br><span class="line">printf(&quot;prealBuf-1:%X\n&quot;,prealBuf);</span><br><span class="line">exception_handling_extract(ReceiveBuf, buflen, &amp;prealBuf, &amp;reallen);</span><br><span class="line">printf(&quot;prealBuf-2:%X\n&quot;,prealBuf);</span><br><span class="line">printf(&quot;接收的真实数据帧长度是:%d\n&quot;,reallen);</span><br><span class="line">for(i=0;i&lt;reallen;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;接收的真实数据帧是:0x%X\n&quot;,prealBuf[i]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;prealBuf-3:%X\n&quot;,prealBuf);</span><br><span class="line">printf(&quot;prealBuf-4:%X\n&quot;,&amp;ReceiveBuf[3]);//可以看到prealBuf此时指向的地址和ReceiveBuf[3]的地址一模一样，所以这里不需要用malloc来申请内存空间</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="三、执行效果"><a href="#三、执行效果" class="headerlink" title="三、执行效果"></a>三、执行效果</h5><p><img src="/2019/11/23/C%E8%AF%AD%E8%A8%80-%E4%BB%8E%E4%B8%80%E5%8C%85%E6%95%B0%E6%8D%AE%E4%B8%AD%E6%8F%90%E5%8F%96%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E6%8D%AE%E5%B8%A7/1.jpg" alt="1"></p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;一、应用场景&quot;&gt;&lt;a href=&quot;#一、应用场景&quot; class=&quot;headerlink&quot; title=&quot;一、应用场景&quot;&gt;&lt;/a&gt;一、应用场景&lt;/h5&gt;&lt;p&gt;有的时候我们一次接收数据可能是20个byte,需要在这20个byte中并不都是我们想要的。&lt;/p&gt;
&lt;h6 id=&quot;具体要求：&quot;&gt;&lt;a href=&quot;#具体要求：&quot; class=&quot;headerlink&quot; title=&quot;具体要求：&quot;&gt;&lt;/a&gt;具体要求：&lt;/h6&gt;&lt;ol&gt;
&lt;li&gt;这个有效长度必须满足收尾都是0x64&lt;/li&gt;
&lt;li&gt;这个有效长度最短长度不得少于8个byte&lt;/li&gt;
&lt;li&gt;这个有效长度的数据必须符合校验和的计算方式&lt;/li&gt;
&lt;li&gt;满足上面3条即可提取这个数据帧&lt;/li&gt;
&lt;li&gt;注意:在真正想要的数据帧之间是没有0x64的,这种情况先假设它不存在(后面会根据校验和的方式来处理)&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://www.faihung.net/categories/C/"/>
    
    
      <category term="指针" scheme="http://www.faihung.net/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="全局变量" scheme="http://www.faihung.net/tags/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    
      <category term="生存周期" scheme="http://www.faihung.net/tags/%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F/"/>
    
      <category term="内存分配" scheme="http://www.faihung.net/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>COM口16进制通信设计</title>
    <link href="http://www.faihung.net/2019/11/23/COM%E5%8F%A316%E8%BF%9B%E5%88%B6%E9%80%9A%E4%BF%A1%E8%AE%BE%E8%AE%A1/"/>
    <id>http://www.faihung.net/2019/11/23/COM口16进制通信设计/</id>
    <published>2019-11-23T07:42:21.000Z</published>
    <updated>2019-11-30T14:25:32.994Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、16进制数据格式通过串口调试工具验证"><a href="#一、16进制数据格式通过串口调试工具验证" class="headerlink" title="一、16进制数据格式通过串口调试工具验证"></a>一、16进制数据格式通过串口调试工具验证</h4><p>拿到MCU板子，根据《mcu com软件接口设计方案_v002.xlsx》进行串口调试验证，见下表。</p><a id="more"></a><p><img src="/2019/11/23/COM%E5%8F%A316%E8%BF%9B%E5%88%B6%E9%80%9A%E4%BF%A1%E8%AE%BE%E8%AE%A1/1.jpg" alt="1"><br>具体操作是用一个串口监视MCU的运行打印信息，用另一个串口作为16进制指令调试发送。稍微验证符合要求，即可进行下一步。</p><h4 id="二、数据格式耦合-解耦合"><a href="#二、数据格式耦合-解耦合" class="headerlink" title="二、数据格式耦合/解耦合"></a>二、数据格式耦合/解耦合</h4><p>数据的传输最终是按照大小端、高低位一个bit个bit的buffer数组方式进行传输。所以我们发送/接收都需要对数据进行封装与解析。</p><h5 id="2-1-数据结构类型"><a href="#2-1-数据结构类型" class="headerlink" title="2.1    数据结构类型"></a>2.1    数据结构类型</h5><p>根据上图构造一个可拓展的数据结构类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br></pre></td><td class="code"><pre><span class="line">#ifndef _HEX_H_</span><br><span class="line">#define _HEX_H_</span><br><span class="line"></span><br><span class="line">typedef unsigned char UINT8;</span><br><span class="line">typedef unsigned short int UINT16;</span><br><span class="line">typedef unsigned int UINT32;</span><br><span class="line"></span><br><span class="line">#define COMMFRA_SEND_HEAD               0x64</span><br><span class="line">#define COMMFRA_SEND_UP_DOWN            0x01</span><br><span class="line">#define COMMFRA_SEND_TAIL               0x64</span><br><span class="line"></span><br><span class="line">#pragma   pack(1)</span><br><span class="line">typedef enum&#123;//关键字</span><br><span class="line">    RESET,</span><br><span class="line">SOFT_HARD_VER,</span><br><span class="line">HEART,</span><br><span class="line">SET_MCU_TIME,</span><br><span class="line">GET_MCU_TIME,</span><br><span class="line">SWITCH_SIM,</span><br><span class="line">GET_SIM,</span><br><span class="line">GET_GPS,</span><br><span class="line">LOW_POWER,</span><br><span class="line">POWER_STATE,</span><br><span class="line">POWER_OFF,</span><br><span class="line">FIRMWARE_UPDATE,</span><br><span class="line"></span><br><span class="line">SET_SAMPLING_RATE = 0x10,</span><br><span class="line">GET_SAMPLING_RATE,</span><br><span class="line">START_SENSOR,</span><br><span class="line">STOP_SENSOR,</span><br><span class="line">CHECK_SENSOR,</span><br><span class="line">SENSOR_BUFFER_FULL,</span><br><span class="line">GET_SENSOR,</span><br><span class="line">UPLOAD_SENSOR,</span><br><span class="line"></span><br><span class="line">START_BUZZER = 0x20</span><br><span class="line">&#125;keyword;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef enum&#123;</span><br><span class="line">KEY1 = 0x55,</span><br><span class="line">KEY2 = 0xAA,</span><br><span class="line">KEY3 = 0x01,</span><br><span class="line">KEY4 = 0x02,</span><br><span class="line">&#125;key;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">联合体里面的单元数组，在定义的时候会按照最大的长度进行分配内存，所以接收到校验和,帧尾有时候会跑到item数据域中去，</span><br><span class="line">后面的结构体的校验和、帧尾会匹配不到。</span><br><span class="line">解决这种问题：</span><br><span class="line">1. 定义发送/接收item数据域的内容时,用指针变量，用的时候malloc堆内存，用的时候再free。但有的时候会遗忘。</span><br><span class="line">2. union中的成员，同一时刻只会用一种，将所有的item数据域的内容长度按照最长的分配。帧尾和校验和在在item数据域中去找。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">typedef union&#123;</span><br><span class="line"></span><br><span class="line">union&#123;</span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">&#125;ComFrameDataReset_Request;//item-reset </span><br><span class="line">&#125;ComFrameDataReset;</span><br><span class="line"></span><br><span class="line">union&#123;</span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">&#125;ComFrameDataVer_Request;  //获取软硬件板本，</span><br><span class="line"></span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">UINT8 data[2];</span><br><span class="line">&#125;ComFrameDataVer_Response;  //得到软硬件板本，</span><br><span class="line">&#125;ComFrameDataVer;//item-Version</span><br><span class="line"></span><br><span class="line">union&#123;</span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">UINT8 item_data[2];</span><br><span class="line">&#125;ComFrameDataHeart_Request;  </span><br><span class="line"></span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">UINT8 item_data[2];</span><br><span class="line">&#125;ComFrameDataHeart_Response;</span><br><span class="line">&#125;ComFrameDataHeart;//item-Heart</span><br><span class="line"></span><br><span class="line">#if 1</span><br><span class="line">union&#123;</span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">UINT8 item_data[7];</span><br><span class="line">&#125;ComFrameDataSetMCUTime_Request;  </span><br><span class="line"> </span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">UINT8 item_data[7];</span><br><span class="line">&#125;ComFrameDataSetMCUTime_Response;  </span><br><span class="line">&#125;ComFrameDataSetMCUTime;//item-SetMCUTime</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">union&#123;</span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">&#125;ComFrameDataGetMCUTime_Request;  </span><br><span class="line"></span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">UINT8 item_data[7];</span><br><span class="line">&#125;ComFrameDataGetMCUTime_Response; </span><br><span class="line">&#125;ComFrameDataGetMCUTime; //item-GetMCUTime</span><br><span class="line"></span><br><span class="line">union&#123;</span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">UINT8 item_data;</span><br><span class="line">&#125;ComFrameDataSwitchSIM_Request; </span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">UINT8 item_data[2];</span><br><span class="line">&#125;ComFrameDataSwitchSIM_Response;</span><br><span class="line">&#125;ComFrameDataSwitchSIM;//切换SIM卡</span><br><span class="line"></span><br><span class="line">union&#123;</span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">&#125;ComFrameDataGetSIM_Request; </span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">UINT8 item_data;</span><br><span class="line">&#125;ComFrameDataGetSIM_Response;</span><br><span class="line">&#125;ComFrameDataGetSIM;//获取目前使用的SIM卡</span><br><span class="line"></span><br><span class="line">union&#123;</span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">&#125;ComFrameDataStartGPS_Request; </span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">&#125;ComFrameDataStartGPS_Response;</span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">UINT8 item_data;</span><br><span class="line">&#125;ComFrameDataGPS_Response;//响应成功or失败</span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">&#125;ComFrameDataGPSGet_Request;//读取GPS坐标，那么下面是不是还有一个响应</span><br><span class="line"></span><br><span class="line">&#125;ComFrameDataGPS;//GPS坐标</span><br><span class="line"></span><br><span class="line">union&#123;</span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">&#125;ComFrameData4GInLowPower_Request; </span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">UINT8 item_data;</span><br><span class="line">&#125;ComFrameData4GInLowPower_Response; </span><br><span class="line">&#125;ComFrameData4GInLowPower;//进入低功耗</span><br><span class="line"></span><br><span class="line">union&#123;</span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">&#125;ComFrameData4GExitLowPower_Request; </span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">UINT8 item_data;</span><br><span class="line">&#125;ComFrameData4GExitLowPower_Response; </span><br><span class="line">&#125;ComFrameData4GExitLowPower;//退出低功耗</span><br><span class="line"></span><br><span class="line">union&#123;</span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">&#125;ComFrameDataPower_Request; </span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">UINT8 item_data[12];//这里数据大小的内容长度不能大于强制转换的数组的数据域内容，否则会错位</span><br><span class="line">&#125;ComFrameDataPower_Response;//是主动获取还是定时上报</span><br><span class="line">&#125;ComFrameDataPower;//电源情况</span><br><span class="line"></span><br><span class="line">union&#123;</span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">&#125;ComFrameDataPowerOff_Request; </span><br><span class="line">&#125;ComFrameDataPowerOff;</span><br><span class="line"></span><br><span class="line">union&#123;</span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">UINT8 item_data;</span><br><span class="line">&#125;ComFrameDataPowerOff_Request; </span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">UINT8 item_data;</span><br><span class="line">&#125;ComFrameDataPowerOff_Response; </span><br><span class="line">&#125;ComFrameDataFrimwareUpdate;//更新程序</span><br><span class="line"></span><br><span class="line">union&#123;</span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">UINT8 item_data;</span><br><span class="line">&#125;ComFrameDataSetSampleRate_Request; </span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">UINT8 item_data;</span><br><span class="line">&#125;ComFrameDataSetSampleRate_Response;</span><br><span class="line">&#125;ComFrameDataSetSampleRate;//设置采样率</span><br><span class="line"></span><br><span class="line">union&#123;</span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">UINT8 item_data;</span><br><span class="line">&#125;ComFrameDataGetSampleRate_Request; </span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">UINT8 item_data;</span><br><span class="line">&#125;ComFrameDataGetSampleRate_Response;</span><br><span class="line">&#125;ComFrameDataGetSampleRate;//读取采样率</span><br><span class="line"></span><br><span class="line">union&#123;</span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">UINT8 item_data;</span><br><span class="line">&#125;ComFrameDataStartSensor_Request; </span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">UINT8 item_data[2];</span><br><span class="line">&#125;ComFrameDataStartSensor_Response;</span><br><span class="line">&#125;ComFrameDataStartSensor;//启动传感器</span><br><span class="line"></span><br><span class="line">union&#123;</span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">UINT8 item_data;</span><br><span class="line">&#125;ComFrameDataStopSensor_Request; </span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">UINT8 item_data[2];</span><br><span class="line">&#125;ComFrameDataStopSensor_Response;</span><br><span class="line">&#125;ComFrameDataStopSensor;//停止传感器</span><br><span class="line"></span><br><span class="line">union&#123;</span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">UINT8 item_data;</span><br><span class="line">&#125;ComFrameDataCheckSensor_Request; </span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">UINT8 item_data[2];</span><br><span class="line">&#125;ComFrameDataCheckSensor_Response;</span><br><span class="line">&#125;ComFrameDataCheckSensor;//传感器自检</span><br><span class="line"></span><br><span class="line">union&#123;</span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">UINT8 item_data[3];</span><br><span class="line">&#125;ComFrameDataSensorBuffFull_Response;</span><br><span class="line">&#125;ComFrameDataSensorBuffFull;//传感器buffer满</span><br><span class="line"></span><br><span class="line">union&#123;</span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">UINT8 item_data[3];</span><br><span class="line">&#125;ComFrameDataGetSensor_Request;</span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">UINT8 item_data;</span><br><span class="line">&#125;ComFrameDataGetSensor_Response;</span><br><span class="line">&#125;ComFrameDataGetSensor;//获取传感器数据</span><br><span class="line"></span><br><span class="line">union&#123;</span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">UINT8 item_data[2];</span><br><span class="line">&#125;ComFrameDataStartBuzzer_Request;</span><br><span class="line">struct&#123;</span><br><span class="line">UINT8 item_key;</span><br><span class="line">UINT8 item_data[2];</span><br><span class="line">&#125;ComFrameDataStartBuzzer_Response;</span><br><span class="line">&#125;ComFrameDataStartBuzzer;//启动蜂鸣器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;ComFrameDataItem;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    UINT8   frame_start;</span><br><span class="line">    UINT8   frame_up_down;</span><br><span class="line"></span><br><span class="line">    UINT8   frame_key_word;</span><br><span class="line">    UINT16   frame_datalength;//UINT8 (frame_datalength_high+frame_datalength_low)   </span><br><span class="line"></span><br><span class="line">    ComFrameDataItem   frame_item;</span><br><span class="line">//将校验和帧尾从这里拿出去，放到每一个组包/解包函数中去。</span><br><span class="line">    //UINT8   frame_CRC;</span><br><span class="line">    //UINT8   frame_stop;</span><br><span class="line">&#125;ComFrameData;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h5 id="2-2-强制转换和初始化"><a href="#2-2-强制转换和初始化" class="headerlink" title="2.2    强制转换和初始化"></a>2.2    强制转换和初始化</h5><p>数据传输之前，需要将buffer数组强制成转换成我们需要的数据结构类型，然后再进行赋值。<br>数据接收之后，需要将buffer数组强制转换成我们需要的数据结构类型，便于查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pdata = (UINT8 *)pData;//将结构体类型强制转换成unsigned char类型</span><br><span class="line">pBuf = (ComFrameData *)fraBuf;//将unsigned char类型强制转换成结构体类型</span><br></pre></td></tr></table></figure><h5 id="2-3-注意字节对齐与大小端"><a href="#2-3-注意字节对齐与大小端" class="headerlink" title="2.3    注意字节对齐与大小端"></a>2.3    注意字节对齐与大小端</h5><p>整个数据结构中有char型、short型、char型数组，所以需要考虑到32位机字节对齐的问题。加上：</p><pre><code>#pragma   pack(1)，强制连续存放，对齐边界为1。</code></pre><h4 id="三、数据格式的组包-解包"><a href="#三、数据格式的组包-解包" class="headerlink" title="三、数据格式的组包/解包"></a>三、数据格式的组包/解包</h4><p>数据传输时，需要对数据进行初始化、校验、打包。</p><h5 id="3-1-校验和"><a href="#3-1-校验和" class="headerlink" title="3.1 校验和"></a>3.1 校验和</h5><p>在组包解包之前有校验和，这里从帧头开始到校验和之前开始累加，对最低byte取反即可。具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">UINT8 checksum(ComFrameData *pData, int len)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int i,sum=0;</span><br><span class="line">    UINT8 ccsum=0;  </span><br><span class="line">UINT8 *pdata;</span><br><span class="line">pdata = (UINT8 *)pData;//将结构体类型强制转换成char类型</span><br><span class="line"></span><br><span class="line">    for(i=0;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        #if 1</span><br><span class="line">        printf(&quot;%X\n&quot;,*pdata);</span><br><span class="line">        #endif</span><br><span class="line">        sum += *(pdata++); </span><br><span class="line">    &#125;</span><br><span class="line">    ccsum = ~(sum&amp;0xFF);  </span><br><span class="line"></span><br><span class="line">#if 1</span><br><span class="line">    printf(&quot;累加和:0x%X\n&quot;,sum);</span><br><span class="line">    printf(&quot;校验和:0x%X\n&quot;,ccsum);</span><br><span class="line">#endif</span><br><span class="line">    return ccsum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-将要Request的组包"><a href="#3-2-将要Request的组包" class="headerlink" title="3.2 将要Request的组包"></a>3.2 将要Request的组包</h5><p>举个例子，对上图Excel表中的reset命令进行组包，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void commFraSend_ResetBulid_Request(UINT8 *fraBuf, UINT8 *plen)</span><br><span class="line">&#123;</span><br><span class="line">ComFrameData *pBuf;</span><br><span class="line">pBuf = (ComFrameData *)fraBuf;//将char类型强制转换成结构体类型</span><br><span class="line">UINT8 frame_CRC,frame_stop;</span><br><span class="line"></span><br><span class="line">pBuf-&gt;frame_start   = COMMFRA_SEND_HEAD;//64</span><br><span class="line">pBuf-&gt;frame_up_down = COMMFRA_SEND_UP_DOWN; //1</span><br><span class="line">pBuf-&gt;frame_key_word= RESET;//0 </span><br><span class="line"></span><br><span class="line">pBuf-&gt;frame_datalength= 0x0001;//高低位 大小端</span><br><span class="line">pBuf-&gt;frame_item.ComFrameDataReset.ComFrameDataReset_Request.item_key= KEY1;//55</span><br><span class="line"></span><br><span class="line">frame_CRC = checksum(pBuf,6);</span><br><span class="line">frame_stop    = COMMFRA_SEND_TAIL;</span><br><span class="line">printf(&quot;帧尾:0x%X\n&quot;,frame_stop);</span><br><span class="line">*plen = sizeof(pBuf-&gt;frame_start)</span><br><span class="line">+sizeof(pBuf-&gt;frame_up_down)</span><br><span class="line">+sizeof(pBuf-&gt;frame_key_word)</span><br><span class="line">+sizeof(pBuf-&gt;frame_datalength)</span><br><span class="line">+sizeof(pBuf-&gt;frame_item.ComFrameDataReset.ComFrameDataReset_Request.item_key)</span><br><span class="line">+sizeof(frame_CRC)</span><br><span class="line">+sizeof(frame_stop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-将要Response的解包"><a href="#3-3-将要Response的解包" class="headerlink" title="3.3 将要Response的解包"></a>3.3 将要Response的解包</h5><p>举个例子，对上图Excel表中的Response命令进行解包包，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void commFraSend_SetMCUTimeAnalysis_Response(UINT8 *fraBuf)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">char i,item_len;</span><br><span class="line">ComFrameData *pBuf;</span><br><span class="line">pBuf = (ComFrameData *)fraBuf;//将char类型强制转换成结构体类型</span><br><span class="line">UINT8 frame_CRC,frame_stop;</span><br><span class="line"></span><br><span class="line">printf(&quot;帧头:0x%X\n&quot;,pBuf-&gt;frame_start);</span><br><span class="line">printf(&quot;上下行:0x%X\n&quot;,pBuf-&gt;frame_up_down);</span><br><span class="line">printf(&quot;关键字:0x%X\n&quot;,pBuf-&gt;frame_key_word);</span><br><span class="line"></span><br><span class="line">item_len = (pBuf-&gt;frame_datalength&amp;0xFF)|(pBuf-&gt;frame_datalength&gt;&gt;8);</span><br><span class="line">printf(&quot;数据长度:0x%X\n&quot;,item_len);</span><br><span class="line"></span><br><span class="line">printf(&quot;数据域-Key:0x%X\n&quot;,pBuf-&gt;frame_item.ComFrameDataSetMCUTime.ComFrameDataSetMCUTime_Response.item_key);</span><br><span class="line">for(i=0;i&lt;item_len-1;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;数据域内容:0x%X\n&quot;,pBuf-&gt;frame_item.ComFrameDataSetMCUTime.ComFrameDataSetMCUTime_Response.item_data[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">frame_CRC = pBuf-&gt;frame_item.ComFrameDataSetMCUTime.ComFrameDataSetMCUTime_Response.item_data[i];</span><br><span class="line">frame_stop = pBuf-&gt;frame_item.ComFrameDataSetMCUTime.ComFrameDataSetMCUTime_Response.item_data[i+1];</span><br><span class="line"></span><br><span class="line">printf(&quot;校验:0x%X\n&quot;,frame_CRC);</span><br><span class="line">printf(&quot;帧尾:0x%X\n&quot;,frame_stop);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-4-对接收数据进行的异常处理"><a href="#3-4-对接收数据进行的异常处理" class="headerlink" title="3.4 对接收数据进行的异常处理"></a>3.4 对接收数据进行的异常处理</h5><p>关于异常处理与提取,接收数据可能是20个byte,需要在这20个byte中提取有效的长度。</p><ol><li>这个有效长度必须满足收尾都是0x64</li><li>这个有效长度最短长度不得少于8个byte</li><li>这个有效长度的数据必须符合校验和的计算方式</li><li>满足上面3条即可提取这个数据帧</li><li>注意:在真正想要的数据帧之间是没有0x64的,这种情况先假设它不存在(后面会根据校验和的方式来处理)</li></ol><p>代码如下：（循环遍历+判断条件）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">UINT8 ReceiveBuf[20] = &#123;</span><br><span class="line">0x00, 0x64, 0x00, 0x64, 0x01, 0x04, 0x00, 0x08, </span><br><span class="line">0x55, 0x07, 0xE2, 0x01, 0x06, 0x01, 0x1C, 0x18, </span><br><span class="line">0x14, 0x64, 0x30, 0x11&#125;;//模拟接收到的MCU响应的时间</span><br><span class="line"></span><br><span class="line">void exception_handling_extract(UINT8 *fraBuf, UINT8 buflen, UINT8 **prealBUF, UINT8 *preallen)</span><br><span class="line">&#123;</span><br><span class="line">UINT8 len = 0;//n = 0,</span><br><span class="line">UINT8 *pcur,*p;//*pBuf,</span><br><span class="line"></span><br><span class="line">printf(&quot;接收到的数据的长度是:%d\n&quot;,buflen);</span><br><span class="line">p = fraBuf;</span><br><span class="line">while(buflen--)</span><br><span class="line">&#123;</span><br><span class="line">if(*p == 0x64)</span><br><span class="line">&#123;</span><br><span class="line">pcur = p;</span><br><span class="line">while(buflen--)</span><br><span class="line">&#123;</span><br><span class="line">p++;</span><br><span class="line">if(*p == 0x64)</span><br><span class="line">&#123;</span><br><span class="line">len = p-pcur;</span><br><span class="line">printf(&quot;两个0x64之间的数据长度:%d\n&quot;,len);</span><br><span class="line">if(len&gt;=8)</span><br><span class="line">&#123;</span><br><span class="line">//进行相应的校验和计算</span><br><span class="line">if(*(p-1) == checksum((ComFrameData*)pcur,len-1))</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;这个真实帧的校验和满足条件!\n&quot;);</span><br><span class="line">//开始提取这个有效的数据帧</span><br><span class="line">*preallen = len+1;</span><br><span class="line">*prealBUF = pcur;</span><br><span class="line">break;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">printf(&quot;这个真实帧的校验和不满足条件!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;else&#123;</span><br><span class="line">//说明真正想要的数据帧帧头不是前面的一个0x64,可能是这一个,或者是下一个。之后继续对p进行遍历</span><br><span class="line">pcur = p;</span><br><span class="line">len = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;此时N2的长度是:%d\n&quot;,buflen);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">p++;</span><br><span class="line">printf(&quot;此时N1的长度是:%d\n&quot;,buflen);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、SEND-RECEIVE-数据"><a href="#四、SEND-RECEIVE-数据" class="headerlink" title="四、SEND/RECEIVE-数据"></a>四、SEND/RECEIVE-数据</h4><p>海思和MCU通信是通过串口通信，这里有现成的接口函数，驱动部分不需要做出太多的改动，现在主要考虑的应用逻辑部分。</p><h5 id="4-1-数据长度必须要满足最小值"><a href="#4-1-数据长度必须要满足最小值" class="headerlink" title="4.1    数据长度必须要满足最小值"></a>4.1    数据长度必须要满足最小值</h5><h5 id="4-2-帧头、帧尾要符合要求，最好要有冗余检测"><a href="#4-2-帧头、帧尾要符合要求，最好要有冗余检测" class="headerlink" title="4.2    帧头、帧尾要符合要求，最好要有冗余检测"></a>4.2    帧头、帧尾要符合要求，最好要有冗余检测</h5><h5 id="4-3-校验对比"><a href="#4-3-校验对比" class="headerlink" title="4.3    校验对比"></a>4.3    校验对比</h5><p>前面在组包的时候已经有了，在接收数据的时候可以对刚接收到的数据进行校验对比。</p><h5 id="4-4-发送数据之后是否有反馈"><a href="#4-4-发送数据之后是否有反馈" class="headerlink" title="4.4    发送数据之后是否有反馈"></a>4.4    发送数据之后是否有反馈</h5><p>根据下面(5 软件图&amp;流程图)可以看到有些是有反馈的有些是没有反馈的。</p><h4 id="五、软件图-amp-流程图"><a href="#五、软件图-amp-流程图" class="headerlink" title="五、软件图&amp;流程图"></a>五、软件图&amp;流程图</h4><h5 id="5-1-Request-Response图"><a href="#5-1-Request-Response图" class="headerlink" title="5.1 Request Response图"></a>5.1 Request Response图</h5><p><img src="/2019/11/23/COM%E5%8F%A316%E8%BF%9B%E5%88%B6%E9%80%9A%E4%BF%A1%E8%AE%BE%E8%AE%A1/2.jpg" alt="2"></p><h5 id="5-1-流程图"><a href="#5-1-流程图" class="headerlink" title="5.1 流程图"></a>5.1 流程图</h5><p><img src="/2019/11/23/COM%E5%8F%A316%E8%BF%9B%E5%88%B6%E9%80%9A%E4%BF%A1%E8%AE%BE%E8%AE%A1/3.jpg" alt="3"></p><h4 id="六、完整版程序代码"><a href="#六、完整版程序代码" class="headerlink" title="六、完整版程序代码"></a>六、完整版程序代码</h4><p>配合《mcu com软件接口设计方案》,且测试验证通过，支持和MCU多次重发3次、支持多次重读20次，每次1ms,且可设置参数。<br><a href="https://github.com/faihung/test/tree/master/5-16%E8%BF%9B%E5%88%B6%E9%80%9A%E4%BF%A1" target="_blank" rel="noopener">参考代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、16进制数据格式通过串口调试工具验证&quot;&gt;&lt;a href=&quot;#一、16进制数据格式通过串口调试工具验证&quot; class=&quot;headerlink&quot; title=&quot;一、16进制数据格式通过串口调试工具验证&quot;&gt;&lt;/a&gt;一、16进制数据格式通过串口调试工具验证&lt;/h4&gt;&lt;p&gt;拿到MCU板子，根据《mcu com软件接口设计方案_v002.xlsx》进行串口调试验证，见下表。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工程设计" scheme="http://www.faihung.net/categories/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="通信设计" scheme="http://www.faihung.net/tags/%E9%80%9A%E4%BF%A1%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="数据结构构造" scheme="http://www.faihung.net/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9E%84%E9%80%A0/"/>
    
      <category term="流程图" scheme="http://www.faihung.net/tags/%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    
      <category term="字节对齐" scheme="http://www.faihung.net/tags/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/"/>
    
      <category term="大小端" scheme="http://www.faihung.net/tags/%E5%A4%A7%E5%B0%8F%E7%AB%AF/"/>
    
      <category term="pragma pack()" scheme="http://www.faihung.net/tags/pragma-pack/"/>
    
      <category term="解耦合" scheme="http://www.faihung.net/tags/%E8%A7%A3%E8%80%A6%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>视音频-视音频信号种类和物理接口</title>
    <link href="http://www.faihung.net/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/"/>
    <id>http://www.faihung.net/2019/11/17/视音频-视音频信号种类和物理接口/</id>
    <published>2019-11-17T09:12:01.000Z</published>
    <updated>2019-11-17T09:17:44.431Z</updated>
    
    <content type="html"><![CDATA[<h5 id="模拟视频信号的格式"><a href="#模拟视频信号的格式" class="headerlink" title="模拟视频信号的格式"></a>模拟视频信号的格式</h5><h6 id="复合信号Composite-Video"><a href="#复合信号Composite-Video" class="headerlink" title="复合信号Composite Video"></a>复合信号Composite Video</h6><p>在一路信号中,使用不同的频率把亮度、色度、同步等所有视频信号结合在一起。只使用一个连接线传输即可。标准的PAL和NTSC信号就是复合信号。信号使用BNC或者“莲花”端子连接。</p><a id="more"></a><h6 id="分量信号Component-Video"><a href="#分量信号Component-Video" class="headerlink" title="分量信号Component Video"></a>分量信号Component Video</h6><p>使用3路信号分别传输模拟的经过Gamma校正的RGB信号,或者更常见地, YPbPr信号,就是模拟YuV信号经过某种线形变换之后的形式,通常线缆上或者接口上会标注Y,Pb,Pr或者Y、U、V或者Y,R-YB-Y等。信号使用BNC或者“莲花”端子连接。</p><h6 id="S-Video或YC"><a href="#S-Video或YC" class="headerlink" title="S-Video或YC"></a>S-Video或YC</h6><p>用两路信号分别传送亮度信号Y和将U、V正交调制而成的色度信号C。信号使用专门的4针mini-DIN端了连接。</p><h5 id="数字视频信号的格式"><a href="#数字视频信号的格式" class="headerlink" title="数字视频信号的格式"></a>数字视频信号的格式</h5><h6 id="SDI"><a href="#SDI" class="headerlink" title="SDI"></a>SDI</h6><p>Serial Digital Interface串行数字接口。SMPTE定义的专业视频数据传输接口,速率为143Mb/s或者360Mb/s通常用来传输非压缩视频数据。HD SDI标准由SMPTE 292M定义,速率为1.485 Gbitls. SMPTE 372M定义了Dual Link SDI,速率为2.970 Gbit/s,最近又定义了3G-SDI,同样速率,都是为HD电视之上的数字影院使用。SDI信号一般使用同轴电缆和BNC端子连接,传输距离设计为演播室内部使用(300米以内)。</p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/1.jpg" alt="1"></p><h6 id="SDTI"><a href="#SDTI" class="headerlink" title="SDTI"></a>SDTI</h6><p>Serial Data Transmission Interface串行数据传输接口。SMPTE定义的SDI的变体,用来传输任意格式的数据,而非限于非压缩视频数据。主要是压缩到视频流数据(DV, DVCPRO, BetaSX, MPEG2),由于是在SDI实时传输非压缩数据的定义的逻辑和物理结构的基础之上传输压缩数据,所以可以做到超实时(2x, 4x等)。270Mb/s速率的SDTI由SMPTE 305M定义,而1.5Gb/s的HD SDTI由SMPTE 348M定义。</p><h5 id="模拟音频信号"><a href="#模拟音频信号" class="headerlink" title="模拟音频信号"></a>模拟音频信号</h5><h6 id="非平衡音频连接及其弱点"><a href="#非平衡音频连接及其弱点" class="headerlink" title="非平衡音频连接及其弱点"></a>非平衡音频连接及其弱点</h6><p>音频电缆中有2根铜线,一条信号线、一条地线,即普通的一条RCA线和莲花插头。家用音响多为非平衡输入输出。非平衡连接的弱点在于噪声控制比较差,如下图噪声透过电缆保护层加入到信号中无法去除。</p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/2.jpg" alt="2"></p><h6 id="平衡音频"><a href="#平衡音频" class="headerlink" title="平衡音频"></a>平衡音频</h6><p>平衡音频电缆中采用3根导线, 2条传输信号, 1条是地线。源设备通过这2条信号线传输相位完全相反的信号,两条导线制作成具有相当一致的阻抗特性和缠绕方式,所以各自拾取的噪声信号也相同,接收设各收到信号后,将第2路反相回来,这样其中的噪声就变成与第1路中的噪声反相了, 2路信号相加,即除去了噪声。专业音频设备多使用平衡线路。</p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/3.jpg" alt="3"></p><p>平衡音频使用3针XLR接头(卡农)或1/4”TRS接头。</p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/4.jpg" alt="4"></p><h5 id="数字音频信号的格式"><a href="#数字音频信号的格式" class="headerlink" title="数字音频信号的格式"></a>数字音频信号的格式</h5><h6 id="SDI嵌入式音频信号"><a href="#SDI嵌入式音频信号" class="headerlink" title="SDI嵌入式音频信号"></a>SDI嵌入式音频信号</h6><p>在SDI信号中,都提供16路单声道音频信号的传输,格式均为24bit,48KHz的PCM音频。音频数据记录在水平消隐期对应的信号数据中。</p><h6 id="AES-EBU音频信号"><a href="#AES-EBU音频信号" class="headerlink" title="AES/EBU音频信号"></a>AES/EBU音频信号</h6><p>AES/EBU的全称是Audio Engineering Society/European Broadcast Union (音频工程师协会/欧洲广播联盟),现已成为专业数字音频较为流行的标准。大量民用产品和专业音频数字设备如CD机、DAT, MD机、数字调音台、数字音频工作站等都支持AES/EBU。</p><p>AES/EBU是一种通过基于单根绞合线对来传输数字音频数据的串行位传输协议。它无须均衡即可在长达100m的距离上传输数据,如果均衡,可以传输更远距离。它提供两个信道的音频数据(最高24比特量化),信道是自动计时和自同步的。它也提供了传输控制的方法和状态信息的表示(channel status bi)和一些误码的检测能力。它的时钟信息是由传输端控制,来自AES/EBU的位流。它的三个标准采样率是32kHz44.1kHz、48kHz,当然许多接口能够工作在其它不同的采样率上。</p><p>AES/EBU提供“专业”和“消费”两种模式。它们两者最大的不同在于信道状态位格式的提供上。专业模式的状态位格式里包括数字信道的源和目的地址、日期时间码、采样点数、字节长度和其它信息。消费模式包括的东西就比较少,但包含了拷贝保护信息。另外, AES/EBU标准提供“用户数据”,在它的位流里包含用户说明(例如厂商说明等)。</p><p>AES/EBU的普通物理连接媒质有: </p><p>(1)平衡或差分连接,使用XLR (卡依)连接器的三芯话筒屏蔽电缆参数为阻抗11032,电平范围0.2V~5Vpp,抖动为土20ns。</p><p>(2)单端非平衡连接,使用RCA插头的音频同轴电缆。</p><p>(3)光学连接,使用光纤连接器。</p><h5 id="同步Genlock"><a href="#同步Genlock" class="headerlink" title="同步Genlock"></a>同步Genlock</h5><p>Genlock (Generator Lock)同步锁相也是一种帧同步技术,通常用于视频后期处理、非线性编辑(NLE)和演播室。该技术可以使工作站图形系统的输出信号与外部生成的(GEN)信号进行同步(LOCK),从而确保演播室中的所有设备(摄像机、录像机、动画或字幕机等等)之间的有效协作。</p><p>各个设备间行、场扫描的同步信号必须一致,如果使用复合信号,则其中的色度付载波的相位也必须相同。广播系统中的同步信号通常使用同步信号发生器产生,其中包含垂直和水平同步脉冲和色度相位脉冲。这个模拟信号通常称为Black Burst (BB)黑场同步信号。</p><h6 id="双电平同步信号Bilevel-Sync"><a href="#双电平同步信号Bilevel-Sync" class="headerlink" title="双电平同步信号Bilevel Sync"></a>双电平同步信号Bilevel Sync</h6><p>传统的BB信号。有一个同步脉冲,从消隐电平向下到达同步峰值电平-285 5/7mV或者-300mV。双电平同步信号主要用于标清设备,也可以用于高清设备。</p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/5.jpg" alt="5"></p><h6 id="三电平同步信号Bi-evel-Sync"><a href="#三电平同步信号Bi-evel-Sync" class="headerlink" title="三电平同步信号Bi-evel Sync"></a>三电平同步信号Bi-evel Sync</h6><p>有2个反向的脉冲,从消隐电平向下到达同步峰值电平-300mV,再向上到达+300mV,然后回到消隐电平。三电平的主要好处是使接收端的模拟电路更容易找到同步信号,也更容易在信号送往显示电路前从中剔除同步信号,避免串扰。三电平同步信号应用于高清设备中,是SMPTE的HD标准之一(SMPTE 240)。</p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/6.jpg" alt="6"></p><h5 id="视音频信号端子"><a href="#视音频信号端子" class="headerlink" title="视音频信号端子"></a>视音频信号端子</h5><h6 id="BNC端子"><a href="#BNC端子" class="headerlink" title="BNC端子"></a>BNC端子</h6><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/7.jpg" alt="7"></p><p>Bayonet Neill-Concelman (Neill-Concelman卡销):一种同轴电缆连接头,现在由IEC-168标准定义。广泛应用于专业视频领域。在贝尔实验室工作的Paul Neill曾经开发了一种带螺纹的接头,被美国海军采用,叫做N接头,后来Carl Concelman又开发了一种接头,采用了滑入在旋转卡住的办法,称为C接头。两人合作开发了一种类似的较小的接头,成了现在的BNC。</p><h6 id="RCA莲花插头RCA-plug-RCA-phono-唱机-connector"><a href="#RCA莲花插头RCA-plug-RCA-phono-唱机-connector" class="headerlink" title="RCA莲花插头RCA plug, RCA phono (唱机) connector"></a>RCA莲花插头RCA plug, RCA phono (唱机) connector</h6><p>RCA是Radio Corporation of American的缩写词,因为RCA接头由这家公司发明的。RCA俗称莲花插座,几乎所有的电视机、影碟机类产品都有这个接口。它并不是专门为哪一种接口设计,既可以用在音频,又可以用在普通的视频信号,也是DVD分量(YCICb)的插座,只不过数量是三个。 RCA接头是目前为止最为常见的一种音/视频接线端子。这种双线连接方式的端子早在收音机出现的时代便由RCA录音公司发明出来,还有一个更老式、也比较奇怪的称呼叫做”唱盘”接头。</p><p>RCA端子采用同轴传输信号的方式,中轴用来传输信号,外沿一圈的接触层用来接地,可以用来传输数字音频信号和模拟视频信号。RCA音频端子一般成对地用不同颜色标注:右声道用红色,左声道用黑色或白色。有的时候,中置和环绕声道连接线会用其他的颜色标注来方便接线时区分,但整个系统中所有的RCA接头在电气性能上都是一样的。一般来讲, RCA立体声音频线都是左右声道为一组,每声道外观上是一根线。</p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/8.jpg" alt="8"></p><p>不像射频接口那样包含了音频信号,复合视频(Composite)通常采用黄色的RCA (莲花插座)接头。”复合”含义是同一信道中传输亮度和色度信号的模拟信号,但电视机如果不能很好的分离这两种信号,就会出现虚影。</p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/9.jpg" alt="9"></p><p>色差(Component)通常标记为YPb/Pr,用红、绿、蓝三种颜色来标注每条线缆和接口。绿色线缆(Y),传输亮度信号。蓝色和红色线缆(Pb和Pr)传输的是颜色差别信号。色差的效果要好于s端子,因此不少DVD以及高清播放设备上都采用该接口。如果使用优质的线材和接口,即使采用10米长的线缆,色差线也能传输优秀的画面。</p><h6 id="Mini-DIN端子"><a href="#Mini-DIN端子" class="headerlink" title="Mini-DIN端子"></a>Mini-DIN端子</h6><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/10.jpg" alt="10"></p><p>德国标准机构Deutsches Instiut fur Normung早期开发的一组多针的电气接口称为DIN端子,后来开发了更小的接头, 叫Mini-DIN,包括3针到9针共7个完全不同的标准。其中, 4针被S-Video信号标准采用作为专用接头; 6针则被PS/2键盘鼠标设备采用。</p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/11.jpg" alt="11"></p><p>s端子(S-Video)连接采用YIC (亮度/色度)分离式输出,使用四芯线传送信号,接口为四针接口。接口中,两针接地,另外两针分别传输亮度和色度信号。因为分别传送亮度和色度信号, s端子效果要好于复合视频。不过s端子的抗干扰能力较弱,所以s端子线的长度最好不要超过7米。</p><h6 id="射频端子"><a href="#射频端子" class="headerlink" title="射频端子"></a>射频端子</h6><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/12.jpg" alt="12"></p><p>天线和模拟闭路连接电视机就是采用射频(RF)接口。作为最常见的视频连接方式,它可同时传输模拟视频以及音频信号。RF接口传输的是视频和音频混合编码后的信号,显示设备的电路将混合编码信号进行一系列分离、解码在输出成像。由于需要进行视频、音频混合编码,信号会互相干扰,所以它的画质输出质量是所有接口中最差的。有线电视和卫星电视接收设备也常用RF连接,但这种情况下,它们传输的是数字信号。</p><h6 id="VGA端子"><a href="#VGA端子" class="headerlink" title="VGA端子"></a>VGA端子</h6><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/13.jpg" alt="13"></p><p>VGA (Video Graphics Array)还有一个名称叫D-Sub, VGA接口共有15针,分成3排,每排5个孔,是显卡上应用最为广泛的接口类型,绝大多数显卡都带有此种接口。它传输红、绿、蓝模拟信号以及同步信号(水平和垂直信号)。使用VGA连接设备,线缆长度最好不要超过10米,而且要注意接头是否安装牢固,否则可能引起图像中出现虚影。</p><h6 id="DVI端子"><a href="#DVI端子" class="headerlink" title="DVI端子"></a>DVI端子</h6><p>DVI (Digital Visual Interface)接口与VGA都是电脑中最常用的接口,与VGA不同的是, DVI可以传输数字信号,不用再进过数模转换,所以画面质量非常高。目前,很多高清电视上也提供了DVI接口。需要注意的是, DVI接口有多种规范,常见的是DVI-D (Digital)和DVI-I (Interated), DVI-D只能传输数字信号,大家可以用它来连接显卡和平板电视。DVI-I则在DVI-D可以和VGA相互转换。</p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/14.jpg" alt="14"></p><h6 id="HDMI"><a href="#HDMI" class="headerlink" title="HDMI"></a>HDMI</h6><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/15.jpg" alt="15"></p><p>HDMI (High Definition Multimedia Interface)按口是最近才出现的接口,它同DVI一样是传输全数字信号的。不同的是HDMI接口不仅能传输高清数字视频信号,还可以同时传输高质量的音频信号。同时功能跟射频接口相同,不过由于采用了全数字化的信号传输,不会像射频接口那样出现画质不佳的情况。对于没有HDMI接口的用户,可以用适配器将HDMI接口转换位DVI接口,但是这样就失去了音频信号。高质量的HDMI线材,即使长达20米,也能保证优质的画质。</p><h6 id="IEEE-1394"><a href="#IEEE-1394" class="headerlink" title="IEEE 1394"></a>IEEE 1394</h6><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%9F%B3%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3/16.jpg" alt="16"></p><p>IEEE 1394也称为火线或ilLink,它能够传输数字视频和音频及机器控制信号,具有较高的带宽,且十分稳定。通常它主要用来连接数码摄像机、DVD录像机等设备。IEEE 1394接口有两种类型: 6针的六角形接口和4针的小型四角形接口。6针的六角形接口可向所连接的设备供电,而4针的四角形接口则不能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;模拟视频信号的格式&quot;&gt;&lt;a href=&quot;#模拟视频信号的格式&quot; class=&quot;headerlink&quot; title=&quot;模拟视频信号的格式&quot;&gt;&lt;/a&gt;模拟视频信号的格式&lt;/h5&gt;&lt;h6 id=&quot;复合信号Composite-Video&quot;&gt;&lt;a href=&quot;#复合信号Composite-Video&quot; class=&quot;headerlink&quot; title=&quot;复合信号Composite Video&quot;&gt;&lt;/a&gt;复合信号Composite Video&lt;/h6&gt;&lt;p&gt;在一路信号中,使用不同的频率把亮度、色度、同步等所有视频信号结合在一起。只使用一个连接线传输即可。标准的PAL和NTSC信号就是复合信号。信号使用BNC或者“莲花”端子连接。&lt;/p&gt;
    
    </summary>
    
    
      <category term="视音频" scheme="http://www.faihung.net/categories/%E8%A7%86%E9%9F%B3%E9%A2%91/"/>
    
    
      <category term="端子" scheme="http://www.faihung.net/tags/%E7%AB%AF%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>视音频-色彩空间介绍(Video Demystified Chapter 3)</title>
    <link href="http://www.faihung.net/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%BB%8B%E7%BB%8D-Video-Demystified-Chapter-3/"/>
    <id>http://www.faihung.net/2019/11/17/视音频-色彩空间介绍-Video-Demystified-Chapter-3/</id>
    <published>2019-11-17T07:59:36.000Z</published>
    <updated>2019-11-17T08:06:41.365Z</updated>
    
    <content type="html"><![CDATA[<p>色彩空间是表示一组颜色的数学模型。</p><p>最常用的3种色彩空间是:</p><p>RGB-应用于计算机图形</p><p>YIQ, YUv,或者YCbCr-视频领域使用</p><p>CMYK-印刷领域</p><p>但这些都不直接对应直观的色调(Hue)、饱和度(Saturation)和亮度(Brightess)的说法,所以还有HSI和HSV的模型。</p><a id="more"></a><h4 id="RGB色彩空间"><a href="#RGB色彩空间" class="headerlink" title="RGB色彩空间"></a>RGB色彩空间</h4><p>红绿蓝三基色相加产生其它颜色,使用三维笛卡尔(Cartesian)坐标系表示:</p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%BB%8B%E7%BB%8D-Video-Demystified-Chapter-3/1.jpg" alt="1"></p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%BB%8B%E7%BB%8D-Video-Demystified-Chapter-3/2.jpg" alt="2"></p><p>彩色显示器都使用红绿蓝三基色相加产生其它颜色,所以RGB空间使用非常普遍。但RGB模型没有区分亮度和色度信息,造成处理不便和数字处理数据量比较大的问题。</p><h4 id="YUV色彩空间"><a href="#YUV色彩空间" class="headerlink" title="YUV色彩空间"></a>YUV色彩空间</h4><p>YUV模型被PAL和NTSC电视系统所采用。黑白电视系统只使用Y亮度信息,彩色电视在加入UV信息。</p><pre><code>Y=0.299R + 0.587G +0.114BU=-0.147R-0.289G + 0.436B= 0.492 (B-Y)V=0.615R-0.515G-0.100B = 0.877(R-Y)R=Y+1.140VG=Y-0.395U-0.581VB=Y+ 2.032URGB: 0-255,Y: 0-255,U: 0-+-112V: 0-+-157.</code></pre><p>通常都会转换到0-255的范围之内。</p><h4 id="YIQ色彩空间"><a href="#YIQ色彩空间" class="headerlink" title="YIQ色彩空间"></a>YIQ色彩空间</h4><p>在NTSC复合信号中有应用。I是in-phase (同相位), Q是quadrature (正交),是调制信号的方法。</p><pre><code>Y=0.299R + 0.587G + 0.114BI=0.596R-0.275G-0.321B= Vcos 33&apos;-Usin 33&apos;= 0.736(R-Y)-0.268(B-Y)Q=0.212R-0.523G + 0.311B= Vsin 33&apos;+ Ucos 33&apos;= 0.478(R-Y) + 0.413(B-Y)(VQ就是把U/V相位旋转了33度)R=Y+0.9561 + 0.6210G=Y-0.2721-0.6470B=Y-1.1071 + 1.704QRGB: 0-255,Y: 0-255,I: 0-+-152,Q: 0-+/134</code></pre><h4 id="YCbCr色彩空间-有时也被称为VUV空间"><a href="#YCbCr色彩空间-有时也被称为VUV空间" class="headerlink" title="YCbCr色彩空间(有时也被称为VUV空间)"></a>YCbCr色彩空间(有时也被称为VUV空间)</h4><p>这是世界通用的分量信号的色彩空间(ITU.601/709标准),实际上是一个经过缩放和位移的YUV空间。其中Y的归一化范围是16-235, CbCr是16-240。</p><h5 id="标清转换公式"><a href="#标清转换公式" class="headerlink" title="标清转换公式:"></a>标清转换公式:</h5><h6 id="视频RGB-16-235-和YCbCr"><a href="#视频RGB-16-235-和YCbCr" class="headerlink" title="视频RGB (16-235)和YCbCr:"></a>视频RGB (16-235)和YCbCr:</h6><pre><code>Y601 = 0.299R + 0.587G + 0.114BCb=-0.172R 0.339G +0.511B + 128Cr=0.511R - 0.428G - 0.083B + 128R=Y601 + 1.371(Cr-128)G=Y601 -0.698(Cr- 128) -0.336(Cb- 128)B=Y601 + 1.732(Cb- 128)</code></pre><h6 id="计算机RGB-0-255-和YCbCr"><a href="#计算机RGB-0-255-和YCbCr" class="headerlink" title="计算机RGB (0-255)和YCbCr:"></a>计算机RGB (0-255)和YCbCr:</h6><pre><code>Y601 = 0.257R + 0.504G +0.098B + 16Сb = -0.148R -0.291G + 0.439B + 128Cr = 0.439R -0.368G - 0.071B + 128R = 1.164(Y601- 16) + 1.596(Cr-128)G = 1.164(Y601- 16)-0.813(Cr-128)- 0.391(Cb- 128)В = 1.164(Y601 - 16) + 2.018(Сb - 128)</code></pre><h5 id="高清转换公式"><a href="#高清转换公式" class="headerlink" title="高清转换公式:"></a>高清转换公式:</h5><h6 id="视频RGB-16-235-和YCbCr-1"><a href="#视频RGB-16-235-和YCbCr-1" class="headerlink" title="视频RGB (16-235)和YCbCr:"></a>视频RGB (16-235)和YCbCr:</h6><pre><code>Y709 =0.213R + 0.715G + 0.072BCb= -0.117R -0.394G + 0.511B+ 128Cr=0.511R - 0.464G-0.047B + 128R=Y709 + 1.540(Cr-128)G=Y709 -0.459(Cr -128)-0.183(Cb - 128)B=Y709 + 1.816(Cb-128</code></pre><h6 id="计算机RGB-0-255-和YCbCr-1"><a href="#计算机RGB-0-255-和YCbCr-1" class="headerlink" title="计算机RGB (0-255)和YCbCr:"></a>计算机RGB (0-255)和YCbCr:</h6><pre><code>Y709 = 0.183R + 0.614G + 0.062B+ 16Cb= -0.101R-0.338G + 0.439B + 128Cr = 0.439R - 0.399G - 0.040B + 128R=1.164(Y709-16) + 1.793(Cr- 128)G= 1.164(Y709- 16) -0.534(Cr -128) -0.213(Cb - 128)B= 1.164(709- 16) + 2.115(Cb- 128)</code></pre><h6 id="YCbCr转换成RGB会产生非法值"><a href="#YCbCr转换成RGB会产生非法值" class="headerlink" title="YCbCr转换成RGB会产生非法值"></a>YCbCr转换成RGB会产生非法值</h6><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%BB%8B%E7%BB%8D-Video-Demystified-Chapter-3/3.jpg" alt="3"></p><h5 id="YCbCr的格式"><a href="#YCbCr的格式" class="headerlink" title="YCbCr的格式:"></a>YCbCr的格式:</h5><p>4:4-每个像素有Y, Cb, Cr三个分量。</p><p>4:2:2-水平方向上,每2个像素有2个Y,和1个Cb,1个Cr分量。</p><p>4:1:1-水平方向上,每4个像素有4个Y,和1个Cb, 1个Cr分量。</p><p>4:2:0-每个2x2像素块,有4个Y,和1个Cb, 1个Cr分量。有3种变体。</p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%BB%8B%E7%BB%8D-Video-Demystified-Chapter-3/4.jpg" alt="4"></p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%BB%8B%E7%BB%8D-Video-Demystified-Chapter-3/5.jpg" alt="5"></p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%BB%8B%E7%BB%8D-Video-Demystified-Chapter-3/6.jpg" alt="6"></p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%BB%8B%E7%BB%8D-Video-Demystified-Chapter-3/7.jpg" alt="7"></p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%BB%8B%E7%BB%8D-Video-Demystified-Chapter-3/8.jpg" alt="8"></p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%BB%8B%E7%BB%8D-Video-Demystified-Chapter-3/9.jpg" alt="9"></p><h4 id="HSI-HLS和HSV色彩空间"><a href="#HSI-HLS和HSV色彩空间" class="headerlink" title="HSI, HLS和HSV色彩空间"></a>HSI, HLS和HSV色彩空间</h4><p>H-hue色度, S-saturation饱和度, I-intensity, L-lightness, V-value都指亮度。</p><p>一些系统用来提供直观的色彩表达方式。</p><p>HSI和HLS等同, HSV与之的不同点在于从RGB计算亮度值的公式不同,同时影响到饱和度值的计算。HSI的1值等量依赖于RGB值,适合用来进行亮度处理;HSV的饱和度动态空间比较大,适合用来调整饱和度和色度。</p><h5 id="色品图chromaticity-diagram"><a href="#色品图chromaticity-diagram" class="headerlink" title="色品图chromaticity diagram"></a>色品图chromaticity diagram</h5><p>1931年CIE组织(International Commission on Ilumination or Commission Internationale de I’ Eclairage)绘制了色品图,把所有的RGB表示的颜色放置在一个图形中。</p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%BB%8B%E7%BB%8D-Video-Demystified-Chapter-3/10.jpg" alt="10"></p><p>坐标计算公式: x=R/(R+G+B), y=G/(R+G+B), z=B/(R+G+B)由于x+y+z总是1,所以一个颜色值可以用x.y在二维平面图上唯一代表。</p><p>沿形状的曲线外沿一周是红绿蓝三基色(波长从700nm到400nm),以及各种最饱和颜色,下方直线是紫色线。形状内部越接近中心饱和度越小,直至白色。形状外不是颜色区,图中没有黑色。</p><p>注意各种电视制式都不能产生所有RGB可以表示的颜色,只能覆盖一定的区域。</p><h5 id="Gamma校正"><a href="#Gamma校正" class="headerlink" title="Gamma校正"></a>Gamma校正</h5><p>在电视和图形监视器中,显像管发生的电子束及其生成的图像亮度并不是随显像管的输入电压线性变化,输入电压与对应亮度的转换关系曲线,称为伽玛曲线(Gamma Curve),以传统CRT (Cathode Ray Tube)屏幕的特性而言,该曲线通常是一个乘幂函数, Y-(Xte)y,其中, Y为亮度、X为输出电压、e为补偿系数、乘幂值(y)为伽玛值,改变乘幂值(y)的大小,就能改变CRT的伽玛曲线。</p><p>电子流与输入电压相比是按照指数曲线变化的,输入电压的指数要大于电子束的指数。</p><p>这说明暗区的信号要比实际情况更暗,而亮区要比实际情况更高。所以,要重现摄像机拍摄的画面,电视和监视器必须进行伽玛补偿。这种伽玛校正也可以由摄像机完成。</p><p>我们对整个电视系统进行伽玛补偿的目的,是使摄像机根据入射光亮度与显像管的亮度对称而产生的输出信号,所以应对图像信号引入一个相反的非线性失真,即与电视系统的伽玛曲线对应的摄像机伽玛曲线,它的值应为1/y,我们称为摄像机的伽玛值。</p><p>电视系统的伽玛值约为2.2,所以电视系统的摄像机非线性补偿伽玛值为0.45,彩色显像管的伽玛值为2.8,它的图像信号校正指数应为1/2.8-0.35,但由于显像管内外杂散光的影响,重现图像的对比度和饱和度均有所降低,所以现在的彩色摄像机的伽玛值仍多采用0.45。在实际应用中,我们可以根据实际情况在一定范围内调整伽玛值,以获得最佳效果。</p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%BB%8B%E7%BB%8D-Video-Demystified-Chapter-3/11.jpg" alt="11"></p><h5 id="模拟信号幅度的表示单位"><a href="#模拟信号幅度的表示单位" class="headerlink" title="模拟信号幅度的表示单位"></a>模拟信号幅度的表示单位</h5><p>这里的YUV模拟信号是针对ITU.601规定的SD的PAL和NTSC来说的。对于HD,由于根本没有这样的模拟YUV信号传送(见Digital Video and HDTV 335页,即使SD的分量信号实际上也不用模拟YUV),也就不存在一个HD YCbCr信号到YUV的转换公式。</p><p>对于PAL制,画面信号的亮度范围ITU.601规定为0到700mV,即归一化的Y的0到1线性对应于0到700mV; UV和Y的单位一致,也就是色度幅度信号sqrt(U的2次幂+ V的2次幂)的0到1线性对应于0到700mV,显示时再乘以2。</p><p>0叫做Blanking Level (等同于Black Level), 100叫做White Level。</p><p>PAL制我们也可以采用计算机化的0-100%来显示,有利于表示100%, 75%彩条的标准位置。</p><p>顺便指出, HD系统的信号范围和PAL制相同;尽管示波器显示对于HD的YCbCr转换后的显示无意义。</p><p>NTSC的情况如下:</p><p>总的画面信号亮度范围是0到714-2/7mV,或者用IRE位表示, 0到100 IRE,所以每个IRE单位约为71.4mV. IRE是Institute of Radio Engineers,是IEEE (美国电气电子工程师协会)的前身。</p><p>在日本N制中, Y的0到1被线性映射到上述整个物理范围。</p><p>在美国N制中, Y的0到1被线性映射到7.5-100 IRE之间,或者5344/7 mV到714+2/7mV之间。色度幅度信号sqrt(U的2次幂 + V的2次幂)的0到1映射范围相同,注意美国N制时映射到0到92.5 IRE。</p><p>这里0叫做Blanking Level, 100叫做White Level,在日本N制中Black Level等同于Blanking Level;美国N制的Black Level则是7.5 IRE,被称为黑电平提升(setup, lif, pedestal [pedistl]文架等等);日本N制,PAL制, HD被对应地称为”0 Setup”。</p><p>N制我们也可以采用计算机化的0-100%来显示,在日本N制中等同于IRE表示,但在美国N制中0到100%映射在7.5到100 IRE的区域内,因此不同于IRE显示。</p><p>有的文档(包括Video Denystified)中,对PAL信号也用IRE表示。Video Demystified 710页把IRE定义成把Blanking Level到White Level之间等分为100份的单位,而不是只限于N制的相当于71.4mV的单位。除了美国N制外,其它制式Black Level等同于Blanking Level,所以这些制式中IRE等同于百分比,在PAL制和HD中相当于70mv。</p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%BB%8B%E7%BB%8D-Video-Demystified-Chapter-3/12.jpg" alt="12"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;色彩空间是表示一组颜色的数学模型。&lt;/p&gt;
&lt;p&gt;最常用的3种色彩空间是:&lt;/p&gt;
&lt;p&gt;RGB-应用于计算机图形&lt;/p&gt;
&lt;p&gt;YIQ, YUv,或者YCbCr-视频领域使用&lt;/p&gt;
&lt;p&gt;CMYK-印刷领域&lt;/p&gt;
&lt;p&gt;但这些都不直接对应直观的色调(Hue)、饱和度(Saturation)和亮度(Brightess)的说法,所以还有HSI和HSV的模型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="视音频" scheme="http://www.faihung.net/categories/%E8%A7%86%E9%9F%B3%E9%A2%91/"/>
    
    
      <category term="色彩空间" scheme="http://www.faihung.net/tags/%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>视音频-电视制式的基本概念</title>
    <link href="http://www.faihung.net/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E7%94%B5%E8%A7%86%E5%88%B6%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://www.faihung.net/2019/11/17/视音频-电视制式的基本概念/</id>
    <published>2019-11-17T04:41:28.000Z</published>
    <updated>2019-11-17T04:46:14.091Z</updated>
    
    <content type="html"><![CDATA[<h5 id="标清电视制式-Standard-Definition-SD"><a href="#标清电视制式-Standard-Definition-SD" class="headerlink" title="标清电视制式(Standard Definition-SD)"></a>标清电视制式(Standard Definition-SD)</h5><h6 id="NTSC"><a href="#NTSC" class="headerlink" title="NTSC"></a>NTSC</h6><p>标准编号: SMPTE 125M/267M</p><p>分辨率: 720 x486 (DVMPEG2等编解码系统使用480以适应8x8的block)长宽比: 4:3 (非方形像素,像素宽小于高)</p><p>扫描方式:隔行扫描、下方一场首先显示</p><p>帧率: 29.97帧/秒</p><a id="more"></a><h6 id="PAL"><a href="#PAL" class="headerlink" title="PAL"></a>PAL</h6><p>标准编号: ITU.BT656/601.5</p><p>分辨率: 720 x 576</p><p>长宽比: 4:3 (非方形像素,像素宽大于高)</p><p>扫描方式:隔行扫描、上方一场首先显示</p><p>帧率: 25帧/秒</p><h5 id="高清电视制式-High-Definition-SD"><a href="#高清电视制式-High-Definition-SD" class="headerlink" title="高清电视制式(High Definition-SD)"></a>高清电视制式(High Definition-SD)</h5><h6 id="720p"><a href="#720p" class="headerlink" title="720p"></a>720p</h6><p>标准编号: SMPTE 296M-2001</p><p>辨率: 1280 x 720</p><p>长宽比: 16:9 (方形像素)</p><p>扫描方式:逐行扫描</p><p>帧率: 50帧/秒、59.94帧/秒、60帧/秒</p><h6 id="1080i"><a href="#1080i" class="headerlink" title="1080i"></a>1080i</h6><p>标准编号: SMPTE 274M</p><p>辨率： 1920 x 1080</p><p>长宽比: 16:9 (方形像素)</p><p>扫描方式:隔行扫描、上方一场首先显示</p><p>帧率: 25帧/秒、29.97帧/秒、30帧/秒</p><h6 id="1080p"><a href="#1080p" class="headerlink" title="1080p"></a>1080p</h6><p>标准编号: SMPTE 274M</p><p>分辨率: 1920 x 1080</p><p>长宽比: 16:9 (方形像素)</p><p>扫描方式:逐行扫描</p><p>帧率: <del>23.98帧/秒、24帧/秒、25帧/秒、29.97帧/秒、30帧/秒</del> 59.94帧/秒 60帧/秒</p><h5 id="标准机构"><a href="#标准机构" class="headerlink" title="标准机构"></a>标准机构</h5><h6 id="SMIPTE"><a href="#SMIPTE" class="headerlink" title="SMIPTE"></a>SMIPTE</h6><p>美国电影和电视工程师协会The Society of Motion Picture and Television Engineers,成立于1916年,现在有来自世界85个国家超过7500名的会员,制定电影电视行业的技术标准。</p><h6 id="ITU"><a href="#ITU" class="headerlink" title="ITU"></a>ITU</h6><p>国际电信联盟(International Telecommunication Union), ITU的历史可以追溯到1865年成立的国际电报联盟(International Telegraph Union , ITU),经联合国同意,1947年10月15日国际电信联盟成为联合国的一个专门机构,其总部由瑞士伯尔尼迁至到日内瓦。</p><h5 id="关于PAL和NTSC"><a href="#关于PAL和NTSC" class="headerlink" title="关于PAL和NTSC"></a>关于PAL和NTSC</h5><p>NTSC是National Television System Commite的缩写, (美国)国家电视标准委员会。其标准主要应用于日本、美国,加拿大、墨西哥等等, </p><p>PAL是Phase Alternating Line (逐行倒相)的缩写。它是西德在1962年指定的彩色电视广播标准,它采用逐行倒相正交平衡调幅的技术方法,克服了NTSC制相位敏感造成色彩失真的缺点。西德、英国等一些西欧国家,新加坡、中国大陆及香港,澳大利亚、新西兰等国家采用这种制式。</p><p>PAL由德国人Walter Bruch在1967年提出,当时他是为德律风根(Telefunken)工作。”PAL”有时亦被用来指625线,每秒25格,隔行扫描,PAL色彩编码的电视制式。</p><p>PAL制式中根据不同的参数细节又可以进一步划分为G、1、D等制式,其中PAL-D制是我国大陆采用的制式。这两种制式是不能互相兼容的,如果在PAL制式的电视上播放NTSC的影像,画面将变成黑白, NTSC制式的也是一样。</p><h5 id="分辨率-Resolution-、画面宽高比-Aspect-Ratio-和像素宽高比-Pixel-Aspect-Ratio"><a href="#分辨率-Resolution-、画面宽高比-Aspect-Ratio-和像素宽高比-Pixel-Aspect-Ratio" class="headerlink" title="分辨率(Resolution)、画面宽高比(Aspect Ratio)和像素宽高比(Pixel Aspect Ratio)"></a>分辨率(Resolution)、画面宽高比(Aspect Ratio)和像素宽高比(Pixel Aspect Ratio)</h5><p>分辨率就是构成画面的像素的个数,对于程序员来说,最重要的是1/0设备中的FrameBuffer的分辨率。对于电视信号来说,指信号中含有的可见画面的分辨率。</p><p>宽高比是指画面物理显示尺寸的宽度比其高度:</p><p>SDTV (1.33: 1)  </p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E7%94%B5%E8%A7%86%E5%88%B6%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/1.jpg" alt="1"></p><p>宽屏SDTV, HDTV (1.78:1)</p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E7%94%B5%E8%A7%86%E5%88%B6%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2.jpg" alt="2"></p><p>35毫米胶片(1.5:1) </p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E7%94%B5%E8%A7%86%E5%88%B6%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/3.jpg" alt="3"></p><p>美国电影(或欧洲1.66:1) </p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E7%94%B5%E8%A7%86%E5%88%B6%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/4.jpg" alt="4"></p><p>全景宽银幕电影(或70mm胶片2.20:1)</p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E7%94%B5%E8%A7%86%E5%88%B6%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/5.jpg" alt="5"></p><p>由画面的分辨率和宽高比可以计算出<strong>像素宽高比(Pixel Aspect Ratio)</strong>:</p><pre><code>(ResX * PixW) / (ResY * PixH) =AR即PixAR = PixW/ PixH=AR * ResY / Resx</code></pre><p>PAL制和NTSC制的电视在显示时,每个像素覆盖的面积不是正方形的</p><p>PAL制,</p><pre><code>PixAR= (4/3) * (576/720) = 1.07;</code></pre><p>NTSC制, </p><pre><code>PixAR= (4/3) * (486/720) =0.9</code></pre><p>而HDTV标准都是像素横纵方向的数量比值等同于画面宽高比,像素宽高比都是1:1,就是方形像素。</p><p>我们产生计算机图形时,很多都是按照方形像素的假设来做的,但如果像素宽高比不是1:1,那么这样产生的图形显示时就会变形了,所以很多图形软件都考虑了各种像素宽高比的影响,输出时进行校正保证画面在那种像素宽高比的显示设备上输出时不变形。下图示意,一个半径为某一固定像素值的圆形在计算机屏幕(通常方形像素)和PAL及NTSC显示器上显示的结果。</p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E7%94%B5%E8%A7%86%E5%88%B6%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/6.jpg" alt="6"></p><p>某种画面宽高比的画面在不同宽高比的显示设备上保持其比例进行显示时需要进行一些转换,下面是一些常用方法。</p><p>LetterBox (信箱)-较宽画面显示在较窄监视器上,上下留空。</p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E7%94%B5%E8%A7%86%E5%88%B6%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/7.jpg" alt="7">2.35:1画面显示在4:3电视上。</p><p>PilarBox (邮简)-较窄画面显示在较宽监视器上,两侧留空。</p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E7%94%B5%E8%A7%86%E5%88%B6%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/8.jpg" alt="8">4:3画面显示在16:9电视上。</p><p>WindowBox (窗口)-画面经过LetterBox和PillarBox两道处理显示出来,四边留空。比如用HD拍的广告在SD广播中做了LetterBox,但观众用HD电视收看这个SD画面,又做了PillarBox。</p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E7%94%B5%E8%A7%86%E5%88%B6%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/9.jpg" alt="9"></p><p>Pan and Scan (摇动和扫描)-把电影转成电视画面常用的技术之一。编辑人员使用扫描器以4:3或者16:9点取景框在较宽的电影画面中选取一部分画面,通常集中在主要的人物活动上,制作成宽高比较窄的画面。</p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E7%94%B5%E8%A7%86%E5%88%B6%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/10.jpg" alt="10"></p><h5 id="扫描方式-Scan-Mode"><a href="#扫描方式-Scan-Mode" class="headerlink" title="扫描方式(Scan Mode)"></a>扫描方式(Scan Mode)</h5><p>通常显示器分隔行扫描(Interlace)和逐行扫描(Progressive)两种扫描方式。隔行扫描指显示屏在显示幅图像时,先扫描奇数行,全部完成奇数行扫描后再扫描偶数行,因此每幅图像需扫描两次才能完成,造成图像显示画面闪烁较大。因此该种扫描方式较为落后,通常用在早期的显示产品中。</p><p>隔行扫描就是每一帧(frame)被分割为两场(field) ,每一场包含了一帧中所有的奇数扫描行或者偶数扫描行,通常是先扫描奇数行得到第一场,然后扫描偶数行得到第一场。由于视觉暂留效应,人眼将会看到平滑的运动而不是闪动的半帧半帧的图像。但是这时会有几乎不会被注意到的闪烁出现,使得人眼容易疲劳。当屏幕的内容是横条纹时,这种闪烁特别容易被注意到。</p><p>每一帧图像由电子束顺序地一行接着一行连续扫描而成,这种扫描方式称为逐行扫描。把每一帧图像通过两场扫描完成则1隔行扫描,两场扫描中,第一场(奇数场)只扫描奇数行,依次扫描1、3、5..行,而第二场(偶数场)只扫描偶数行,依次扫描2、4、6..行。隔行扫描技术在传送信号带宽不够的情况下起了很大作用,逐行扫描和隔行扫描的显示效果主要区别在稳定性上面,隔行扫描的行间闪烁比较明显,逐行扫描克服了隔行扫描的缺点,画面平滑自然无闪烁。在电视的标准显示模式中, i表示隔行扫描, p表示逐行扫描。</p><p>场的命名,以时间顺序(temporal order)成为第一场和第二场(First Field and Second Field),以空间顺序(spatial order)分为上面一场和下面一场(Top Field and Bottom rield, Upper Field and Lower Field),还有一个含义不清的说法-奇数场和偶数场(Odd Field and Even Field) 。注意NTSC制中,是lower-field-first的扫描方式,其它均为upper-field-firsto。</p><p>回扫(Retracing)指CRT显示电视画面时,其电子枪的扫描束在结束一行或一帧/场画面扫描时移动到下一行(行逆程)或下一帧/场的第一行开始(场逆程)时需要进行的扫描移动,这个期间,电子束实际是被关闭的,所以也叫空白区间(Blanking Interval)。从一行的结尾到下一行开始的回扫叫水平回扫,约占每行的15%时间,从一帧/场到下一帧/场的回扫称为垂直回扫(VBI),约占一帧/场的8%时间。PAL的总扫描线数是625行, NTSC是525行, 1080i和1080p都是1125行, 720p是750行。在模拟电视信号中,行场的同步信息是加在回扫区间的信号中的,还可以夹带VITC (Vertical Interval Time Code), VIrS (VerticalInterval Test Signal)和闭路字幕(Closed Caption)。</p><p>隔行扫描产生的抖动,对于图文字幕尤其明显,需要专门的防抖动技术予以消除,通常采用三行平均的算法。另外,在图文字幕的动画关键帧插值中,由于一帧中两场的显示时间有前后,所以参数插值必须按照场时间进行。</p><p>另外,还有一种Progressive Segmented Frame (PSF)扫描方式,还是将一帧分为上下隔行的两场记录和发送,但播放时是按照一帧逐行在同一时刻显示。发明者们说是要以传统隔行设备记录和传送逐行画面。</p><h5 id="帧率-Frame-Rate"><a href="#帧率-Frame-Rate" class="headerlink" title="帧率(Frame Rate)"></a>帧率(Frame Rate)</h5><p>为什么NTSC制是29.97? 3000/1001 NTSC制早期发展时需要兼容当时的黑白电视,包括水平扫描、颜色和声音的传送,这些限制最后使用减小场扫描频率(60Hz)来解决,最后减小了1000/10010。</p><h6 id="时码"><a href="#时码" class="headerlink" title="时码"></a>时码</h6><p>LTC (longitudinallinear timecode)线性时码-时码记录在磁带的专门轨道中,与音频轨道类似,信号输入也使用XLR接口。</p><p>VITC (vertical interval timecode)时码-在场逆程中含有时码信息。克服了LTC的缺点-在磁带停止或者慢速播放时不能读取。</p><p>DFTC (Drop frame timecode)-在NTSC制中,如果时码按照每帧累加,并按照30帧/秒的速率来显示的话,显示的时间就比实际慢,每秒差1000/1001,每小时累计达到3.6秒。所以DFTC就是大约数每100帧扔掉一个时码计数,让计算的时码与实际时间相符。实际计算时以每10分钟为一周期,在其中的1:06:202:13:10. 3:20:00, 4:26:20, 5:33:10、 6:40:00, 7:46:20, 8:53:10时丢掉一帧的计数。</p><h6 id="电影到电视影像的转换-Telecine-中的帧率转换"><a href="#电影到电视影像的转换-Telecine-中的帧率转换" class="headerlink" title="电影到电视影像的转换(Telecine)中的帧率转换"></a>电影到电视影像的转换(Telecine)中的帧率转换</h6><p>电影(24帧/秒)和PAL (25帧/秒-包括HD)每秒只差1帧,所以以前一般来说就直接一帧对一帧进行制作,这样PAL每秒会比电影多放一帧,也就是速度提高了124,而且声音的音调会升高。这就是一些DVD爱好者不喜欢PAL制DVD的原因之一。但是据说现在有些PAL制DVD采取了24+1的制作方法,就是把24帧中的一帧重复一次,从而获得跟电影一样的播放速度。</p><p>而NTSC (29.97帧/秒-包括HD)因为每秒约有30帧,不能直接一帧对一帧制作,所以要通过2-3PULLDOWN等办法把24个电影帧转成30个视频帧,这30个视频帧里所包含的内容和24个电影帧是相等的,所以NTSC的播放速度和电影一样。</p><p>2-3 PULLDOWN的具体解释:电影胶片以4帧为一个循环, A帧转换为视频第1帧的两场, B帧转换为视频第2帧的两场和第3帧的第一场, C帧转换为视频第3帧的第二场和第4帧的第一场, D帧转换为视频第4帧的第二场和第5帧的两场,这样以2:3:2:3的循序,通过把B和D帧重复采样一场,将4个电影帧转换为5个视频帧,视频以30帧/秒播放画面动感速度和24帧/秒播放的电影一样;实际上上由于是29.97帧秒(3000/1001),动感速度还是较电影慢了1/1000,以电影帧计算是23.98帧/秒(24/1001 )。</p><p><img src="/2019/11/17/%E8%A7%86%E9%9F%B3%E9%A2%91-%E7%94%B5%E8%A7%86%E5%88%B6%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/11.jpg" alt="11"></p><p>如果把上述循环从电影B帧开始看,模式变成了3:2:3:2,所以也叫3-2 PULLDOWN,但SMPTE标准(RP197)规定的是2:3模式。另外还有3:3:2:2, 2:3:32, 2:2:3:3等模式,但产生的颤抖略大。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;标清电视制式-Standard-Definition-SD&quot;&gt;&lt;a href=&quot;#标清电视制式-Standard-Definition-SD&quot; class=&quot;headerlink&quot; title=&quot;标清电视制式(Standard Definition-SD)&quot;&gt;&lt;/a&gt;标清电视制式(Standard Definition-SD)&lt;/h5&gt;&lt;h6 id=&quot;NTSC&quot;&gt;&lt;a href=&quot;#NTSC&quot; class=&quot;headerlink&quot; title=&quot;NTSC&quot;&gt;&lt;/a&gt;NTSC&lt;/h6&gt;&lt;p&gt;标准编号: SMPTE 125M/267M&lt;/p&gt;
&lt;p&gt;分辨率: 720 x486 (DVMPEG2等编解码系统使用480以适应8x8的block)长宽比: 4:3 (非方形像素,像素宽小于高)&lt;/p&gt;
&lt;p&gt;扫描方式:隔行扫描、下方一场首先显示&lt;/p&gt;
&lt;p&gt;帧率: 29.97帧/秒&lt;/p&gt;
    
    </summary>
    
    
      <category term="视音频" scheme="http://www.faihung.net/categories/%E8%A7%86%E9%9F%B3%E9%A2%91/"/>
    
    
      <category term="标清高清" scheme="http://www.faihung.net/tags/%E6%A0%87%E6%B8%85%E9%AB%98%E6%B8%85/"/>
    
      <category term="NTSC" scheme="http://www.faihung.net/tags/NTSC/"/>
    
      <category term="PAL" scheme="http://www.faihung.net/tags/PAL/"/>
    
      <category term="帧率" scheme="http://www.faihung.net/tags/%E5%B8%A7%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>C语言-数组强制转换成结构体类型存储(2)</title>
    <link href="http://www.faihung.net/2019/11/16/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8-2/"/>
    <id>http://www.faihung.net/2019/11/16/C语言-数组强制转换成结构体类型存储-2/</id>
    <published>2019-11-16T07:56:50.000Z</published>
    <updated>2019-11-16T07:59:53.317Z</updated>
    
    <content type="html"><![CDATA[<p>废话不多说，直接上代码</p><a id="more"></a><h5 id="1-没有-pragma-pack-1"><a href="#1-没有-pragma-pack-1" class="headerlink" title="1. 没有#pragma   pack(1)"></a>1. 没有#pragma   pack(1)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;      /*标准输入输出定义*/</span><br><span class="line">#include &lt;stdlib.h&gt;     /*标准函数库定义*/</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;      /*文件控制定义*/</span><br><span class="line">#include &lt;termios.h&gt;    /*PPSIX 终端控制定义*/</span><br><span class="line">#include &lt;unistd.h&gt;     /*Unix 标准函数定义*/</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line"></span><br><span class="line">#define UI_PARAM_FILE &quot;/mnt/hgfs/VMWARE/test/config/2.txt&quot;</span><br><span class="line"></span><br><span class="line">unsigned char appWritePara(unsigned char* Para, unsigned int paraSize, char *fileName)</span><br><span class="line">&#123;</span><br><span class="line">int fd = 0;</span><br><span class="line"></span><br><span class="line">fd = open(fileName,O_RDWR, 0644); //O_SYNC O_DIRECT</span><br><span class="line">if (-1 == fd)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;open file:%s\n&quot;, fileName);</span><br><span class="line">close(fd);</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;Open %s success\n&quot;, fileName);</span><br><span class="line">write(fd,Para,paraSize);</span><br><span class="line">printf(&quot;-----------write----------\n&quot;);</span><br><span class="line">close(fd);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char ch[12] = &#123;&#125;;</span><br><span class="line">typedef struct arr_s</span><br><span class="line">&#123;</span><br><span class="line">char i;</span><br><span class="line">short j;</span><br><span class="line">char l;</span><br><span class="line"></span><br><span class="line">&#125;arr_t;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">char * filename = UI_PARAM_FILE;</span><br><span class="line">arr_t* p = (arr_t*)ch;</span><br><span class="line">p-&gt;i = 0x30;</span><br><span class="line">p-&gt;j = 0x3132;</span><br><span class="line">p-&gt;l = 0x33;</span><br><span class="line">printf(&quot;%X, %X, %X\n&quot;,p-&gt;i,p-&gt;j,p-&gt;l);</span><br><span class="line"></span><br><span class="line">appWritePara(ch,sizeof(ch),filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果演示：</p><p><img src="/2019/11/16/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8-2/1.jpg" alt="1"></p><p><img src="/2019/11/16/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8-2/2.jpg" alt="2"></p><p>可以看到文本文件中保持12个字节大小的数据。其中i类型之后是填空补充的。<br>这说明数据是4个字节数据，结构体是6个字节数据。</p><h5 id="2-有-pragma-pack-1"><a href="#2-有-pragma-pack-1" class="headerlink" title="2. 有#pragma   pack(1)"></a>2. 有#pragma   pack(1)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;      /*标准输入输出定义*/</span><br><span class="line">#include &lt;stdlib.h&gt;     /*标准函数库定义*/</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;      /*文件控制定义*/</span><br><span class="line">#include &lt;termios.h&gt;    /*PPSIX 终端控制定义*/</span><br><span class="line">#include &lt;unistd.h&gt;     /*Unix 标准函数定义*/</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line"></span><br><span class="line">#define UI_PARAM_FILE &quot;/mnt/hgfs/VMWARE/test/config/2.txt&quot;</span><br><span class="line"></span><br><span class="line">unsigned char appWritePara(unsigned char* Para, unsigned int paraSize, char *fileName)</span><br><span class="line">&#123;</span><br><span class="line">int fd = 0;</span><br><span class="line"></span><br><span class="line">fd = open(fileName,O_RDWR, 0644); //O_SYNC O_DIRECT</span><br><span class="line">if (-1 == fd)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;open file:%s\n&quot;, fileName);</span><br><span class="line">close(fd);</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;Open %s success\n&quot;, fileName);</span><br><span class="line">write(fd,Para,paraSize);</span><br><span class="line">printf(&quot;-----------write----------\n&quot;);</span><br><span class="line">close(fd);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char ch[12] = &#123;&#125;;</span><br><span class="line">#pragma   pack(1) //强制连续存放,对齐边界为 1</span><br><span class="line">typedef struct arr_s</span><br><span class="line">&#123;</span><br><span class="line">char i;</span><br><span class="line">short j;</span><br><span class="line">char l;</span><br><span class="line"></span><br><span class="line">&#125;arr_t;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">char * filename = UI_PARAM_FILE;</span><br><span class="line">arr_t* p = (arr_t*)ch;</span><br><span class="line">p-&gt;i = 0x30;</span><br><span class="line">p-&gt;j = 0x3132;</span><br><span class="line">p-&gt;l = 0x33;</span><br><span class="line">printf(&quot;%X, %X, %X\n&quot;,p-&gt;i,p-&gt;j,p-&gt;l);</span><br><span class="line"></span><br><span class="line">appWritePara(ch,sizeof(ch),filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果演示:</p><p><img src="/2019/11/16/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8-2/3.jpg" alt="3"></p><p><img src="/2019/11/16/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8-2/4.jpg" alt="4"></p><p>这说明数据是4个字节数据，结构体是4个字节数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;废话不多说，直接上代码&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://www.faihung.net/categories/C/"/>
    
    
      <category term="字节对齐" scheme="http://www.faihung.net/tags/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/"/>
    
      <category term="大小端" scheme="http://www.faihung.net/tags/%E5%A4%A7%E5%B0%8F%E7%AB%AF/"/>
    
      <category term="pragma pack()" scheme="http://www.faihung.net/tags/pragma-pack/"/>
    
      <category term="数组" scheme="http://www.faihung.net/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="结构体" scheme="http://www.faihung.net/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
      <category term="强制转换" scheme="http://www.faihung.net/tags/%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
      <category term="配置文件" scheme="http://www.faihung.net/tags/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
      <category term="文本保存" scheme="http://www.faihung.net/tags/%E6%96%87%E6%9C%AC%E4%BF%9D%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>C语言-数组强制转换成结构体类型存储(1)</title>
    <link href="http://www.faihung.net/2019/11/16/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8-1/"/>
    <id>http://www.faihung.net/2019/11/16/C语言-数组强制转换成结构体类型存储-1/</id>
    <published>2019-11-16T07:37:48.000Z</published>
    <updated>2019-11-23T07:04:13.809Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-数组强制转换成结构类型-数组类型和结构体成员类型一致"><a href="#1-数组强制转换成结构类型-数组类型和结构体成员类型一致" class="headerlink" title="1. 数组强制转换成结构类型,数组类型和结构体成员类型一致"></a>1. 数组强制转换成结构类型,数组类型和结构体成员类型一致</h5><a id="more"></a><p>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;      /*标准输入输出定义*/</span><br><span class="line">#include &lt;stdlib.h&gt;     /*标准函数库定义*/</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;      /*文件控制定义*/</span><br><span class="line">#include &lt;termios.h&gt;    /*PPSIX 终端控制定义*/</span><br><span class="line">#include &lt;unistd.h&gt;     /*Unix 标准函数定义*/</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">/*</span><br><span class="line">字节对齐问题，一个数组强制转换成结构体类型</span><br><span class="line">*/</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">int ch[] = &#123;0x12, 0x34, 0x56, 0x78&#125;;</span><br><span class="line">typedef struct arr_s</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">int j;</span><br><span class="line">&#125;arr_t;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">arr_t* p = (arr_t*)ch;</span><br><span class="line">printf(&quot;数组强制转换成结构类型,数组类型和结构体成员类型一致:0x%X, 0x%X\n&quot;,p-&gt;i,p-&gt;j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组是int类型，结构体成员也是int类型。</p><p>演示效果：</p><p><img src="/2019/11/16/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8-1/1.jpg" alt="1"></p><h5 id="2-数组强制转换成结构类型-数组类型和结构体成员类型不一致"><a href="#2-数组强制转换成结构类型-数组类型和结构体成员类型不一致" class="headerlink" title="2.  数组强制转换成结构类型,数组类型和结构体成员类型不一致"></a>2.  数组强制转换成结构类型,数组类型和结构体成员类型不一致</h5><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;      /*标准输入输出定义*/</span><br><span class="line">#include &lt;stdlib.h&gt;     /*标准函数库定义*/</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;      /*文件控制定义*/</span><br><span class="line">#include &lt;termios.h&gt;    /*PPSIX 终端控制定义*/</span><br><span class="line">#include &lt;unistd.h&gt;     /*Unix 标准函数定义*/</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line"></span><br><span class="line">char ch[] = &#123;0x12, 0x34, 0x56, 0x78&#125;;</span><br><span class="line">typedef struct arr_s</span><br><span class="line">&#123;</span><br><span class="line">char i;</span><br><span class="line">short j;</span><br><span class="line">char l;</span><br><span class="line"></span><br><span class="line">&#125;arr_t;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">arr_t* p = (arr_t*)ch;</span><br><span class="line">printf(&quot;数组大小:%d\n&quot;,sizeof(ch));</span><br><span class="line">printf(&quot;结构体成员大小:%d\n&quot;,sizeof(arr_t));</span><br><span class="line">printf(&quot;数组强制转换成结构类型,数组类型和结构体成员类型不一致:%X, %X, %X\n&quot;,p-&gt;i,p-&gt;j,p-&gt;l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果演示：</p><p><img src="/2019/11/16/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8-1/2.jpg" alt="2"></p><p>数组为char型，结构体成员为依次char型，short型，char型。其中数组有四个字节，结构体成员因为对齐的原因有6个字节。</p><p>可以看到，i的类型因为j的类型的原因，补充了一个字节，所以当数组强制转换成结构体类型之后，0x34会漏掉。 0x56 0x78 因为小端的原因，排序成0x7856</p><p>但是如果稍微将j和l位置替换一下，结果又不一样，请看示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;      /*标准输入输出定义*/</span><br><span class="line">#include &lt;stdlib.h&gt;     /*标准函数库定义*/</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;      /*文件控制定义*/</span><br><span class="line">#include &lt;termios.h&gt;    /*PPSIX 终端控制定义*/</span><br><span class="line">#include &lt;unistd.h&gt;     /*Unix 标准函数定义*/</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line"></span><br><span class="line">char ch[] = &#123;0x12, 0x34, 0x56, 0x78&#125;;</span><br><span class="line">typedef struct arr_s</span><br><span class="line">&#123;</span><br><span class="line">char i;</span><br><span class="line">char l;</span><br><span class="line">short j;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;arr_t;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">arr_t* p = (arr_t*)ch;</span><br><span class="line">printf(&quot;数组大小:%d\n&quot;,sizeof(ch));</span><br><span class="line">printf(&quot;结构体成员大小:%d\n&quot;,sizeof(arr_t));</span><br><span class="line">printf(&quot;数组强制转换成结构类型,数组类型和结构体成员类型不一致:%X, %X, %X\n&quot;,p-&gt;i,p-&gt;j,p-&gt;l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果演示：</p><p><img src="/2019/11/16/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8-1/3.jpg" alt="3"></p><p>看到没有，此时数组的大小和结构体大小一致。那么此时打印出来的数据也是一样的。</p><p>其实还可以这样，加一个</p><pre><code>#pragma   pack(1)</code></pre><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;      /*标准输入输出定义*/</span><br><span class="line">#include &lt;stdlib.h&gt;     /*标准函数库定义*/</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;      /*文件控制定义*/</span><br><span class="line">#include &lt;termios.h&gt;    /*PPSIX 终端控制定义*/</span><br><span class="line">#include &lt;unistd.h&gt;     /*Unix 标准函数定义*/</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line"></span><br><span class="line">char ch[] = &#123;0x12, 0x34, 0x56, 0x78&#125;;</span><br><span class="line">#pragma   pack(1) //强制连续存放,对齐边界为 1</span><br><span class="line">typedef struct arr_s</span><br><span class="line">&#123;</span><br><span class="line">char i;</span><br><span class="line">short j;</span><br><span class="line">char l;</span><br><span class="line">&#125;arr_t;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">arr_t* p = (arr_t*)ch;</span><br><span class="line">printf(&quot;数组大小:%d\n&quot;,sizeof(ch));</span><br><span class="line">printf(&quot;结构体成员大小:%d\n&quot;,sizeof(arr_t));</span><br><span class="line">printf(&quot;数组强制转换成结构类型,数组类型和结构体成员类型不一致:%X, %X, %X\n&quot;,p-&gt;i,p-&gt;j,p-&gt;l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果演示：</p><p><img src="/2019/11/16/C%E8%AF%AD%E8%A8%80-%E6%95%B0%E7%BB%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8-1/4.jpg" alt="4"></p><p>由此可以看到，其实结构体的存储和数组的存储其实本质上是一样的，不同的是数组只能有一种数据类型，结构体可以有多种数据类型，他们之间强制转换时，要考虑到字节对齐、大小端问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;1-数组强制转换成结构类型-数组类型和结构体成员类型一致&quot;&gt;&lt;a href=&quot;#1-数组强制转换成结构类型-数组类型和结构体成员类型一致&quot; class=&quot;headerlink&quot; title=&quot;1. 数组强制转换成结构类型,数组类型和结构体成员类型一致&quot;&gt;&lt;/a&gt;1. 数组强制转换成结构类型,数组类型和结构体成员类型一致&lt;/h5&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://www.faihung.net/categories/C/"/>
    
    
      <category term="字节对齐" scheme="http://www.faihung.net/tags/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/"/>
    
      <category term="大小端" scheme="http://www.faihung.net/tags/%E5%A4%A7%E5%B0%8F%E7%AB%AF/"/>
    
      <category term="pragma pack()" scheme="http://www.faihung.net/tags/pragma-pack/"/>
    
      <category term="数组" scheme="http://www.faihung.net/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="结构体" scheme="http://www.faihung.net/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
      <category term="强制转换" scheme="http://www.faihung.net/tags/%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
</feed>
