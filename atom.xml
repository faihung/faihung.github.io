<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Faihung&#39;s blog</title>
  
  <subtitle>作者：faihung</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.faihung.net/"/>
  <updated>2020-02-15T10:42:17.147Z</updated>
  <id>http://www.faihung.net/</id>
  
  <author>
    <name>faihung</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>makefile-1.1-Makefile基本概念</title>
    <link href="http://www.faihung.net/2020/02/15/makefile-1-1-Makefile%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://www.faihung.net/2020/02/15/makefile-1-1-Makefile基本概念/</id>
    <published>2020-02-15T10:38:28.000Z</published>
    <updated>2020-02-15T10:42:17.147Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一、一个示例"><a href="#一、一个示例" class="headerlink" title="一、一个示例"></a>一、一个示例</h5><p>先看一个代码演示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;hello world!\n&quot;);</span><br><span class="line">printf(&quot;hello maekfile\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>makefile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hello:helloworld.o</span><br><span class="line">gcc -o hello helloworld.o</span><br><span class="line">helloworld.o:helloworld.c</span><br><span class="line">gcc -o helloworld.o -c helloworld.c</span><br><span class="line">clean:</span><br><span class="line">rm hello helloworld.o</span><br></pre></td></tr></table></figure><p>执行: make</p><p><img src="/2020/02/15/makefile-1-1-Makefile%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/1.jpg" alt="1"></p><p>执行: ./hello</p><p><img src="/2020/02/15/makefile-1-1-Makefile%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2.jpg" alt="2"></p><h5 id="二、什么是Makefile"><a href="#二、什么是Makefile" class="headerlink" title="二、什么是Makefile?"></a>二、什么是Makefile?</h5><p>make命令执行时，需要一个makefile文件，以告诉make命令需要怎么样的去编译和链接程序。</p><p>makefile文件保存了编译器和连接器的参数选项,还表述了所有源文件之间的关系(源代码文件需要的特定的包含文件,可执行文件要求包含的目标文件模块及库等)。</p><p>创建程序(make程序)首先读取makefile文件,然后再激活编译器,汇编器,资源编译器和连接器以便产生最后的输出,最后输出并生成的通常是可执行文件。</p><p>创建程序利用内置的推理规则来激活编译器,以便通过对特定CPP文件的编译来产生特定的OBJ文件。</p><p><img src="/2020/02/15/makefile-1-1-Makefile%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/3.jpg" alt="3"></p><h5 id="三、Make是如何工作的？"><a href="#三、Make是如何工作的？" class="headerlink" title="三、Make是如何工作的？"></a>三、Make是如何工作的？</h5><p>在默认的方式下，也就是我们只输入make命令。那么，</p><p>1、make会在当前目录下找名字叫“Makefile”或“makefile”的文件。</p><p>2、如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“hello”这个文件，并把这个文件作为最终的目标文件。</p><p>3、如果hello文件不存在，或是hello所依赖的后面的 .o 文件的文件修改时间要比hello这个文件新，那么，他就会执行后面所定义的命令来生成hello这个文件。</p><p>4、如果hello所依赖的.o文件也不存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程）</p><p>5、当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件生成make的终极任务，也就是执行文件hello了。</p><p>这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。</p><h5 id="四、学习Makefile的必要性"><a href="#四、学习Makefile的必要性" class="headerlink" title="四、学习Makefile的必要性"></a>四、学习Makefile的必要性</h5><p>会不会写Makefile从侧面可以看出一个人是否具有完成大型项目工程的能力。</p><ul><li>Linux/Unix环境下开发必备技能</li><li>系统架构师、项目经理核心技能</li><li>研究开源项目、Linux内核的地图</li><li>加深对底层软件构造系统及过程的理解</li></ul><h5 id="五、如何学习Makefile？"><a href="#五、如何学习Makefile？" class="headerlink" title="五、如何学习Makefile？"></a>五、如何学习Makefile？</h5><h6 id="5-1-理论基础"><a href="#5-1-理论基础" class="headerlink" title="5.1 理论基础"></a>5.1 理论基础</h6><blockquote><p>面向依赖的思维</p></blockquote><ul><li><p><a href="https://pan.baidu.com/s/1qLoethrcmuhqnqNfu8P9lg" target="_blank" rel="noopener">程序员的自我修养(装载&amp;库)(高清带完整书签版)</a></p><blockquote><p>提取码：6ukr</p></blockquote></li><li><p><a href="https://pan.baidu.com/s/1VQ07fDdRuLOrT6rK2ZKmBQ" target="_blank" rel="noopener">GNU+makefile中文手册</a></p><blockquote><p>提取码：le6g </p></blockquote></li><li><p><a href="https://pan.baidu.com/s/1zJr2rC6UoFzDDdXnB9EwEg" target="_blank" rel="noopener">深入理解软件构造系统 原理与最佳实践</a></p><blockquote><p>提取码：pwpa</p></blockquote></li></ul><h6 id="5-2-学习环境"><a href="#5-2-学习环境" class="headerlink" title="5.2 学习环境"></a>5.2 学习环境</h6><ul><li>Linux、Unix环境</li><li>Windows下的cygwin等模拟环境</li></ul><h6 id="5-3-项目编程基础"><a href="#5-3-项目编程基础" class="headerlink" title="5.3 项目编程基础"></a>5.3 项目编程基础</h6><ul><li><p>C语言基础</p></li><li><p>C语言项目基础</p><ul><li><p>C语言实战之学生成绩管理系统</p></li><li><p>多文件源码管理、头文件包含、函数的声明与定义</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;一、一个示例&quot;&gt;&lt;a href=&quot;#一、一个示例&quot; class=&quot;headerlink&quot; title=&quot;一、一个示例&quot;&gt;&lt;/a&gt;一、一个示例&lt;/h5&gt;&lt;p&gt;先看一个代码演示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
    
      <category term="makefile" scheme="http://www.faihung.net/categories/makefile/"/>
    
    
      <category term="make" scheme="http://www.faihung.net/tags/make/"/>
    
      <category term="makefile" scheme="http://www.faihung.net/tags/makefile/"/>
    
      <category term="资料" scheme="http://www.faihung.net/tags/%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>shell-shell命令监测程序运行状态</title>
    <link href="http://www.faihung.net/2020/01/14/shell-shell%E5%91%BD%E4%BB%A4%E7%9B%91%E6%B5%8B%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81/"/>
    <id>http://www.faihung.net/2020/01/14/shell-shell命令监测程序运行状态/</id>
    <published>2020-01-14T01:30:53.000Z</published>
    <updated>2020-01-14T01:32:53.214Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在系统没有断电的前提下，监控脚本一直处于运行中</p></blockquote><p>1.将av_streamer -i input_stream.so -o output_app.so 后台重定向到无底洞中去或者是运行在后台中</p><a id="more"></a><p>2.检测程序运行的命令</p><pre><code>ps |grep -w av_streamer  |grep -v grep|wc -l</code></pre><p>监测到运行程序返回1</p><p>没有监测到则返回0​​​</p><p>3.根据检测到的状态决定是否启动程序<br>返回0启动程序 av_streamer -i input_stream.so -o output_app.so<br>返回1打印：程序正在运行。</p><p>具体表现在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">count=0</span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">ProcNumber=`ps |grep -w av_streamer  |grep -v grep|wc -l`</span><br><span class="line">if [ 1 -eq $ProcNumber ];then</span><br><span class="line">#echo &quot;task running...&quot; </span><br><span class="line">count=$((count + 1))</span><br><span class="line">echo &quot;task running is&quot; $count</span><br><span class="line">sleep 30s</span><br><span class="line">else                                                   </span><br><span class="line">echo &quot;task not run...&quot;   </span><br><span class="line">sleep 30s</span><br><span class="line">av_streamer -i input_stream.so -o output_app.so &amp;</span><br><span class="line">echo &quot;task start run...&quot;</span><br><span class="line">fi       </span><br><span class="line">done</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在系统没有断电的前提下，监控脚本一直处于运行中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.将av_streamer -i input_stream.so -o output_app.so 后台重定向到无底洞中去或者是运行在后台中&lt;/p&gt;
    
    </summary>
    
    
      <category term="shell" scheme="http://www.faihung.net/categories/shell/"/>
    
    
      <category term="shell" scheme="http://www.faihung.net/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Git-03_gitlab的应用场景</title>
    <link href="http://www.faihung.net/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://www.faihung.net/2020/01/12/Git-03-gitlab的应用场景/</id>
    <published>2020-01-12T04:50:39.000Z</published>
    <updated>2020-01-12T05:00:48.943Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前面简单介绍了Web端gitlab的配置与准备工作，这里主要介绍gitlab的一些应用场景。</p></blockquote><p>以Linux为例，Windows平台和linux一样。<br>前面(2.2.1点击按钮“New project”建立项目)在建立一个新的project的时候出现Command line instructions,下面几乎所有的操作都是围绕着这几条命令。</p><a id="more"></a><h5 id="Command-line-instructions"><a href="#Command-line-instructions" class="headerlink" title="Command line instructions"></a>Command line instructions</h5><h6 id="Git-global-setup"><a href="#Git-global-setup" class="headerlink" title="Git global setup"></a>Git global setup</h6><p>在第一次使用时需要对Git进行设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yhh&quot;</span><br><span class="line">git config --global user.email &quot;yihuihong@example.cn&quot;</span><br></pre></td></tr></table></figure><h6 id="Create-a-new-repository"><a href="#Create-a-new-repository" class="headerlink" title="Create a new repository"></a>Create a new repository</h6><p>从远程库中克隆一个空的project下来，然后创建新的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone git@example.wicp.vip:example_firmware/test.git</span><br><span class="line">cd test</span><br><span class="line">touch README.md</span><br><span class="line">git add README.md        //1.将代码从工作区中添加到版本库暂存区中去</span><br><span class="line">git commit -m &quot;add README&quot;  //2.把暂存区的所有修改提交到master分支上去</span><br><span class="line">git push -u origin master   //3.把分master支上代码push到远程仓库中去</span><br></pre></td></tr></table></figure><h6 id="Existing-folder"><a href="#Existing-folder" class="headerlink" title="Existing folder"></a>Existing folder</h6><p>我们一般用的是这个命令，将现有工程代码push到远程库中去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd existing_folder</span><br><span class="line">git init //创建版本库，后面会有详细介绍（只有第一次操作即可，后面不用操作）</span><br><span class="line"></span><br><span class="line">关联仓库（两种push代码方式）</span><br><span class="line">git remote add origin http://example.wicp.vip/example_firmware/test.git /*走http协议（只有第一次操作即可，后面不用操作）*/</span><br><span class="line">git remote add origin git@192.168.0.xx:example_firmware/plug-in_framework.git /*走SSH协议 （只有第一次操作即可，后面不用操作）*/</span><br><span class="line"></span><br><span class="line">git add .                      //1.将代码从工作区中添加到版本库暂存区中去</span><br><span class="line">git commit -m &quot;Initial commit&quot; //2.把暂存区的所有修改提交到master分支上去</span><br><span class="line">git push -u origin master      //3.把分master支上代码push到远程仓库中去</span><br></pre></td></tr></table></figure><h6 id="Existing-Git-repository"><a href="#Existing-Git-repository" class="headerlink" title="Existing Git repository"></a>Existing Git repository</h6><p>没做研究（略）</p><h5 id="1-创建版本库"><a href="#1-创建版本库" class="headerlink" title="1.    创建版本库"></a>1.    创建版本库</h5><p>在linux平台相应项目工作目录中执行：git init 之后对应的工作目录中就会生成一个.git文件。这个是用来跟踪库管理版本库的，以后千万不要把这个删除了，不然之前的所有git记录都会被破坏掉。<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/1.png" alt="1"><br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/2.png" alt="2"></p><h5 id="2-关联仓库"><a href="#2-关联仓库" class="headerlink" title="2.  关联仓库"></a>2.  关联仓库</h5><p>将本地仓库和远程仓库进行关联，之后才能把内容添加到远程仓库中去。</p><h6 id="SSH方式"><a href="#SSH方式" class="headerlink" title="SSH方式"></a>SSH方式</h6><pre><code>git remote add origin git@192.168.0.xx:example_firmware/plug-in_framework.git  </code></pre><h6 id="HTTP方式"><a href="#HTTP方式" class="headerlink" title="HTTP方式"></a>HTTP方式</h6><pre><code>git remote add origin http://example.wicp.vip/example_firmware/test.git</code></pre><h5 id="3-代码管理"><a href="#3-代码管理" class="headerlink" title="3.    代码管理"></a>3.    代码管理</h5><p>代码管理，常用的几个命令，其实就是三板斧。</p><h6 id="3-1查看代码状态"><a href="#3-1查看代码状态" class="headerlink" title="3.1查看代码状态"></a>3.1查看代码状态</h6><p>执行命令：</p><pre><code>git status</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/3.png" alt="3"></p><h6 id="3-2-添加代码到版本库"><a href="#3-2-添加代码到版本库" class="headerlink" title="3.2    添加代码到版本库"></a>3.2    添加代码到版本库</h6><p>执行命令：</p><pre><code>git add .</code></pre><h6 id="3-3-将代码添加分支"><a href="#3-3-将代码添加分支" class="headerlink" title="3.3    将代码添加分支"></a>3.3    将代码添加分支</h6><p>执行命令：</p><pre><code>git commit -m “初次提交”</code></pre><p>（太多了就不上图了）</p><h6 id="3-4-将分支代码提交到远程库"><a href="#3-4-将分支代码提交到远程库" class="headerlink" title="3.4    将分支代码提交到远程库"></a>3.4    将分支代码提交到远程库</h6><p>执行命令：</p><pre><code>git push -u origin master(第一次执行命令需要加上-u，后面就不需要)</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/4.png" alt="4"></p><h5 id="4-版本回退"><a href="#4-版本回退" class="headerlink" title="4.    版本回退"></a>4.    版本回退</h5><p>我们这工作中，经常想知道我们在版本库中提交了多少版本，执行命令：</p><pre><code>git log</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/5.png" alt="5"></p><p>或者命令：</p><pre><code>git log --pretty=onelin</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/6.png" alt="6"><br>其中commit 4b10e619d0b82c574a34b2266ca40ad13b7d5622，是每一个版本的id 通过SHA1计算出来的。</p><p>或者命令：</p><pre><code>git reflog</code></pre><h6 id="4-1-代码回退到上一个版本"><a href="#4-1-代码回退到上一个版本" class="headerlink" title="4.1 代码回退到上一个版本"></a>4.1 代码回退到上一个版本</h6><p>执行命令：</p><pre><code>git reset --hard HEAD^</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/7.png" alt="7"><br>其中HEAD是当前版本的指针，^ 表示上一个版本，^^表示上上一个版本。</p><h6 id="4-2-代码回退指定版本"><a href="#4-2-代码回退指定版本" class="headerlink" title="4.2 代码回退指定版本"></a>4.2 代码回退指定版本</h6><p>指令命令：</p><pre><code>git reset --hard 57d3f9aa669dc646697064a97810b842a50fe1bc</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/8.png" alt="8"></p><h6 id="4-3-代码回退最新版本"><a href="#4-3-代码回退最新版本" class="headerlink" title="4.3 代码回退最新版本"></a>4.3 代码回退最新版本</h6><p>第一步，执行命令：</p><pre><code>git reflog //找到所有版本的 commit id</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/9.png" alt="9"></p><p>第二步，执行命令：</p><pre><code>git reset --hard 4b10e61</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/10.png" alt="10"></p><h5 id="5-多个分支"><a href="#5-多个分支" class="headerlink" title="5.    多个分支"></a>5.    多个分支</h5><p>平时开发，我们一般是master分支留作发布版本，dev分支做测试开发。</p><h6 id="5-1-建立新分支"><a href="#5-1-建立新分支" class="headerlink" title="5.1 建立新分支"></a>5.1 建立新分支</h6><p>执行一个命令：</p><pre><code>git checkout -b dev</code></pre><p>这个命令可分解为两步：git branch dev和git checkout dev</p><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/11.png" alt="11"></p><blockquote><p>注意：切换dev分支时，需要将master分支中的代码 commit 到版本库中去，否则切换不成功，或者原有的代码将不保存。</p></blockquote><h6 id="5-2-查看分支"><a href="#5-2-查看分支" class="headerlink" title="5.2 查看分支"></a>5.2 查看分支</h6><p>执行命令：</p><pre><code>git branch</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/12.png" alt="12"><br>表示现在可以在dev分支上进行开发了，图中绿色字体。    </p><h6 id="5-3-合并分支"><a href="#5-3-合并分支" class="headerlink" title="5.3 合并分支"></a>5.3 合并分支</h6><p>在dev分支上修改代码并提交到版本库中去，然后进入master分支上去执行命令：</p><pre><code>git merge dev</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/13.png" alt="13"></p><h6 id="5-4-删除分支"><a href="#5-4-删除分支" class="headerlink" title="5.4 删除分支"></a>5.4 删除分支</h6><p>执行命令：</p><pre><code>git branch -d dev</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/14.png" alt="14"></p><h6 id="5-5-合并分支的冲突"><a href="#5-5-合并分支的冲突" class="headerlink" title="5.5 合并分支的冲突"></a>5.5 合并分支的冲突</h6><p>所谓的冲突，就是多个分支之间不同步，一般我们在修改master分支代码之前，先pull一下代码，不然就会出现下面这种冲突的情况，出现这种情况，我们就需要把git合并失败的文件手动编辑为我们希望的内容，再提交。</p><p>第一步：创建并修改一个分支，然后提交。如下：<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/15.png" alt="15"></p><p>第二步：切换到master分支，并修改master分支，之后合并dev1分支。<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/16.png" alt="16"><br>可以看到有合并冲突，同时查看readme.txt<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/17.png" alt="17"><br>这种情况就是冲突，必须需要手动解决冲突后再提交。删除readme.txt不需要的部分然后再commit上去即可。<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/18.png" alt="18"><br>执行命令：</p><pre><code>git log --graph --pretty=oneline --abbrev-commit</code></pre><p>可以查看分子合并的情况，如图。</p><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/19.png" alt="19"></p><h6 id="5-6-多人协作"><a href="#5-6-多人协作" class="headerlink" title="5.6 多人协作"></a>5.6 多人协作</h6><p>多人协作时，大家都会往master和dev分支上推送各自的修改。假设你是A，同时有一个人B在另一台电脑（注意要把SSH Key添加到GitLab）或者同一台电脑的另一个目录下克隆。</p><p>执行命令：</p><pre><code>git clone git@192.168.0.xx:xxx_firmware/test.git</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/20.png" alt="20"></p><p>默认情况下就是master分支，如下：git branch<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/21.png" alt="21"></p><p>此时B会在dev分支上开发并push代码<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/22.png" alt="22"></p><p>然后A也做了修改，同时将代码push到dev分支上去，如下<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/23.png" alt="23"></p><p>上面显示推送失败，因为B在最新的提交和A的提交有冲突，解决方法就是先将远程库的代码拉取下来，看下图。</p><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/24.png" alt="24"><br>注意：在拉取代码失败的时候，需要指定本地的dev分支和远程库的origin/dev分支的关联。同时查看本地readme.txt分支修改情况，可以发现<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/25.png" alt="25"></p><p>这个时候和5.6合并分支的冲突一样。解决之后再提交，最后在push。<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/26.png" alt="26"></p><h5 id="6-标签设定与版本号"><a href="#6-标签设定与版本号" class="headerlink" title="6.    标签设定与版本号"></a>6.    标签设定与版本号</h5><p>Gitlab没push一个版本代码都有一个commit id，我们根据这些commit id 可以给他们打上一个标签，这写标签可以是一个版本号。</p><h6 id="6-1-默认标签"><a href="#6-1-默认标签" class="headerlink" title="6.1 默认标签"></a>6.1 默认标签</h6><p>默认标签是打在最新提交的commit上的如下：<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/27.png" alt="27"></p><h6 id="6-2-指定commit-id-上打标签"><a href="#6-2-指定commit-id-上打标签" class="headerlink" title="6.2    指定commit id 上打标签"></a>6.2    指定commit id 上打标签</h6><p>第一步：</p><pre><code>git log --pretty=oneline --abbrev-commit</code></pre><p>找到所有master分支上提交版本commit id</p><p>第二步：</p><pre><code>git tag v0.9 8c1b181 </code></pre><p>指定commit 打标签</p><h6 id="6-3-查看具体标签具体信息"><a href="#6-3-查看具体标签具体信息" class="headerlink" title="6.3    查看具体标签具体信息"></a>6.3    查看具体标签具体信息</h6><p>执行命令：</p><pre><code>git show v0.9</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/28.png" alt="28"></p><h6 id="6-4-推送标签"><a href="#6-4-推送标签" class="headerlink" title="6.4    推送标签"></a>6.4    推送标签</h6><p>推送某一个标签：</p><pre><code>git push origin v1.0</code></pre><p>推送所有标签：</p><pre><code>git push origin –tags</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/29.png" alt="29"></p><p>此时观察Web端：<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/30.png" alt="30"><br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/31.png" alt="31"><br>这个就是标签。</p><h6 id="6-5-删除标签"><a href="#6-5-删除标签" class="headerlink" title="6.5    删除标签"></a>6.5    删除标签</h6><p>若标签只存在本地，直接执行命令：</p><pre><code>git tag -d v1.0</code></pre><p>若标签已经推送到远程，要删除远程标签需要<br>第一步，先删除本地标签：</p><pre><code>git tag -d v1.0</code></pre><p>第二步，再删除远程的标签：</p><pre><code>git push origin :refs/tags/v1.0</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前面简单介绍了Web端gitlab的配置与准备工作，这里主要介绍gitlab的一些应用场景。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以Linux为例，Windows平台和linux一样。&lt;br&gt;前面(2.2.1点击按钮“New project”建立项目)在建立一个新的project的时候出现Command line instructions,下面几乎所有的操作都是围绕着这几条命令。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://www.faihung.net/categories/Git/"/>
    
    
      <category term="gitlab" scheme="http://www.faihung.net/tags/gitlab/"/>
    
      <category term="github" scheme="http://www.faihung.net/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>C语言-shell命令方式&amp;函数方式执行汇总</title>
    <link href="http://www.faihung.net/2020/01/10/C%E8%AF%AD%E8%A8%80-shell%E5%91%BD%E4%BB%A4%E6%96%B9%E5%BC%8F-%E5%87%BD%E6%95%B0%E6%96%B9%E5%BC%8F%E6%89%A7%E8%A1%8C%E6%B1%87%E6%80%BB/"/>
    <id>http://www.faihung.net/2020/01/10/C语言-shell命令方式-函数方式执行汇总/</id>
    <published>2020-01-10T03:10:41.000Z</published>
    <updated>2020-01-10T03:30:52.874Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一、调用system执行shell命令"><a href="#一、调用system执行shell命令" class="headerlink" title="一、调用system执行shell命令"></a>一、调用system执行shell命令</h5><p><strong>编译验证过的源码码</strong>：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">#define FILE_PATH_HISI_TAR &quot;/mnt/hgfs/VMWARE/curl/app/temp/&quot;</span><br><span class="line">#define FILE_PATH_HISI_TAR_AFTER &quot;/mnt/hgfs/VMWARE/curl/app/temp/root/&quot;</span><br><span class="line">#define FILE_PATH_MD5 &quot;/mnt/hgfs/VMWARE/test/12-shell_cmd_func/&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int shell_system(char *pcmd)</span><br><span class="line">&#123;</span><br><span class="line">pid_t status;</span><br><span class="line"></span><br><span class="line">printf(&quot;execute cmd:%s\n&quot;,pcmd);</span><br><span class="line">status = system(pcmd);</span><br><span class="line">if (-1 == status)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;system error!&quot;);</span><br><span class="line">return -1;</span><br><span class="line">    &#125;</span><br><span class="line">if(WIFEXITED(status) != 0)//正常退出</span><br><span class="line">&#123;</span><br><span class="line">if(WEXITSTATUS(status) == 0)//操作正确</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;run command success\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;run error\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else//异常退出</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;exit error is %d\n&quot;, WEXITSTATUS(status));</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">char shell_cmd_ls[128];</span><br><span class="line">char shell_cmd_tar[128];</span><br><span class="line">char shell_cmd_md5[128];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sprintf(shell_cmd_ls,&quot;ls -al&quot;);</span><br><span class="line">if(0 != shell_system(shell_cmd_ls))</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;System call failed!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">/* </span><br><span class="line">//解压文件</span><br><span class="line">sprintf(shell_cmd_tar,&quot;tar zxvf %s%s -C %s&quot;,FILE_PATH_HISI_TAR,&quot;hisi_app.tar.gz&quot;,FILE_PATH_HISI_TAR_AFTER);</span><br><span class="line">if(0 != shell_system(shell_cmd_tar))</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;System call failed!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//拷贝文件</span><br><span class="line">//删除文件</span><br><span class="line">//统计文件</span><br><span class="line">//改变文件权限</span><br><span class="line">//计算md5值</span><br><span class="line">sprintf(shell_cmd_md5,&quot;md5sum %s%s&quot;,FILE_PATH_MD5,&quot;chmod.c&quot;);</span><br><span class="line">if(0 != shell_system(shell_cmd_md5))</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;System call failed!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="二、调用popen执行shell命令"><a href="#二、调用popen执行shell命令" class="headerlink" title="二、调用popen执行shell命令"></a>二、调用popen执行shell命令</h5><p><strong>编译验证过的源码码</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">#define FILE_PATH_HISI_TAR &quot;/mnt/hgfs/VMWARE/curl/app/temp/&quot;</span><br><span class="line">#define FILE_PATH_HISI_TAR_AFTER &quot;/mnt/hgfs/VMWARE/curl/app/temp/root/&quot;</span><br><span class="line">#define FILE_PATH_MD5 &quot;/mnt/hgfs/VMWARE/test/12-shell_cmd_func/&quot;</span><br><span class="line"></span><br><span class="line">int shell_popen(char *pbuf,char *pfile_path)</span><br><span class="line">&#123;</span><br><span class="line">char cmd_buf[64];</span><br><span class="line">FILE* fp = NULL;</span><br><span class="line">sprintf(cmd_buf,&quot;md5sum %s&quot;,pfile_path);</span><br><span class="line">fp = popen(cmd_buf, &quot;r&quot;);</span><br><span class="line">if(NULL == fp)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;popen&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">while(fgets(pbuf, 1024, fp) != NULL);</span><br><span class="line"></span><br><span class="line">pclose(fp);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void) </span><br><span class="line">&#123;</span><br><span class="line">char buf[128] = &#123;0&#125;;</span><br><span class="line">char file_path[128];</span><br><span class="line"></span><br><span class="line">//ls -al</span><br><span class="line">//拷贝文件</span><br><span class="line">//删除文件</span><br><span class="line">//统计文件</span><br><span class="line">//改变文件权限</span><br><span class="line">//解压文件</span><br><span class="line">//计算md5值</span><br><span class="line">sprintf(file_path,&quot;%s/%s&quot;,FILE_PATH_MD5,&quot;chmod.c&quot;);</span><br><span class="line">if(0 == shell_popen(buf,file_path))</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;MD5:%s\n&quot;, buf);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">printf(&quot;get MD5&apos;s value is failed!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">memset(buf, 0x0, sizeof(buf));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以前用shell命令通过管道或者系统方式执行一条命令，这样会在线程里面开启新的进程，从而会造成代码出现不可控的状态。<br>管道或者system会返回出各种状态值，这些状态值是不可控。</p><h5 id="三、函数方式删除文件"><a href="#三、函数方式删除文件" class="headerlink" title="三、函数方式删除文件"></a>三、函数方式删除文件</h5><p><strong>编译验证过的源码码</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#ifndef _DELETE_FILE</span><br><span class="line">#define _DELETE_FILE</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;limits.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line"></span><br><span class="line">//判断是否为目录</span><br><span class="line">bool is_dir(const char *path)</span><br><span class="line">&#123;</span><br><span class="line">    struct stat statbuf;</span><br><span class="line">    if(lstat(path, &amp;statbuf) ==0)//lstat返回文件的信息，文件信息存放在stat结构中</span><br><span class="line">    &#123;</span><br><span class="line">        return S_ISDIR(statbuf.st_mode) != 0;//S_ISDIR宏，判断文件类型是否为目录</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//判断是否为常规文件</span><br><span class="line">bool is_file(const char *path)</span><br><span class="line">&#123;</span><br><span class="line">    struct stat statbuf;</span><br><span class="line">    if(lstat(path, &amp;statbuf) ==0)</span><br><span class="line">        return S_ISREG(statbuf.st_mode) != 0;//判断文件是否为常规文件</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//判断是否是特殊目录</span><br><span class="line">bool is_special_dir(const char *path)</span><br><span class="line">&#123;</span><br><span class="line">    return strcmp(path, &quot;.&quot;) == 0 || strcmp(path, &quot;..&quot;) == 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//生成完整的文件路径</span><br><span class="line">void get_file_path(const char *path, const char *file_name,  char *file_path)</span><br><span class="line">&#123;</span><br><span class="line">    strcpy(file_path, path);</span><br><span class="line">    if(file_path[strlen(path) - 1] != &apos;/&apos;)</span><br><span class="line">        strcat(file_path, &quot;/&quot;);</span><br><span class="line">    strcat(file_path, file_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void delete_file(const char *path)</span><br><span class="line">&#123;</span><br><span class="line">    DIR *dir;</span><br><span class="line">    struct dirent *dir_info;</span><br><span class="line">    char file_path[PATH_MAX];</span><br><span class="line">    if(is_file(path))</span><br><span class="line">    &#123;</span><br><span class="line">        remove(path);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(is_dir(path))</span><br><span class="line">    &#123;</span><br><span class="line">        if((dir = opendir(path)) == NULL)</span><br><span class="line">            return;</span><br><span class="line">        while((dir_info = readdir(dir)) != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            get_file_path(path, dir_info-&gt;d_name, file_path);</span><br><span class="line">            if(is_special_dir(dir_info-&gt;d_name))</span><br><span class="line">                continue;</span><br><span class="line">            delete_file(file_path);</span><br><span class="line">            rmdir(file_path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;argv[1]=%s\n&quot;,argv[1]);</span><br><span class="line">    delete_file(argv[1]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h5 id="四、函数方式统计某个目录下的文件个数"><a href="#四、函数方式统计某个目录下的文件个数" class="headerlink" title="四、函数方式统计某个目录下的文件个数"></a>四、函数方式统计某个目录下的文件个数</h5><p><strong>编译验证过的源码码</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define MAX 1024</span><br><span class="line">/*</span><br><span class="line">返回值,返回该文件夹中的文件个数</span><br><span class="line">参数ppathfile,所求文件夹目录的路径</span><br><span class="line">*/</span><br><span class="line">int get_file_count(char *ppathfile)</span><br><span class="line">&#123;</span><br><span class="line">DIR *dir;</span><br><span class="line">struct dirent * ptr;</span><br><span class="line">int total = 0;</span><br><span class="line">char path[MAX];</span><br><span class="line">dir = opendir(ppathfile); /* 打开目录*/</span><br><span class="line">if(dir == NULL)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;fail to open dir&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line">errno = 0;</span><br><span class="line">while((ptr = readdir(dir)) != NULL)</span><br><span class="line">&#123;</span><br><span class="line">//顺序读取每一个目录项；</span><br><span class="line">//跳过“..”和“.”两个目录</span><br><span class="line">if(strcmp(ptr-&gt;d_name,&quot;.&quot;) == 0 || strcmp(ptr-&gt;d_name,&quot;..&quot;) == 0)</span><br><span class="line">&#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">//printf(&quot;%s%s\n&quot;,ppathfile,ptr-&gt;d_name);</span><br><span class="line">//如果是目录，则递归调用 get_file_count函数</span><br><span class="line">if(ptr-&gt;d_type == DT_DIR)</span><br><span class="line">&#123;</span><br><span class="line">sprintf(path,&quot;%s%s/&quot;,ppathfile,ptr-&gt;d_name);</span><br><span class="line">//printf(&quot;%s\n&quot;,path);</span><br><span class="line"></span><br><span class="line">total += get_file_count(path);</span><br><span class="line">&#125;</span><br><span class="line">if(ptr-&gt;d_type == DT_REG)</span><br><span class="line">&#123;</span><br><span class="line">total++;</span><br><span class="line">printf(&quot;%s%s\n&quot;,ppathfile,ptr-&gt;d_name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(errno != 0)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;fail to read dir&quot;); //失败则输出提示信息</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line">closedir(dir);</span><br><span class="line">return total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">int total;</span><br><span class="line">if(argc != 2)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;wrong usage\n&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line">total = get_file_count(argv[1]);</span><br><span class="line">printf(&quot;%s have %d files\n&quot;,argv[1],total);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="五、函数方式改变文件权限"><a href="#五、函数方式改变文件权限" class="headerlink" title="五、函数方式改变文件权限"></a>五、函数方式改变文件权限</h5><p><strong>编译验证过的源码码</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    chmod(&quot;/home/yhh/123&quot;, S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IWGRP|S_IXGRP|S_IROTH|S_IWOTH|S_IXOTH);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#if 0</span><br><span class="line">函数说明：</span><br><span class="line">chmod()会依参数mode 权限来更改参数path 指定文件的权限</span><br><span class="line"></span><br><span class="line">参数 mode 有下列数种组合：</span><br><span class="line">S_ISUID 04000 文件的 (set user-id on execution)位</span><br><span class="line">S_ISGID 02000 文件的 (set group-id on execution)位</span><br><span class="line">S_ISVTX 01000 文件的sticky 位</span><br><span class="line">S_IRUSR (S_IREAD) 00400 文件所有者具可读取权限</span><br><span class="line">S_IWUSR (S_IWRITE)00200 文件所有者具可写入权限</span><br><span class="line">S_IXUSR (S_IEXEC) 00100 文件所有者具可执行权限</span><br><span class="line">S_IRGRP 00040 用户组具可读取权限</span><br><span class="line">S_IWGRP 00020 用户组具可写入权限</span><br><span class="line">S_IXGRP 00010 用户组具可执行权限</span><br><span class="line">S_IROTH 00004 其他用户具可读取权限</span><br><span class="line">S_IWOTH 00002 其他用户具可写入权限</span><br><span class="line">S_IXOTH 00001 其他用户具可执行权限</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h5 id="六、函数方式计算文件的md5值"><a href="#六、函数方式计算文件的md5值" class="headerlink" title="六、函数方式计算文件的md5值"></a>六、函数方式计算文件的md5值</h5><p><strong>编译验证过的源码码</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned int count[2];  </span><br><span class="line">    unsigned int state[4];  </span><br><span class="line">    unsigned char buffer[64];     </span><br><span class="line">&#125;MD5_CTX;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define F(x,y,z) ((x &amp; y) | (~x &amp; z))  </span><br><span class="line">#define G(x,y,z) ((x &amp; z) | (y &amp; ~z))  </span><br><span class="line">#define H(x,y,z) (x^y^z)  </span><br><span class="line">#define I(x,y,z) (y ^ (x | ~z))  </span><br><span class="line">#define ROTATE_LEFT(x,n) ((x &lt;&lt; n) | (x &gt;&gt; (32-n)))  </span><br><span class="line">#define FF(a,b,c,d,x,s,ac) \</span><br><span class="line">&#123; \</span><br><span class="line">    a += F(b,c,d) + x + ac; \</span><br><span class="line">    a = ROTATE_LEFT(a,s); \</span><br><span class="line">    a += b; \</span><br><span class="line">&#125;  </span><br><span class="line">#define GG(a,b,c,d,x,s,ac) \</span><br><span class="line">&#123; \</span><br><span class="line">    a += G(b,c,d) + x + ac; \</span><br><span class="line">    a = ROTATE_LEFT(a,s); \</span><br><span class="line">    a += b; \</span><br><span class="line">&#125;  </span><br><span class="line">#define HH(a,b,c,d,x,s,ac) \</span><br><span class="line">&#123; \</span><br><span class="line">    a += H(b,c,d) + x + ac; \</span><br><span class="line">    a = ROTATE_LEFT(a,s); \</span><br><span class="line">    a += b; \</span><br><span class="line">&#125;  </span><br><span class="line">#define II(a,b,c,d,x,s,ac) \</span><br><span class="line">&#123; \</span><br><span class="line">    a += I(b,c,d) + x + ac; \</span><br><span class="line">    a = ROTATE_LEFT(a,s); \</span><br><span class="line">    a += b; \</span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line">unsigned char PADDING[]=&#123;</span><br><span class="line">0x80,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  </span><br><span class="line">0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  </span><br><span class="line">0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  </span><br><span class="line">0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">void MD5Encode(unsigned char *output,unsigned int *input,unsigned int len)  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned int i = 0,j = 0;  </span><br><span class="line">    while(j &lt; len)  </span><br><span class="line">    &#123;  </span><br><span class="line">        output[j] = input[i] &amp; 0xFF;    </span><br><span class="line">        output[j+1] = (input[i] &gt;&gt; 8) &amp; 0xFF;  </span><br><span class="line">        output[j+2] = (input[i] &gt;&gt; 16) &amp; 0xFF;  </span><br><span class="line">        output[j+3] = (input[i] &gt;&gt; 24) &amp; 0xFF;  </span><br><span class="line">        i++;  </span><br><span class="line">        j+=4;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">void MD5Decode(unsigned int *output,unsigned char *input,unsigned int len)  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned int i = 0,j = 0;  </span><br><span class="line">    while(j &lt; len)  </span><br><span class="line">    &#123;  </span><br><span class="line">        output[i] = (input[j]) |  </span><br><span class="line">            (input[j+1] &lt;&lt; 8) |  </span><br><span class="line">            (input[j+2] &lt;&lt; 16) |  </span><br><span class="line">            (input[j+3] &lt;&lt; 24);  </span><br><span class="line">        i++;  </span><br><span class="line">        j+=4;   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">void MD5Transform(unsigned int state[4],unsigned char block[64])  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned int a = state[0];  </span><br><span class="line">    unsigned int b = state[1];  </span><br><span class="line">    unsigned int c = state[2];  </span><br><span class="line">    unsigned int d = state[3];  </span><br><span class="line">    unsigned int x[64];  </span><br><span class="line">    MD5Decode(x,block,64);  </span><br><span class="line">    FF(a, b, c, d, x[ 0], 7, 0xd76aa478);   </span><br><span class="line">    FF(d, a, b, c, x[ 1], 12, 0xe8c7b756);   </span><br><span class="line">    FF(c, d, a, b, x[ 2], 17, 0x242070db);   </span><br><span class="line">    FF(b, c, d, a, x[ 3], 22, 0xc1bdceee);   </span><br><span class="line">    FF(a, b, c, d, x[ 4], 7, 0xf57c0faf);   </span><br><span class="line">    FF(d, a, b, c, x[ 5], 12, 0x4787c62a);   </span><br><span class="line">    FF(c, d, a, b, x[ 6], 17, 0xa8304613);   </span><br><span class="line">    FF(b, c, d, a, x[ 7], 22, 0xfd469501);   </span><br><span class="line">    FF(a, b, c, d, x[ 8], 7, 0x698098d8);   </span><br><span class="line">    FF(d, a, b, c, x[ 9], 12, 0x8b44f7af);   </span><br><span class="line">    FF(c, d, a, b, x[10], 17, 0xffff5bb1);   </span><br><span class="line">    FF(b, c, d, a, x[11], 22, 0x895cd7be);   </span><br><span class="line">    FF(a, b, c, d, x[12], 7, 0x6b901122);   </span><br><span class="line">    FF(d, a, b, c, x[13], 12, 0xfd987193);   </span><br><span class="line">    FF(c, d, a, b, x[14], 17, 0xa679438e);   </span><br><span class="line">    FF(b, c, d, a, x[15], 22, 0x49b40821);   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    GG(a, b, c, d, x[ 1], 5, 0xf61e2562);   </span><br><span class="line">    GG(d, a, b, c, x[ 6], 9, 0xc040b340);   </span><br><span class="line">    GG(c, d, a, b, x[11], 14, 0x265e5a51);   </span><br><span class="line">    GG(b, c, d, a, x[ 0], 20, 0xe9b6c7aa);   </span><br><span class="line">    GG(a, b, c, d, x[ 5], 5, 0xd62f105d);   </span><br><span class="line">    GG(d, a, b, c, x[10], 9,  0x2441453);   </span><br><span class="line">    GG(c, d, a, b, x[15], 14, 0xd8a1e681);   </span><br><span class="line">    GG(b, c, d, a, x[ 4], 20, 0xe7d3fbc8);   </span><br><span class="line">    GG(a, b, c, d, x[ 9], 5, 0x21e1cde6);   </span><br><span class="line">    GG(d, a, b, c, x[14], 9, 0xc33707d6);   </span><br><span class="line">    GG(c, d, a, b, x[ 3], 14, 0xf4d50d87);   </span><br><span class="line">    GG(b, c, d, a, x[ 8], 20, 0x455a14ed);   </span><br><span class="line">    GG(a, b, c, d, x[13], 5, 0xa9e3e905);   </span><br><span class="line">    GG(d, a, b, c, x[ 2], 9, 0xfcefa3f8);   </span><br><span class="line">    GG(c, d, a, b, x[ 7], 14, 0x676f02d9);   </span><br><span class="line">    GG(b, c, d, a, x[12], 20, 0x8d2a4c8a);   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    HH(a, b, c, d, x[ 5], 4, 0xfffa3942);   </span><br><span class="line">    HH(d, a, b, c, x[ 8], 11, 0x8771f681);   </span><br><span class="line">    HH(c, d, a, b, x[11], 16, 0x6d9d6122);   </span><br><span class="line">    HH(b, c, d, a, x[14], 23, 0xfde5380c);   </span><br><span class="line">    HH(a, b, c, d, x[ 1], 4, 0xa4beea44);   </span><br><span class="line">    HH(d, a, b, c, x[ 4], 11, 0x4bdecfa9);   </span><br><span class="line">    HH(c, d, a, b, x[ 7], 16, 0xf6bb4b60);   </span><br><span class="line">    HH(b, c, d, a, x[10], 23, 0xbebfbc70);   </span><br><span class="line">    HH(a, b, c, d, x[13], 4, 0x289b7ec6);   </span><br><span class="line">    HH(d, a, b, c, x[ 0], 11, 0xeaa127fa);   </span><br><span class="line">    HH(c, d, a, b, x[ 3], 16, 0xd4ef3085);   </span><br><span class="line">    HH(b, c, d, a, x[ 6], 23,  0x4881d05);   </span><br><span class="line">    HH(a, b, c, d, x[ 9], 4, 0xd9d4d039);   </span><br><span class="line">    HH(d, a, b, c, x[12], 11, 0xe6db99e5);   </span><br><span class="line">    HH(c, d, a, b, x[15], 16, 0x1fa27cf8);   </span><br><span class="line">    HH(b, c, d, a, x[ 2], 23, 0xc4ac5665);   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    II(a, b, c, d, x[ 0], 6, 0xf4292244);   </span><br><span class="line">    II(d, a, b, c, x[ 7], 10, 0x432aff97);   </span><br><span class="line">    II(c, d, a, b, x[14], 15, 0xab9423a7);   </span><br><span class="line">    II(b, c, d, a, x[ 5], 21, 0xfc93a039);   </span><br><span class="line">    II(a, b, c, d, x[12], 6, 0x655b59c3);   </span><br><span class="line">    II(d, a, b, c, x[ 3], 10, 0x8f0ccc92);   </span><br><span class="line">    II(c, d, a, b, x[10], 15, 0xffeff47d);   </span><br><span class="line">    II(b, c, d, a, x[ 1], 21, 0x85845dd1);   </span><br><span class="line">    II(a, b, c, d, x[ 8], 6, 0x6fa87e4f);   </span><br><span class="line">    II(d, a, b, c, x[15], 10, 0xfe2ce6e0);   </span><br><span class="line">    II(c, d, a, b, x[ 6], 15, 0xa3014314);   </span><br><span class="line">    II(b, c, d, a, x[13], 21, 0x4e0811a1);   </span><br><span class="line">    II(a, b, c, d, x[ 4], 6, 0xf7537e82);   </span><br><span class="line">    II(d, a, b, c, x[11], 10, 0xbd3af235);   </span><br><span class="line">    II(c, d, a, b, x[ 2], 15, 0x2ad7d2bb);   </span><br><span class="line">    II(b, c, d, a, x[ 9], 21, 0xeb86d391);   </span><br><span class="line">    state[0] += a;  </span><br><span class="line">    state[1] += b;  </span><br><span class="line">    state[2] += c;  </span><br><span class="line">    state[3] += d;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">void MD5Init(MD5_CTX *context)  </span><br><span class="line">&#123;  </span><br><span class="line">    context-&gt;count[0] = 0;  </span><br><span class="line">    context-&gt;count[1] = 0;  </span><br><span class="line">    context-&gt;state[0] = 0x67452301;  </span><br><span class="line">    context-&gt;state[1] = 0xEFCDAB89;  </span><br><span class="line">    context-&gt;state[2] = 0x98BADCFE;  </span><br><span class="line">    context-&gt;state[3] = 0x10325476;  </span><br><span class="line">&#125;  </span><br><span class="line">void MD5Update(MD5_CTX *context,unsigned char *input,unsigned int inputlen)  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned int i = 0,index = 0,partlen = 0;  </span><br><span class="line">    index = (context-&gt;count[0] &gt;&gt; 3) &amp; 0x3F;  </span><br><span class="line">    partlen = 64 - index;  </span><br><span class="line">    context-&gt;count[0] += inputlen &lt;&lt; 3;  </span><br><span class="line">    if(context-&gt;count[0] &lt; (inputlen &lt;&lt; 3))  </span><br><span class="line">        context-&gt;count[1]++;  </span><br><span class="line">    context-&gt;count[1] += inputlen &gt;&gt; 29;  </span><br><span class="line"></span><br><span class="line">    if(inputlen &gt;= partlen)  </span><br><span class="line">    &#123;  </span><br><span class="line">        memcpy(&amp;context-&gt;buffer[index],input,partlen);  </span><br><span class="line">        MD5Transform(context-&gt;state,context-&gt;buffer);  </span><br><span class="line">        for(i = partlen;i+64 &lt;= inputlen;i+=64)  </span><br><span class="line">            MD5Transform(context-&gt;state,&amp;input[i]);  </span><br><span class="line">        index = 0;          </span><br><span class="line">    &#125;    </span><br><span class="line">    else  </span><br><span class="line">    &#123;  </span><br><span class="line">        i = 0;  </span><br><span class="line">    &#125;  </span><br><span class="line">    memcpy(&amp;context-&gt;buffer[index],&amp;input[i],inputlen-i);  </span><br><span class="line">&#125;  </span><br><span class="line">void MD5Final(MD5_CTX *context,unsigned char digest[16])  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned int index = 0,padlen = 0;  </span><br><span class="line">    unsigned char bits[8];  </span><br><span class="line">    index = (context-&gt;count[0] &gt;&gt; 3) &amp; 0x3F;  </span><br><span class="line">    padlen = (index &lt; 56)?(56-index):(120-index);  </span><br><span class="line">    MD5Encode(bits,context-&gt;count,8);  </span><br><span class="line">    MD5Update(context,PADDING,padlen);  </span><br><span class="line">    MD5Update(context,bits,8);  </span><br><span class="line">    MD5Encode(digest,context-&gt;state,16);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* md5函数测试 */</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">FILE *fp = fopen(&quot;chmod.c&quot;, &quot;r&quot;);</span><br><span class="line">    struct stat st;</span><br><span class="line">    unsigned char digest[16] = &#123;0&#125;;</span><br><span class="line">    MD5_CTX context;</span><br><span class="line">    int i = 0;</span><br><span class="line"></span><br><span class="line">    MD5Init(&amp;context);</span><br><span class="line">if(0 == stat(&quot;chmod.c&quot;, &amp;st))//获取文件信息</span><br><span class="line">    &#123;</span><br><span class="line">/* 计算文件MD5 */</span><br><span class="line">char *data = NULL;</span><br><span class="line">int ret = 0;</span><br><span class="line"></span><br><span class="line">if(!fp)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;fopen&quot;);</span><br><span class="line">exit(-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data = malloc(st.st_size);</span><br><span class="line">if(!data)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;malloc&quot;);</span><br><span class="line">exit(-1);</span><br><span class="line">&#125;</span><br><span class="line">ret = fread(data, 1, st.st_size, fp);</span><br><span class="line">if(ret != st.st_size)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;fread&quot;);</span><br><span class="line">exit(-1);</span><br><span class="line">&#125; </span><br><span class="line">MD5Update(&amp;context, data, st.st_size);</span><br><span class="line">fclose(fp);</span><br><span class="line">free(data);</span><br><span class="line">    &#125;</span><br><span class="line">    MD5Final(&amp;context, digest);</span><br><span class="line"></span><br><span class="line">    /* 打印MD5值 */</span><br><span class="line">    printf(&quot;md5: &quot;);</span><br><span class="line">    for(i = 0; i &lt; 16; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%02x&quot;, digest[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="七、函数方式查看磁盘空间"><a href="#七、函数方式查看磁盘空间" class="headerlink" title="七、函数方式查看磁盘空间"></a>七、函数方式查看磁盘空间</h5><p><strong>编译验证过的源码码</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/statfs.h&gt;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">void get_system_available(unsigned long long *pavailable)</span><br><span class="line">&#123;</span><br><span class="line">struct statfs diskInfo;</span><br><span class="line"></span><br><span class="line">statfs(&quot;/&quot;, &amp;diskInfo);</span><br><span class="line">unsigned long long blocksize = diskInfo.f_bsize;//每个block里包含的字节数</span><br><span class="line">unsigned long long totalsize = blocksize * diskInfo.f_blocks; //总的字节数，f_blocks为block的数目</span><br><span class="line">printf(&quot;Total_size = %llu B = %llu KB = %llu MB = %llu GB\n&quot;, totalsize, totalsize&gt;&gt;10, totalsize&gt;&gt;20, totalsize&gt;&gt;30);</span><br><span class="line"></span><br><span class="line">unsigned long long freeDisk = diskInfo.f_bfree * blocksize;//剩余空间的大小</span><br><span class="line">*pavailable = diskInfo.f_bavail * blocksize; //可用空间大小</span><br><span class="line">printf(&quot;Disk_free = %llu MB = %llu GB\n&quot;, freeDisk&gt;&gt;20, freeDisk&gt;&gt;30);</span><br><span class="line">//printf(&quot;Disk_available = %llu MB = %llu GB\n&quot;, availableDisk&gt;&gt;20, availableDisk&gt;&gt;30);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">unsigned long long available;</span><br><span class="line">get_system_available(&amp;available);</span><br><span class="line">printf(&quot;Disk_available = %llu MB = %llu GB\n&quot;, available&gt;&gt;20, available&gt;&gt;30);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;一、调用system执行shell命令&quot;&gt;&lt;a href=&quot;#一、调用system执行shell命令&quot; class=&quot;headerlink&quot; title=&quot;一、调用system执行shell命令&quot;&gt;&lt;/a&gt;一、调用system执行shell命令&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;编译验证过的源码码&lt;/strong&gt;：&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://www.faihung.net/categories/C/"/>
    
    
      <category term="system" scheme="http://www.faihung.net/tags/system/"/>
    
      <category term="popen" scheme="http://www.faihung.net/tags/popen/"/>
    
      <category term="remove" scheme="http://www.faihung.net/tags/remove/"/>
    
      <category term="dirent" scheme="http://www.faihung.net/tags/dirent/"/>
    
      <category term="chmod" scheme="http://www.faihung.net/tags/chmod/"/>
    
      <category term="MD5" scheme="http://www.faihung.net/tags/MD5/"/>
    
      <category term="statfs" scheme="http://www.faihung.net/tags/statfs/"/>
    
  </entry>
  
  <entry>
    <title>Git-02_gitlab的配置与准备工作</title>
    <link href="http://www.faihung.net/2020/01/01/Git-02-gitlab%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"/>
    <id>http://www.faihung.net/2020/01/01/Git-02-gitlab的配置与准备工作/</id>
    <published>2020-01-01T15:44:57.000Z</published>
    <updated>2020-01-01T16:01:02.388Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前面简单介绍了Web端gitlab的一些基本信息，这里主要介绍gitlab 一些配置和准备工作。</p></blockquote><h5 id="1-修改密码和邮箱"><a href="#1-修改密码和邮箱" class="headerlink" title="1.修改密码和邮箱"></a>1.修改密码和邮箱</h5><p>略</p><h5 id="2-配置SSH-Keys"><a href="#2-配置SSH-Keys" class="headerlink" title="2.配置SSH Keys"></a>2.配置SSH Keys</h5><p>前面Web端介绍时提到了SSH Keys的设置（见web端界面2.12账户设置）。<br>在往前我们建立一个新项目的时候也看到了一个SSH协议（见Web界面2.2.1点击按钮“New project”建立一个新项目，那里还有一个http协议，http协议不需要配置，但是push代码比较慢）。<br>都有提到关于SSH，这是因为我们git仓库和Gitlab仓库之间是通过SSH加密的，所以需要进行相应的配置。</p><a id="more"></a><h6 id="第1步：创建SSH-Key"><a href="#第1步：创建SSH-Key" class="headerlink" title="第1步：创建SSH Key"></a>第1步：创建SSH Key</h6><p>在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：<br>ssh-keygen -t rsa -C <a href="mailto:email@example.com" target="_blank" rel="noopener">email@example.com</a><br>之后一路回车，使用默认值，就可以获得一个Key值。一切顺利可以在用户主目录下面找到.ssh文件夹，可以看到里面有两个文件id_rsa和id_rsa.pub。其中id_rsa是私钥，id_rsa.pub是公钥。</p><p>如图：<br><img src="/2020/01/01/Git-02-gitlab%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/1.png" alt="1"></p><h6 id="第2步：登陆GitLab，打开账户设置，“SSH-Keys”页面："><a href="#第2步：登陆GitLab，打开账户设置，“SSH-Keys”页面：" class="headerlink" title="第2步：登陆GitLab，打开账户设置，“SSH Keys”页面："></a>第2步：登陆GitLab，打开账户设置，“SSH Keys”页面：</h6><p><img src="/2020/01/01/Git-02-gitlab%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/2.png" alt="2"></p><p><img src="/2020/01/01/Git-02-gitlab%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/3.png" alt="3"><br>这样就成功添加了。<br>其实在前面创建项目的时候提示这个，就表示要添加SSH Keys了。<br><img src="/2020/01/01/Git-02-gitlab%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/4.png" alt="4"></p><h5 id="3-安装Git"><a href="#3-安装Git" class="headerlink" title="3.安装Git"></a>3.安装Git</h5><p>Windows端需要下载一个git 客户端工具GitHubDesktopSetup.exe，这里主要是以Linux为主。<br>执行命令：</p><pre><code>sudo apt install git</code></pre><p>然后直接安装即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前面简单介绍了Web端gitlab的一些基本信息，这里主要介绍gitlab 一些配置和准备工作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;1-修改密码和邮箱&quot;&gt;&lt;a href=&quot;#1-修改密码和邮箱&quot; class=&quot;headerlink&quot; title=&quot;1.修改密码和邮箱&quot;&gt;&lt;/a&gt;1.修改密码和邮箱&lt;/h5&gt;&lt;p&gt;略&lt;/p&gt;
&lt;h5 id=&quot;2-配置SSH-Keys&quot;&gt;&lt;a href=&quot;#2-配置SSH-Keys&quot; class=&quot;headerlink&quot; title=&quot;2.配置SSH Keys&quot;&gt;&lt;/a&gt;2.配置SSH Keys&lt;/h5&gt;&lt;p&gt;前面Web端介绍时提到了SSH Keys的设置（见web端界面2.12账户设置）。&lt;br&gt;在往前我们建立一个新项目的时候也看到了一个SSH协议（见Web界面2.2.1点击按钮“New project”建立一个新项目，那里还有一个http协议，http协议不需要配置，但是push代码比较慢）。&lt;br&gt;都有提到关于SSH，这是因为我们git仓库和Gitlab仓库之间是通过SSH加密的，所以需要进行相应的配置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://www.faihung.net/categories/Git/"/>
    
    
      <category term="gitlab" scheme="http://www.faihung.net/tags/gitlab/"/>
    
      <category term="github" scheme="http://www.faihung.net/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Git-01_gitlab的Web端界面</title>
    <link href="http://www.faihung.net/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/"/>
    <id>http://www.faihung.net/2019/12/30/Git-01-gitlab的Web端界面/</id>
    <published>2019-12-30T15:42:15.000Z</published>
    <updated>2020-01-01T16:00:07.174Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、gitlab的登录"><a href="#一、gitlab的登录" class="headerlink" title="一、gitlab的登录"></a>一、gitlab的登录</h4><p>Web网页输入：<a href="http://xxx.wicp.vip/" target="_blank" rel="noopener">http://xxx.wicp.vip/</a> 进入gitlab登录界面，输入账号密码之后，选择 standard登录，进入Web页面。不同权限的人进入的界面是不一样的。<br>如下：<br><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/1.png" alt="1"></p><a id="more"></a><h4 id="二、gitlab-Web端的介绍"><a href="#二、gitlab-Web端的介绍" class="headerlink" title="二、gitlab Web端的介绍"></a>二、gitlab Web端的介绍</h4><p>点击Web端菜单栏上标签按钮，可以进入不同的功能任务主窗口。</p><h5 id="2-1-gitlab-一个logo标志-，进入或者恢复初始界面。"><a href="#2-1-gitlab-一个logo标志-，进入或者恢复初始界面。" class="headerlink" title="2.1 gitlab(一个logo标志)，进入或者恢复初始界面。"></a>2.1 gitlab(一个logo标志)，进入或者恢复初始界面。</h5><h5 id="2-2-Project，根据下拉列表或者Project标签页中的Tab列表选择同类型的项目。如下图"><a href="#2-2-Project，根据下拉列表或者Project标签页中的Tab列表选择同类型的项目。如下图" class="headerlink" title="2.2 Project，根据下拉列表或者Project标签页中的Tab列表选择同类型的项目。如下图"></a>2.2 Project，根据下拉列表或者Project标签页中的Tab列表选择同类型的项目。如下图</h5><p><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/2.png" alt="2"><br><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/3.png" alt="3"></p><h6 id="2-2-1点击按钮“New-project”建立项目"><a href="#2-2-1点击按钮“New-project”建立项目" class="headerlink" title="2.2.1点击按钮“New project”建立项目"></a>2.2.1点击按钮“New project”建立项目</h6><p><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/4.png" alt="4"><br>可以看到主窗口中有三个待选标签页：Blank project、Create from template、 Import project分别表示不同project的创建方式，一般我们用第一种。</p><p>根据项目Group的下拉菜单，选择beacom_firmware开发小组，输入项目名名称test，添加项目描述信息。</p><p>最后选择Visibility Level 的权限(可以选上README文件，最后会生成一个README文件)，点击按钮“Create project”就在这个开发小组中可以建立一个项目了。<br>如下图：<br><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/5.png" alt="5"></p><p>注意: </p><ol><li>点击按钮“clone”弹出一个对话框，上面有关于SSH和HTTP方式的链接，后续会有介绍。</li><li>每建立一个project 都会有这样一个命令：Command line instructions，这个是让我我们上传代码的命令，后面所有的操作基本上都是围绕这几步来，一般我们用这个命令：Create a new repository，后续会有介绍。</li></ol><h6 id="2-2-2回到刚才的Project-gt-Your-project-页面中可以看到新建的子项目xxx-firmware-test，以后开发就可以从这里进入"><a href="#2-2-2回到刚才的Project-gt-Your-project-页面中可以看到新建的子项目xxx-firmware-test，以后开发就可以从这里进入" class="headerlink" title="2.2.2回到刚才的Project-&gt;Your project 页面中可以看到新建的子项目xxx_firmware/test，以后开发就可以从这里进入"></a>2.2.2回到刚才的Project-&gt;Your project 页面中可以看到新建的子项目xxx_firmware/test，以后开发就可以从这里进入</h6><h5 id="2-3-Group-根据顶级菜单的下拉列表或者是子菜单的Tab列表都可以进如到不同的开发小组中去。"><a href="#2-3-Group-根据顶级菜单的下拉列表或者是子菜单的Tab列表都可以进如到不同的开发小组中去。" class="headerlink" title="2.3 Group,根据顶级菜单的下拉列表或者是子菜单的Tab列表都可以进如到不同的开发小组中去。"></a>2.3 Group,根据顶级菜单的下拉列表或者是子菜单的Tab列表都可以进如到不同的开发小组中去。</h5><p>以XXX_firmware开发小组为例，可以看到左边的的功能菜单上有：<br><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/6.png" alt="6"></p><h6 id="2-3-1-Owerview"><a href="#2-3-1-Owerview" class="headerlink" title="2.3.1 Owerview"></a>2.3.1 Owerview</h6><p>是一些项目细节或者是开发人员的活跃记录，如上图和下图所示。<br><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/7.png" alt="7"></p><h6 id="2-3-2-Issues"><a href="#2-3-2-Issues" class="headerlink" title="2.3.2 Issues"></a>2.3.2 Issues</h6><p>在这里这个项目组成员可以提交一些问题，大家相互交流，项目开发进度等等，代码发布版本都可以在这里做记录，这里没做研究。</p><h6 id="2-3-3-Merge-Requests"><a href="#2-3-3-Merge-Requests" class="headerlink" title="2.3.3 Merge Requests"></a>2.3.3 Merge Requests</h6><p>主要是别人提交代码请求合并的记录</p><h6 id="2-3-4-Kubernetes"><a href="#2-3-4-Kubernetes" class="headerlink" title="2.3.4 Kubernetes"></a>2.3.4 Kubernetes</h6><p>略</p><h6 id="2-3-5-Members"><a href="#2-3-5-Members" class="headerlink" title="2.3.5 Members"></a>2.3.5 Members</h6><p>这里有开发人员的相关信息，包括各级权限。</p><h5 id="2-4-Activity"><a href="#2-4-Activity" class="headerlink" title="2.4 Activity"></a>2.4 Activity</h5><p>不同人员各种代码提交、活跃记录都在上面。</p><h5 id="2-5-Milestones"><a href="#2-5-Milestones" class="headerlink" title="2.5 Milestones"></a>2.5 Milestones</h5><p>同2.3.2Issues中的milestones,就是项目开发达到某一个程度，比如可以发布的一个版本。（后面给代码打标签设置版本号还会提到如：git tag v1.0）</p><h5 id="2-6-Snippet"><a href="#2-6-Snippet" class="headerlink" title="2.6 Snippet"></a>2.6 Snippet</h5><p>个人的一些工作中的Idea启发,都可以记录在这里，有权限设置，相当于个人blog。</p><h5 id="2-7-“-”"><a href="#2-7-“-”" class="headerlink" title="2.7 “+”"></a>2.7 “+”</h5><p>根据下拉列表看到New Project、New group、New snippet，这个前面都有相关介绍。</p><h5 id="2-8-Issues"><a href="#2-8-Issues" class="headerlink" title="2.8 Issues"></a>2.8 Issues</h5><p>同2.3.2 Issues</p><h5 id="2-9-Merge-Requests"><a href="#2-9-Merge-Requests" class="headerlink" title="2.9 Merge Requests"></a>2.9 Merge Requests</h5><p>同2.3.3 Merge Requests</p><h5 id="2-9-Todos"><a href="#2-9-Todos" class="headerlink" title="2.9 Todos"></a>2.9 Todos</h5><p>接下来要做的事情，同2.3.2 Issues</p><h5 id="2-10？"><a href="#2-10？" class="headerlink" title="2.10？"></a>2.10？</h5><p>一款工具不能少的，常见帮助信息。</p><h5 id="2-11-账户设置"><a href="#2-11-账户设置" class="headerlink" title="2.11 账户设置"></a>2.11 账户设置</h5><p>选择账户中下拉列表Setings进入账户设置。如下图</p><p><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/8.png" alt="8"></p><p>这里主要是一些个人信息的设置，比如修改账户密码、邮箱等。还有一个重要的操作修改添加SSH Keys后面会有介绍。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、gitlab的登录&quot;&gt;&lt;a href=&quot;#一、gitlab的登录&quot; class=&quot;headerlink&quot; title=&quot;一、gitlab的登录&quot;&gt;&lt;/a&gt;一、gitlab的登录&lt;/h4&gt;&lt;p&gt;Web网页输入：&lt;a href=&quot;http://xxx.wicp.vip/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://xxx.wicp.vip/&lt;/a&gt; 进入gitlab登录界面，输入账号密码之后，选择 standard登录，进入Web页面。不同权限的人进入的界面是不一样的。&lt;br&gt;如下：&lt;br&gt;&lt;img src=&quot;/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/1.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://www.faihung.net/categories/Git/"/>
    
    
      <category term="gitlab" scheme="http://www.faihung.net/tags/gitlab/"/>
    
      <category term="github" scheme="http://www.faihung.net/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>工程设计-软件升级之设备端版本号管理(3)</title>
    <link href="http://www.faihung.net/2019/12/29/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E8%BD%AF%E4%BB%B6%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%AE%BE%E5%A4%87%E7%AB%AF%E7%89%88%E6%9C%AC%E5%8F%B7%E7%AE%A1%E7%90%86-3/"/>
    <id>http://www.faihung.net/2019/12/29/工程设计-软件升级之设备端版本号管理-3/</id>
    <published>2019-12-29T15:30:15.000Z</published>
    <updated>2020-01-12T07:39:10.173Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于版本号管控需要满足以空间分支为主导,用时间变更作定位,方便bug查找修改。</p></blockquote><p>1.需要满足设备的向上兼容,通过版本号的变更迭代可以实现。形如：3.000.0001</p><p>2.需要满足事物存在的3要素：</p><ul><li><p>时间(就是设备发货时间,也是设备的初始版本号,例如3.000.0001到3.000.0002的变更，就是一个时间变迁的过程)</p></li><li><p>地点(就是设备发货地点,同时对应代码库的分支)</p></li><li><p>设备(设备是必须存在的)</p></li></ul><a id="more"></a><p>每往一个地方发送设备,设备端代码通过git库建立一个分支,之后这个分支代码就主要是这个地方设备运行代码,方便以后bug查找,但不会对这个分支代码进行修改。<br>初始版本,以发往四川的为例：sichuan-3.000.0001</p><p>3.我们的程序不断的在master分支上进行更新迭代。</p><p>4.关于升级,会出现两种情况。(其它各种情况都离不开这两种情况)</p><p>4.1 一种情况就是某一个地方的设备出现了bug被人发现了,这个时候必须要对这个地方的设备进行升级,此时修改master分支测试验证通过<br>将master分支代码克隆到这个地方分支上去,代码的版本号变更由sichuan-3.000.0001到sichuan-3.000.0002的变更。</p><p>4.2 此时master分支,对4.1中bug进行修复并验证通过,同时我们也解决了一个其它的代码bug或者实现了一个功能,代码测试验证通过之后,感觉可以升级了,<br>这就是第二种情况升级(第二种升级又是系列情况升级)。<br>但并不是所有的设备都能升级,所以将master分支代码克隆到能够升级的地方分支上去。(时刻谨记地点分支代码不是用来修改的,是用来定位查找bug的)<br>形如：</p><pre><code>sichuan-3.000.0002到sichuan-3.001.0000的升级tieling-3.000.0001到tieling-3.001.0000的升级xian-3.000.00001  到xian-3.000.00001不升级</code></pre><p>5.所以从上面可以看出：sichuan-3.000.00000,从右往左起,<br>第1段是bug&amp;功能的升级<br>第2段是代码进行系列的升级<br>第3段前半部分是地方名称,后半部分是产品换代升级</p><p>6.代码的升级虽然是在服务器端升级的,但其实还是由设备端提供代码进行升级的。<br>所以每发一批设备,设备端都要给服务器端一个版本号：地点+一串号码,用来放入软件升级代码中去。</p><p>每次发出去之前,肯定要经过相应的一系列测试,这些测试必然包括版本升级测试。<br>(关于软件升级版本号必然是以if else if的方式不端的扩张的,因为它是未知的。)</p><p>7.软件升级代码以后要集中到运行程序中去,这样软件升级代码自身也会不断的迭代更新。</p><blockquote><p>注：此只为自己的一些不成熟的想法，真正版本号管理需要领导们自己决定。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;关于版本号管控需要满足以空间分支为主导,用时间变更作定位,方便bug查找修改。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.需要满足设备的向上兼容,通过版本号的变更迭代可以实现。形如：3.000.0001&lt;/p&gt;
&lt;p&gt;2.需要满足事物存在的3要素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;时间(就是设备发货时间,也是设备的初始版本号,例如3.000.0001到3.000.0002的变更，就是一个时间变迁的过程)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;地点(就是设备发货地点,同时对应代码库的分支)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设备(设备是必须存在的)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="工程设计" scheme="http://www.faihung.net/categories/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>系统函数&amp;库函数-Linux中的popen函数和system函数(转)</title>
    <link href="http://www.faihung.net/2019/12/22/%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0-%E5%BA%93%E5%87%BD%E6%95%B0-Linux%E4%B8%AD%E7%9A%84popen%E5%87%BD%E6%95%B0%E5%92%8Csystem%E5%87%BD%E6%95%B0-%E8%BD%AC/"/>
    <id>http://www.faihung.net/2019/12/22/系统函数-库函数-Linux中的popen函数和system函数-转/</id>
    <published>2019-12-22T15:57:19.000Z</published>
    <updated>2019-12-22T16:05:12.314Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>说在前面，在实际编程中尽量减少使用system函数。</p></blockquote><h5 id="int-system-const-char-command"><a href="#int-system-const-char-command" class="headerlink" title="int system(const char *command);"></a>int system(const char *command);</h5><h6 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h6><p>system()通过调用/bin/sh -c命令执行命令中指定的命令，并在命令完成后返回。在执行该命令期间，SIGCHLD将被阻塞，并且SIGINT和SIGQUIT将被忽略。</p><a id="more"></a><h6 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h6><p>实际上system调用了三个函数：fork()、exec()、waitpid()。因此有三种返回值：</p><ol><li>fork()失败或者waitpid()返回除了EINTR之外的出错，则system返回-1.而且errno中设置了错误类型值。</li><li>如果exec失败（表示不能执行shell），则其返回值如同shell执行了exit（127）一样</li><li>如果三个函数都执行成功，并且system的返回值是shell的终止状态，其格式已在已在waitpid中说明。</li></ol><h6 id="system的实现："><a href="#system的实现：" class="headerlink" title="system的实现："></a>system的实现：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int system(const char * cmdstring)  </span><br><span class="line">&#123;   </span><br><span class="line">  pid_t pid;   </span><br><span class="line">  int status;   </span><br><span class="line">  if(cmdstring == NULL)  </span><br><span class="line">    &#123;   </span><br><span class="line">      return (1);   </span><br><span class="line">    &#125;   </span><br><span class="line">  if((pid = fork())&lt;0)  </span><br><span class="line">    &#123;   </span><br><span class="line">      status = -1;   </span><br><span class="line">    &#125;   </span><br><span class="line">  else if(pid = 0)  </span><br><span class="line">    &#123;  </span><br><span class="line">       execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-c&quot;, cmdstring, (char *)0); -exit(127); //子进程正常执行则不会执行此语句 &#125;   </span><br><span class="line">  else  </span><br><span class="line">    &#123;   </span><br><span class="line">       while(waitpid(pid, &amp;status, 0) &lt; 0)  </span><br><span class="line">    &#123;  </span><br><span class="line">  if(errno != EINTER)&#123; status = -1; break;   </span><br><span class="line">    &#125;   </span><br><span class="line">   &#125;  </span><br><span class="line">  &#125;   </span><br><span class="line">  return status;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="简单的使用："><a href="#简单的使用：" class="headerlink" title="简单的使用："></a>简单的使用：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int status = 0;</span><br><span class="line">  status = system(&quot;ls -a&quot;);</span><br><span class="line">  if(-1 == status)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(&quot;system&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  if(WIFEXITED(status) != 0)  //正常退出</span><br><span class="line">  &#123;</span><br><span class="line">    if(WEXITSTATUS(status) == 0)  //操作正确</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;run command success\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;run error\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else      //异常退出</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;exit error is %d\n&quot;, WEXITSTATUS(status));</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以看到，system在使用时的一个弊端，由于返回值太多，要安全的使用它就要进行许多步的出错处理。</p><p>所以，不太建议使用system。</p><h6 id="使用system需要注意："><a href="#使用system需要注意：" class="headerlink" title="使用system需要注意："></a>使用system需要注意：</h6><p>1.建议system()函数只用来执行shell命令，因为一般来讲，system()返回值不是0就说明出错了； </p><p>2.监控一下system()函数的执行完毕后的errno值，争取出错时给出更多有用信息； </p><h5 id="建议使用popen函数取代system"><a href="#建议使用popen函数取代system" class="headerlink" title="建议使用popen函数取代system();"></a>建议使用popen函数取代system();</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *popen(const char *command, const char *type);</span><br><span class="line">int pclose(FILE *stream);返回值： command的终止状态， 出错返回-1</span><br></pre></td></tr></table></figure><h6 id="popen-函数较于system-函数的优势在于使用简单，popen-函数只返回两个值："><a href="#popen-函数较于system-函数的优势在于使用简单，popen-函数只返回两个值：" class="headerlink" title="popen()函数较于system()函数的优势在于使用简单，popen()函数只返回两个值："></a>popen()函数较于system()函数的优势在于使用简单，popen()函数只返回两个值：</h6><p>成功返回子进程的status，使用WIFEXITED相关宏就可以取得command的返回结果；</p><p>失败返回-1，我们可以使用perro()函数或strerror()函数得到有用的错误信息。</p><p>popen先执行fork，然后调用exec以执行command并返回一个标准I/O文件指针。如果type是“r”，则文件指针链接到command的标准输出。如果type是“w”,则文件指针链接到command的标准输入。将popen和fopen进行类比，方便记忆其最后一个参数及其作用，如果type是“r”，则返回文件指针是刻度的，如果type是是“w”，则是可写的。</p><p><img src="/2019/12/22/%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0-%E5%BA%93%E5%87%BD%E6%95%B0-Linux%E4%B8%AD%E7%9A%84popen%E5%87%BD%E6%95%B0%E5%92%8Csystem%E5%87%BD%E6%95%B0-%E8%BD%AC/1.png" alt="1"></p><p>简单使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  FILE* fp = NULL;</span><br><span class="line">  char buf[1024] = &#123;0&#125;;</span><br><span class="line">  fp = popen(&quot;ls -a&quot;, &quot;r&quot;);</span><br><span class="line">  if(NULL == fp)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(&quot;popen&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  while(fgets(buf, 1024, fp) != NULL)</span><br><span class="line">  &#123;</span><br><span class="line">   fprintf(stdout, &quot;%s&quot;, buf); </span><br><span class="line">  &#125;</span><br><span class="line">  pclose(fp);</span><br><span class="line"> </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，popen绝不应该由设置用户ID或设置组ID程序调用。当它执行命令</p><p>popen等同于execl(“/bin/sh”, “sh”, “-c”, command ,NULL);</p><p>它在从调用者继承的环境中执行shell，并由shell解释执行command。一个心怀不轨的用户可以操纵这种环境，使得shell能以设置ID文件模式所授予的提升了的权限以及非预期的方式执行命令。</p><p>popen特别适用于构造简单的过滤程序，它变换运行命令的输入或输出。</p><p>当命令希望构建自己的管道线时就是这种情形。</p><blockquote><p>借楼发个问题：在多次调用system和popen（中间没有做delay处理）后，再次调用是直接fp返回空或system返回无此目录或文件。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;说在前面，在实际编程中尽量减少使用system函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;int-system-const-char-command&quot;&gt;&lt;a href=&quot;#int-system-const-char-command&quot; class=&quot;headerlink&quot; title=&quot;int system(const char *command);&quot;&gt;&lt;/a&gt;int system(const char *command);&lt;/h5&gt;&lt;h6 id=&quot;说明：&quot;&gt;&lt;a href=&quot;#说明：&quot; class=&quot;headerlink&quot; title=&quot;说明：&quot;&gt;&lt;/a&gt;说明：&lt;/h6&gt;&lt;p&gt;system()通过调用/bin/sh -c命令执行命令中指定的命令，并在命令完成后返回。在执行该命令期间，SIGCHLD将被阻塞，并且SIGINT和SIGQUIT将被忽略。&lt;/p&gt;
    
    </summary>
    
    
      <category term="系统函数&amp;库函数" scheme="http://www.faihung.net/categories/%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0-%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="system" scheme="http://www.faihung.net/tags/system/"/>
    
      <category term="popen" scheme="http://www.faihung.net/tags/popen/"/>
    
  </entry>
  
  <entry>
    <title>系统函数&amp;库函数-popen 的使用方法及场景(转)</title>
    <link href="http://www.faihung.net/2019/12/22/%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0-%E5%BA%93%E5%87%BD%E6%95%B0-popen-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%8F%8A%E5%9C%BA%E6%99%AF-%E8%BD%AC/"/>
    <id>http://www.faihung.net/2019/12/22/系统函数-库函数-popen-的使用方法及场景-转/</id>
    <published>2019-12-22T15:56:46.000Z</published>
    <updated>2019-12-22T16:02:47.363Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-Popen的应用场景"><a href="#1-Popen的应用场景" class="headerlink" title="1.Popen的应用场景"></a>1.Popen的应用场景</h5><p>popen应用于执行shell命令，并读取此命令的返值，或者与执行的命令进行交互。</p><a id="more"></a><h5 id="2-Popen的实现"><a href="#2-Popen的实现" class="headerlink" title="2.Popen的实现"></a>2.Popen的实现</h5><p>popen()函数通过创建一个管道，调用fork()产生一个子进程，执行一个shell以运行命令来开启一个进程。可以通过这个管道执行标准输入输出操作。这个管道必须由pclose()函数关闭，必须由pclose()函数关闭，必须由pclose()函数关闭，而不是fclose()函数（若使用fclose则会产生僵尸进程）。pclose()函数关闭标准I/O流，等待命令执行结束，然后返回shell的终止状态。如果shell不能被执行，则pclose()返回的终止状态与shell已执行exit一样。</p><p>type参数只能是读或者写中的一种，得到的返回值（标准I/O流）也具有和type相应的只读或只写类型。如果type是”r”则文件指针连接到command的标准输出；如果type是”w”则文件指针连接到command的标准输入。</p><p>command参数是一个指向以NULL结束的shell命令字符串的指针。这行命令将被传到bin/sh并使用-c标志，shell将执行这个命令。</p><p>popen()的返回值是个标准I/O流，必须由pclose来终止。前面提到这个流是单向的（只能用于读或写）。向这个流写内容相当于写入该命令的标准输入，命令的标准输出和调用popen()的进程相同；与之相反的，从流中读数据相当于读取命令的标准输出，命令的标准输入和调用popen()的进程相同。</p><p><strong>返回值</strong></p><p>如果调用fork()或pipe()失败，或者不能分配内存将返回NULL，否则返回标准I/O流。popen()没有为内存分配失败设置errno值。如果调用fork()或pipe()时出现错误，errno被设为相应的错误类型。如果type参数不合法，errno将返回EINVAL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *popen(const char *command, const char *type);</span><br><span class="line">int pclose(FILE *stream);</span><br></pre></td></tr></table></figure><h5 id="3-Pclose操作"><a href="#3-Pclose操作" class="headerlink" title="3.Pclose操作"></a>3.Pclose操作</h5><p>Pclose()函数会闭标准i/0流，等待子进程结束，然后返回shell终止状态。如果不执行，则pclose()返回终止状态就是shell的exit状态。</p><p><strong>源码附上：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line">/* Copyright (C) 2004       Manuel Novoa III    &lt;mjn3@codepoet.org&gt;</span><br><span class="line"> * Copyright (C) 2000-2006 Erik Andersen &lt;andersen@uclibc.org&gt;</span><br><span class="line"> *</span><br><span class="line"> * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.</span><br><span class="line"> *</span><br><span class="line"> * Dedicated to Toni.  See uClibc/DEDICATION.mjn3 for details.</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/* Jan 1, 2004</span><br><span class="line"> *</span><br><span class="line"> * Rewrite popen for SUSv3 compliance.</span><br><span class="line"> *   Added a list of popen()&apos;d to store pids and use waitpid() in pclose().</span><br><span class="line"> *   Loop on waitpid() failure due to EINTR as required.</span><br><span class="line"> *   Close parent&apos;s popen()&apos;d FILEs in the &#123;v&#125;fork()&apos;d child.</span><br><span class="line"> *   Fix failure exit code for failed execve().</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;bits/uClibc_mutex.h&gt;</span><br><span class="line"> </span><br><span class="line">#ifdef __UCLIBC_MJN3_ONLY__</span><br><span class="line">#warning &quot;hmm... susv3 says Pipe streams are byte-oriented.&quot;</span><br><span class="line">#endif /* __UCLIBC_MJN3_ONLY__ */</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/* uClinux-2.0 has vfork, but Linux 2.0 doesn&apos;t */</span><br><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line">#if ! defined __NR_vfork</span><br><span class="line"># define vfork fork</span><br><span class="line"># define VFORK_LOCK((void) 0)</span><br><span class="line"># define VFORK_UNLOCK((void) 0)</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">#ifndef VFORK_LOCK</span><br><span class="line">__UCLIBC_MUTEX_STATIC(mylock, PTHREAD_MUTEX_INITIALIZER);</span><br><span class="line"># define VFORK_LOCK__UCLIBC_MUTEX_LOCK(mylock)</span><br><span class="line"># define VFORK_UNLOCK__UCLIBC_MUTEX_UNLOCK(mylock)</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">struct popen_list_item &#123;</span><br><span class="line">struct popen_list_item *next;</span><br><span class="line">FILE *f;</span><br><span class="line">pid_t pid;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">static struct popen_list_item *popen_list /* = NULL (bss initialized) */;</span><br><span class="line"> </span><br><span class="line">FILE *popen(const char *command, const char *modes)</span><br><span class="line">&#123;</span><br><span class="line">FILE *fp;</span><br><span class="line">struct popen_list_item *pi;</span><br><span class="line">struct popen_list_item *po;</span><br><span class="line">int pipe_fd[2];</span><br><span class="line">int parent_fd;</span><br><span class="line">int child_fd;</span><br><span class="line">int child_writing;/* Doubles as the desired child fildes. */</span><br><span class="line">pid_t pid;</span><br><span class="line"> </span><br><span class="line">child_writing = 0;/* Assume child is writing. */</span><br><span class="line">if (modes[0] != &apos;w&apos;) &#123;/* Parent not writing... */</span><br><span class="line">++child_writing;/* so child must be writing. */</span><br><span class="line">if (modes[0] != &apos;r&apos;) &#123;/* Oops!  Parent not reading either! */</span><br><span class="line">__set_errno(EINVAL);</span><br><span class="line">goto RET_NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">if (!(pi = malloc(sizeof(struct popen_list_item)))) &#123;</span><br><span class="line">goto RET_NULL;</span><br><span class="line">&#125;</span><br><span class="line">// 打开一个pipe，管道是单向。故数据流只能单向流动。</span><br><span class="line">if (pipe(pipe_fd)) &#123;</span><br><span class="line">goto FREE_PI;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//下面两个描述符就是管道的两端的描述，一个为读一个为写。</span><br><span class="line">child_fd = pipe_fd[child_writing]; </span><br><span class="line">parent_fd = pipe_fd[1-child_writing]; </span><br><span class="line">//fdopen就是打开一个描述，fd相同模式或者字集的方式打开。意思就是把一个已找打开的流与一个文件描述符相关联，且</span><br><span class="line">//这个文件描述是唯一的，这样也就可以保证这个函数接口的可重入性。如果设计的不可重入性，也就没必要再做一次fdopen了。</span><br><span class="line">if (!(fp = fdopen(parent_fd, modes))) &#123;</span><br><span class="line">close(parent_fd);</span><br><span class="line">close(child_fd);</span><br><span class="line">goto FREE_PI;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">VFORK_LOCK;</span><br><span class="line">//再这里创建一个子进程，然后执行 shell命令。这里最重的两步就是用pipe的两个描述替换标准输入或者输出。</span><br><span class="line">if ((pid = vfork()) == 0) &#123;/* Child of vfork... */</span><br><span class="line">close(parent_fd);</span><br><span class="line">if (child_fd != child_writing) &#123;</span><br><span class="line">dup2(child_fd, child_writing); //用child_fd来代替标准输入或输出。</span><br><span class="line">close(child_fd);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* SUSv3 requires that any previously popen()&apos;d streams in the</span><br><span class="line"> * parent shall be closed in the child. */</span><br><span class="line">//关闭不必要的资源。</span><br><span class="line">for (po = popen_list ; po ; po = po-&gt;next) &#123;</span><br><span class="line">close(po-&gt;f-&gt;__filedes);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//执行exec shell,这个时候标准输入/输出就变为pipe管道的一端了。</span><br><span class="line">//这里只能实现单向的功能。要么读要么写。</span><br><span class="line">execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-c&quot;, command, (char *)0);</span><br><span class="line"> </span><br><span class="line">/* SUSv3 mandates an exit code of 127 for the child if the</span><br><span class="line"> * command interpreter can not be invoked. */</span><br><span class="line">_exit(127);</span><br><span class="line">&#125;</span><br><span class="line">VFORK_UNLOCK;</span><br><span class="line"> </span><br><span class="line">/* We need to close the child filedes whether vfork failed or</span><br><span class="line"> * it succeeded and we&apos;re in the parent. */</span><br><span class="line">close(child_fd);</span><br><span class="line">//将当前的信息保存到全局链表。为了是pclose可以找到对的子进程与通信文件描述。</span><br><span class="line">if (pid &gt; 0) &#123;/* Parent of vfork... */</span><br><span class="line">pi-&gt;pid = pid;</span><br><span class="line">pi-&gt;f = fp;</span><br><span class="line">VFORK_LOCK;</span><br><span class="line">pi-&gt;next = popen_list;</span><br><span class="line">popen_list = pi;</span><br><span class="line">VFORK_UNLOCK;</span><br><span class="line"> </span><br><span class="line">return fp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* If we get here, vfork failed. */</span><br><span class="line">fclose(fp);/* Will close parent_fd. */</span><br><span class="line"> </span><br><span class="line"> FREE_PI:</span><br><span class="line">free(pi);</span><br><span class="line"> </span><br><span class="line"> RET_NULL:</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#warning is pclose correct wrt the new mutex semantics?</span><br><span class="line"> </span><br><span class="line">int pclose(FILE *stream)</span><br><span class="line">&#123;</span><br><span class="line">struct popen_list_item *p;</span><br><span class="line">int stat;</span><br><span class="line">pid_t pid;</span><br><span class="line"> </span><br><span class="line">/* First, find the list entry corresponding to stream and remove it</span><br><span class="line"> * from the list.  Set p to the list item (NULL if not found). */</span><br><span class="line">VFORK_LOCK;</span><br><span class="line">if ((p = popen_list) != NULL) &#123;</span><br><span class="line">if (p-&gt;f == stream) &#123;// 找到stream对应的popen结点。</span><br><span class="line">popen_list = p-&gt;next;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">struct popen_list_item *t;</span><br><span class="line">do &#123;</span><br><span class="line">t = p;</span><br><span class="line">if (!(p = t-&gt;next)) &#123;</span><br><span class="line">__set_errno(EINVAL); /* Not required by SUSv3. */</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if (p-&gt;f == stream) &#123;</span><br><span class="line">t-&gt;next = p-&gt;next;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125; while (1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">VFORK_UNLOCK;</span><br><span class="line"> </span><br><span class="line">if (p) &#123;</span><br><span class="line">pid = p-&gt;pid;/* Save the pid we need */</span><br><span class="line">free(p);/* and free the list item. */</span><br><span class="line"> </span><br><span class="line">fclose(stream);/* The SUSv3 example code ignores the return. */</span><br><span class="line"> </span><br><span class="line">/* SUSv3 specificly requires that pclose not return before the child</span><br><span class="line"> * terminates, in order to disallow pclose from returning on EINTR. */</span><br><span class="line">do &#123;</span><br><span class="line">if (waitpid(pid, &amp;stat, 0) &gt;= 0) &#123; //等待子进程返回。获取返回值。</span><br><span class="line">return stat;</span><br><span class="line">&#125;</span><br><span class="line">if (errno != EINTR) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125; while (1);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>举例附上：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">FILE *fp = NULL;</span><br><span class="line">char buf[1024] = &quot;&quot;;</span><br><span class="line"> </span><br><span class="line">fp = popen(&quot;ls -al&quot;, &quot;r&quot;);</span><br><span class="line">if(fp == NULL)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;popen error\n&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">while(fgets(buf, sizeof(buf), fp) != 0)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%s\n&quot;, buf);</span><br><span class="line">memset(buf, 0x0, sizeof(buf));</span><br><span class="line">&#125;</span><br><span class="line">pclose(fp);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;1-Popen的应用场景&quot;&gt;&lt;a href=&quot;#1-Popen的应用场景&quot; class=&quot;headerlink&quot; title=&quot;1.Popen的应用场景&quot;&gt;&lt;/a&gt;1.Popen的应用场景&lt;/h5&gt;&lt;p&gt;popen应用于执行shell命令，并读取此命令的返值，或者与执行的命令进行交互。&lt;/p&gt;
    
    </summary>
    
    
      <category term="系统函数&amp;库函数" scheme="http://www.faihung.net/categories/%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0-%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="popen" scheme="http://www.faihung.net/tags/popen/"/>
    
  </entry>
  
  <entry>
    <title>工程设计-软件升级之设备端版本号管理(2)</title>
    <link href="http://www.faihung.net/2019/12/22/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E8%BD%AF%E4%BB%B6%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%AE%BE%E5%A4%87%E7%AB%AF%E7%89%88%E6%9C%AC%E5%8F%B7%E7%AE%A1%E7%90%86-2/"/>
    <id>http://www.faihung.net/2019/12/22/工程设计-软件升级之设备端版本号管理-2/</id>
    <published>2019-12-22T14:44:26.000Z</published>
    <updated>2019-12-29T15:50:44.020Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于版本号管理，之前升级都是在嵌入式设备中移植一个微型服务器，然后通过web端进行升级。现在是设备作为客户端向http发送版本号，http发送下载指令，设备端再想ftp服务器请求下载文件。所以思维方式要转换一下。<br>并且预期忘版本号的管理符合git库版本管理规则。</p></blockquote><a id="more"></a><h5 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h5><p>服务器只有一个，而设备却有很多种，且分布在全国各地，各个地方情况不一样。<br>有的地方因为设备或者其它原因，软件不需要更新。<br>有的设备因为硬件与软件兼容性问题，只能升级特定的版本。<br>所以远程升级必须需要满足下面两种情况。</p><h5 id="二、远程升级满足下面两种情况"><a href="#二、远程升级满足下面两种情况" class="headerlink" title="二、远程升级满足下面两种情况"></a>二、远程升级满足下面两种情况</h5><h6 id="2-1-后台服务器的手动升级-暴力升级"><a href="#2-1-后台服务器的手动升级-暴力升级" class="headerlink" title="2.1 后台服务器的手动升级(暴力升级)"></a>2.1 后台服务器的手动升级(暴力升级)</h6><h6 id="2-2-设备端的自动升级"><a href="#2-2-设备端的自动升级" class="headerlink" title="2.2 设备端的自动升级"></a>2.2 设备端的自动升级</h6><p>参考：<img src="/2019/12/22/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E8%BD%AF%E4%BB%B6%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%AE%BE%E5%A4%87%E7%AB%AF%E7%89%88%E6%9C%AC%E5%8F%B7%E7%AE%A1%E7%90%86-2/1.png" alt="1"></p><h5 id="三、关于版本号管控"><a href="#三、关于版本号管控" class="headerlink" title="三、关于版本号管控"></a>三、关于版本号管控</h5><p>版本号管控或称三段式管控，形如：3.000.00000，3.100.10000,以10进制字符串的方式体现出来。（关于版本号的管控也可以按照设备发送的地方进行管控。按照时间来进行版本号回退管理，按照空间(发货地点)来进行分支进退管理。）</p><p>注意：16进制数据和字符串型数据容易混淆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HISI_APP:3.01.0001 </span><br><span class="line">16进制方式：(0x03 0x2e 0x00 0x01 0x2e 0x00 0x00 0x00 0x01) </span><br><span class="line">字符串方式：(0x33 0x2e 0x30 0x31 0x2e 0x30 0x30 0x30 0x31)</span><br></pre></td></tr></table></figure><h6 id="3-1-第3段—-00001，子功能升级-amp-BUG的修改（软件对应子功能添加-amp-BUG的修改的升级）"><a href="#3-1-第3段—-00001，子功能升级-amp-BUG的修改（软件对应子功能添加-amp-BUG的修改的升级）" class="headerlink" title="3.1 第3段—-00001，子功能升级&amp;BUG的修改（软件对应子功能添加&amp;BUG的修改的升级）"></a>3.1 第3段—-00001，子功能升级&amp;BUG的修改（软件对应子功能添加&amp;BUG的修改的升级）</h6><p>从文本文件中读取的’.’后面的第一位，为1表示该不可以升级，为0表示该段程序可以升级。</p><p>之后的4位，表示版本号的范围：0000-9999。</p><p>关于兼容性：修改bug有9999种版本完全够用，可能还没有达到这么多，就进入了系列升级。</p><h6 id="3-2-第2段—-001，产品系列的升级（软件对应硬件方面的升级）"><a href="#3-2-第2段—-001，产品系列的升级（软件对应硬件方面的升级）" class="headerlink" title="3.2 第2段—-001，产品系列的升级（软件对应硬件方面的升级）"></a>3.2 第2段—-001，产品系列的升级（软件对应硬件方面的升级）</h6><p>从文本文件中读取的’.’后面的第一位，为1表示该不可以升级，为0表示该段程序可以升级。</p><p>之后的2位，表示版本号的范围：00-99</p><p>关于兼容性：修改bug有99种版本完全够用，可能还没有达到这么多，就进入了换代升级</p><h6 id="3-3-第1段—-3，产品的换代升级（软件对应产品发布方面的升级）"><a href="#3-3-第1段—-3，产品的换代升级（软件对应产品发布方面的升级）" class="headerlink" title="3.3 第1段—-3，产品的换代升级（软件对应产品发布方面的升级）"></a>3.3 第1段—-3，产品的换代升级（软件对应产品发布方面的升级）</h6>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;关于版本号管理，之前升级都是在嵌入式设备中移植一个微型服务器，然后通过web端进行升级。现在是设备作为客户端向http发送版本号，http发送下载指令，设备端再想ftp服务器请求下载文件。所以思维方式要转换一下。&lt;br&gt;并且预期忘版本号的管理符合git库版本管理规则。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="工程设计" scheme="http://www.faihung.net/categories/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="FTP" scheme="http://www.faihung.net/tags/FTP/"/>
    
      <category term="流程图" scheme="http://www.faihung.net/tags/%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    
      <category term="http" scheme="http://www.faihung.net/tags/http/"/>
    
      <category term="版本号" scheme="http://www.faihung.net/tags/%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>C语言-函数返回局部变量的几种方式</title>
    <link href="http://www.faihung.net/2019/12/15/C%E8%AF%AD%E8%A8%80-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.faihung.net/2019/12/15/C语言-函数返回局部变量的几种方式/</id>
    <published>2019-12-15T04:46:13.000Z</published>
    <updated>2019-12-18T10:53:21.032Z</updated>
    
    <content type="html"><![CDATA[<p>一般的来说，函数是可以返回局部变量的。</p><p>局部变量的作用域只在函数内部，在函数返回后，局部变量的内存已经释放了。</p><p>因此，如果函数返回的是局部变量的值，不涉及地址，程序不会出错。</p><p>但是如果返回的是局部变量的地址(指针)的话，程序运行后会出错。</p><p>因为函数只是把指针复制后返回了，但是指针指向的内容已经被释放了，这样指针指向的内容就是不可预料的内容，调用就会出错。</p><p>准确的来说，函数不能通过返回指向栈内存的指针(注意这里指的是栈，返回指向堆内存的指针是可以的)。</p><a id="more"></a><p>下面以函数返回局部变量的指针举几个典型的例子来说明：</p><h5 id="1-字符串常量’hello-world’，存放在只读数据段"><a href="#1-字符串常量’hello-world’，存放在只读数据段" class="headerlink" title="1. 字符串常量’hello world’，存放在只读数据段"></a>1. 字符串常量’hello world’，存放在只读数据段</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;   </span><br><span class="line">char *returnStr()   </span><br><span class="line">&#123;   </span><br><span class="line">    char *p=&quot;hello world!&quot;;   </span><br><span class="line">    return p;   </span><br><span class="line">&#125;   </span><br><span class="line">int main()   </span><br><span class="line">&#123;   </span><br><span class="line">    char *str;   </span><br><span class="line">    str=returnStr();   </span><br><span class="line">    printf(&quot;%s\n&quot;, str);   </span><br><span class="line">    return 0;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个没有任何问题，因为”hello world!”是一个字符串常量，存放在只读数据段，把该字符串常量存放的只读数据段的首地址赋值给了指针，所以returnStr函数退出时，该该字符串常量所在内存不会被回收，故能够通过指针顺利无误的访问。</p><h5 id="2-局部变量’hello-world’存放在栈中"><a href="#2-局部变量’hello-world’存放在栈中" class="headerlink" title="2. 局部变量’hello world’存放在栈中"></a>2. 局部变量’hello world’存放在栈中</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;   </span><br><span class="line"></span><br><span class="line">char *returnStr()   </span><br><span class="line">&#123;   </span><br><span class="line">    char p[]=&quot;hello world!&quot;;   </span><br><span class="line">    return p;   </span><br><span class="line">&#125;   </span><br><span class="line">int main()   </span><br><span class="line">&#123;   </span><br><span class="line">    char *str;   </span><br><span class="line">    str=returnStr();   </span><br><span class="line">    printf(&quot;%s\n&quot;, str);   </span><br><span class="line">    return 0;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“hello world!”是局部变量存放在栈中。当returnStr函数退出时，栈要清空，局部变量的内存也被清空了，所以这时的函数返回的是一个已被释放的内存地址，所以有可能打印出来的是乱码。 </p><h5 id="3-局部变量（实参与型参）、地址（指针）栈（指向内存的释放）、静态变量地址（指针）的生存周期"><a href="#3-局部变量（实参与型参）、地址（指针）栈（指向内存的释放）、静态变量地址（指针）的生存周期" class="headerlink" title="3. 局部变量（实参与型参）、地址（指针）栈（指向内存的释放）、静态变量地址（指针）的生存周期"></a>3. 局部变量（实参与型参）、地址（指针）栈（指向内存的释放）、静态变量地址（指针）的生存周期</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int func()  </span><br><span class="line">&#123;  </span><br><span class="line">      int a;  </span><br><span class="line">      ....  </span><br><span class="line">      return a;    //允许  </span><br><span class="line">&#125;                     </span><br><span class="line">  </span><br><span class="line">int * func()  </span><br><span class="line">&#123;  </span><br><span class="line">      int a;  </span><br><span class="line">      ....  </span><br><span class="line">      return &amp;a;    //无意义，不应该这样做  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部变量也分局部自动变量和局部静态变量，由于a返回的是值，因此返回一个局部变量是可以的，无论自动还是静态，因为这时候返回的是这个局部变量的值。</p><p>但不应该返回指向局部自动变量的指针，因为函数调用结束后该局部自动变量<br>被抛弃，这个指针指向一个不再存在的对象，是无意义的。</p><p>但可以返回指向局部静态变量的指针，因为静态变量的生存期从定义起到程序结束。</p><h5 id="4-如果函数的返回值非要是一个局部变量的地址，那么该局部变量一定要申明为static类型。"><a href="#4-如果函数的返回值非要是一个局部变量的地址，那么该局部变量一定要申明为static类型。" class="headerlink" title="4. 如果函数的返回值非要是一个局部变量的地址，那么该局部变量一定要申明为static类型。"></a>4. 如果函数的返回值非要是一个局部变量的地址，那么该局部变量一定要申明为static类型。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;   </span><br><span class="line">char *returnStr()   </span><br><span class="line">&#123;   </span><br><span class="line">    static char p[]=&quot;hello world!&quot;;   </span><br><span class="line">    return p;   </span><br><span class="line">&#125;   </span><br><span class="line">int main()   </span><br><span class="line">&#123;   </span><br><span class="line">    char *str;   </span><br><span class="line">    str=returnStr();   </span><br><span class="line">    printf(&quot;%s\n&quot;, str);   </span><br><span class="line">  </span><br><span class="line">    return 0;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-数组是不能作为函数的返回值的，原因是编译器把数组名认为是局部变量（数组）的地址。返回一个数组一般用返回指向这个数组的指针代替，而且这个指针不能指向一个自动数组，因为函数结束后自动数组被抛弃，但可以返回一个指向静态局部数组的指针，因为静态存储期是从对象定义到程序结束的。"><a href="#5-数组是不能作为函数的返回值的，原因是编译器把数组名认为是局部变量（数组）的地址。返回一个数组一般用返回指向这个数组的指针代替，而且这个指针不能指向一个自动数组，因为函数结束后自动数组被抛弃，但可以返回一个指向静态局部数组的指针，因为静态存储期是从对象定义到程序结束的。" class="headerlink" title="5. 数组是不能作为函数的返回值的，原因是编译器把数组名认为是局部变量（数组）的地址。返回一个数组一般用返回指向这个数组的指针代替，而且这个指针不能指向一个自动数组，因为函数结束后自动数组被抛弃，但可以返回一个指向静态局部数组的指针，因为静态存储期是从对象定义到程序结束的。"></a>5. 数组是不能作为函数的返回值的，原因是编译器把数组名认为是局部变量（数组）的地址。返回一个数组一般用返回指向这个数组的指针代替，而且这个指针不能指向一个自动数组，因为函数结束后自动数组被抛弃，但可以返回一个指向静态局部数组的指针，因为静态存储期是从对象定义到程序结束的。</h5><p>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int* func( void )  </span><br><span class="line">&#123;  </span><br><span class="line">    static int a[10];  </span><br><span class="line">    ........  </span><br><span class="line">    return a;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-返回指向堆内存的指针是可以的"><a href="#6-返回指向堆内存的指针是可以的" class="headerlink" title="6. 返回指向堆内存的指针是可以的"></a>6. 返回指向堆内存的指针是可以的</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">char *GetMemory3(int num)  </span><br><span class="line">&#123;  </span><br><span class="line">    char *p = (char *)malloc(sizeof(char) * num);  </span><br><span class="line">    return p;  </span><br><span class="line">&#125;  </span><br><span class="line">void Test3(void)  </span><br><span class="line">&#123;  </span><br><span class="line">    char *str = NULL;  </span><br><span class="line">    str = GetMemory3(100);  </span><br><span class="line">    strcpy(str, &quot;hello&quot;);  </span><br><span class="line">    cout&lt;&lt; str &lt;&lt; endl;  </span><br><span class="line">    free(str);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序在运行的时候用 malloc 申请任意多少的内存,程序员自己负责在何时用 free释放内存。动态内存的生存期由程序员自己决定,使用非常灵活。</p><h5 id="7-通过局部变量在另一个函数去取值-传一个地址，用指针变量来接收，用指针来指向一个值"><a href="#7-通过局部变量在另一个函数去取值-传一个地址，用指针变量来接收，用指针来指向一个值" class="headerlink" title="7. 通过局部变量在另一个函数去取值(传一个地址，用指针变量来接收，用指针来指向一个值)"></a>7. 通过局部变量在另一个函数去取值(传一个地址，用指针变量来接收，用指针来指向一个值)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void get_value(int* Temp)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;2:0x%x\n&quot;,Temp);</span><br><span class="line">    *Temp = 6;</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    int temp;</span><br><span class="line">    printf(&quot;1:0x%x\n&quot;,&amp;temp);</span><br><span class="line">    </span><br><span class="line">    get_value(&amp;temp);</span><br><span class="line">    printf(&quot;3:%d\n&quot;,temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-通过局部变量数组在另一个函数去取值-传一个地址，用指针变量来接收，用指针来指向一个值"><a href="#8-通过局部变量数组在另一个函数去取值-传一个地址，用指针变量来接收，用指针来指向一个值" class="headerlink" title="8. 通过局部变量数组在另一个函数去取值(传一个地址，用指针变量来接收，用指针来指向一个值)"></a>8. 通过局部变量数组在另一个函数去取值(传一个地址，用指针变量来接收，用指针来指向一个值)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void get_value(char * ptemp)</span><br><span class="line">&#123;</span><br><span class="line">char i;</span><br><span class="line">    printf(&quot;2:0x%x\n&quot;,ptemp);</span><br><span class="line">    ptemp = &quot;hello world!&quot;;//这样不行，字符串常量放在只读数据段，和主函数中的temp局部数据区域有冲突</span><br><span class="line"></span><br><span class="line">printf(&quot;3:%s\n&quot;,ptemp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char temp[13]=&#123;0&#125;;</span><br><span class="line">    printf(&quot;1:0x%x\n&quot;,temp);</span><br><span class="line">    </span><br><span class="line">    get_value(temp);</span><br><span class="line"></span><br><span class="line">    printf(&quot;4:%s\n&quot;,temp);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2019/12/15/C%E8%AF%AD%E8%A8%80-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/1.png" alt="1"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void get_value(char * ptemp)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;2:0x%x\n&quot;,ptemp);</span><br><span class="line">    for(char i=0;i&lt;13;i++)//这样可以，temp和ptemp都在栈函数数据区域中，main函数调用get_value，get_value会先释放，但是temp申请的内存空间，此时并没有释放，所以可以拿到值。</span><br><span class="line">&#123;</span><br><span class="line">ptemp[i] = &apos;h&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;3:%s\n&quot;,ptemp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char temp[13]=&#123;0&#125;;</span><br><span class="line">    printf(&quot;1:0x%x\n&quot;,temp);</span><br><span class="line">    </span><br><span class="line">    get_value(temp);</span><br><span class="line"></span><br><span class="line">    printf(&quot;4:%s\n&quot;,temp);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2019/12/15/C%E8%AF%AD%E8%A8%80-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/2.png" alt="2"></p><h5 id="9-通过结构体类型的局部变量数组在另一个函数去取值-传一个结构体变量的地址，用指针变量来接收，用指针来指向一个值"><a href="#9-通过结构体类型的局部变量数组在另一个函数去取值-传一个结构体变量的地址，用指针变量来接收，用指针来指向一个值" class="headerlink" title="9. 通过结构体类型的局部变量数组在另一个函数去取值(传一个结构体变量的地址，用指针变量来接收，用指针来指向一个值)"></a>9. 通过结构体类型的局部变量数组在另一个函数去取值(传一个结构体变量的地址，用指针变量来接收，用指针来指向一个值)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">char hisi_app[9];</span><br><span class="line">char sys_lib[9];</span><br><span class="line">char mb_mcu[9];</span><br><span class="line">char mcu_4g[9];</span><br><span class="line">char mcu_1256[9];</span><br><span class="line">char device[7];</span><br><span class="line">&#125;file_ver_t;</span><br><span class="line"></span><br><span class="line">void read_file_version(file_ver_t *pfile_ver)</span><br><span class="line">&#123;</span><br><span class="line">memset(pfile_ver-&gt;hisi_app,0,9);</span><br><span class="line">memcpy(pfile_ver-&gt;hisi_app,&quot;3.01.0001&quot;,9);</span><br><span class="line">printf(&quot;%s\n&quot;, pfile_ver-&gt;hisi_app);</span><br><span class="line">memcpy(pfile_ver-&gt;sys_lib,&quot;3.01.0001&quot;,9);</span><br><span class="line">printf(&quot;%s\n&quot;, pfile_ver-&gt;sys_lib);</span><br><span class="line">memcpy(pfile_ver-&gt;mb_mcu,&quot;3.01.0001&quot;,9);</span><br><span class="line">printf(&quot;%s\n&quot;, pfile_ver-&gt;mb_mcu);</span><br><span class="line">memcpy(pfile_ver-&gt;mcu_4g,&quot;3.01.0001&quot;,9);</span><br><span class="line">printf(&quot;%s\n&quot;, pfile_ver-&gt;mcu_4g);</span><br><span class="line">memcpy(pfile_ver-&gt;mcu_1256,&quot;3.01.0001&quot;,9);</span><br><span class="line">printf(&quot;%s\n&quot;, pfile_ver-&gt;mcu_1256);</span><br><span class="line">memcpy(pfile_ver-&gt;device,&quot;1.00.00&quot;,7);</span><br><span class="line">printf(&quot;%s\n&quot;, pfile_ver-&gt;device);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">file_ver_t file_ver;</span><br><span class="line">read_file_version(&amp;file_ver);</span><br><span class="line"></span><br><span class="line">printf(&quot;%s\n&quot;, file_ver.hisi_app);</span><br><span class="line">printf(&quot;%s\n&quot;, file_ver.sys_lib);</span><br><span class="line">printf(&quot;%s\n&quot;, file_ver.mb_mcu);</span><br><span class="line">printf(&quot;%s\n&quot;, file_ver.mcu_4g);</span><br><span class="line">printf(&quot;%s\n&quot;, file_ver.mcu_1256);</span><br><span class="line">printf(&quot;%s\n&quot;, file_ver.device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2019/12/15/C%E8%AF%AD%E8%A8%80-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/3.png" alt="3"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般的来说，函数是可以返回局部变量的。&lt;/p&gt;
&lt;p&gt;局部变量的作用域只在函数内部，在函数返回后，局部变量的内存已经释放了。&lt;/p&gt;
&lt;p&gt;因此，如果函数返回的是局部变量的值，不涉及地址，程序不会出错。&lt;/p&gt;
&lt;p&gt;但是如果返回的是局部变量的地址(指针)的话，程序运行后会出错。&lt;/p&gt;
&lt;p&gt;因为函数只是把指针复制后返回了，但是指针指向的内容已经被释放了，这样指针指向的内容就是不可预料的内容，调用就会出错。&lt;/p&gt;
&lt;p&gt;准确的来说，函数不能通过返回指向栈内存的指针(注意这里指的是栈，返回指向堆内存的指针是可以的)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://www.faihung.net/categories/C/"/>
    
    
      <category term="指针" scheme="http://www.faihung.net/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="局部变量" scheme="http://www.faihung.net/tags/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"/>
    
      <category term="生存周期" scheme="http://www.faihung.net/tags/%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F/"/>
    
      <category term="内存分配" scheme="http://www.faihung.net/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
      <category term="数组取值" scheme="http://www.faihung.net/tags/%E6%95%B0%E7%BB%84%E5%8F%96%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>问题-notepadd++  ANSI编码与UTF-8编码</title>
    <link href="http://www.faihung.net/2019/12/15/%E9%97%AE%E9%A2%98-notepadd-ANSI%E7%BC%96%E7%A0%81%E4%B8%8EUTF-8%E7%BC%96%E7%A0%81/"/>
    <id>http://www.faihung.net/2019/12/15/问题-notepadd-ANSI编码与UTF-8编码/</id>
    <published>2019-12-14T16:33:10.000Z</published>
    <updated>2019-12-14T16:36:13.899Z</updated>
    
    <content type="html"><![CDATA[<p>之前有一种见鬼的感觉，主要表现在写脚本上（写脚本主要是因为空格的原因），写程序倒是不会出现。结果导致脚本执行不成功。</p><a id="more"></a><p>使用UTF-8编码</p><p><img src="/2019/12/15/%E9%97%AE%E9%A2%98-notepadd-ANSI%E7%BC%96%E7%A0%81%E4%B8%8EUTF-8%E7%BC%96%E7%A0%81/1.png" alt="1"></p><p>使用ANSI编码</p><p><img src="/2019/12/15/%E9%97%AE%E9%A2%98-notepadd-ANSI%E7%BC%96%E7%A0%81%E4%B8%8EUTF-8%E7%BC%96%E7%A0%81/2.png" alt="2"></p><p>这种情况要记住，以后不要在这上面浪费时间了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前有一种见鬼的感觉，主要表现在写脚本上（写脚本主要是因为空格的原因），写程序倒是不会出现。结果导致脚本执行不成功。&lt;/p&gt;
    
    </summary>
    
    
      <category term="问题" scheme="http://www.faihung.net/categories/%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="notepadd" scheme="http://www.faihung.net/tags/notepadd/"/>
    
      <category term="UTF-8" scheme="http://www.faihung.net/tags/UTF-8/"/>
    
      <category term="ANSI" scheme="http://www.faihung.net/tags/ANSI/"/>
    
  </entry>
  
  <entry>
    <title>工程设计-html boa cgi上传文件</title>
    <link href="http://www.faihung.net/2019/12/15/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-html-boa-cgi%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"/>
    <id>http://www.faihung.net/2019/12/15/工程设计-html-boa-cgi上传文件/</id>
    <published>2019-12-14T16:20:25.000Z</published>
    <updated>2019-12-14T16:21:48.864Z</updated>
    
    <content type="html"><![CDATA[<p>暂略</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;暂略&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="工程设计" scheme="http://www.faihung.net/categories/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="html" scheme="http://www.faihung.net/tags/html/"/>
    
      <category term="boa" scheme="http://www.faihung.net/tags/boa/"/>
    
      <category term="cgi" scheme="http://www.faihung.net/tags/cgi/"/>
    
  </entry>
  
  <entry>
    <title>工程设计-软件升级之设备端FTP文件上传与下载(1)</title>
    <link href="http://www.faihung.net/2019/12/14/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E8%BD%AF%E4%BB%B6%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%AE%BE%E5%A4%87%E7%AB%AFFTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD-1/"/>
    <id>http://www.faihung.net/2019/12/14/工程设计-软件升级之设备端FTP文件上传与下载-1/</id>
    <published>2019-12-14T15:25:12.000Z</published>
    <updated>2019-12-29T15:50:10.674Z</updated>
    
    <content type="html"><![CDATA[<h4 id="主要目的"><a href="#主要目的" class="headerlink" title="主要目的"></a>主要目的</h4><h5 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h5><h6 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h6><p>av_streamer input_streamer output_app</p><a id="more"></a><h6 id="系统库"><a href="#系统库" class="headerlink" title="系统库"></a>系统库</h6><p>libapp_para.so<br>libntptime.so<br>libsys_commom.so<br>libsys_serial.so<br>libdevsdk.so<br>librtmp_push.so<br>libsys_httppro.so<br>libdhclient.so<br>librtsp.so<br>libsys_media.so<br>libnnie_ai.so<br>libsys_base.so<br>libsys_mp4_storage.so</p><h6 id="MCU程序"><a href="#MCU程序" class="headerlink" title="MCU程序"></a>MCU程序</h6><p>和上面类似（略）</p><h5 id="上传日志"><a href="#上传日志" class="headerlink" title="上传日志"></a>上传日志</h5><p>程序运行记录（略）</p><h4 id="第一阶段-正常环境下"><a href="#第一阶段-正常环境下" class="headerlink" title="第一阶段-正常环境下"></a>第一阶段-正常环境下</h4><p>还是直接看图比较直观。<br><img src="/2019/12/14/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E8%BD%AF%E4%BB%B6%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%AE%BE%E5%A4%87%E7%AB%AFFTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD-1/1.png" alt="1"></p><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p><a href="https://github.com/faihung/cURL" target="_blank" rel="noopener">参考代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;主要目的&quot;&gt;&lt;a href=&quot;#主要目的&quot; class=&quot;headerlink&quot; title=&quot;主要目的&quot;&gt;&lt;/a&gt;主要目的&lt;/h4&gt;&lt;h5 id=&quot;下载文件&quot;&gt;&lt;a href=&quot;#下载文件&quot; class=&quot;headerlink&quot; title=&quot;下载文件&quot;&gt;&lt;/a&gt;下载文件&lt;/h5&gt;&lt;h6 id=&quot;应用程序&quot;&gt;&lt;a href=&quot;#应用程序&quot; class=&quot;headerlink&quot; title=&quot;应用程序&quot;&gt;&lt;/a&gt;应用程序&lt;/h6&gt;&lt;p&gt;av_streamer input_streamer output_app&lt;/p&gt;
    
    </summary>
    
    
      <category term="工程设计" scheme="http://www.faihung.net/categories/%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="cURL" scheme="http://www.faihung.net/tags/cURL/"/>
    
      <category term="FTP" scheme="http://www.faihung.net/tags/FTP/"/>
    
      <category term="流程图" scheme="http://www.faihung.net/tags/%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    
      <category term="http" scheme="http://www.faihung.net/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>cURL-09_使用curl库进行http通信(转)</title>
    <link href="http://www.faihung.net/2019/12/12/cURL-09-%E4%BD%BF%E7%94%A8curl%E5%BA%93%E8%BF%9B%E8%A1%8Chttp%E9%80%9A%E4%BF%A1-%E8%BD%AC/"/>
    <id>http://www.faihung.net/2019/12/12/cURL-09-使用curl库进行http通信-转/</id>
    <published>2019-12-12T07:37:14.000Z</published>
    <updated>2019-12-12T07:38:23.583Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一、LibCurl基本编程框架"><a href="#一、LibCurl基本编程框架" class="headerlink" title="一、LibCurl基本编程框架"></a>一、LibCurl基本编程框架</h5><p>关于libcurl，<a href="https://www.faihung.net/2019/11/03/cURL-01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BA%86%E8%A7%A3/">前面已经有了很多介绍</a>，这里就不详西描述了。</p><p>在基于LibCurl的程序里，主要采用callback function （回调函数）的形式完成传输任务，用户在启动传输前设置好各类参数和回调函数，当满足条件时libcurl将调用用户的回调函数实现特定功能。</p><a id="more"></a><p>下面是利用libcurl完成传输任务的流程：</p><ol><li>调用curl_global_init()初始化libcurl</li><li>调用curl_easy_init()函数得到 easy interface 型指针</li><li>调用curl_easy_setopt()设置传输选项</li><li>根据curl_easy_setopt()设置的传输选项，实现回调函数以完成用户特定任务</li><li>调用curl_easy_perform()函数完成传输任务</li><li>调用curl_easy_cleanup()释放内存</li></ol><p>在整过过程中设置curl_easy_setopt()参数是最关键的，几乎所有的libcurl程序都要使用它。</p><h5 id="二、一些基本的函数"><a href="#二、一些基本的函数" class="headerlink" title="二、一些基本的函数"></a>二、一些基本的函数</h5><h6 id="1-CURLcode-curl-global-init-long-flags"><a href="#1-CURLcode-curl-global-init-long-flags" class="headerlink" title="1.CURLcode curl_global_init(long flags);"></a>1.CURLcode curl_global_init(long flags);</h6><p>描述：<br>这个函数只能用一次。(其实在调用curl_global_cleanup 函数后仍然可再用)<br>如果这个函数在curl_easy_init函数调用时还没调用，它将由libcurl库自动调用，所以多线程下最好主动调用该函数以防止在线程中curl_easy_init时多次调用。</p><p>注意：虽然libcurl是线程安全的，但curl_global_init是不能保证线程安全的，所以不要在每个线程中都调用curl_global_init，应该将该函数的调用放在主线程中。</p><p>参数：flags</p><pre><code>CURL_GLOBAL_ALL             //初始化所有的可能的调用。CURL_GLOBAL_SSL             //初始化支持安全套接字层。CURL_GLOBAL_WIN32           //初始化win32套接字库。CURL_GLOBAL_NOTHING         //没有额外的初始化。</code></pre><h6 id="2-void-curl-global-cleanup-void"><a href="#2-void-curl-global-cleanup-void" class="headerlink" title="2 void curl_global_cleanup(void);"></a>2 void curl_global_cleanup(void);</h6><p>描述：在结束libcurl使用的时候，用来对curl_global_cleanup做的工作清理。类似于close的函数。</p><p>注意：虽然libcurl是线程安全的，但curl_global_cleanup是不能保证线程安全的，所以不要在每个线程中都调用curl_global_init，应该将该函数的调用放在主线程中。</p><h6 id="3-char-curl-version"><a href="#3-char-curl-version" class="headerlink" title="3 char *curl_version( );"></a>3 char *curl_version( );</h6><p>描述: 打印当前libcurl库的版本。</p><h6 id="4-CURL-curl-easy-init"><a href="#4-CURL-curl-easy-init" class="headerlink" title="4 CURL *curl_easy_init( );"></a>4 CURL *curl_easy_init( );</h6><p>描述:<br>curl_easy_init用来初始化一个CURL的指针(有些像返回FILE类型的指针一样). 相应的在调用结束时要用curl_easy_cleanup函数清理.<br>一般curl_easy_init意味着一个会话的开始. 它会返回一个easy_handle(CURL*对象), 一般都用在easy系列的函数中.</p><h6 id="5-void-curl-easy-cleanup-CURL-handle"><a href="#5-void-curl-easy-cleanup-CURL-handle" class="headerlink" title="5 void curl_easy_cleanup(CURL *handle);"></a>5 void curl_easy_cleanup(CURL *handle);</h6><p>描述:<br>这个调用用来结束一个会话，curl_easy_init配合着用。</p><p>参数:<br>CURL类型的指针.</p><h6 id="6-CURLcode-curl-easy-setopt-CURL-handle-CURLoption-option-parameter"><a href="#6-CURLcode-curl-easy-setopt-CURL-handle-CURLoption-option-parameter" class="headerlink" title="6 CURLcode curl_easy_setopt(CURL *handle, CURLoption option, parameter);"></a>6 CURLcode curl_easy_setopt(CURL *handle, CURLoption option, parameter);</h6><p>描述: 这个函数最重要了.几乎所有的curl程序都要频繁的使用它.它告诉curl库.程序将有如何的行为. 比如要查看一个网页的html代码等.(这个函数有些像ioctl函数)参数:</p><ol><li>CURL类型的指针。</li><li>各种CURLoption类型的选项.(都在curl.h库里有定义,man也可以查看到)</li><li>parameter 这个参数既可以是个函数的指针,也可以是某个对象的指针,也可以是个long型的变量.它用什么这取决于第二个参数。<br>CURLoption 这个参数的取值很多.具体的可以查看man手册。</li></ol><h6 id="7-CURLcode-curl-easy-perform-CURL-handle"><a href="#7-CURLcode-curl-easy-perform-CURL-handle" class="headerlink" title="7 CURLcode curl_easy_perform(CURL *handle);"></a>7 CURLcode curl_easy_perform(CURL *handle);</h6><p>描述:这个函数在初始化CURL类型的指针 以及curl_easy_setopt完成后调用.就像字面的意思所说perform就像是个舞台，让我们设置的<br>option 运作起来.</p><p>参数:<br>CURL类型的指针。</p><h5 id="三、curl-easy-setopt函数部分选项介绍"><a href="#三、curl-easy-setopt函数部分选项介绍" class="headerlink" title="三、curl_easy_setopt函数部分选项介绍"></a>三、curl_easy_setopt函数部分选项介绍</h5><p>本节主要介绍curl_easy_setopt中跟http相关的参数。该函数是curl中非常重要的函数，curl所有设置都是在该函数中完成的，该函数的设置选项众多，注意本节的阐述的只是部分常见选项。</p><h6 id="1-CURLOPT-URL"><a href="#1-CURLOPT-URL" class="headerlink" title="1.CURLOPT_URL"></a>1.CURLOPT_URL</h6><p>设置访问URL</p><h6 id="2-CURLOPT-WRITEFUNCTION，CURLOPT-WRITEDATA"><a href="#2-CURLOPT-WRITEFUNCTION，CURLOPT-WRITEDATA" class="headerlink" title="2.CURLOPT_WRITEFUNCTION，CURLOPT_WRITEDATA"></a>2.CURLOPT_WRITEFUNCTION，CURLOPT_WRITEDATA</h6><p>回调函数原型为：</p><pre><code>size_t function( void *ptr, size_t size, size_t nmemb, void *stream);</code></pre><p>函数将在libcurl接收到数据后被调用，因此函数多做数据保存的功能，如处理下载文件。</p><p>CURLOPT_WRITEDATA 用于表明CURLOPT_WRITEFUNCTION函数中的stream指针的来源。<br>如果你没有通过CURLOPT_WRITEFUNCTION属性给easy handle设置回调函数，libcurl会提供一个默认的回调函数，它只是简单的将接收到的数据打印到标准输出。你也可以通过 CURLOPT_WRITEDATA属性给默认回调函数传递一个已经打开的文件指针，用于将数据输出到文件里。</p><h6 id="3-CURLOPT-HEADERFUNCTION，CURLOPT-HEADERDATA"><a href="#3-CURLOPT-HEADERFUNCTION，CURLOPT-HEADERDATA" class="headerlink" title="3.CURLOPT_HEADERFUNCTION，CURLOPT_HEADERDATA"></a>3.CURLOPT_HEADERFUNCTION，CURLOPT_HEADERDATA</h6><p>回调函数原型为 </p><pre><code>size_t function( void *ptr, size_t size,size_t nmemb, void *stream);</code></pre><p>libcurl一旦接收到http 头部数据后将调用该函数。CURLOPT_WRITEDATA 传递指针给libcurl，该指针表明CURLOPT_HEADERFUNCTION函数的stream指针的来源。</p><h6 id="4-CURLOPT-READFUNCTION-CURLOPT-READDATA"><a href="#4-CURLOPT-READFUNCTION-CURLOPT-READDATA" class="headerlink" title="4.CURLOPT_READFUNCTION CURLOPT_READDATA"></a>4.CURLOPT_READFUNCTION CURLOPT_READDATA</h6><p>libCurl需要读取数据传递给远程主机时将调用CURLOPT_READFUNCTION指定的函数，函数原型是：</p><pre><code>size_t function(void *ptr, size_t size, size_t nmemb,void *stream)；</code></pre><p>CURLOPT_READDATA 表明CURLOPT_READFUNCTION函数原型中的stream指针来源。</p><h6 id="5-CURLOPT-NOPROGRESS，CURLOPT-PROGRESSFUNCTION，CURLOPT-PROGRESSDATA"><a href="#5-CURLOPT-NOPROGRESS，CURLOPT-PROGRESSFUNCTION，CURLOPT-PROGRESSDATA" class="headerlink" title="5.CURLOPT_NOPROGRESS，CURLOPT_PROGRESSFUNCTION，CURLOPT_PROGRESSDATA"></a>5.CURLOPT_NOPROGRESS，CURLOPT_PROGRESSFUNCTION，CURLOPT_PROGRESSDATA</h6><p>跟数据传输进度相关的参数。CURLOPT_PROGRESSFUNCTION指定的函数正常情况下每秒被libcurl调用一次，为了使CURLOPT_PROGRESSFUNCTION被调用，CURLOPT_NOPROGRESS必须被设置为false，CURLOPT_PROGRESSDATA指定的参数将作为CURLOPT_PROGRESSFUNCTION指定函数的第一个参数</p><h6 id="6-CURLOPT-TIMEOUT，CURLOPT-CONNECTIONTIMEOUT"><a href="#6-CURLOPT-TIMEOUT，CURLOPT-CONNECTIONTIMEOUT" class="headerlink" title="6.CURLOPT_TIMEOUT，CURLOPT_CONNECTIONTIMEOUT"></a>6.CURLOPT_TIMEOUT，CURLOPT_CONNECTIONTIMEOUT</h6><p>CURLOPT_TIMEOUT 由于设置传输时间，CURLOPT_CONNECTIONTIMEOUT 设置连接等待时间</p><h6 id="7-CURLOPT-FOLLOWLOCATION"><a href="#7-CURLOPT-FOLLOWLOCATION" class="headerlink" title="7.CURLOPT_FOLLOWLOCATION"></a>7.CURLOPT_FOLLOWLOCATION</h6><p>设置重定位URL</p><h6 id="8-CURLOPT-RANGE-CURLOPT-RESUME-FROM"><a href="#8-CURLOPT-RANGE-CURLOPT-RESUME-FROM" class="headerlink" title="8.CURLOPT_RANGE: CURLOPT_RESUME_FROM:"></a>8.CURLOPT_RANGE: CURLOPT_RESUME_FROM:</h6><p>断点续传相关设置。CURLOPT_RANGE 指定char *参数传递给libcurl，用于指明http域的RANGE头域，</p><p>例如：</p><pre><code>表示头500个字节：bytes=0-499表示第二个500字节：bytes=500-999表示最后500个字节：bytes=-500表示500字节以后的范围：bytes=500-第一个和最后一个字节：bytes=0-0,-1同时指定几个范围：bytes=500-600,601-999</code></pre><p>CURLOPT_RESUME_FROM 传递一个long参数给libcurl，指定你希望开始传递的偏移量。</p><h5 id="四、curl-easy-perform-函数说明（error-状态码）"><a href="#四、curl-easy-perform-函数说明（error-状态码）" class="headerlink" title="四、curl_easy_perform 函数说明（error 状态码）"></a>四、curl_easy_perform 函数说明（error 状态码）</h5><p>该函数是完成curl_easy_setopt指定的所有选项，本节重点介绍curl_easy_perform的返回值。返回0意味一切ok，非0代表错误发生。主要错误码说明：</p><pre><code>1.CURLE_OK任务完成一切都好2.CURLE_UNSUPPORTED_PROTOCOL不支持的协议，由URL的头部指定3.CURLE_COULDNT_CONNECT不能连接到remote 主机或者代理4.CURLE_REMOTE_ACCESS_DENIED访问被拒绝5.CURLE_HTTP_RETURNED_ERRORHttp返回错误6.CURLE_READ_ERROR读本地文件错误</code></pre><p>要获取详细的错误描述字符串，可以通过</p><pre><code>const char *curl_easy_strerror(CURLcode errornum ) </code></pre><p>这个函数取得。    </p><h5 id="五、libcurl使用的HTTP消息头"><a href="#五、libcurl使用的HTTP消息头" class="headerlink" title="五、libcurl使用的HTTP消息头"></a>五、libcurl使用的HTTP消息头</h5><p>当使用libcurl发送http请求时，它会自动添加一些http头。我们可以通过CURLOPT_HTTPHEADER属性手动替换、添加或删除相应 的HTTP消息头。</p><pre><code>Hosthttp1.1（大部分http1.0)版本都要求客户端请求提供这个信息头。Pragma&quot;no-cache&quot;。表示不要缓冲数据。Accept&quot;*/*&quot;。表示允许接收任何类型的数据。Expect以POST的方式向HTTP服务器提交请求时，libcurl会设置该消息头为&quot;100-continue&quot;，它要求服务器在正式处理该请求之前，返回一 个&quot;OK&quot;消息。如果POST的数据很小，libcurl可能不会设置该消息头。</code></pre><p><strong>自定义选项</strong></p><p>当前越来越多的协议都构建在HTTP协议之上（如：soap），这主要归功于HTTP的可靠性，以及被广泛使用的代理支持（可以穿透大部分防火墙）。 这些协议的使用方式与传统HTTP可能有很大的不同。对此，libcurl作了很好的支持。</p><p>自定义请求方式(CustomRequest)，<br>HTTP支持GET, HEAD或者POST提交请求。可以设置CURLOPT_CUSTOMREQUEST来设置自定义的请求方式，libcurl默认以GET方式提交请求：</p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_CUSTOMREQUEST, &quot;MYOWNREQUEST&quot;);</code></pre><p><strong>修改消息头</strong></p><p>HTTP协议提供了消息头，请求消息头用于告诉服务器如何处理请求；响应消息头则告诉浏览器如何处理接收到的数据。在libcurl中，你可以自由的添加这些消息头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct curl_slist *headers=NULL; /* init to NULL is important */</span><br><span class="line">headers = curl_slist_append(headers, &quot;Hey-server-hey: how are you?&quot;);</span><br><span class="line">headers = curl_slist_append(headers, &quot;X-silly-content: yes&quot;);</span><br><span class="line">/* pass our list of custom made headers */</span><br><span class="line">curl_easy_setopt(easyhandle, CURLOPT_HTTPHEADER, headers);</span><br><span class="line">curl_easy_perform(easyhandle); /* transfer http */</span><br><span class="line">curl_slist_free_all(headers); /* free the header list */</span><br></pre></td></tr></table></figure><p>对于已经存在的消息头，可以重新设置它的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">headers = curl_slist_append(headers, &quot;Accept: Agent-007&quot;); </span><br><span class="line">headers = curl_slist_append(headers, &quot;Host: munged.host.line&quot;);</span><br></pre></td></tr></table></figure><p><strong>删除消息头</strong></p><p>对于一个已经存在的消息头，设置它的内容为空，libcurl在发送请求时就不会同时提交该消息头：</p><pre><code>headers = curl_slist_append(headers, &quot;Accept:&quot;);</code></pre><h5 id="六、获取http应答头信息"><a href="#六、获取http应答头信息" class="headerlink" title="六、获取http应答头信息"></a>六、获取http应答头信息</h5><p>发出http请求后，服务器会返回应答头信息和应答数据，如果仅仅是打印应答头的所有内容，则直接可以通过curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, 打印函数)的方式来完成，这里需要获取的是应答头中特定的信息，比如应答码、cookies列表等，则需要通过下面这个函数：</p><pre><code>CURLcode curl_easy_getinfo(CURL *curl, CURLINFO info, ... );</code></pre><p>info参数就是我们需要获取的内容，下面是一些参数值:</p><pre><code>1.CURLINFO_RESPONSE_CODE 获取应答码2.CURLINFO_HEADER_SIZE 头大小3.CURLINFO_COOKIELIST cookies列表</code></pre><p>除了获取应答信息外，这个函数还能获取curl的一些内部信息，如请求时间、连接时间等等。</p><p>更多的参数可以参考API文档。</p><h5 id="七、多线程问题"><a href="#七、多线程问题" class="headerlink" title="七、多线程问题"></a>七、多线程问题</h5><p>首先一个基本原则就是：绝对不应该在线程之间共享同一个libcurl handle(CURL *对象)，不管是easy handle还是multi handle（本文只介绍easy_handle）。一个线程每次只能使用一个handle。</p><p>libcurl是线程安全的，但有两点例外：信号(signals)和SSL/TLS handler。 信号用于超时失效名字解析(timing out name resolves)。libcurl依赖其他的库来支持SSL/STL，所以用多线程的方式访问HTTPS或FTPS的URL时，应该满足这些库对多线程 操作的一些要求。</p><p>NSS: 宣称是多线程安全的。</p><h5 id="八、什么时候libcurl无法正常工作"><a href="#八、什么时候libcurl无法正常工作" class="headerlink" title="八、什么时候libcurl无法正常工作"></a>八、什么时候libcurl无法正常工作</h5><p>传输失败总是有原因的。你可能错误的设置了一些libcurl的属性或者没有正确的理解某些属性的含义，或者是远程主机返回一些无法被正确解析的内容。</p><p>这里有一个<strong>黄金法则</strong>来处理这些问题：</p><p>将CURLOPT_VERBOSE属性设置为1，libcurl会输出通信过程中的一些细节。如果使用的是http协议，请求头/响应头也会被输出。将CURLOPT_HEADER设为1，这些头信息将出现在消息的内容中。</p><p>当然不可否认的是，libcurl还存在bug。</p><p>如果你对相关的协议了解越多，在使用libcurl时，就越不容易犯错。</p><h5 id="九、关于密码"><a href="#九、关于密码" class="headerlink" title="九、关于密码"></a>九、关于密码</h5><p>客户端向服务器发送请求时，许多协议都要求提供用户名与密码。libcurl提供了多种方式来设置它们。</p><p>一些协议支持在URL中直接指定用户名和密码，类似于：<br>protocol://user:<a href="mailto:password@example.com" target="_blank" rel="noopener">password@example.com</a>/path/。libcurl能正确的识别这种URL中的用户名与密码并执行相应的操作。如果你提供的用户名和密码中有特殊字符，首先应该对其进行URL编码。</p><p>也可以通过CURLOPT_USERPWD属性来设置用户名与密码。参数是格式如<br>“user:password ”的字符串：</p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_USERPWD, &quot;user_name:password&quot;);</code></pre><p>有时候在访问代理服务器的时候，可能时时要求提供用户名和密码进行用户身份验证。这种情况下，libcurl提供了另一个属性CURLOPT_PROXYUSERPWD：</p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_PROXYUSERPWD, &quot;user_name:password&quot;);</code></pre><p>在UNIX平台下，访问FTP的用户名和密码可能会被保存在$HOME/.netrc文件中。libcurl支持直接从这个文件中获取用户名与密码：  </p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_NETRC, 1L);    </code></pre><p>在使用SSL时，可能需要提供一个私钥用于数据安全传输，通过CURLOPT_KEYPASSWD来设置私钥：</p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_KEYPASSWD, &quot;keypassword&quot;);</code></pre><h5 id="十、HTTP验证"><a href="#十、HTTP验证" class="headerlink" title="十、HTTP验证"></a>十、HTTP验证</h5><p>在使用HTTP协议时，客户端有很多种方式向服务器提供验证信息。默认的HTTP验证方法是”Basic”，它将用户名与密码以明文的方式、经Base64编码后保存在HTTP请求头中，发往服务器。当然这不太安全。</p><p>当前版本的libcurl支持的验证方法有：basic, Digest, NTLM, Negotiate, GSS-Negotiate and SPNEGO。（译者感叹：搞Web这么多年，尽然不知道这些Http的验证方式，实在惭愧。）可以通过CURLOPT_HTTPAUTH属性来设置具体 的验证方式：</p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_HTTPAUTH, CURLAUTH_DIGEST);</code></pre><p>向代理服务器发送验证信息时，可以通过CURLOPT_PROXYAUTH设置验证方式：</p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_PROXYAUTH, CURLAUTH_NTLM);</code></pre><p>也可以同时设置多种验证方式（通过按位与）， 使用’CURLAUTH_ANY’将允许libcurl可以选择任何它所支持的验证方式。通过CURLOPT_HTTPAUTH或 CURLOPT_PROXYAUTH属性设置的多种验证方式，libcurl会在运行时选择一种它认为是最好的方式与服务器通信：</p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_HTTPAUTH,  CURLAUTH_DIGEST|CURLAUTH_BASIC);// curl_easy_setopt(easy_handle, CURLOPT_HTTPAUTH,  CURLAUTH_ANY);</code></pre><h5 id="十一、代码示例"><a href="#十一、代码示例" class="headerlink" title="十一、代码示例"></a>十一、代码示例</h5><h6 id="1-基本的http-GET-POST操作"><a href="#1-基本的http-GET-POST操作" class="headerlink" title="1.基本的http GET/POST操作"></a>1.基本的http GET/POST操作</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line"></span><br><span class="line">bool getUrl(char *filename)</span><br><span class="line">&#123;</span><br><span class="line">    CURL *curl;</span><br><span class="line">    CURLcode res;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    if ((fp = fopen(filename, &quot;w&quot;)) == NULL)  //返回结果用文件存储</span><br><span class="line">        return false;</span><br><span class="line">    struct curl_slist *headers = NULL;</span><br><span class="line">    headers = curl_slist_append(headers, &quot;Accept: Agent-007&quot;);</span><br><span class="line">    curl = curl_easy_init();    //初始化</span><br><span class="line">    if (curl)</span><br><span class="line">    &#123;</span><br><span class="line">        //curl_easy_setopt(curl, CURLOPT_PROXY, &quot;10.99.60.201:8080&quot;);//代理</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);//改协议头</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_URL,&quot;http://www.baidu.com&quot;);</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp); //将返回的http头输出到fp指向的文件</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_HEADERDATA, fp); //将返回的html主体数据输出到fp指向的文件</span><br><span class="line">        res = curl_easy_perform(curl);   // 执行</span><br><span class="line">        if (res != 0) &#123;</span><br><span class="line"></span><br><span class="line">            curl_slist_free_all(headers);</span><br><span class="line">            curl_easy_cleanup(curl);</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool postUrl(char *filename)</span><br><span class="line">&#123;</span><br><span class="line">    CURL *curl;</span><br><span class="line">    CURLcode res;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    if ((fp = fopen(filename, &quot;w&quot;)) == NULL)</span><br><span class="line">        return false;</span><br><span class="line">    curl = curl_easy_init();</span><br><span class="line">    if (curl)</span><br><span class="line">    &#123;</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_COOKIEFILE, &quot;/mnt/hgfs/VMWARE/test/10-http/temp/cookie.txt&quot;); // 指定cookie文件</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, &quot;&amp;logintype=uid&amp;u=xieyan&amp;psw=xxx86&quot;);    // 指定post内容</span><br><span class="line">        //curl_easy_setopt(curl, CURLOPT_PROXY, &quot;10.99.60.201:8080&quot;);</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_URL, &quot; http://mail.sina.com.cn/cgi-bin/login.cgi &quot;);   // 指定url</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);</span><br><span class="line">        res = curl_easy_perform(curl);</span><br><span class="line">        curl_easy_cleanup(curl);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    getUrl(&quot;/mnt/hgfs/VMWARE/test/10-http/temp/get.html&quot;);</span><br><span class="line">    postUrl(&quot;/mnt/hgfs/VMWARE/test/10-http/temp/post.html&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令：</p><pre><code>gcc  get_post.c  -o get_post –lcurl./ get_post</code></pre><p>得到结果：<br>略</p><h6 id="2-获取html网页"><a href="#2-获取html网页" class="headerlink" title="2. 获取html网页"></a>2. 获取html网页</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    CURL *curl;             //定义CURL类型的指针</span><br><span class="line">    CURLcode res;           //定义CURLcode类型的变量，保存返回状态码</span><br><span class="line">    if(argc!=2)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Usage : file &lt;url&gt;;\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    curl = curl_easy_init();        //初始化一个CURL类型的指针</span><br><span class="line">    if(curl!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        //设置curl选项. 其中CURLOPT_URL是让用户指 定url. argv[1]中存放的命令行传进来的网址</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_URL, argv[1]);        </span><br><span class="line">        //调用curl_easy_perform 执行我们的设置.并进行相关的操作. 在这 里只在屏幕上显示出来.</span><br><span class="line">        res = curl_easy_perform(curl);</span><br><span class="line">        //清除curl操作.</span><br><span class="line">        curl_easy_cleanup(curl);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令：</p><pre><code>gcc  get_http.c  -o get_http –lcurl./get_http www.baidu.com</code></pre><h6 id="3-网页下载保存实例"><a href="#3-网页下载保存实例" class="headerlink" title="3. 网页下载保存实例"></a>3. 网页下载保存实例</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 采用CURLOPT_WRITEFUNCTION 实现网页下载保存功能</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;;</span><br><span class="line"> </span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line">#include &lt;curl/types.h&gt;</span><br><span class="line">#include &lt;curl/easy.h&gt;</span><br><span class="line"> </span><br><span class="line">FILE *fp;  //定义FILE类型指针</span><br><span class="line">//这个函数是为了符合CURLOPT_WRITEFUNCTION而构造的</span><br><span class="line">//完成数据保存功能</span><br><span class="line">size_t write_data(void *ptr, size_t size, size_t nmemb, void *stream)  </span><br><span class="line">&#123;</span><br><span class="line">    int written = fwrite(ptr, size, nmemb, (FILE *)fp);</span><br><span class="line">    return written;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    CURL *curl;</span><br><span class="line"> </span><br><span class="line">    curl_global_init(CURL_GLOBAL_ALL);  </span><br><span class="line">    curl=curl_easy_init();</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL, argv[1]);  </span><br><span class="line"> </span><br><span class="line">    if((fp=fopen(argv[2],&quot;w&quot;))==NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        curl_easy_cleanup(curl);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    ////CURLOPT_WRITEFUNCTION 将后继的动作交给write_data函数处理</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);  </span><br><span class="line">    curl_easy_perform(curl);</span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令：</p><pre><code>gcc  save_http.c  -o save_http –lcurl./ save_http www.baidu.com/tmp/baidu</code></pre><h6 id="4-进度条实例显示文件下载进度"><a href="#4-进度条实例显示文件下载进度" class="headerlink" title="4.进度条实例显示文件下载进度"></a>4.进度条实例显示文件下载进度</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">// 采用CURLOPT_NOPROGRESS， CURLOPT_PROGRESSFUNCTION    CURLOPT_PROGRESSDATA 实现文件传输进度提示功能</span><br><span class="line">//函数采用了gtk库，故编译时需指定gtk库</span><br><span class="line">//函数启动专门的线程用于显示gtk 进度条bar</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;gtk/gtk.h&gt;</span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line">#include &lt;curl/types.h&gt; /* new for v7 */</span><br><span class="line">#include &lt;curl/easy.h&gt; /* new for v7 */</span><br><span class="line"> </span><br><span class="line">GtkWidget *Bar;</span><br><span class="line">////这个函数是为了符合CURLOPT_WRITEFUNCTION而构造的</span><br><span class="line">//完成数据保存功能</span><br><span class="line">size_t my_write_func(void *ptr, size_t size, size_t nmemb, FILE *stream)</span><br><span class="line">&#123;</span><br><span class="line">  return fwrite(ptr, size, nmemb, stream);</span><br><span class="line">&#125;</span><br><span class="line">//这个函数是为了符合CURLOPT_READFUNCTION而构造的</span><br><span class="line">//数据上传时使用</span><br><span class="line">size_t my_read_func(void *ptr, size_t size, size_t nmemb, FILE *stream)</span><br><span class="line">&#123;</span><br><span class="line">  return fread(ptr, size, nmemb, stream);</span><br><span class="line">&#125;</span><br><span class="line">//这个函数是为了符合CURLOPT_PROGRESSFUNCTION而构造的</span><br><span class="line">//显示文件传输进度，t代表文件大小，d代表传 输已经完成部分</span><br><span class="line">int my_progress_func(GtkWidget *bar,</span><br><span class="line">                     double t, /* dltotal */</span><br><span class="line">                     double d, /* dlnow */</span><br><span class="line">                     double ultotal,</span><br><span class="line">                     double ulnow)</span><br><span class="line">&#123;</span><br><span class="line">/*  printf(&quot;%d / %d (%g %%)\n&quot;, d, t, d*100.0/t);*/</span><br><span class="line">  gdk_threads_enter();</span><br><span class="line">  gtk_progress_set_value(GTK_PROGRESS(bar), d*100.0/t);</span><br><span class="line">  gdk_threads_leave();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void *my_thread(void *ptr)</span><br><span class="line">&#123;</span><br><span class="line">  CURL *curl;</span><br><span class="line">  CURLcode res;</span><br><span class="line">  FILE *outfile;</span><br><span class="line">  gchar *url = ptr;</span><br><span class="line"> </span><br><span class="line">  curl = curl_easy_init();</span><br><span class="line">  if(curl)</span><br><span class="line">  &#123;</span><br><span class="line">    outfile = fopen(&quot;test.curl&quot;, &quot;w&quot;);</span><br><span class="line"> </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL, url);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEDATA, outfile);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, my_write_func);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_READFUNCTION, my_read_func);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 0L);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_PROGRESSFUNCTION, my_progress_func);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_PROGRESSDATA, Bar);</span><br><span class="line"> </span><br><span class="line">    res = curl_easy_perform(curl);</span><br><span class="line"> </span><br><span class="line">    fclose(outfile);</span><br><span class="line">    /* always cleanup */</span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">  GtkWidget *Window, *Frame, *Frame2;</span><br><span class="line">  GtkAdjustment *adj;</span><br><span class="line"> </span><br><span class="line">  /* Must initialize libcurl before any threads are started */</span><br><span class="line">  curl_global_init(CURL_GLOBAL_ALL);</span><br><span class="line"> </span><br><span class="line">  /* Init thread */</span><br><span class="line">  g_thread_init(NULL);</span><br><span class="line"> </span><br><span class="line">  gtk_init(&amp;argc, &amp;argv);</span><br><span class="line">  Window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</span><br><span class="line">  Frame = gtk_frame_new(NULL);</span><br><span class="line">  gtk_frame_set_shadow_type(GTK_FRAME(Frame), GTK_SHADOW_OUT);</span><br><span class="line">  gtk_container_add(GTK_CONTAINER(Window), Frame);</span><br><span class="line">  Frame2 = gtk_frame_new(NULL);</span><br><span class="line">  gtk_frame_set_shadow_type(GTK_FRAME(Frame2), GTK_SHADOW_IN);</span><br><span class="line">  gtk_container_add(GTK_CONTAINER(Frame), Frame2);</span><br><span class="line">  gtk_container_set_border_width(GTK_CONTAINER(Frame2), 5);</span><br><span class="line">  adj = (GtkAdjustment*)gtk_adjustment_new(0, 0, 100, 0, 0, 0);</span><br><span class="line">  Bar = gtk_progress_bar_new_with_adjustment(adj);</span><br><span class="line">  gtk_container_add(GTK_CONTAINER(Frame2), Bar);</span><br><span class="line">  gtk_widget_show_all(Window);</span><br><span class="line"> </span><br><span class="line">  if (!g_thread_create(&amp;my_thread, argv[1], FALSE, NULL) != 0)</span><br><span class="line">    g_warning(&quot;can&apos;t create the thread&quot;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  gdk_threads_enter();</span><br><span class="line">  gtk_main();</span><br><span class="line">  gdk_threads_leave();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令：</p><pre><code>export PKG_CONFIG_PATH=/usr/lib/pkgconfig/gcc progress.c –o progress ` pkg-config --libs –cflags gtk+-2..0` -lcurl –lgthread-2.0./ progress  http://software.sky-union.cn/index.asp</code></pre><h6 id="5-断点续传实例"><a href="#5-断点续传实例" class="headerlink" title="5.断点续传实例"></a>5.断点续传实例</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">//采用CURLOPT_RESUME_FROM_LARGE 实现文件断点续传功能</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line"> </span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line">//这个函数为CURLOPT_HEADERFUNCTION参数构造</span><br><span class="line">/* 从http头部获取文件size*/</span><br><span class="line">size_t getcontentlengthfunc(void *ptr, size_t size, size_t nmemb, void *stream) &#123;</span><br><span class="line">       int r;</span><br><span class="line">       long len = 0;</span><br><span class="line"> </span><br><span class="line">       /* _snscanf() is Win32 specific */</span><br><span class="line">       // r = _snscanf(ptr, size * nmemb, &quot;Content-Length: %ld\n&quot;, &amp;len);</span><br><span class="line"> r = sscanf(ptr, &quot;Content-Length: %ld\n&quot;, &amp;len);</span><br><span class="line">       if (r) /* Microsoft: we don&apos;t read the specs */</span><br><span class="line">              *((long *) stream) = len;</span><br><span class="line"> </span><br><span class="line">       return size * nmemb;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* 保存下载文件 */</span><br><span class="line">size_t wirtefunc(void *ptr, size_t size, size_t nmemb, void *stream)</span><br><span class="line">&#123;</span><br><span class="line">        return fwrite(ptr, size, nmemb, stream);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/*读取上传文件 */</span><br><span class="line">size_t readfunc(void *ptr, size_t size, size_t nmemb, void *stream)</span><br><span class="line">&#123;</span><br><span class="line">       FILE *f = stream;</span><br><span class="line">       size_t n;</span><br><span class="line"> </span><br><span class="line">       if (ferror(f))</span><br><span class="line">              return CURL_READFUNC_ABORT;</span><br><span class="line"> </span><br><span class="line">       n = fread(ptr, size, nmemb, f) * size;</span><br><span class="line"> </span><br><span class="line">       return n;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 下载 或者上传文件函数</span><br><span class="line">int download(CURL *curlhandle, const char * remotepath, const char * localpath,</span><br><span class="line">           long timeout, long tries)</span><br><span class="line">&#123;</span><br><span class="line">       FILE *f;</span><br><span class="line">       curl_off_t local_file_len = -1 ;</span><br><span class="line">       long filesize =0 ;</span><br><span class="line">       </span><br><span class="line">       CURLcode r = CURLE_GOT_NOTHING;</span><br><span class="line">       int c;</span><br><span class="line">  struct stat file_info;</span><br><span class="line">  int use_resume = 0;</span><br><span class="line">  /* 得到本地文件大小 */</span><br><span class="line">  //if(access(localpath,F_OK) ==0)</span><br><span class="line">  </span><br><span class="line">    if(stat(localpath, &amp;file_info) == 0) </span><br><span class="line">     &#123;</span><br><span class="line">        local_file_len =  file_info.st_size;</span><br><span class="line">        use_resume  = 1;</span><br><span class="line">      &#125;</span><br><span class="line">  //采用追加方式打开文件，便于实现文件断点续传工作</span><br><span class="line">       f = fopen(localpath, &quot;ab+&quot;); </span><br><span class="line">       if (f == NULL) &#123;</span><br><span class="line">              perror(NULL);</span><br><span class="line">              return 0;</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">       //curl_easy_setopt(curlhandle, CURLOPT_UPLOAD, 1L);</span><br><span class="line"> </span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_URL, remotepath);</span><br><span class="line"> </span><br><span class="line">              curl_easy_setopt(curlhandle, CURLOPT_CONNECTTIMEOUT, timeout);  // 设置连接超时，单位秒</span><br><span class="line">       //设置http 头部处理函数</span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_HEADERFUNCTION, getcontentlengthfunc);</span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_HEADERDATA, &amp;filesize);</span><br><span class="line"> // 设置文件续传的位置给libcurl</span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_RESUME_FROM_LARGE, use_resume?local_file_len:0);</span><br><span class="line"> </span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_WRITEDATA, f);</span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_WRITEFUNCTION, wirtefunc);</span><br><span class="line"> </span><br><span class="line">       //curl_easy_setopt(curlhandle, CURLOPT_READFUNCTION, readfunc);</span><br><span class="line">       //curl_easy_setopt(curlhandle, CURLOPT_READDATA, f);</span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_NOPROGRESS, 1L);</span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_VERBOSE, 1L);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  r = curl_easy_perform(curlhandle);</span><br><span class="line">       </span><br><span class="line"> </span><br><span class="line">       fclose(f);</span><br><span class="line"> </span><br><span class="line">       if (r == CURLE_OK)</span><br><span class="line"></span><br><span class="line">              return 1;</span><br><span class="line">       else &#123;</span><br><span class="line">              fprintf(stderr, &quot;%s\n&quot;, curl_easy_strerror(r));</span><br><span class="line">              return 0;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int c, char **argv) &#123;</span><br><span class="line">       CURL *curlhandle = NULL;</span><br><span class="line"> </span><br><span class="line">       curl_global_init(CURL_GLOBAL_ALL);</span><br><span class="line">       curlhandle = curl_easy_init();</span><br><span class="line"> </span><br><span class="line">       //download(curlhandle, &quot;ftp://user:pass@host/path/file&quot;, &quot;C:\\file&quot;, 0, 3);</span><br><span class="line">  download(curlhandle , &quot;http://software.sky-union.cn/index.asp&quot;,&quot;/mnt/hgfs/VMWARE/test/10-http/temp/index.asp&quot;,1,3);</span><br><span class="line">       curl_easy_cleanup(curlhandle);</span><br><span class="line">       curl_global_cleanup();</span><br><span class="line"> </span><br><span class="line">       return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令：</p><pre><code>gcc  resume.c  -o resume –lcurl./ resume  </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;一、LibCurl基本编程框架&quot;&gt;&lt;a href=&quot;#一、LibCurl基本编程框架&quot; class=&quot;headerlink&quot; title=&quot;一、LibCurl基本编程框架&quot;&gt;&lt;/a&gt;一、LibCurl基本编程框架&lt;/h5&gt;&lt;p&gt;关于libcurl，&lt;a href=&quot;https://www.faihung.net/2019/11/03/cURL-01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BA%86%E8%A7%A3/&quot;&gt;前面已经有了很多介绍&lt;/a&gt;，这里就不详西描述了。&lt;/p&gt;
&lt;p&gt;在基于LibCurl的程序里，主要采用callback function （回调函数）的形式完成传输任务，用户在启动传输前设置好各类参数和回调函数，当满足条件时libcurl将调用用户的回调函数实现特定功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="cURL" scheme="http://www.faihung.net/categories/cURL/"/>
    
    
      <category term="cURL" scheme="http://www.faihung.net/tags/cURL/"/>
    
  </entry>
  
  <entry>
    <title>cURL-08_ARM交叉编译</title>
    <link href="http://www.faihung.net/2019/12/12/cURL-08-ARM%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"/>
    <id>http://www.faihung.net/2019/12/12/cURL-08-ARM交叉编译/</id>
    <published>2019-12-12T06:24:59.000Z</published>
    <updated>2019-12-12T06:25:53.992Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.faihung.net/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/">前面</a>提到过libcurl在Ubuntu环境下的编译安装，本章主要是嵌入式环境下的ARM交叉编译</p><p>执行<a href="https://www.faihung.net/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/">前面</a>的操作之后，进行arm的交叉编译</p><pre><code>./configure --host=arm-himix200-linux CC=arm-himix200-linux-gcc CXX=arm-himix200-linux-g++ </code></pre><a id="more"></a><p>交叉编译，说实话整了好几个小时没怎么明白，不知道为什么不行。</p><p>但是，我把原有工程的的cURL模块拆分出来，修改了Makefile之后，可以交叉编译可以在设备中运行。</p><p>目前关于cURL的交叉编译就告一段落，之后有时间在研究编译。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.faihung.net/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/&quot;&gt;前面&lt;/a&gt;提到过libcurl在Ubuntu环境下的编译安装，本章主要是嵌入式环境下的ARM交叉编译&lt;/p&gt;
&lt;p&gt;执行&lt;a href=&quot;https://www.faihung.net/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/&quot;&gt;前面&lt;/a&gt;的操作之后，进行arm的交叉编译&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./configure --host=arm-himix200-linux CC=arm-himix200-linux-gcc CXX=arm-himix200-linux-g++ &lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="cURL" scheme="http://www.faihung.net/categories/cURL/"/>
    
    
      <category term="cURL" scheme="http://www.faihung.net/tags/cURL/"/>
    
  </entry>
  
  <entry>
    <title>cURL-07_Linux下使用libcurl实现FTP文件上传下载功能</title>
    <link href="http://www.faihung.net/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/"/>
    <id>http://www.faihung.net/2019/12/08/cURL-07-Linux下使用libcurl实现FTP文件上传下载功能/</id>
    <published>2019-12-08T10:24:54.000Z</published>
    <updated>2019-12-31T07:43:50.080Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Linux下使用libcurl实现FTP单个文件或者压缩包上传下载功能</p></blockquote><a id="more"></a><h5 id="一、关于FTP"><a href="#一、关于FTP" class="headerlink" title="一、关于FTP"></a>一、关于FTP</h5><p>参考：<br><a href="https://www.faihung.net/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/">在WIN10上搭建Ftp服务器</a></p><h5 id="二、FTP上传"><a href="#二、FTP上传" class="headerlink" title="二、FTP上传"></a>二、FTP上传</h5><p>该FTP上传代码为官网上的<a href="https://curl.haxx.se/libcurl/c/example.html" target="_blank" rel="noopener">demo</a>例程代码，若要为己所用，只需将宏定义修改并准备一个要上传的文件即可。当然，该函数只能上传一个文件或者压缩包至FTP服务器，若要上传多个文件，可以在此例程上进行修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#ifdef WIN32</span><br><span class="line">#include &lt;io.h&gt;</span><br><span class="line">#else</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define LOCAL_FILE      &quot;/mnt/hgfs/VMWARE/test/8-curl/1206.rar&quot; //要上传的文件</span><br><span class="line">#define UPLOAD_FILE_AS  &quot;while-uploading.txt&quot;</span><br><span class="line">#define REMOTE_URL      &quot;ftp://192.168.31.175/&quot;  UPLOAD_FILE_AS //FTP服务器地址</span><br><span class="line">#define RENAME_FILE_TO  &quot;1206.rar&quot;//最终写入到这个文件名中</span><br><span class="line"></span><br><span class="line">static size_t read_callback(void *ptr, size_t size, size_t nmemb, void *stream)</span><br><span class="line">&#123;</span><br><span class="line">  curl_off_t nread;</span><br><span class="line"></span><br><span class="line">  size_t retcode = fread(ptr, size, nmemb, stream);</span><br><span class="line"></span><br><span class="line">  nread = (curl_off_t)retcode;</span><br><span class="line"></span><br><span class="line">  fprintf(stderr, &quot; We read %&quot; CURL_FORMAT_CURL_OFF_T</span><br><span class="line">          &quot; bytes from file\n&quot;, nread);</span><br><span class="line">  return retcode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">  CURL *curl;</span><br><span class="line">  CURLcode res;</span><br><span class="line">  FILE *hd_src;</span><br><span class="line">  struct stat file_info;</span><br><span class="line">  curl_off_t fsize;</span><br><span class="line"></span><br><span class="line">  struct curl_slist *headerlist = NULL;</span><br><span class="line">  static const char buf_1 [] = &quot;RNFR &quot; UPLOAD_FILE_AS;</span><br><span class="line">  static const char buf_2 [] = &quot;RNTO &quot; RENAME_FILE_TO;</span><br><span class="line"></span><br><span class="line">  /* 获得上传文件的大小 */ </span><br><span class="line">  if(stat(LOCAL_FILE, &amp;file_info)) &#123;</span><br><span class="line">    printf(&quot;Couldn&apos;t open &apos;%s&apos;: %s\n&quot;, LOCAL_FILE, strerror(errno));</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  fsize = (curl_off_t)file_info.st_size;</span><br><span class="line"></span><br><span class="line">  printf(&quot;Local file size: %&quot; CURL_FORMAT_CURL_OFF_T &quot; bytes.\n&quot;, fsize);</span><br><span class="line"></span><br><span class="line">  /* 获得FILE类型变量 */ </span><br><span class="line">  hd_src = fopen(LOCAL_FILE, &quot;rb&quot;);</span><br><span class="line"></span><br><span class="line">  /* 初始化 */ </span><br><span class="line">  curl_global_init(CURL_GLOBAL_ALL);</span><br><span class="line"></span><br><span class="line">  /* 获得curl操作符 */ </span><br><span class="line">  curl = curl_easy_init();</span><br><span class="line">  if(curl) &#123;</span><br><span class="line">    /*建立一个传递给libcurl的命令列表 */ </span><br><span class="line">    headerlist = curl_slist_append(headerlist, buf_1);</span><br><span class="line">    headerlist = curl_slist_append(headerlist, buf_2);</span><br><span class="line"></span><br><span class="line">    /* 使用curl提供的Read功能 */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_READFUNCTION, read_callback);</span><br><span class="line"></span><br><span class="line">    /* 上传使能 */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_UPLOAD, 1L);</span><br><span class="line"></span><br><span class="line">    /* 设置特定目标 */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL, REMOTE_URL);</span><br><span class="line"></span><br><span class="line">    /* 传递最后一个FTP命令以在传输后运行 */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_POSTQUOTE, headerlist);</span><br><span class="line"></span><br><span class="line">    /*指定上传文件 */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_READDATA, hd_src);</span><br><span class="line"></span><br><span class="line">    /*设置要上传的文件的大小（可选） */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_INFILESIZE_LARGE,</span><br><span class="line">                     (curl_off_t)fsize);</span><br><span class="line"></span><br><span class="line">    /* 运行 */ </span><br><span class="line">    res = curl_easy_perform(curl);</span><br><span class="line">    /* 容错处理 */ </span><br><span class="line">    if(res != CURLE_OK)</span><br><span class="line">      fprintf(stderr, &quot;curl_easy_perform() failed: %s\n&quot;,</span><br><span class="line">              curl_easy_strerror(res));</span><br><span class="line"></span><br><span class="line">    /* 清除FTP命令列表 */ </span><br><span class="line">    curl_slist_free_all(headerlist);</span><br><span class="line"></span><br><span class="line">    /*释放所有curl资源 */ </span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(hd_src); /*关闭本地文件 */ </span><br><span class="line"></span><br><span class="line">  /*释放所有curl资源 */ </span><br><span class="line">  curl_global_cleanup();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存代码，文件名命名为“ftpupload.c”，并在/mnt/hgfs/VMWARE/test/8-curl文件夹中准备“1206.rar”文件（即代码中指定的要上传的文件名），使用gcc编译，编译指令：</p><pre><code>gcc -o ftpupload ftpupload.c -lcurl</code></pre><p>执行结果：</p><p><img src="/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/1.png" alt="1"></p><p>上传前的代码：</p><p><img src="/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/2.png" alt="2"></p><p>上传到FTP服务器之后：</p><p><img src="/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/3.png" alt="3"></p><p>至此，上传功能完成。</p><h5 id="三、FTP下载"><a href="#三、FTP下载" class="headerlink" title="三、FTP下载"></a>三、FTP下载</h5><p>同样，该FTP下载代码为官网上的<a href="https://curl.haxx.se/libcurl/c/example.html" target="_blank" rel="noopener">demo</a>例程代码，若要为己所用，只需将宏定义修改并指定一个要下载的文件即可。当然，该函数只能下载一个文件或者压缩包至FTP客户端，若要下载多个文件，可以在此例程上进行修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line"></span><br><span class="line">struct FtpFile &#123;</span><br><span class="line">  const char *filename;</span><br><span class="line">  FILE *stream;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static size_t my_fwrite(void *buffer, size_t size, size_t nmemb, void *stream)</span><br><span class="line">&#123;</span><br><span class="line">  struct FtpFile *out = (struct FtpFile *)stream;</span><br><span class="line">  if(out &amp;&amp; !out-&gt;stream) &#123;</span><br><span class="line">    /* 打开文件以进行写操作 */ </span><br><span class="line">    out-&gt;stream = fopen(out-&gt;filename, &quot;wb&quot;);</span><br><span class="line">    if(!out-&gt;stream)</span><br><span class="line">      return -1; /* failure, can&apos;t open file to write */ </span><br><span class="line">  &#125;</span><br><span class="line">  return fwrite(buffer, size, nmemb, out-&gt;stream);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">  CURL *curl;</span><br><span class="line">  CURLcode res;</span><br><span class="line">  struct FtpFile ftpfile = &#123;</span><br><span class="line">    &quot;/mnt/hgfs/VMWARE/test/8-curl/1208.rar&quot;, /* 若FTP下载成功，名命下载后的文件为&quot;curl.txt&quot; */ </span><br><span class="line">    NULL</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  curl_global_init(CURL_GLOBAL_DEFAULT);</span><br><span class="line"></span><br><span class="line">  curl = curl_easy_init();</span><br><span class="line">  if(curl) &#123;</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL,</span><br><span class="line">                     &quot;ftp://192.168.31.175/1208.rar&quot;);//下载指定的文件</span><br><span class="line">    /* 定义回调函数，以便在需要写入数据时进行调用 */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, my_fwrite);</span><br><span class="line">    /*设置一个指向我们的结构的指针传递给回调函数*/ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;ftpfile);</span><br><span class="line"></span><br><span class="line">    /* 打开完整的协议/调试输出*/ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);</span><br><span class="line"></span><br><span class="line">    res = curl_easy_perform(curl);</span><br><span class="line"></span><br><span class="line">    /* 释放所有curl资源*/ </span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line"></span><br><span class="line">    if(CURLE_OK != res) &#123;</span><br><span class="line">      /*容错处理 */ </span><br><span class="line">      fprintf(stderr, &quot;curl told us %d\n&quot;, res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(ftpfile.stream)</span><br><span class="line">    fclose(ftpfile.stream); /* 关闭本地文件 */ </span><br><span class="line"> /*释放所有curl资源*/</span><br><span class="line">  curl_global_cleanup();</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用gcc编译，编译指令：</p><pre><code>gcc -o ftpDown ftpDown.c -lcurl</code></pre><p>执行结果：</p><p><img src="/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/4.png" alt="4"></p><p>下载之前，放在FTP服务器中时：</p><p><img src="/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/5.png" alt="5"></p><p>下载之后，放在本地文件中中时：</p><p><img src="/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/6.png" alt="6"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Linux下使用libcurl实现FTP单个文件或者压缩包上传下载功能&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="cURL" scheme="http://www.faihung.net/categories/cURL/"/>
    
    
      <category term="cURL" scheme="http://www.faihung.net/tags/cURL/"/>
    
  </entry>
  
  <entry>
    <title>cURL-06_cURL和libcurl的安装的安装途径</title>
    <link href="http://www.faihung.net/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/"/>
    <id>http://www.faihung.net/2019/12/08/cURL-06-cURL和libcuel的安装的安装途径/</id>
    <published>2019-12-08T08:51:06.000Z</published>
    <updated>2019-12-16T10:02:40.128Z</updated>
    
    <content type="html"><![CDATA[<p>cURL的安装一般有三种方式:<a href="https://ec.haxx.se/" target="_blank" rel="noopener">https://ec.haxx.se/</a></p><a id="more"></a><h5 id="一、ubuntu16-04-安装curl，一般用于命令行工具操作"><a href="#一、ubuntu16-04-安装curl，一般用于命令行工具操作" class="headerlink" title="一、ubuntu16.04 安装curl，一般用于命令行工具操作"></a>一、ubuntu16.04 安装curl，一般用于命令行工具操作</h5><h6 id="1-直接安装"><a href="#1-直接安装" class="headerlink" title="1. 直接安装"></a>1. 直接安装</h6><pre><code>sudo apt install curl</code></pre><h6 id="2-或者是下载软件压缩包安装-Ubuntu下安装cURL库用于libcurl开发"><a href="#2-或者是下载软件压缩包安装-Ubuntu下安装cURL库用于libcurl开发" class="headerlink" title="2. 或者是下载软件压缩包安装-Ubuntu下安装cURL库用于libcurl开发"></a>2. 或者是下载软件压缩包安装-Ubuntu下安装cURL库用于libcurl开发</h6><p>2.1 下载curl包（可以在这个网站上找最新的版本 <a href="http://curl.haxx.se/download/）" target="_blank" rel="noopener">http://curl.haxx.se/download/）</a></p><p><img src="/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/1.png" alt="1"></p><pre><code>wget https://curl.haxx.se/download/curl-7.55.1.tar.gz</code></pre><p>2.2 解压</p><pre><code>tar -xzvf  curl-7.55.1.tar.gz</code></pre><p>2.3 覆盖安装</p><pre><code>stemp 1 cd curl-7.55.1stemp 2 ./configurestemp 3 makestemp 4 make install</code></pre><p>2.4 使用 curl –version 检查是否更新成功</p><p><img src="/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/2.png" alt="2"></p><h5 id="二、ubuntu16-04-安装libcurl-主要用于ubuntu中应用程序开发-curl和libcurl的区别"><a href="#二、ubuntu16-04-安装libcurl-主要用于ubuntu中应用程序开发-curl和libcurl的区别" class="headerlink" title="二、ubuntu16.04 安装libcurl,主要用于ubuntu中应用程序开发(curl和libcurl的区别)"></a>二、ubuntu16.04 安装libcurl,主要用于ubuntu中应用程序开发(curl和libcurl的区别)</h5><pre><code>sudo apt install libcurl4-openssl-dev</code></pre><p>可以看到-ubuntu系统中/usr/include/curl中的头文件,此操作可以作为Ubuntu虚拟程序中的&lt;curl/curl.h&gt;,一般作为Ubuntu平台模拟程序使用。</p><p>库文件：/usr/lib/x86_64-linux-gnu/libcurl.so.4</p><h5 id="三、linux下编译安装libcurl"><a href="#三、linux下编译安装libcurl" class="headerlink" title="三、linux下编译安装libcurl"></a>三、linux下编译安装libcurl</h5><h6 id="1-直接下载"><a href="#1-直接下载" class="headerlink" title="1. 直接下载"></a>1. 直接下载</h6><pre><code>git clone https://github.com/curl/curl.git </code></pre><h6 id="2-tar解压后，进入curl工程目录输入指令：-buidconf，产生configure脚本"><a href="#2-tar解压后，进入curl工程目录输入指令：-buidconf，产生configure脚本" class="headerlink" title="2.tar解压后，进入curl工程目录输入指令：./buidconf，产生configure脚本"></a>2.tar解压后，进入curl工程目录输入指令：./buidconf，产生configure脚本</h6><p>之后和第一条步骤类似</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cURL的安装一般有三种方式:&lt;a href=&quot;https://ec.haxx.se/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ec.haxx.se/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="cURL" scheme="http://www.faihung.net/categories/cURL/"/>
    
    
      <category term="cURL" scheme="http://www.faihung.net/tags/cURL/"/>
    
  </entry>
  
  <entry>
    <title>cURL-05_curl和libcurl的区别简介(转)</title>
    <link href="http://www.faihung.net/2019/12/08/cURL-05-curl%E5%92%8Clibcurl%E7%9A%84%E5%8C%BA%E5%88%AB%E7%AE%80%E4%BB%8B-%E8%BD%AC/"/>
    <id>http://www.faihung.net/2019/12/08/cURL-05-curl和libcurl的区别简介-转/</id>
    <published>2019-12-08T08:33:44.000Z</published>
    <updated>2019-12-08T08:38:47.024Z</updated>
    
    <content type="html"><![CDATA[<h5 id="curl简介"><a href="#curl简介" class="headerlink" title="curl简介"></a>curl简介</h5><p>curl是利用URL语法在命令行方式下工作的开源文件传输工具。<br>它支持很多协议：DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP。</p><p>curl同样支持SSL证书,HTTP POST, HTTP PUT,FTP上传，基于表单的HTTP上传，代理(proxies)、cookies、用户名/密码认证(Basic, Digest, NTLM等)、下载文件断点续传，上载文件断点续传(file transfer resume)，http代理服务器管道（proxy tunneling)以及其他特性。</p><p>curl是瑞典curl组织开发的,curl的官网是<a href="http://curl.haxx.se/,可以从官网获取它的源代码和相关说明。" target="_blank" rel="noopener">http://curl.haxx.se/,可以从官网获取它的源代码和相关说明。</a></p><a id="more"></a><h5 id="libcurl简介"><a href="#libcurl简介" class="headerlink" title="libcurl简介"></a>libcurl简介</h5><p>libcurl为一个免费开源的，客户端url传输库，支持DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP等协议。</p><p>同curl一样，libcurl也支持SSL证书,HTTP POST, HTTP PUT,FTP上传，基于表单的HTTP上传，代理(proxies)、cookies、用户名/密码认证(Basic, Digest, NTLM等)、下载文件断点续传，上载文件断点续传(file transfer resume)，http代理服务器管道（proxy tunneling)等。</p><p>libcurl是高度可移植的，可以工作在不同的平台上，支持Windows，Unix，Linux等。</p><p>libcurl是免费的，线程安全的，IPV6兼容的，同时它还有很多其它非常丰富的特性。libcurl已经被很多知名的大企业以及应用程序所采用。</p><h5 id="curl与libcurl对比"><a href="#curl与libcurl对比" class="headerlink" title="curl与libcurl对比"></a>curl与libcurl对比</h5><h6 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h6><p>curl和libcurl都可以利用多种多样的协议来传输文件，包括HTTP, HTTPS, FTP, FTPS, GOPHER, LDAP, DICT, TELNET and FILE等。</p><h6 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h6><ul><li>curl是命令行工具，可以通过shell或脚本来运行curl。curl底层所使用的库是libcurl。</li><li>libcurl是一个库，通常与别的程序绑定在一起使用，如命令行工具curl就是封装了libcurl库。所以我们也可以在你自己的程序或项目中使用libcurl以获得类似CURL的强大功能。接下来将要介绍的PHP扩展就是对curl的一个封装。</li></ul><h5 id="几个名词"><a href="#几个名词" class="headerlink" title="几个名词"></a>几个名词</h5><h6 id="“curl”的不同意思"><a href="#“curl”的不同意思" class="headerlink" title="“curl”的不同意思"></a>“curl”的不同意思</h6><p>1.curl指的是curl命令行工具，可以从命令行或者脚本或者批处理文件中运行curl。curl创建于1998年，并且提供了100多个选项去控制它。</p><p>2.cURL是一个软件项目的名字。该软件项目包含了上面所说的curl和libcurl，并且都是开源的。</p><p>3.cURL通常用作PHP中libcurl扩展的名字。这个扩展确保了PHP程序员在程序中可以访问libcurl库所提供的功能。</p><h6 id="curl—命令行工具"><a href="#curl—命令行工具" class="headerlink" title="curl—命令行工具"></a>curl—命令行工具</h6><ol><li>命令行工具，可以从shell或者脚本中运行该工具。</li><li>提供了130多种不同的“flags”</li><li>通常被用来模拟浏览器的行为</li><li>跨平台</li></ol><h6 id="libcurl—库"><a href="#libcurl—库" class="headerlink" title="libcurl—库"></a>libcurl—库</h6><ol><li>用作其他程序的开发库</li><li>可以与许多语言想结合，如PHP、C++</li><li>跨平台</li><li>提供了多种不同的使用它的APIs</li></ol><h5 id="PHP中使用curl和libcurl"><a href="#PHP中使用curl和libcurl" class="headerlink" title="PHP中使用curl和libcurl"></a>PHP中使用curl和libcurl</h5><h6 id="PHP中使用curl"><a href="#PHP中使用curl" class="headerlink" title="PHP中使用curl"></a>PHP中使用curl</h6><p>在PHP中使用curl非常简单，只要调用PHP中几个执行系统命令的相关函数即可。<br>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$baidu=shell_exec(&quot;/usr/bin/curl -L http://www.baidu.com&quot;); </span><br><span class="line">var_dump($baidu);</span><br></pre></td></tr></table></figure><h6 id="PHP中使用libcurl"><a href="#PHP中使用libcurl" class="headerlink" title="PHP中使用libcurl"></a>PHP中使用libcurl</h6><p>在PHP中使用libcurl，也就是我们通常所说的PHP中的“curl”。这部分的内容会在以后的文章中给出，这里只写出一个示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// FTP this script to a server</span><br><span class="line">$fp = fopen(__FILE__, &quot;r&quot;);</span><br><span class="line">$url = &quot;ftp://username:password@mydomain.com:21/path/to/newfile.php&quot;;</span><br><span class="line">$ch = curl_init();   </span><br><span class="line">curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);</span><br><span class="line">curl_setopt($ch, CURLOPT_UPLOAD, 1);</span><br><span class="line">curl_setopt($ch, CURLOPT_INFILE, $fp);</span><br><span class="line">curl_setopt($ch, CURLOPT_FTPASCII, 1);</span><br><span class="line">curl_setopt($ch, CURLOPT_INFILESIZE, filesize(__FILE__));</span><br><span class="line">$result = curl_exec($ch);</span><br><span class="line">curl_close($ch);</span><br></pre></td></tr></table></figure><h5 id="使用curl还是libcurl？"><a href="#使用curl还是libcurl？" class="headerlink" title="使用curl还是libcurl？"></a>使用curl还是libcurl？</h5><p>使用curl还是libcurl这个需要根据具体的情况而定。例如，当有一个定时脚本在远程服务器的文件改变时发送邮件或者当前PHP环境不支持libcurl时，我们应该使用curl。否则，我们使用libcurl即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;curl简介&quot;&gt;&lt;a href=&quot;#curl简介&quot; class=&quot;headerlink&quot; title=&quot;curl简介&quot;&gt;&lt;/a&gt;curl简介&lt;/h5&gt;&lt;p&gt;curl是利用URL语法在命令行方式下工作的开源文件传输工具。&lt;br&gt;它支持很多协议：DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP。&lt;/p&gt;
&lt;p&gt;curl同样支持SSL证书,HTTP POST, HTTP PUT,FTP上传，基于表单的HTTP上传，代理(proxies)、cookies、用户名/密码认证(Basic, Digest, NTLM等)、下载文件断点续传，上载文件断点续传(file transfer resume)，http代理服务器管道（proxy tunneling)以及其他特性。&lt;/p&gt;
&lt;p&gt;curl是瑞典curl组织开发的,curl的官网是&lt;a href=&quot;http://curl.haxx.se/,可以从官网获取它的源代码和相关说明。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://curl.haxx.se/,可以从官网获取它的源代码和相关说明。&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="cURL" scheme="http://www.faihung.net/categories/cURL/"/>
    
    
      <category term="cURL" scheme="http://www.faihung.net/tags/cURL/"/>
    
  </entry>
  
  <entry>
    <title>工具-虚拟机的桥接模式和NAT模式的区别</title>
    <link href="http://www.faihung.net/2019/12/08/%E5%B7%A5%E5%85%B7-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E5%92%8CNAT%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.faihung.net/2019/12/08/工具-虚拟机的桥接模式和NAT模式的区别/</id>
    <published>2019-12-08T08:09:29.000Z</published>
    <updated>2019-12-08T08:14:31.317Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-桥接模式"><a href="#1-桥接模式" class="headerlink" title="1.桥接模式"></a>1.桥接模式</h5><p>通过使用物理机的网卡，有自己的IP地址，就像在电脑上虚拟出来另一台主机，它可以访问网内任何一台主机，需要手工为其配置IP地址、子网掩码、需要和宿主机器处于同一个网段，这样虚拟机才能和宿主机器进行通信。同时，由于这个虚拟系统是局域网中的一个独立主机系统，就可以手工配置他的TCP\IP信息，实现通过局域网的网关或路由进行互联网访问。</p><a id="more"></a><p><strong>弊端:</strong></p><ol><li><p>Ip地址可能会发生变化 192.150.1.100/192.168.1.101</p></li><li><p>如果这时传递文件时需要依靠交换机/路由器</p></li></ol><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E5%92%8CNAT%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/1.png" alt="1"></p><h5 id="2-NAT模式"><a href="#2-NAT模式" class="headerlink" title="2.NAT模式"></a>2.NAT模式</h5><p>使用NAT模式，就是让虚拟系统借助NAT（网络地址的转换功能），通过宿主机器所在的网络来访问公网，也就是说使用NAT模式可以实现在虚拟系统里访问互联网，NAT模式下的虚拟系统的TCP/IP配置是由VMnet8（NAT）虚拟网络的DHCP服务器提供的，无法进行手工修改，因此虚拟系统也就无法和本局域网中的其他真是主机进行通讯。采用NAT模式的虚拟机的有点就是，想要接入互联网十分方便，只要宿主机能访问到互联网即可。</p><p><strong>特点:</strong></p><ol><li><p>NAT模式时,只能由真实的计算机连接虚拟网络空间,其他的计算机由于网络不在一个网段内,则不能通信.</p></li><li><p>NAT模式时,IP地址一般都是固定不变的.所以无论在哪里.Ip都能直接连接.</p></li></ol><p><img src="/2019/12/08/%E5%B7%A5%E5%85%B7-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E5%92%8CNAT%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/2.png" alt="2"></p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;1-桥接模式&quot;&gt;&lt;a href=&quot;#1-桥接模式&quot; class=&quot;headerlink&quot; title=&quot;1.桥接模式&quot;&gt;&lt;/a&gt;1.桥接模式&lt;/h5&gt;&lt;p&gt;通过使用物理机的网卡，有自己的IP地址，就像在电脑上虚拟出来另一台主机，它可以访问网内任何一台主机，需要手工为其配置IP地址、子网掩码、需要和宿主机器处于同一个网段，这样虚拟机才能和宿主机器进行通信。同时，由于这个虚拟系统是局域网中的一个独立主机系统，就可以手工配置他的TCP\IP信息，实现通过局域网的网关或路由进行互联网访问。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://www.faihung.net/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="VMware" scheme="http://www.faihung.net/tags/VMware/"/>
    
      <category term="网络配置" scheme="http://www.faihung.net/tags/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
</feed>
