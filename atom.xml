<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Faihung&#39;s blog</title>
  
  <subtitle>作者：faihung</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.faihung.net/"/>
  <updated>2020-04-13T01:26:49.625Z</updated>
  <id>http://www.faihung.net/</id>
  
  <author>
    <name>faihung</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>移植编译-库函数方式实现文件的解压缩</title>
    <link href="http://www.faihung.net/2020/04/13/%E7%A7%BB%E6%A4%8D%E7%BC%96%E8%AF%91-%E5%BA%93%E5%87%BD%E6%95%B0%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E5%8E%8B%E7%BC%A9/"/>
    <id>http://www.faihung.net/2020/04/13/移植编译-库函数方式实现文件的解压缩/</id>
    <published>2020-04-13T01:23:22.000Z</published>
    <updated>2020-04-13T01:26:49.625Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、-为什么要用函数方式来解压缩文件"><a href="#一、-为什么要用函数方式来解压缩文件" class="headerlink" title="一、    为什么要用函数方式来解压缩文件"></a>一、    为什么要用函数方式来解压缩文件</h4><p>之前关于算法模型的下载更新之后的一系列操作，如删除之前的文件、改变现有文件权限等操作用的是shell命令方式执行的。这种方式是在现有程序进程的基础上重新开启一个新的进程来执行shell命令。而用到的系统命令函数system、popen函数等会返回出各种程序状态，这些状态是不可控的，所以我们需要用到相应的库函数来实现它们的功能，目前都已经实现和验证它们的功能。</p><p>现在关于海思应用程序和第3方库的下载更新是以文件压缩包的方式下载的，下载之后同样是用的shell命令方式来解压的。所以我们同样需要用到相应的库函数来实现文件的解压缩功能。</p><a id="more"></a><h4 id="二、-选用哪种库来解压缩文件"><a href="#二、-选用哪种库来解压缩文件" class="headerlink" title="二、    选用哪种库来解压缩文件"></a>二、    选用哪种库来解压缩文件</h4><p>对如何在linux系统中以函数的方式实现文件的解压缩，网上提到可以使用compress和uncompress函数，而这两个函数就在zlib的函数库中。</p><p>zlib是一个专用的数据格式压缩库，支持很多格式的压缩，网上有很多资料可供查找，所以我们也选用的是zlib库。</p><h4 id="三、-zlib库的操作记录"><a href="#三、-zlib库的操作记录" class="headerlink" title="三、    zlib库的操作记录"></a>三、    zlib库的操作记录</h4><h5 id="3-1如何下载zlib库"><a href="#3-1如何下载zlib库" class="headerlink" title="3.1如何下载zlib库"></a>3.1如何下载zlib库</h5><p>在zlib库的<a href="http://www.zlib.net/" target="_blank" rel="noopener">官方网站</a>中，可以下载最新版本的zlib库。<br><img src="/2020/04/13/%E7%A7%BB%E6%A4%8D%E7%BC%96%E8%AF%91-%E5%BA%93%E5%87%BD%E6%95%B0%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E5%8E%8B%E7%BC%A9/1.png" alt="1"><br>然后将下载好的库zlib-1.2.11.tar.gz拷贝到linux系统中去。</p><h5 id="3-2交叉编译-zlib-库"><a href="#3-2交叉编译-zlib-库" class="headerlink" title="3.2交叉编译 zlib 库"></a>3.2交叉编译 zlib 库</h5><p>zlib库最终是要在嵌入式linux系统中运行的，所以需要交叉编译。</p><h6 id="3-2-1编译安装的步骤"><a href="#3-2-1编译安装的步骤" class="headerlink" title="3.2.1编译安装的步骤"></a>3.2.1编译安装的步骤</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">步骤1：$ tar zxvf zlib-1.2.11.tar.gz</span><br><span class="line"></span><br><span class="line">步骤2：$ cd zlib-1.2.11/</span><br><span class="line"></span><br><span class="line">步骤3：$ export CC=arm-himix200-linux-gcc    </span><br><span class="line">它的configure不支持用CC变量来指定交叉工具链</span><br><span class="line"></span><br><span class="line">步骤4：$ ./configure --prefix=$PWD/_install  </span><br><span class="line">最后生成的库、头文件和man文件都在当前目录的_install目录下</span><br><span class="line"></span><br><span class="line">步骤5：$ make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>在make install这一步，由于要把zlib安装到/usr/local/lib路径下，所以有些linux系统需要root 权限。安装成功后，可以在/home/yhh/zlib-1.2.11/_install/lib下找到 libz.a。</li><li>libz.a是一个静态库，为了使用zlib的接口，我们必须在连接我们的程序时，libz.a链接进来。只需在 链接命令后加-lz /usr/llocal/lib/libz.a即可。</li></ol><h6 id="3-2-1编译安装中遇到的问题"><a href="#3-2-1编译安装中遇到的问题" class="headerlink" title="3.2.1编译安装中遇到的问题"></a>3.2.1编译安装中遇到的问题</h6><ol><li>关于zlib安装时出现的错和执行make的时候出现：ln: 无法创建符号链接” …… “: 不支持的操作。<br>解决办法：将Windows下的共享目录中的源码移动到linux虚拟机里再执行make命令。</li></ol><ol start="2"><li>执行命令：~/zlib-1.2.11/examples$ arm-himix200-linux-gcc 1.c -o test_zip出现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/tmp/ccUEzkKU.o: In function `main&apos;:</span><br><span class="line">1.c:(.text+0xcc): undefined reference to `compressBound&apos;</span><br><span class="line">1.c:(.text+0xfc): undefined reference to `compress&apos;</span><br><span class="line">1.c:(.text+0x130): undefined reference to `uncompress&apos;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>这是因为编译zlib应用测试程序时没有链接到相应的库文件<br>解决办法：arm-himix200-linux-gcc 1.c -o test_zip -lz</li></ol><ol start="3"><li>执行命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/zlib-1.2.11/examples$ arm-himix200-linux-gcc 1.c -o test_zip -lz出现</span><br><span class="line">/opt/hisi-linux/x86-arm/arm-himix200-linux/host_bin/../lib/gcc/arm-linux-gnueabi/6.3.0/../../../../arm-linux-gnueabi/bin/ld: cannot find -lz</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>在2的基础上出现这个错误<br>解决办法：arm-himix200-linux-gcc 1.c -o test_zip -lz -L/home/yhh/zlib-1.2.11/_install/lib/</li></ol><h5 id="3-3-zlib的使用验证"><a href="#3-3-zlib的使用验证" class="headerlink" title="3.3 zlib的使用验证"></a>3.3 zlib的使用验证</h5><h6 id="3-3-1使用zlib库中的什么文件进行验证"><a href="#3-3-1使用zlib库中的什么文件进行验证" class="headerlink" title="3.3.1使用zlib库中的什么文件进行验证"></a>3.3.1使用zlib库中的什么文件进行验证</h6><p>zlib 在 examples 路径下提供了许多使用zlib的例子，如zpipe.c 基于单个文件的解压缩。这里我们用到的是多个文件的解压缩。可以使用：zlib-1.2.11\contrib\minizip\ miniunz.c中的一些接口函数。</p><h6 id="3-3-2直接修改编译miniunz-c文件，然后交叉编译，证明此步骤的可行性"><a href="#3-3-2直接修改编译miniunz-c文件，然后交叉编译，证明此步骤的可行性" class="headerlink" title="3.3.2直接修改编译miniunz.c文件，然后交叉编译，证明此步骤的可行性"></a>3.3.2直接修改编译miniunz.c文件，然后交叉编译，证明此步骤的可行性</h6><p>下面是一个修改过的，直接交叉编译过的miniunz程序，在嵌入式linux系统中执行后：<br><img src="/2020/04/13/%E7%A7%BB%E6%A4%8D%E7%BC%96%E8%AF%91-%E5%BA%93%E5%87%BD%E6%95%B0%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E5%8E%8B%E7%BC%A9/2.png" alt="2"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~ # ./miniunz </span><br><span class="line">MiniUnz 1.01b, demo of zLib + Unz package written by Gilles Vollant</span><br><span class="line">more info at http://www.winimage.com/zLibDll/unzip.html</span><br><span class="line">hisi_app.zip opened</span><br><span class="line"> extracting: av_streamer</span><br><span class="line"> extracting: input_stream.so</span><br><span class="line"> extracting: output_app.so</span><br></pre></td></tr></table></figure><p>可以看到zlib库中的miniunz.c文件的一些函数是可以对嵌入式系统中的*.zip文件进行解压缩的。</p><h6 id="3-3-3接下来"><a href="#3-3-3接下来" class="headerlink" title="3.3.3接下来"></a>3.3.3接下来</h6><p>满足3.3.2要求之后，就可以将miniunz.c函数的main函数做成一个接口函数，plug-in_framework工程会调用这个接口，然后可以解压hisi_app.zip文件了。这是整个工作最关键的一步。</p><h5 id="3-4-zlib库移植到plug-in-framework中去，需要修改的地方"><a href="#3-4-zlib库移植到plug-in-framework中去，需要修改的地方" class="headerlink" title="3.4 zlib库移植到plug-in_framework中去，需要修改的地方"></a>3.4 zlib库移植到plug-in_framework中去，需要修改的地方</h5><h6 id="3-4-1-plug-in-framework-1-0-9-ai-av-streamer需要修改的地方"><a href="#3-4-1-plug-in-framework-1-0-9-ai-av-streamer需要修改的地方" class="headerlink" title="3.4.1 plug-in_framework_1.0.9_ai/av-streamer需要修改的地方"></a>3.4.1 plug-in_framework_1.0.9_ai/av-streamer需要修改的地方</h6><p>1.CMakeLists.txt添加如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">include_directories(&quot;../lib/app_zip/include&quot;) </span><br><span class="line">link_directories(&quot;../lib/app_zip/lib&quot;) </span><br><span class="line">target_link_libraries(av_streamer pthread dl m stdc++ libdhclient.so libsys_commom.so libsys_base.so  libdevsdk.so libsys_media.so librtsp.so librtmp_push.so libsys_serial.so libsys_mp4_storage.so libsys_httppro.so libnnie_ai.so libapp_para.so libapp_zip.so)</span><br></pre></td></tr></table></figure><p>2.plugins/output_app/CMakeLists.txt添加如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include_directories(&quot;../../../lib/app_zip/include&quot;)</span><br></pre></td></tr></table></figure><h6 id="3-4-2-plug-in-framework-1-0-9-ai-lib需要修改的地方"><a href="#3-4-2-plug-in-framework-1-0-9-ai-lib需要修改的地方" class="headerlink" title="3.4.2 plug-in_framework_1.0.9_ai/lib需要修改的地方"></a>3.4.2 plug-in_framework_1.0.9_ai/lib需要修改的地方</h6><ol><li>建立一个app_zip文件夹，其中app_zip包含4个字文件夹include、lib、src、test</li><li>include文件夹中建立libapp_zip.h文件， app_zip模块中的一些申明函数，主要是给之后的output_app.c文件进行调用。</li><li>lib文件夹是编译的动态库目录。</li><li>src文件夹是源码库目录，包括zlib-1.2.11库和Makefile</li><li>test文件是一些测试文件，包括test.c和Makefile</li><li>在这里，已经编译生成了一个动态库和静态库，感觉Makefile中没有目标文件链接成功，现在会仔细检查一块。</li></ol><h4 id="四、一直出现的错误："><a href="#四、一直出现的错误：" class="headerlink" title="四、一直出现的错误："></a>四、一直出现的错误：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">av_streamer: symbol lookup error: /usr/lib/output_app.so: undefined symbol: do_zip</span><br><span class="line">av_streamer: symbol lookup error: /usr/lib/output_app.so: undefined symbol: do_zip</span><br><span class="line">av_streamer: symbol lookup error: /usr/lib/output_app.so: undefined symbol: unzOpen64</span><br><span class="line">av_streamer: symbol lookup error: /usr/lib/output_app.so: undefined symbol: inflateInit2_</span><br></pre></td></tr></table></figure><p>这种错误，不管怎么移植代码都是这个错误。</p><p>删除libapp_zip.so之后，运行output_app.so，发现还是报上述错误，说明是根本就没有找这个库。</p><p>运行./test_zip示例程序出现：./test_zip: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory这种现象是正常的。</p><p>==所以关键还是的比较做测试用的Makefile与我们工程用的Makefile的区别==</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、-为什么要用函数方式来解压缩文件&quot;&gt;&lt;a href=&quot;#一、-为什么要用函数方式来解压缩文件&quot; class=&quot;headerlink&quot; title=&quot;一、    为什么要用函数方式来解压缩文件&quot;&gt;&lt;/a&gt;一、    为什么要用函数方式来解压缩文件&lt;/h4&gt;&lt;p&gt;之前关于算法模型的下载更新之后的一系列操作，如删除之前的文件、改变现有文件权限等操作用的是shell命令方式执行的。这种方式是在现有程序进程的基础上重新开启一个新的进程来执行shell命令。而用到的系统命令函数system、popen函数等会返回出各种程序状态，这些状态是不可控的，所以我们需要用到相应的库函数来实现它们的功能，目前都已经实现和验证它们的功能。&lt;/p&gt;
&lt;p&gt;现在关于海思应用程序和第3方库的下载更新是以文件压缩包的方式下载的，下载之后同样是用的shell命令方式来解压的。所以我们同样需要用到相应的库函数来实现文件的解压缩功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="移植编译" scheme="http://www.faihung.net/categories/%E7%A7%BB%E6%A4%8D%E7%BC%96%E8%AF%91/"/>
    
    
      <category term="zlib" scheme="http://www.faihung.net/tags/zlib/"/>
    
      <category term="Makefile" scheme="http://www.faihung.net/tags/Makefile/"/>
    
  </entry>
  
  <entry>
    <title>RTSP-RTCP协议介绍</title>
    <link href="http://www.faihung.net/2020/04/08/RTSP-RTCP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/"/>
    <id>http://www.faihung.net/2020/04/08/RTSP-RTCP协议介绍/</id>
    <published>2020-04-08T10:01:56.000Z</published>
    <updated>2020-04-08T10:05:06.305Z</updated>
    
    <content type="html"><![CDATA[<h4 id="RTCP概要"><a href="#RTCP概要" class="headerlink" title="RTCP概要"></a>RTCP概要</h4><p>实时传输控制协议(Real-time Control Protocol，RTCP)与RTP共同定义在1996年提出的RFC 1889中，是和 RTP一起工作的控制协议。RTCP单独运行在低层协议上，由低层协议提供数据与控制包的复用。在RTP会话期间，每个会话参与者周期性地向所有其他参与者发送RTCP控制信息包，如下图所示。对于RTP会话或者广播，通常使用单个多目标广播地址，属于这个会话的所有RTP和RTCP信息包都使用这个多目标广播地址，通过使用不同的端口号可把RTP信息包和RTCP信息包区分开来。</p><p><img src="/2020/04/08/RTSP-RTCP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/1.jpg" alt="1"></p><a id="more"></a><h4 id="RTCP功能"><a href="#RTCP功能" class="headerlink" title="RTCP功能"></a>RTCP功能</h4><h5 id="1、为应用程序提供会话质量或者广播性能质量的信息"><a href="#1、为应用程序提供会话质量或者广播性能质量的信息" class="headerlink" title="1、为应用程序提供会话质量或者广播性能质量的信息"></a>1、为应用程序提供会话质量或者广播性能质量的信息</h5><p>RTCP的主要功能是为应用程序提供会话质量或者广播性能质量的信息。每个RTCP信息包不封装声音数据或者电视数据，而是封装发送端和/或者接收端的统计报表。这些信息包括发送的信息包数目、丢失的信息包数目和信息包的抖动等情况，这些反馈信息反映了当前的网络状况，对发送端、接收端或者网络管理员都非常有用。RTCP规格没有指定应用程序应该使用这些反馈信息做什么，这完全取决于应用程序开发人员。例如，发送端可以根据反馈信息来调整传输速率，接收端可以根据反馈信息判断问题是本地的、区域性的还是全球性的，网络管理员也可以使用RTCP信息包中的信息来评估网络用于多目标广播的性能。</p><h5 id="2、确定-RTP用户源"><a href="#2、确定-RTP用户源" class="headerlink" title="2、确定 RTP用户源"></a>2、确定 RTP用户源</h5><p>RTCP为每个RTP用户提供了一个全局唯一的称为规范名称 (Canonical Name)的标志符 CNAME，接收者使用它来追踪一个RTP进程的参加者。当发现冲突或程序重新启动时，RTP中的同步源标识符SSRC可能发生改变，接收者可利用CNAME来跟踪参加者。同时，接收者也需要利用CNAME在相关RTP连接中的几个数据流之间建立联系。当RTP需要进行音视频同步的时候，接受者就需要使用CNAME来使得同一发送者的音视频数据相关联。</p><h5 id="3、控制-RTCP传输间隔"><a href="#3、控制-RTCP传输间隔" class="headerlink" title="3、控制 RTCP传输间隔"></a>3、控制 RTCP传输间隔</h5><p>由于每个对话成员定期发送RTCP信息包，随着参加者不断增加，RTCP信息包频繁发送将占用过多的网络资源，为了防止拥塞，必须限制RTCP信息包的流量，控制信息所占带宽一般不超过可用带宽的5%，因此就需要调整RTCP包的发送速率。由于任意两个RTP终端之间都互发RTCP包，因此终端的总数很容易估计出来，应用程序根据参加者总数就可以调整 RTCP包的发送速率。</p><h5 id="4、传输最小进程控制信息"><a href="#4、传输最小进程控制信息" class="headerlink" title="4、传输最小进程控制信息　"></a>4、传输最小进程控制信息　</h5><p>这项功能对于参加者可以任意进入和离开的松散会话进程十分有用，参加者可以自由进入或离开，没有成员控制或参数协调。</p><h4 id="RTCP信息包"><a href="#RTCP信息包" class="headerlink" title="RTCP信息包"></a>RTCP信息包</h4><p>类似于RTP信息包，每个RTCP信息包以固定部分开始，紧接着的是可变长结构单元，最后以一个32位边界结束。</p><p>根据所携带的控制信息不同RTCP信息包可分为RR（接收者报告包）、SR（源报告包）、SEDS（源描述包）、BYE（离开申明）和APP（特殊应用包）五类5类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SR：源报告包，用于发送和接收活动源的统计信息；</span><br><span class="line">RR：接收者报告包，用于接收非活动站的统计信息；</span><br><span class="line">SDES：源描述包，用于报告和站点相关的信息，包括CNAME；</span><br><span class="line">BYE：断开RTCP包，是站点离开系统的报告，表示结束；</span><br><span class="line">APP：应用特定函数。</span><br></pre></td></tr></table></figure><p>不同类型的RTCP信息包可堆叠，不需要插入任何分隔符就可以将多个RTCP包连接起来形成一个RTCP组合包，然后由低层协议用单一包发送出去。由于需要低层协议提供整体长度来决定组合包的结尾，在组合包中没有单个RTCP包的显式计数。</p><p>组合包中每个RTCP包可独立处理，而不需要按照包组合的先后顺序处理。在组合包中有以下几条强制约束：</p><ol><li><p>只要带宽允许，在SR包或RR包中的接收统计应该经常发送，因此每个周期发送的组合RTCP 包中应包含报告包。</p></li><li><p>每个组合包中都应该包含SDES CNAME，因为新接收者需要通过接收CNAME来识别源，并与媒体联系进行同步。</p></li><li><p>组合包前面是包类型数量，其增长应该受到限制。</p></li></ol><p>所有RTCP包至少必须以两个包组合形式发送，推荐格式如下：</p><p>加密前缀（Encryption prefix）</p><blockquote><p>仅当组合包被加密，才加上一个32位随机数用于每个组合包发送。</p></blockquote><p>SR或RR</p><blockquote><p>组合包中第一个RTCP包必须是一个报告包，以帮助分组头的确认。即使没有数据发送，也没有接收到数据，也要发送一个空RR，那怕组合包中RTCP包为BYE。</p></blockquote><p>附加RR</p><blockquote><p>如报告统计源数目超过31，在初始报告包后应该有附加RR 包。</p></blockquote><p>SDES</p><blockquote><p>包含CNAME 项的SDES包必须包含在每个组合RTCP包中。SDES包可能包括其他源描述项，这要根据特别的应用需要，并同时考虑带宽限制。</p></blockquote><p>BYE或APP</p><blockquote><p>除了BYE应作为最后一个包发送，其它RTCP包类型可以任意顺序排列，包类型出现可不止一次。</p></blockquote><p>混合器从多个源组合单个RTCP包，如组合包整体长度超过网络路径最大传输单元，可分成多个较短组合包用低层协议以单个包形式发送。注意，每个组合包必须以SR或RR包开始。附加RTCP包类型可在Internet Assigned Numbers Authority (IANA)处注册，以获得合法的类型号。</p><h4 id="RTCP传输间隔"><a href="#RTCP传输间隔" class="headerlink" title="RTCP传输间隔"></a>RTCP传输间隔</h4><p>由于RTP设计成允许应用自动扩展，可从几个人的小规模系统扩展成上千人的大规模系统。而每个会话参与者周期性地向所有其他参与者发送RTCP控制信息包，如每个参与者以固定速率发送接收报告，控制流量将随参与者数量线性增长。由于网络资源有限，相应的数据包就要减少，直接影响用户关心的数据传输。为了限制控制信息的流量，RTCP控制信息包速率必须按比例下降。</p><p>一旦确认加入到RTP会话中，即使后来被标记成非活动站，地址的状态仍会被保留，地址应继续计入共享RTCP带宽地址的总数中，时间要保证能扫描典型网络分区，建议为30分钟。注意，这仍大于RTCP报告间隔最大值的五倍。</p><h4 id="SR源报告包和RR接收者报告包"><a href="#SR源报告包和RR接收者报告包" class="headerlink" title="SR源报告包和RR接收者报告包"></a>SR源报告包和RR接收者报告包</h4><p>SR源报告包和RR接收者报告包用于提供接收质量反馈，除包类型代码外，SR与RR间唯一的差别是源报告包含有一个20字节发送者信息段。</p><p>RR针对每个信源都提供信息包丢失数、已收信息包最大序列号、到达时间抖动、接收最后一个SR的时间、接收最后一个SR的延迟等信息。</p><p>SR不仅提供接收质量反馈信息（与RR相同），而且提供SSRC标识符、NTP时间戳、RTP时间戳、发送包数以及发送字节数等。</p><p>根据接收者是否为发送者来决定使用SR还是RR包，活动源在发出最后一个数据包之后或前一个数据包与下一个数据包间隔期间发送SR；否则，就发送RR；SR和RR包都可没有接收报告块也可以包括多个接收报告块，其发布报告表示的源不一定是在CSRC列表上的起作用的源，每个接收报告块提供从特殊源接收数据的统计。</p><p>最大可有31个接收报告块嵌入在SR 或 RR包中，丢失包累计数差别给出间隔期间丢包的数量，而系列号的差别给出间隔期间希望发送的包数量，两者之比等于经过间隔期间包丢失百分比。</p><p>从发送者信息，第三方监控器可计算载荷平均数据速率与没收到数据间隔的平均包速率，两者比值给出平均载荷大小。</p><p>如假设包丢失与包大小无关，那么特殊接收者收到的包数量给出此接收者收到的表观流量。</p><h4 id="SDES源描述包"><a href="#SDES源描述包" class="headerlink" title="SDES源描述包"></a>SDES源描述包</h4><p>SDES源描述包提供了直观的文本信息来描述会话的参加者，包括CNAME、NAME、EMAIL、PHONE、LOC等源描述项，这些为接收方获取发送方的有关信息提供了方便。SDES 包由包头与数据块组成，数据块可以没有，也可有多个。包头由版本（V）、填充（P）、长度指示、包类型（PT）和源计数（SC）组成。PT占8位，用于识别RTCP的SDES包，SC占5位，指示包含在SDES包中的SSRC/CSRC块数量，零值有效，但没有意义。数据块由源描述项组成，源描述项的内容如下：</p><p>CNAME: 规范终端标识SDES项</p><blockquote><p>类似SSRC标识，RTCP为RTP连接中每一个参加者赋予唯一一个CNAME标识。在发生冲突或重启程序时，由于随机分配的SSRC标识可能发生变化，CNAME项可以提供从SSRC标识到仍为常量的源标识的绑定。<br>为方便第三方监控，CNAME应适合程序或人员定位源。</p></blockquote><p>NAME：用户名称SDES项</p><blockquote><p>这是用于描述源的真正的名称，如”John Doe, Bit Recycler, Megacorp”，可以是用户想要的任意形式。由于采用文本信息来描述，对诸如会议应用，可以对参加者直接列表显示，NAME项是除CNAME项以外发送最频繁的项目。NAME值在一次RTP会话期间应该保持为常数，但它不该成为连接的所有参加者中唯一依赖。</p></blockquote><p>EMAIL：电子邮件地址SDES项</p><blockquote><p>邮件地址格式由RFC822规定，如”<a href="mailto:John.Doe@megacorp.com" target="_blank" rel="noopener">John.Doe@megacorp.com</a>“。一次RTP会话期间，EMAIL项的内容希望保持不变。</p></blockquote><p>PHONE：电话号码SDES项</p><blockquote><p>电话号码应带有加号，代替国际接入代码，如”+1 908 555 1212”即为美国电话号码。</p></blockquote><p>LOC：用户地理位置SDES项</p><blockquote><p>根据应用，此项具有不同程度的细节。对会议应用，字符串如”Murray Hill, New Jersey”就足够了。然而，对活动标记系统，字符串如”Room 2A244, AT&amp;T BL MH”也许就适用。细节留给实施或用户，但格式和内容可用设置指示。在一次RTP会话期间，除移动主机外，LOC值期望保持不变。</p></blockquote><p>TOOL：应用或工具名称SDES项</p><blockquote><p>TOOL项包含一个字符串，表示产生流的应用的名称与版本，如”videotool 1.2”。这部分信息对调试很有用，类似于邮件或邮件系统版本SMTP头。TOOL值在一次RTP会话期间保持不变。</p></blockquote><p>NOTE: 通知/状态SDES项</p><blockquote><p>NOTE 项旨在描述源当前状态的过渡信息，如”on the phone, can’t talk”，或在讲座期间用于传送谈话的题目，它的语法可在设置中显式定义。NOTE项一般只用于携带例外信息，而不应包含在全部参加者中，因为这将降低接收报告和CNAME发送的速度，损害协议的性能。一般NOTE 项不作为用户设置文件的项目，也不会自动产生。</p></blockquote><blockquote><p>由于NOTE项对显示很重要，当会话的参加者处于活动状态时，其它非CNAME项（如NAME）传输速率将会降低，结果使NOTE项占用RTCP部分带宽。若过渡信息不活跃，NOTE项继续以同样的速度重复发送几次，并以一个串长为零的字符串通知接收者。</p></blockquote><p>PRIV: 专用扩展SDES项</p><blockquote><p>PRIV项用于定义实验或应用特定的SDES扩展，它由长字符串对组成的前缀，后跟填充该项其他部分和携带所需信息的字符串值组成。前缀长度段为8位。前缀字符串是定义PRIV项人员选择的名称，唯一对应应用接收到的其它PRIV项。应用实现者可选择使用应用名称，如有必要，外加附加子类型标识。另外，推荐其它人根据其代表的实体选择名称，然后，在实体内部协调名称的使用。</p></blockquote><blockquote><p>注意，前缀应尽可能的短。SDES 的PRIV项前缀没在IANA处注册。如证实某些形式的PRIV项具有通用性， IANA应给它分配一个正式的SDES项类型，这样就不再需要前缀，从而简化应用，并提高传输的效率。</p></blockquote><h4 id="BYE断开RTCP包"><a href="#BYE断开RTCP包" class="headerlink" title="BYE断开RTCP包"></a>BYE断开RTCP包</h4><p>如混合器接收到一个BYE包，混合器转发BYE包，而不改变SSRC/CSRC 标识。如混合器关闭，在关闭之前它应该发出一个BYE包，列出混合器处理的所有源，而不只是自己的SSRC标识。作为可选项，BYE包可包括一个8位八进制计数，后跟文本信息，表示离开原因，如：”camera malfunction”或”RTP loop detected”。字符串的编码与在SDES 项中所描述的相同。如字符串信息至BYE包下32位边界结束处，字符串就不以空结尾；否则，BYE包以空八进制填充。</p><h4 id="APP特殊应用包"><a href="#APP特殊应用包" class="headerlink" title="APP特殊应用包"></a>APP特殊应用包</h4><p>APP包用于开发新应用和新特征的实验，不要求注册包类型值。带有不可识别名称的APP包应被忽略掉。测试后，如确定应用广泛，推荐重新定义每个APP包，而不用向IANA注册子类型和名称段。</p><h4 id="RTP-RTCP的不足之处"><a href="#RTP-RTCP的不足之处" class="headerlink" title="RTP/ RTCP的不足之处"></a>RTP/ RTCP的不足之处</h4><p>RTP与RTCP相结合虽然保证了实时数据的传输，但也有自己的缺点。最显著的是当有许多用户一起加入会话进程的时候，由于每个参与者都周期发送RTCP信息包，导致RTCP包泛滥 (flooding)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;RTCP概要&quot;&gt;&lt;a href=&quot;#RTCP概要&quot; class=&quot;headerlink&quot; title=&quot;RTCP概要&quot;&gt;&lt;/a&gt;RTCP概要&lt;/h4&gt;&lt;p&gt;实时传输控制协议(Real-time Control Protocol，RTCP)与RTP共同定义在1996年提出的RFC 1889中，是和 RTP一起工作的控制协议。RTCP单独运行在低层协议上，由低层协议提供数据与控制包的复用。在RTP会话期间，每个会话参与者周期性地向所有其他参与者发送RTCP控制信息包，如下图所示。对于RTP会话或者广播，通常使用单个多目标广播地址，属于这个会话的所有RTP和RTCP信息包都使用这个多目标广播地址，通过使用不同的端口号可把RTP信息包和RTCP信息包区分开来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/04/08/RTSP-RTCP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/1.jpg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="RTSP" scheme="http://www.faihung.net/categories/RTSP/"/>
    
    
      <category term="RTCP" scheme="http://www.faihung.net/tags/RTCP/"/>
    
  </entry>
  
  <entry>
    <title>RTSP-RTP协议分析</title>
    <link href="http://www.faihung.net/2020/04/08/RTSP-RTP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"/>
    <id>http://www.faihung.net/2020/04/08/RTSP-RTP协议分析/</id>
    <published>2020-04-08T08:38:39.000Z</published>
    <updated>2020-04-08T08:50:24.261Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、RTP概述"><a href="#一、RTP概述" class="headerlink" title="一、RTP概述"></a>一、RTP概述</h4><h5 id="1-1-RTP是什么"><a href="#1-1-RTP是什么" class="headerlink" title="1.1 RTP是什么"></a>1.1 RTP是什么</h5><p>RTP全名是Real-time Transport Protocol（实时传输协议）。它是IETF提出的一个标准，对应的RFC文档为RFC3550（RFC1889为其过期版本）。RFC3550不仅定义了RTP，而且定义了配套的相关协议RTCP（Real-time Transport Control Protocol，即实时传输控制协议）。RTP用来为IP网上的语音、图像、传真等多种需要实时传输的多媒体数据提供端到端的实时传输服务。RTP为Internet上端到端的实时传输提供时间信息和流同步，但并不保证服务质量，服务质量由RTCP来提供。</p><a id="more"></a><h5 id="1-2-RTP的应用环境"><a href="#1-2-RTP的应用环境" class="headerlink" title="1.2 RTP的应用环境"></a>1.2 RTP的应用环境</h5><p>RTP用于在单播或多播网络中传送实时数据。它们典型的应用场合有如下几个。</p><p>简单的多播音频会议。语音通信通过一个多播地址和一对端口来实现。一个用于音频数据（RTP），另一个用于控制包（RTCP）。</p><p>音频和视频会议。如果在一次会议中同时使用了音频和视频会议，这两种媒体将分别在不同的RTP会话中传送，每一个会话使用不同的传输地址（IP地址＋端口）。如果一个用户同时使用了两个会话，则每个会话对应的RTCP包都使用规范化名字CNAME（Canonical Name）。与会者可以根据RTCP包中的CNAME来获取相关联的音频和视频，然后根据RTCP包中的计时信息(Network time protocol)来实现音频和视频的同步。</p><p>翻译器和混合器。翻译器和混合器都是RTP级的中继系统。翻译器用在通过IP多播不能直接到达的用户区，例如发送者和接收者之间存在防火墙。当与会者能接收的音频编码格式不一样，比如有一个与会者通过一条低速链路接入到高速会议，这时就要使用混合器。在进入音频数据格式需要变化的网络前，混合器将来自一个源或多个源的音频包进行重构，并把重构后的多个音频合并，采用另一种音频编码进行编码后，再转发这个新的RTP包。从一个混合器出来的所有数据包要用混合器作为它们的同步源（SSRC，见RTP的封装）来识别，可以通过贡献源列表（CSRC表，见RTP的封装）可以确认谈话者。</p><h5 id="1-3-相关概念（流媒体）"><a href="#1-3-相关概念（流媒体）" class="headerlink" title="1.3 相关概念（流媒体）"></a>1.3 相关概念（流媒体）</h5><p>流媒体是指Internet上使用流式传输技术的连续时基媒体。当前在Internet上传输音频和视频等信息主要有两种方式：下载和流式传输两种方式。</p><p>下载情况下，用户需要先下载整个媒体文件到本地，然后才能播放媒体文件。在视频直播等应用场合，由于生成整个媒体文件要等直播结束，也就是用户至少要在直播结束后才能看到直播节目，所以用下载方式不能实现直播。</p><p>流式传输是实现流媒体的关键技术。使用流式传输可以边下载边观看流媒体节目。由于Internet是基于分组传输的，所以接收端收到的数据包往往有延迟和乱序（流式传输构建在UDP上）。要实现流式传输，就是要从降低延迟和恢复数据包时序入手。在发送端，为降低延迟，往往对传输数据进行预处理（降低质量和高效压缩）。在接收端为了恢复时序，采用了接收缓冲；而为了实现媒体的流畅播放，则采用了播放缓冲。</p><p>使用接收缓冲，可以将接收到的数据包缓存起来，然后根据数据包的封装信息（如包序号和时戳等），将乱序的包重新排序，最后将重新排序了的数据包放入播放缓冲播放。</p><p>为什么需要播放缓冲呢？容易想到，由于网络不可能很理想，并且对数据包排序需要处理时耗，我们得到排序好的数据包的时间间隔是不等的。如果不用播放缓冲，那么播放节目会很卡，这叫时延抖动。相反，使用播放缓冲，在开始播放时，花费几十秒钟先将播放缓冲填满（例如PPLIVE），可以有效地消除时延抖动，从而在不太损失实时性的前提下实现流媒体的顺畅播放。</p><p>到目前为止,Internet 上使用较多的流式视频格式主要有以下三种:RealNetworks 公司的RealMedia ,Apple 公司的QuickTime 以及Microsoft 公司的Advanced Streaming Format (ASF) 。</p><p>上面在谈接收缓冲时，说到了流媒体数据包的封装信息（包序号和时戳等），这在后面的RTP封装中会有体现。另外，RealMedia这些流式媒体格式只是编解码有不同，但对于RTP来说，它们都是待封装传输的流媒体数据而没有什么不同。</p><h4 id="二、RTP详解"><a href="#二、RTP详解" class="headerlink" title="二、RTP详解"></a>二、RTP详解</h4><h5 id="2-1-RTP的协议层次"><a href="#2-1-RTP的协议层次" class="headerlink" title="2.1 RTP的协议层次"></a>2.1 RTP的协议层次</h5><h6 id="2-1-1-传输层的子层"><a href="#2-1-1-传输层的子层" class="headerlink" title="2.1.1 传输层的子层"></a>2.1.1 传输层的子层</h6><p>RTP（实时传输协议），顾名思义它是用来提供实时传输的，因而可以看成是传输层的一个子层。图1(流媒体体系结构)给出了流媒体应用中的一个典型的协议体系结构。<br><img src="/2020/04/08/RTSP-RTP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/1.jpg" alt="1"></p><p>从图中可以看出，RTP被划分在传输层，它建立在UDP上。同UDP协议一样，为了实现其实时传输功能，RTP也有固定的封装形式。RTP用来为端到端的实时传输提供时间信息和流同步，但并不保证服务质量。服务质量由RTCP来提供。这些特点，在(四、常见的疑问)可以看到。</p><h6 id="2-1-2-应用层的一部分"><a href="#2-1-2-应用层的一部分" class="headerlink" title="2.1.2 应用层的一部分"></a>2.1.2 应用层的一部分</h6><p>不少人也把RTP归为应用层的一部分，这是从应用开发者的角度来说的。操作系统中的TCP/IP等协议栈所提供的是我们最常用的服务，而RTP的实现还是要靠开发者自己。因此从开发的角度来说，RTP的实现和应用层协议的实现没不同，所以可将RTP看成应用层协议。</p><p>RTP实现者在发送RTP数据时，需先将数据封装成RTP包，而在接收到RTP数据包，需要将数据从RTP包中提取出来。</p><h5 id="2-2-RTP的封装"><a href="#2-2-RTP的封装" class="headerlink" title="2.2 RTP的封装"></a>2.2 RTP的封装</h5><p>一个协议的封装是为了满足协议的功能需求的。从前面提出的功能需求，可以推测出RTP封装中应该有同步源和时戳等字段，但更为完整的封装是什么样子呢？请看图2(RTP的头部格式)。</p><p><img src="/2020/04/08/RTSP-RTP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/2.jpg" alt="2"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">版本号（V）：2比特，用来标志使用的RTP版本。</span><br><span class="line">填充位（P）：1比特，如果该位置位，则该RTP包的尾部就包含附加的填充字节。</span><br><span class="line">扩展位（X）：1比特，如果该位置位的话，RTP固定头部后面就跟有一个扩展头部。</span><br><span class="line">CSRC计数器（CC）：4比特，含有固定头部后面跟着的CSRC的数目。</span><br><span class="line">标记位（M）：1比特,该位的解释由配置文档（Profile）来承担.</span><br><span class="line">载荷类型（PT）：7比特，标识了RTP载荷的类型。</span><br><span class="line">序列号（SN）：16比特，发送方在每发送完一个RTP包后就将该域的值增加1，接收方可以由该域检测包的丢失及恢复包序列。序列号的初始值是随机的。</span><br><span class="line">时间戳：32比特，记录了该包中数据的第一个字节的采样时刻。在一次会话开始时，时间戳初始化成一个初始值。即使在没有信号发送时，时间戳的数值也要随时间而不断地增加（时间在流逝嘛）。时间戳是去除抖动和实现同步不可缺少的。</span><br><span class="line">同步源标识符(SSRC)：32比特，同步源就是指RTP包流的来源。在同一个RTP会话中不能有两个相同的SSRC值。该标识符是随机选取的 RFC1889推荐了MD5随机算法。</span><br><span class="line">贡献源列表（CSRC List）：0～15项，每项32比特，用来标志对一个RTP混合器产生的新包有贡献的所有RTP包的源。由混合器将这些有贡献的SSRC标识符插入表中。SSRC标识符都被列出来，以便接收端能正确指出交谈双方的身份。</span><br></pre></td></tr></table></figure><h5 id="2-3-RTCP的封装"><a href="#2-3-RTCP的封装" class="headerlink" title="2.3 RTCP的封装"></a>2.3 RTCP的封装</h5><p>RTP需要RTCP为其服务质量提供保证，因此下面介绍一下RTCP的相关知识。</p><p>RTCP的主要功能是：服务质量的监视与反馈、媒体间的同步，以及多播组中成员的标识。在RTP会话期间，各参与者周期性地传送RTCP包。RTCP包中含有已发送的数据包的数量、丢失的数据包的数量等统计资料，因此，各参与者可以利用这些信息动态地改变传输速率，甚至改变有效载荷类型。RTP和RTCP配合使用，它们能以有效的反馈和最小的开销使传输效率最佳化，因而特别适合传送网上的实时数据。</p><p>从图 1可以看到，RTCP也是用UDP来传送的，但RTCP封装的仅仅是一些控制信息，因而分组很短，所以可以将多个RTCP分组封装在一个UDP包中。RTCP有如下五种分组类型。</p><p>表 1 RTCP的5种分组类型:</p><table><thead><tr><th>类型</th><th>缩写表示</th><th>用途</th></tr></thead><tbody><tr><td>200</td><td>SR（Sender Report）</td><td>发送端报告</td></tr><tr><td>201</td><td>RR（Receiver Report）</td><td>接收端报告</td></tr><tr><td>202</td><td>SDES（Source Description Items）</td><td>源点描述</td></tr><tr><td>203</td><td>BYE</td><td>结束传输</td></tr><tr><td>204</td><td>APP</td><td>特定应用</td></tr></tbody></table><p>上述五种分组的封装大同小异，下面只讲述SR类型，而其它类型请参考RFC3550。</p><p>发送端报告分组SR（Sender Report）用来使发送端以多播方式向所有接收端报告发送情况。SR分组的主要内容有：相应的RTP流的SSRC，RTP流中最新产生的RTP分组的时间戳和NTP，RTP流包含的分组数，RTP流包含的字节数。SR包的封装如图3(RTCP头部的格式)所示。</p><p><img src="/2020/04/08/RTSP-RTP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/3.jpg" alt="3"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">版本（V）：同RTP包头域。</span><br><span class="line">填充（P）：同RTP包头域。</span><br><span class="line">接收报告计数器（RC）：5比特，该SR包中的接收报告块的数目，可以为零。</span><br><span class="line">包类型（PT）：8比特，SR包是200。</span><br><span class="line">长度域（Length）：16比特，其中存放的是该SR包以32比特为单位的总长度减一。</span><br><span class="line">同步源（SSRC）：SR包发送者的同步源标识符。与对应RTP包中的SSRC一样。</span><br><span class="line">NTP Timestamp（Network time protocol）SR包发送时的绝对时间值。NTP的作用是同步不同的RTP媒体流。</span><br><span class="line">RTP Timestamp：与NTP时间戳对应，与RTP数据包中的RTP时间戳具有相同的单位和随机初始值。</span><br><span class="line">Sender’s packet count：从开始发送包到产生这个SR包这段时间里，发送者发送的RTP数据包的总数. SSRC改变时，这个域清零。</span><br><span class="line">Sender`s octet count：从开始发送包到产生这个SR包这段时间里，发送者发送的净荷数据的总字节数（不包括头部和填充）。发送者改变其SSRC时，这个域要清零。</span><br><span class="line">同步源n的SSRC标识符：该报告块中包含的是从该源接收到的包的统计信息。</span><br><span class="line">丢失率（Fraction Lost）：表明从上一个SR或RR包发出以来从同步源n(SSRC_n)来的RTP数据包的丢失率。</span><br><span class="line">累计的包丢失数目：从开始接收到SSRC_n的包到发送SR,从SSRC_n传过来的RTP数据包的丢失总数。</span><br><span class="line">收到的扩展最大序列号：从SSRC_n收到的RTP数据包中最大的序列号</span><br><span class="line">接收抖动（Interarrival jitter）：RTP数据包接受时间的统计方差估计</span><br><span class="line">上次SR时间戳（Last SR,LSR）：取最近从SSRC_n收到的SR包中的NTP时间戳的中间32比特。如果目前还没收到SR包，则该域清零。</span><br><span class="line">上次SR以来的延时（Delay since last SR,DLSR）：上次从SSRC_n收到SR包到发送本报告的延时。</span><br></pre></td></tr></table></figure><h5 id="2-4-RTP的会话过程"><a href="#2-4-RTP的会话过程" class="headerlink" title="2.4 RTP的会话过程"></a>2.4 RTP的会话过程</h5><p>当应用程序建立一个RTP会话时，应用程序将确定一对目的传输地址。目的传输地址由一个网络地址和一对端口组成，有两个端口：一个给RTP包，一个给RTCP包，使得RTP/RTCP数据能够正确发送。RTP数据发向偶数的UDP端口，而对应的控制信号RTCP数据发向相邻的奇数UDP端口（偶数的UDP端口＋1），这样就构成一个UDP端口对。 RTP的发送过程如下，接收过程则相反。</p><p>1) RTP 协议从上层接收流媒体信息码流（如H.263），封装成RTP数据包；RTCP从上层接收控制信息，封装成RTCP控制包。<br>2) RTP将RTP 数据包发往UDP端口对中偶数端口；RTCP将RTCP控制包发往UDP端口对中的接收端口。</p><h4 id="三、相关的协议"><a href="#三、相关的协议" class="headerlink" title="三、相关的协议"></a>三、相关的协议</h4><h5 id="3-1-实时流协议RTSP"><a href="#3-1-实时流协议RTSP" class="headerlink" title="3.1 实时流协议RTSP"></a>3.1 实时流协议RTSP</h5><p>实时流协议RTSP（Real-Time Streaming Protocol）是IETF提出的协议，对应的RFC文档为RFC2362。</p><p>从图 1可以看出，RTSP是一个应用层协议（TCP/IP网络体系中）。它以C/S模式工作，它是一个多媒体播放控制协议，主要用来使用户在播放流媒体时可以像操作本地的影碟机一样进行控制，即可以对流媒体进行暂停/继续、后退和前进等控制。</p><h5 id="3-2-资源预定协议RSVP"><a href="#3-2-资源预定协议RSVP" class="headerlink" title="3.2 资源预定协议RSVP"></a>3.2 资源预定协议RSVP</h5><p>资源预定协议RSVP(Resource Reservation Protocol)是IETF提出的协议，对应的RFC文档为RFC2208。</p><p>从图 1可以看出，RSVP工作在IP层之上传输层之下，是一个网络控制协议。RSVP通过在路由器上预留一定的带宽，能在一定程度上为流媒体的传输提供服务质量。在某些试验性的系统如网络视频会议工具vic中就集成了RSVP。</p><h4 id="四、常见的疑问"><a href="#四、常见的疑问" class="headerlink" title="四、常见的疑问"></a>四、常见的疑问</h4><h5 id="4-1-怎样重组乱序的数据包"><a href="#4-1-怎样重组乱序的数据包" class="headerlink" title="4.1 怎样重组乱序的数据包"></a>4.1 怎样重组乱序的数据包</h5><p>可以根据RTP包的序列号来排序。</p><h5 id="4-2-怎样获得数据包的时序"><a href="#4-2-怎样获得数据包的时序" class="headerlink" title="4.2 怎样获得数据包的时序"></a>4.2 怎样获得数据包的时序</h5><p>可以根据RTP包的时间戳来获得数据包的时序。</p><h5 id="4-3-声音和图像怎么同步"><a href="#4-3-声音和图像怎么同步" class="headerlink" title="4.3 声音和图像怎么同步"></a>4.3 声音和图像怎么同步</h5><p>根据声音流和图像流的相对时间（即RTP包的时间戳），以及它们的绝对时间（即对应的RTCP包中的RTCP），可以实现声音和图像的同步。</p><h5 id="4-4-接收缓冲和播放缓冲的作用"><a href="#4-4-接收缓冲和播放缓冲的作用" class="headerlink" title="4.4 接收缓冲和播放缓冲的作用"></a>4.4 接收缓冲和播放缓冲的作用</h5><p>如1.3.1所述，接收缓冲用来排序乱序了的数据包；播放缓冲用来消除播放的抖动，实现等时播放。</p><h4 id="五、实现方案"><a href="#五、实现方案" class="headerlink" title="五、实现方案"></a>五、实现方案</h4><p><img src="/2020/04/08/RTSP-RTP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/4.jpg" alt="4"></p><p>表 2给出了协议分析要求。容易看出要获取RTP音频包中的音频信息很容易，直接将RTP包的包头去掉即可。当然，要成功地播放解码获取到的音频流，需要知道其编码，这可从RTP包包头的有效载荷类型字段（PT）获得。</p><h4 id="六、参考资料"><a href="#六、参考资料" class="headerlink" title="六、参考资料"></a>六、参考资料</h4><p>RFC文档：RFC3550对应RTP/RTCP，RFC2362对应RTSP，RFC2208对应RSVP</p><p><a href="http://www.faqs.org/rfcs/" target="_blank" rel="noopener">RFC文档</a><br><a href="http://www.cnpaf.net/" target="_blank" rel="noopener">协议分析文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、RTP概述&quot;&gt;&lt;a href=&quot;#一、RTP概述&quot; class=&quot;headerlink&quot; title=&quot;一、RTP概述&quot;&gt;&lt;/a&gt;一、RTP概述&lt;/h4&gt;&lt;h5 id=&quot;1-1-RTP是什么&quot;&gt;&lt;a href=&quot;#1-1-RTP是什么&quot; class=&quot;headerlink&quot; title=&quot;1.1 RTP是什么&quot;&gt;&lt;/a&gt;1.1 RTP是什么&lt;/h5&gt;&lt;p&gt;RTP全名是Real-time Transport Protocol（实时传输协议）。它是IETF提出的一个标准，对应的RFC文档为RFC3550（RFC1889为其过期版本）。RFC3550不仅定义了RTP，而且定义了配套的相关协议RTCP（Real-time Transport Control Protocol，即实时传输控制协议）。RTP用来为IP网上的语音、图像、传真等多种需要实时传输的多媒体数据提供端到端的实时传输服务。RTP为Internet上端到端的实时传输提供时间信息和流同步，但并不保证服务质量，服务质量由RTCP来提供。&lt;/p&gt;
    
    </summary>
    
    
      <category term="RTSP" scheme="http://www.faihung.net/categories/RTSP/"/>
    
    
      <category term="RTP" scheme="http://www.faihung.net/tags/RTP/"/>
    
  </entry>
  
  <entry>
    <title>RTSP-RTSP协议详解</title>
    <link href="http://www.faihung.net/2020/04/08/RTSP-RTSP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.faihung.net/2020/04/08/RTSP-RTSP协议详解/</id>
    <published>2020-04-08T06:53:48.000Z</published>
    <updated>2020-04-08T07:08:40.713Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><h5 id="1-1-RTSP简介"><a href="#1-1-RTSP简介" class="headerlink" title="1.1 RTSP简介"></a>1.1 RTSP简介</h5><p>RTSP(Real Time Streaming Protocol), 实时流传输协议, 是TCP/IP协议体系中的一个应用层协议, 由哥伦比亚大学, 网景和RealNetworks公司提交的IETF RFC标准. 该协议定义了一对多应用程序如何有效地通过IP网络传送多媒体数据. RTSP在体系结构上位于RTP和RTCP之上, 它使用TCP或RTP完成数据传输.</p><a id="more"></a><p><img src="/2020/04/08/RTSP-RTSP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/1.jpg" alt="1"></p><p><strong>流媒体服务协议栈</strong></p><p>RTSP提供了一个可扩展框架, 使实时数据, 如音频与视频的受控点播成为可能。 数据源包括现场数据与存储在剪辑中数据。该协议目的在于控制多个数据发送连接, 为选择发送通道, 如UDP, 组播UDP与TCP, 提供途径, 并为选择基于RTP上发送机制提供方法。</p><p>它的语法和运作跟HTTP 1.1类似, 但并不特别强调时间同步,所以比较能容忍网络延迟。</p><p>HTTP与RTSP相比, * HTTP传送HTML. HTTP请求由客户机发出, 服务器作出响应 * RTSP传送的是多媒体数据。使用RTSP时, 客户机和服务器都可以发出请求, 即RTSP可以是双向的。</p><p>RTSP是用来控制声音或影像的多媒体串流协议, 并允许同时多个串流需求控制, 传输时所用的网络通讯协议并不在其定义的范围内, 服务器端可以自行选择使用TCP或UDP来传送串流内容。</p><p>而前面提到的允许同时多个串流需求控制(Multicast), 除了可以降低服务器端的网络用量, 更进而支持多方视讯会议(Video Conference)。 因为与HTTP1.1的运作方式相似, 所以代理服务器〈Proxy〉的快取功能〈Cache〉也同样适用于RTSP, 并因RTSP具有重新导向功能, 可视实际负载情况来转换提供服务的服务器, 以避免过大的负载集中于同一服务器而造成延迟。</p><p>该协议用于C/S模型, 是一个基于文本的协议, 用于在客户端和服务器端建立和协商实时流会话。</p><p>实时流协议(RTSP)建立并控制一个或几个时间同步的连续流媒体。 尽管连续媒体流与控制流交换是可能的, 通常它本身并不发送连续流。换言之, RTSP充当多媒体服务器的网络远程控制。RTSP连接没有绑定到传输层连接, 如TCP。 在RTSP连接期间, RTSP用户可打开或关闭多个对服务器的可传输连接以发出RTSP请求。此外, 可使用无连接传输协议, 如UDP。 RTSP流控制的流可能用到RTP, 但RTSP操作并不依赖用于携带连续媒体的传输机制。</p><p><strong>协议支持的操作如下</strong></p><ol><li>从媒体服务器上检索媒体: 用户可通过HTTP或其它方法提交一个演示描述。 如演示是组播, 演示式就包含用于连续媒体的的组播地址和端口。 如演示仅通过单播发送给用户, 用户为了安全应提供目的地址。</li><li>媒体服务器邀请进入会议: 媒体服务器可被邀请参加正进行的会议, 或回放媒体, 或记录其中一部分, 或全部。这种模式在分布式教育应用上很有用, 会议中几方可轮流按远程控制按钮。</li><li>将媒体加到现成讲座中: 如服务器告诉用户可获得附加媒体内容, 对现场讲座显得尤其有用。如HTTP/1.1中类似, RTSP请求可由代理, 通道与缓存处理。</li></ol><h5 id="1-2-协议特点"><a href="#1-2-协议特点" class="headerlink" title="1.2 协议特点"></a>1.2 协议特点</h5><ul><li>可扩展性: 新方法和参数很容易加入RTSP.</li><li>易解析: RTSP可由标准HTTP或MIME解析器解析.</li><li>安全: RTSP使用网页安全机制.</li><li>独立于传输: RTSP可使用不可靠数据报协议(EDP), 可靠数据报协议(RDP); 如要实现应用级可靠, 可使用可靠流协议.</li><li>多服务器支持: 每个流可放在不同服务器上, 用户端自动与不同服务器建立几个并发控制连接, 媒体同步在传输层执行.</li><li>记录设备控制: 协议可控制记录和回放设备.</li><li>流控与会议开始分离: 仅要求会议初始化协议提供, 或可用来创建惟一会议标识号. 特殊情况下, 可用SIP或H.323来邀请服务器入会.</li><li>适合专业应用: 通过SMPTE时标, RTSP支持帧级精度, 允许远程数字编辑.</li><li>演示描述中立: 协议没强加特殊演示或元文件, 可传送所用格式类型; 然而, 演示描述至少必须包括一个RTSP URL.</li><li>代理与防火墙友好: 协议可由应用和传输层防火墙处理。 防火墙需要理解SETUP方法, 为UDP媒体流打开一个“缺口”。</li><li>HTTP友好: 此处, RTSP明智地采用HTTP观念, 使现在结构都可重用。 结构包括Internet内容选择平台(PICS)。 由于在大多数情况下控制连续媒体需要服务器状态, RTSP不仅仅向HTFP添加方法。</li><li>适当的服务器控制: 如用户启动一个流, 必须也可以停止一个流。</li><li>传输协调: 实际处理连续媒体流前, 用户可协调传输方法。</li><li>性能协调: 如基本特征无效, 必须有一些清理机制让用户决定哪种方法没生效， 这允许用户提出适合的用户界面。</li></ul><h4 id="二、协议细节"><a href="#二、协议细节" class="headerlink" title="二、协议细节"></a>二、协议细节</h4><h5 id="2-1-典型的rtsp交互过程"><a href="#2-1-典型的rtsp交互过程" class="headerlink" title="2.1 典型的rtsp交互过程"></a>2.1 典型的rtsp交互过程</h5><blockquote><p>C表示rtsp客户端, S表示rtsp服务端</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. C-&gt;S:OPTION request //询问S有哪些方法可用 </span><br><span class="line">1. S-&gt;C:OPTION response //S回应信息中包括提供的所有可用方法</span><br><span class="line">2. C-&gt;S:DESCRIBE request //要求得到S提供的媒体初始化描述信息 </span><br><span class="line">2. S-&gt;C:DESCRIBE response //S回应媒体初始化描述信息, 主要是sdp </span><br><span class="line">3. C-&gt;S:SETUP request //设置会话的属性, 以及传输模式, 提醒S建立会话 </span><br><span class="line">3. S-&gt;C:SETUP response //S建立会话, 返回会话标识符, 以及会话相关信息 </span><br><span class="line">4. C-&gt;S:PLAY request //C请求播放 </span><br><span class="line">4. S-&gt;C:PLAY response //S回应该请求的信息 S-&gt;C:发送流媒体数据 </span><br><span class="line">5. C-&gt;S:TEARDOWN request //C请求关闭会话 </span><br><span class="line">5. S-&gt;C:TEARDOWN response //S回应该请求</span><br></pre></td></tr></table></figure><p>上述的过程是标准的, 友好的rtsp流程, 但实际的需求中并不一定按部就班来. 其中第3和4步是必需的！</p><p>第一步, 只要服务器客户端约定好, 有哪些方法可用, 则option请求可以不要.</p><p>第二步, 如果我们有其他途径得到媒体初始化描述信息(比如http请求等等), 则我们也不需要通过rtsp中的describe请求来完成.</p><p>第五步, 可以根据系统需求的设计来决定是否需要.</p><h5 id="2-2-RTSP消息格式"><a href="#2-2-RTSP消息格式" class="headerlink" title="2.2 RTSP消息格式"></a>2.2 RTSP消息格式</h5><p>RTSP的消息有两大类: 请求消息(request), 回应消息(response</p><p>++请求消息++</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法 URI RTSP版本 CR LF 消息头 CR LF CR LF 消息体 CR LF</span><br></pre></td></tr></table></figure><p>其中方法包括OPTION回应中所有的命令,URI是接受方的地址,例如:rtsp://192.168.20.136. RTSP版本一般都是 RTSP/1.0. 每行后面的CR LF表示回车换行, 需要接受端有相应的解析, 最后一个消息头需要有两个CR LF(即空行)</p><p>++回应消息++</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTSP版本 状态码 解释 CR LF 消息头 CR LF CR LF 消息体 CR LF</span><br></pre></td></tr></table></figure><p>其中RTSP版本一般都是RTSP/1.0, 状态码是一个数值, 200表示成功, 解释是与状态码对应的文本解释.</p><h5 id="2-3-方法定义"><a href="#2-3-方法定义" class="headerlink" title="2.3 方法定义"></a>2.3 方法定义</h5><p>方法记号表示资源上执行的方法, 它区分大小写. 新方法可在将来定义, 但不能以$开头. 已定义方法如下表所示:(注: P—-演示, S—-流, C—-用户端, S—-服务器端)</p><table><thead><tr><th>方法</th><th>方向</th><th>对象</th><th>要求</th><th>含义</th></tr></thead><tbody><tr><td>DESCRIBE</td><td>C-&gt;S</td><td>P,S</td><td>推荐</td><td>检查演示或媒体对象的描述,也允许使用接收头指定用户理解的描述格式. DESCRIBE的答复-响应组成媒体RTSP初始阶段</td></tr><tr><td>ANNOUNCE</td><td>C-&gt;S S-&gt;C</td><td>P,S</td><td>可选</td><td>当从用户发往服务器时, ANNOUNCE将请求URL识别的演示或媒体对象描述发送给服务器; 反之, ANNOUNCE实时更新连接描述. 如新媒体流加入演示, 整个演示描述再次发送, 而不仅仅是附加组件, 使组件能被删除</td></tr><tr><td>GET_PARAMETER</td><td>C-&gt;S S-&gt;C</td><td>P,S</td><td>可选</td><td><code>GET_PARAMETER</code>请求检查RUL指定的演示与媒体的参数值. 没有实体体时,<code>GET_PARAMETER</code>也许能用来测试用户与服务器的连通情况</td></tr><tr><td>OPTIONS</td><td>C-&gt;S S-&gt;C</td><td>P,S</td><td>要求</td><td>可在任意时刻发出OPTIONS请求, 如用户打算尝试非标准请求, 并不影响服务器状态</td></tr><tr><td>PAUSE</td><td>C-&gt;S</td><td>P,S</td><td>推荐</td><td>PAUSE请求引起流发送临时中断. 如请求URL命名一个流, 仅回放和记录被停止; 如请求URL命名一个演示或流组, 演示或组中所有当前活动的流发送都停止. 恢复回放或记录后, 必须维持同步. 在SETUP消息中连接头超时参数所指定时段期间被暂停后, 尽管服务器可能关闭连接并释放资源, 但服务器资源会被预订</td></tr><tr><td>PLAY</td><td>C-&gt;S</td><td>P,S</td><td>要求</td><td>PLAY告诉服务器以SETUP指定的机制开始发送数据; 直到一些SETUP请求被成功响应, 客户端才可发布PLAY请求. PLAY请求将正常播放时间设置在所指定范围的起始处, 发送流数据直到范围的结束处. PLAY请求可排成队列, 服务器将PLAY请求排成队列, 顺序执行</td></tr><tr><td>RECORD</td><td>C-&gt;S</td><td>P,S</td><td>可选</td><td>该方法根据演示描述初始化媒体数据记录范围, 时标反映开始和结束时间; 如没有给出时间范围, 使用演示描述提供的开始和结束时间. 如连接已经启动, 立即开始记录, 服务器数据请求URL或其他URL决定是否存储记录的数据; 如服务器没有使用URL请求, 响应应为201(创建), 并包含描述请求状态和参考新资源的实体与位置头. 支持现场演示记录的媒体服务器必须支持时钟范围格式, smpte格式没有意义</td></tr><tr><td>REDIRECT</td><td>S-&gt;C</td><td>P,S</td><td>可选</td><td>重定向请求通知客户端连接到另一服务器地址. 它包含强制头地址, 指示客户端发布URL请求; 也可能包括参数范围, 以指明重定向何时生效. 若客户端要继续发送或接收URL媒体, 客户端必须对当前连接发送TEARDOWN请求, 而对指定主执新连接发送SETUP请求</td></tr><tr><td>SETUP</td><td>C-&gt;S</td><td>S</td><td>要求</td><td>对URL的SETUP请求指定用于流媒体的传输机制. 客户端对正播放的流发布一个SETUP请求, 以改变服务器允许的传输参数. 如不允许这样做, 响应错误为”455 Method Not Valid In This State”. 为了透过防火墙, 客户端必须指明传输参数, 即使对这些参数没有影响</td></tr><tr><td>SET_PARAMETER</td><td>C-&gt;S S-&gt;C</td><td>P,S</td><td>可选</td><td>这个方法请求设置演示或URL指定流的参数值. 请求仅应包含单个参数, 允许客户端决定某个特殊请求为何失败. 如请求包含多个参数, 所有参数可成功设置, 服务器必须只对该请求起作用. 服务器必须允许参数可重复设置成同一值, 但不让改变参数值. 注意: 媒体流传输参数必须用SETUP命令设置. 将设置传输参数限制为SETUP有利于防火墙. 将参数划分成规则排列形式, 结果有更多有意义的错误指示</td></tr><tr><td>TEARDOWN</td><td>C-&gt;S</td><td>P,S</td><td>要求</td><td>TEARDOWN请求停止给定URL流发送, 释放相关资源. 如URL是此演示URL, 任何RTSP连接标识不再有效. 除非全部传输参数是连接描述定义的, SETUP请求必须在连接可再次播放前发布</td></tr></tbody></table><p>某些防火墙设计与其他环境可能要求服务器插入RTSP方法和流数据. 由于插入将使客户端和服务器操作复杂, 并增加附加开销, 除非有必要, 应避免这样做. 插入二进制数据仅在RTSP通过TCP传输时才可使用.</p><p>流数据(如RTP包)用一个ASCII字符’′封装, 后跟一个一字节通道标识, 其后是封装二进制数据的长度, 两字节整数.流数据紧跟其后, 没有CRLF, 但包括高层协议头.每个块包含一个高层协议数据单元.</p><p>当传输选择为RTP, RTCP信息也被服务器通过TCP连接插入. 缺省情况下, RTCP包在比RTP通道高的第一个可用通道上发送. 客户端可能在另一通道显式请求RTCP包, 这可通过指定传输头插入参数中的两个通道来做到. 当两个或更多流交叉时, 为取得同步, 需要RTCP. 而且, 这为当网络设置需要通过TCP控制连接透过RTP/RTCP提供了一条方便的途径, 可能时, 在UDP上进行传输.</p><h5 id="2-4-消息头定义"><a href="#2-4-消息头定义" class="headerlink" title="2.4 消息头定义"></a>2.4 消息头定义</h5><p>消息头的定义如下表. 表格说明:</p><table><thead><tr><th>Type</th></tr></thead><tbody><tr><td>类型 “g” 表示请求和响应中的通用请求头;</td></tr><tr><td>类型 “R” 表示请求头;</td></tr><tr><td>类型 “r” 表示响应头;</td></tr><tr><td>类型 “e” 表示实体头字段.</td></tr></tbody></table><table><thead><tr><th>Support</th></tr></thead><tbody><tr><td>“req.” 表示必须由接收者以特殊的方法实现; 注意, 不是所有 “req.” 字段在该类型的每个请求中都会被发送. “req.” 只表示客户机(支持响应头)和服务器(支持请求头)必须执行该字段.</td></tr><tr><td>“opt.” 表示是可选的.</td></tr></tbody></table><p>最后一栏列出了关于头字段产生作用的方法; 其中 “entity” 针对于返回一个信息主体的所有方法. )</p><p><img src="/2020/04/08/RTSP-RTSP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/2.jpg" alt="2"></p><p><img src="/2020/04/08/RTSP-RTSP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/3.jpg" alt="3"></p><p><strong>常用头解析</strong>:</p><p><img src="/2020/04/08/RTSP-RTSP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/4.jpg" alt="4"></p><p><img src="/2020/04/08/RTSP-RTSP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/5.jpg" alt="5"></p><h5 id="2-5-状态码"><a href="#2-5-状态码" class="headerlink" title="2.5 状态码"></a>2.5 状态码</h5><p>标准RTSP 消息的状态码(在应答消息的第一行表示)</p><p><img src="/2020/04/08/RTSP-RTSP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/6.jpg" alt="6"></p><p><img src="/2020/04/08/RTSP-RTSP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/7.jpg" alt="7"></p><p><img src="/2020/04/08/RTSP-RTSP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/8.jpg" alt="8"></p><h4 id="三、rtsp中常用方法举例"><a href="#三、rtsp中常用方法举例" class="headerlink" title="三、rtsp中常用方法举例"></a>三、rtsp中常用方法举例</h4><p>本节针对上面所述的典型交互过程进行说明</p><h5 id="3-1-OPTION"><a href="#3-1-OPTION" class="headerlink" title="3.1 OPTION"></a>3.1 OPTION</h5><p>目的是得到服务器提供的可用方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS rtsp://192.168.20.136:5000/xxx666 RTSP/1.0 CSeq: 1 //每个消息都有序号来标记, 第一个包通常是option请求消息 User-Agent: VLC media player (LIVE555 Streaming Media v2005.11.10)</span><br></pre></td></tr></table></figure><p>服务器的回应信息包括提供的一些方法,例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RTSP/1.0 200 OK Server: UServer 0.9.7_rc1 Cseq: 1 //每个回应消息的cseq数值和请求消息的cseq相对应 </span><br><span class="line">Public: OPTIONS, DESCRIBE, SETUP, TEARDOWN, PLAY, PAUSE, SCALE,GET_PARAMETER //服务器提供的可用的方法</span><br></pre></td></tr></table></figure><h5 id="3-2-DESCRIBE"><a href="#3-2-DESCRIBE" class="headerlink" title="3.2 DESCRIBE"></a>3.2 DESCRIBE</h5><p>C向S发起DESCRIBE请求,为了得到会话描述信息(SDP):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DESCRIBE rtsp://192.168.20.136:5000/xxx666 RTSP/1.0 </span><br><span class="line">CSeq: 2 </span><br><span class="line">token: </span><br><span class="line">Accept: application/sdp </span><br><span class="line">User-Agent: VLC media player (LIVE555 Streaming Media v2005.11.10)</span><br></pre></td></tr></table></figure><p>服务器回应一些对此会话的描述信息(sdp):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RTSP/1.0 200 OK Server: UServer 0.9.7_rc1 </span><br><span class="line">Cseq: 2 </span><br><span class="line">x-prev-url: rtsp://192.168.20.136:5000 </span><br><span class="line">x-next-url: rtsp://192.168.20.136:5000 </span><br><span class="line">x-Accept-Retransmit: our-retransmit </span><br><span class="line">x-Accept-Dynamic-Rate: 1 </span><br><span class="line">Cache-Control: must-revalidate </span><br><span class="line">Last-Modified: Fri, 10 Nov 2006 12:34:38 GMT Date: Fri, 10 Nov 2006 12:34:38 </span><br><span class="line">GMT Expires: Fri, 10 Nov 2006 12:34:38 GMT </span><br><span class="line">Content-Base: rtsp://192.168.20.136:5000/xxx666/ Content-Length: 344 Content-Type: application/sdp v=0 //以下都是sdp信息 o=OnewaveUServerNG 1451516402 1025358037 IN IP4 192.168.20.136 s=/xxx666 u=http:/// e=admin@ c=IN IP4 0.0.0.0 t=0 0 a=isma-compliance:1,1.0,1 a=range:npt=0- m=video 0 RTP/AVP 96 //m表示媒体描述, 下面是对会话中视频通道的媒体描述 a=rtpmap:96 MP4V-ES/90000 a=fmtp:96 profile-level-id=245;config=000001B0F5000001B509000001000000012000C888B0E0E0FA62D089028307 a=control:trackID=0 //trackID＝0表示视频流用的是通道0</span><br></pre></td></tr></table></figure><h5 id="3-3-SETUP"><a href="#3-3-SETUP" class="headerlink" title="3.3 SETUP"></a>3.3 SETUP</h5><p>客户端提醒服务器建立会话,并确定传输模式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SETUP rtsp://192.168.20.136:5000/xxx666/trackID=0 RTSP/1.0 </span><br><span class="line">CSeq: 3 </span><br><span class="line">Transport: RTP/AVP/TCP;unicast;interleaved=0-1 </span><br><span class="line">User-Agent: VLC media player (LIVE555 Streaming Media v2005.11.10) //uri中 带有trackID＝0, 表示对该通道进行设置. Transport参数设置了传输模式, 包的结构. 接下来的数据包头部第二个字节位置就是 interleaved, 它的值是每个通道都不同的, trackID＝0的interleaved值有两个0或1, 0表示rtp包, 1表示rtcp包, 接 受端根据interleaved的值来区别是哪种数据包.</span><br></pre></td></tr></table></figure><p>服务器回应信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RTSP/1.0 200 OK Server: UServer 0.9.7_rc1 </span><br><span class="line">Cseq: 3 </span><br><span class="line">Session: 6310936469860791894 //服务器回应的会话标识符 </span><br><span class="line">Cache-Control: no-cache </span><br><span class="line">Transport: RTP/AVP/TCP;unicast;interleaved=0-1;ssrc=6B8B4567</span><br></pre></td></tr></table></figure><h5 id="3-4-PLAY"><a href="#3-4-PLAY" class="headerlink" title="3.4 PLAY"></a>3.4 PLAY</h5><p>客户端发送播放请求:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PLAY rtsp://192.168.20.136:5000/xxx666 RTSP/1.0 </span><br><span class="line">CSeq: 4 </span><br><span class="line">Session: 6310936469860791894 </span><br><span class="line">Range: npt=0.000- //设置播放时间的范围 </span><br><span class="line">User-Agent: VLC media player (LIVE555 Streaming Media v2005.11.10)</span><br></pre></td></tr></table></figure><p>服务器回应信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RTSP/1.0 200 OK Server: UServer 0.9.7_rc1 </span><br><span class="line">Cseq: 4 </span><br><span class="line">Session: 6310936469860791894 </span><br><span class="line">Range: npt=0.000000- </span><br><span class="line">RTP-Info: url=trackID=0;seq=17040;rtptime=1467265309 //seq和rtptime都是rtp包中的信息</span><br></pre></td></tr></table></figure><h5 id="3-5-TEARDOWN"><a href="#3-5-TEARDOWN" class="headerlink" title="3.5 TEARDOWN"></a>3.5 TEARDOWN</h5><p>客户端发起关闭请求:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TEARDOWN rtsp://192.168.20.136:5000/xxx666 RTSP/1.0 </span><br><span class="line">CSeq: 5 </span><br><span class="line">Session: 6310936469860791894 </span><br><span class="line">User-Agent: VLC media player (LIVE555 Streaming Media v2005.11.10)</span><br></pre></td></tr></table></figure><p>服务器回应:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RTSP/1.0 200 OK Server: UServer 0.9.7_rc1 </span><br><span class="line">Cseq: 5 </span><br><span class="line">Session: 6310936469860791894 </span><br><span class="line">Connection: Close</span><br></pre></td></tr></table></figure><p>以上方法都是交互过程中最为常用的, 其它还有一些重要的方法如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get/set_parameter,pause,redirect等等</span><br></pre></td></tr></table></figure><h4 id="四、SDP协议概述"><a href="#四、SDP协议概述" class="headerlink" title="四、SDP协议概述"></a>四、SDP协议概述</h4><h5 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h5><p>SDP 完全是一种会话描述格式, 它不属于传输协议.<br>它使用不同的适当的传输协议，包括会话通知协议（SAP）、会话初始协议（SIP）、 实时流协议（RTSP）、MIME扩展协议的电子邮件以及超文本传输协议（HTTP）。<br>SDP协议是也是基于文本的协议，这样就能保证协议的可扩展性比较强, 这样就使其具有广泛的应用范围。SDP 不支持会话内容或媒体编码的协商, 所以在流媒体中只用来描述媒体信息。媒体协商这一块要用RTSP来实现．</p><h5 id="4-2-SDP协议格式"><a href="#4-2-SDP协议格式" class="headerlink" title="4.2 SDP协议格式"></a>4.2 SDP协议格式</h5><p>SDP描述由许多文本行组成，文本行的格式为&lt;类型&gt;=&lt;值&gt;，&lt;类型&gt;是一个字母，&lt;值&gt;是结构化的文本串，其格式依&lt;类型&gt;而定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">＜type＞=&lt;value&gt;[CRLF]</span><br></pre></td></tr></table></figure><p><strong>sdp的格式</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">v=&lt;version&gt; </span><br><span class="line">o=&lt;username&gt; &lt;session id&gt; &lt;version&gt; &lt;network type&gt; &lt;address type&gt; &lt;address&gt; </span><br><span class="line">s=&lt;session name&gt; </span><br><span class="line">i=&lt;session description&gt; </span><br><span class="line">u=&lt;URI&gt; </span><br><span class="line">e=&lt;email address&gt; </span><br><span class="line">p=&lt;phone number&gt; </span><br><span class="line">c=&lt;network type&gt; &lt;address type&gt; &lt;connection address&gt; b=&lt;modifier&gt;:&lt;bandwidth-value&gt; </span><br><span class="line">t=&lt;start time&gt; &lt;stop time&gt; </span><br><span class="line">r=&lt;repeat interval&gt; &lt;active duration&gt; &lt;list of offsets from start-time&gt; z=&lt;adjustment time&gt; &lt;offset&gt; &lt;adjustment time&gt; &lt;offset&gt; .... </span><br><span class="line">k=&lt;method&gt; </span><br><span class="line">k=&lt;method&gt;:&lt;encryption key&gt; </span><br><span class="line">a=&lt;attribute&gt; </span><br><span class="line">a=&lt;attribute&gt;:&lt;value&gt; </span><br><span class="line">m=&lt;media&gt; &lt;port&gt; &lt;transport&gt; &lt;fmt list&gt; </span><br><span class="line">v = (协议版本) </span><br><span class="line">o = (所有者/创建者和会话标识符) </span><br><span class="line">s = (会话名称) </span><br><span class="line">i = * (会话信息) </span><br><span class="line">u = * (URI 描述) </span><br><span class="line">e = * (Email 地址) </span><br><span class="line">p = * (电话号码) </span><br><span class="line">c = * (连接信息) </span><br><span class="line">b = * (带宽信息) </span><br><span class="line">z = * (时间区域调整) </span><br><span class="line">k = * (加密密钥) </span><br><span class="line">a = * (0 个或多个会话属性行) </span><br><span class="line">时间描述: </span><br><span class="line">t = (会话活动时间) </span><br><span class="line">r = * (0或多次重复次数) </span><br><span class="line">媒体描述: </span><br><span class="line">m = (媒体名称和传输地址) </span><br><span class="line">i = * (媒体标题) </span><br><span class="line">c = * (连接信息 — 如果包含在会话层则该字段可选) </span><br><span class="line">b = * (带宽信息) </span><br><span class="line">k = * (加密密钥) </span><br><span class="line">a = * (0 个或多个媒体属性行)</span><br></pre></td></tr></table></figure><h5 id="4-3-SDP协议举例说明"><a href="#4-3-SDP协议举例说明" class="headerlink" title="4.3 SDP协议举例说明"></a>4.3 SDP协议举例说明</h5><p>SDP（Session Description Protocol）是一个用来描述多媒体会话的应用层控制协议，它是一个基于文本的协议，用于会话建立过程中的媒体类型和编码方案的协商等。<br><strong>消息正文格式</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v=0 //该行指示协议的版本</span><br><span class="line">o=mhandley 2890844526 2890842807 IN IP4 126.16.64.4 //o行中包含与会话所有者有关的参数</span><br></pre></td></tr></table></figure><ul><li>第一个参数表明会话发起者的名称，该参数可不填写，如填写和SIP消息中，from消息头的内容一致。</li><li>第二个参数为主叫方的会话标识符。</li><li>第三个参数为主叫方会话的版本，会话数据有改变时，版本号递增。</li><li>第四个参数定义了网络类型，IN表示Internet网络类型，目前仅定义该网络类型。</li><li>第五个参数为地址类型，目前支持IPV4和IPV6两种地址类型。</li><li>第六个参数为地址：表明会话发起者的IP地址，该地址为信令面的IP地址，信令PDP激活时为手机分配。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s=SDP Seminar //表明本次会话的标题，或会话的名称</span><br><span class="line">i=A Seminar on the session description protocol //会话的描述</span><br><span class="line">u=http://www.cs.ucl.ac.uk/staff/M.Handley/sdp.03.ps //会话的URI，通过该地址可以查阅到会话的更多内容</span><br><span class="line">e=mjh@isi.edu (Mark Handley) //会话责任人的EMIAL地址</span><br><span class="line">c=IN IP4 224.2.17.12/127 //C行包含为多媒体会话而建立的连接的信息，其中指出了真正的媒体流使用的IP地址</span><br></pre></td></tr></table></figure></li><li>第一个参数为网络类型，目前仅定义INTERNET网络类型。用“IN”表示。</li><li>第二个参数为地址类型，目前支持两种地址类型：IPV4和IPV6。</li><li>第三个参数为地址，该地址为多媒体流使用的IP地址。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t=2873397496 2873404696 //表示会话的开始时间和结束时间</span><br></pre></td></tr></table></figure><ul><li>第一个参数表明会话的开始时间，数字表明从1900年1月1日00：00以来所经过的秒数。</li><li>第二个参数表明会话的结束时间，数字表明从1900年1月1日00：00以来所经过的秒数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m=audio 3458 RTP/AVP 0 96 97 // m行又称媒体行，描述了发送方所支持的媒体类型等信息</span><br></pre></td></tr></table></figure><ul><li>第一个参数为媒体名称：表明支持音频类型。</li><li>第二个参数为端口号，表明UE在本地端口为3458上发送音频流。</li><li>第三个参数为传输协议，一般为RTP/AVP协议。</li><li>第四~七参数为所支持的四种净荷类型编号</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=rtpmap:0 PCMU //a行为媒体的属性行，以属性的名称：属性值的方式表示。</span><br><span class="line">a=rtpmap:96 G726-32/8000</span><br><span class="line">a=rtpmap:97 AMR-WB</span><br><span class="line">格式为：a=rtpmap:&lt;净荷类型&gt;&lt;编码名称&gt; * 净荷类型0固定分配给了PCMU， * 净荷类型96对应的编码方案为G.726,为动态分配的。 * 净荷类型97对应的编码方式为自适应多速率宽带编码（AMR-WB），为动态分配的。</span><br><span class="line">m=video 3400 RTP/AVP 98 99 //m行又称媒体行，描述了发送方所支持的媒体类型等信息</span><br></pre></td></tr></table></figure><ul><li>第一个参数为媒体名称：表明支持视频类型。</li><li>第二个参数为端口号，表明UE在本地端口为3400上发送视频流。</li><li>第三个参数为传输协议，一般为RTP/AVP协议。</li><li>四、五参数给出了两种净荷类型编号</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=rtpmap:98 MPV</span><br><span class="line">a=rtpmap:99 H.261</span><br></pre></td></tr></table></figure><p>格式为：a=rtpmap:&lt;净荷类型&gt;&lt;编码名称&gt; * 净荷类型98对应的编码方案为MPV,为动态分配的。 * 净荷类型97对应的编码方式为H.261，为动态分配的。</p><p>还可参考：<a href="https://www.faihung.net/2020/04/08/RTSP-SDP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/">RTSP-SDP协议介绍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h4&gt;&lt;h5 id=&quot;1-1-RTSP简介&quot;&gt;&lt;a href=&quot;#1-1-RTSP简介&quot; class=&quot;headerlink&quot; title=&quot;1.1 RTSP简介&quot;&gt;&lt;/a&gt;1.1 RTSP简介&lt;/h5&gt;&lt;p&gt;RTSP(Real Time Streaming Protocol), 实时流传输协议, 是TCP/IP协议体系中的一个应用层协议, 由哥伦比亚大学, 网景和RealNetworks公司提交的IETF RFC标准. 该协议定义了一对多应用程序如何有效地通过IP网络传送多媒体数据. RTSP在体系结构上位于RTP和RTCP之上, 它使用TCP或RTP完成数据传输.&lt;/p&gt;
    
    </summary>
    
    
      <category term="RTSP" scheme="http://www.faihung.net/categories/RTSP/"/>
    
    
      <category term="RTSP" scheme="http://www.faihung.net/tags/RTSP/"/>
    
      <category term="消息格式" scheme="http://www.faihung.net/tags/%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F/"/>
    
      <category term="状态码" scheme="http://www.faihung.net/tags/%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    
      <category term="SDP" scheme="http://www.faihung.net/tags/SDP/"/>
    
  </entry>
  
  <entry>
    <title>RTSP-SDP协议介绍</title>
    <link href="http://www.faihung.net/2020/04/08/RTSP-SDP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/"/>
    <id>http://www.faihung.net/2020/04/08/RTSP-SDP协议介绍/</id>
    <published>2020-04-08T06:13:18.000Z</published>
    <updated>2020-04-08T06:18:04.671Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>SDP 传递着媒体流信息，接收者可以解析传入的 sdp 数据，从而知道发送者的基本信<br>息。SDP 基本上在 internet 上工作。定义了会话描述的统一格式，但并不定义多播地址的分配和 SDP 消息的传输方式，也不支持媒体编码方案的协商，这些功能均由下层传送协议完成。典型的会话传送协议包括:SAP(Session Announcement Protocol 会话公告协议),SIP(Session Initiation Protocol，会话初始协议),RTSP,HTTP,和使用<br>MIME 的 E-Mail。</p><a id="more"></a><p>SDP 包括以下一些方面：</p><ul><li>会话的名称和目的</li><li>会话存活时间</li><li>包含在会话中的媒体信息，包括:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">媒体类型(例:video,audio)</span><br><span class="line">传输协议(例:RTP/UDP/IP,H.320)</span><br><span class="line">媒体格式(例:H.261video, MPEG video)</span><br><span class="line">多播或远端（单播）地址和端口</span><br></pre></td></tr></table></figure></li><li>为接收媒体而需的信息(addresses, ports, formats and so on)</li><li>使用的带宽信息</li><li>可信赖的接洽信息（Contact information）</li></ul><h4 id="二、SDP-规格"><a href="#二、SDP-规格" class="headerlink" title="二、SDP 规格"></a>二、SDP 规格</h4><p>SDP 会话描述由多行<type>=<value>组成。其中<type>是一个字符。<value>是<br>一个字符串，其格式视<type>而定。整个协议区分大小写。“=”两侧不允许有空格。</type></value></type></value></type></p><p>SDP 会话描述由一个会话级描述（session_level description）和多个媒体级描述（media_level description）组成。会话级（session_level）的作用域是整个会话。其位置是从’v=’行开始到第一个媒体描述为止。媒体级（media_level）描述是对单个的媒体流进行描述（例如传送单个音频或者视频的 vlc sdp 文件只有短短的几句话，<br>从 m=开始，这其实就是个媒体机描述），其位置是从’m=’行开始到下一个媒体描述为止。<br>总之，除非媒体部分重载，会话级的值是各个媒体的缺省默认值（就是说媒体级描述其实也<br>是一个会话级描述，只不过没写出来的会话级描述参数都用的缺省值）。</p><p>SDP 的结构如下：</p><p><img src="/2020/04/08/RTSP-SDP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/1.png" alt="1"><br><img src="/2020/04/08/RTSP-SDP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/2.png" alt="2"><br>上面的有些行是必需有的，有些行是可选的。可选的行有*号标记。必需的是<br>v,o,s,t,m（这是对于会话级描述和媒体及描述总体而言的，对于媒体级描述而言只有 m= 是必须的）。注意所有的描述项必须按照上面的顺序给出。</p><h4 id="三、各个字段的描述"><a href="#三、各个字段的描述" class="headerlink" title="三、各个字段的描述"></a>三、各个字段的描述</h4><h5 id="1-SDP-文件实例"><a href="#1-SDP-文件实例" class="headerlink" title="1. SDP 文件实例"></a>1. SDP 文件实例</h5><p><img src="/2020/04/08/RTSP-SDP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/3.png" alt="3"></p><h5 id="2-version-必选"><a href="#2-version-必选" class="headerlink" title="2. version(必选)"></a>2. version(必选)</h5><p>v=0;SDP 的版本号，不包括次版本号。</p><h5 id="3-origion-必选"><a href="#3-origion-必选" class="headerlink" title="3. origion(必选)"></a>3. origion(必选)</h5><p><img src="/2020/04/08/RTSP-SDP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/4.png" alt="4"><br><img src="/2020/04/08/RTSP-SDP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/5.png" alt="5"></p><h5 id="4-Session-Name"><a href="#4-Session-Name" class="headerlink" title="4. Session Name"></a>4. Session Name</h5><p>s=<sessionname>;会话名，在整个会话中有且只有一个”s=”。</sessionname></p><h5 id="5-Connection-Data-必选"><a href="#5-Connection-Data-必选" class="headerlink" title="5. Connection Data(必选)"></a>5. Connection Data(必选)</h5><p><img src="/2020/04/08/RTSP-SDP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/6.png" alt="6"></p><h5 id="6-Bandwidth-可选"><a href="#6-Bandwidth-可选" class="headerlink" title="6. Bandwidth(可选)"></a>6. Bandwidth(可选)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b=&lt;modifier&gt;:&lt;bandwidth-value&gt;;描述了建议的带宽，单位 kbps，可选。</span><br><span class="line">&lt;modifier&gt;：包括两种 CT 和 AS。</span><br><span class="line">CT：ConferenceTotal，总带宽。</span><br><span class="line">AS：Application-SpecificMaximum，单个媒体带宽的最大值。</span><br></pre></td></tr></table></figure><p>扩展机制：<modifier>以”X－”开始。建议 modifier 越短越好。例:b=X-YZ:128</modifier></p><h5 id="7-Times-必选-RepeatTimesand-Time-Zones"><a href="#7-Times-必选-RepeatTimesand-Time-Zones" class="headerlink" title="7. Times(必选), RepeatTimesand Time Zones"></a>7. Times(必选), RepeatTimesand Time Zones</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t=&lt;start time&gt; &lt;stop time&gt;;描述了会话的开始时间和结束时间。</span><br><span class="line">&lt;start time&gt; 和&lt;stop time&gt; 为 NTP 时间，单位是秒。假如&lt;stop time&gt;为零表示</span><br><span class="line">过了&lt;start time&gt;时间后会话一直持续。当&lt;start time&gt; 和&lt;stoptime&gt;均为零时表</span><br><span class="line">示持久会话。</span><br></pre></td></tr></table></figure><p>建议 start time 和 stoptime 不要设为0。因为不知道此会话的开始和结束时间，<br>增加了调度（scheduling）的难度。</p><h5 id="8-Media-Announcements-必选"><a href="#8-Media-Announcements-必选" class="headerlink" title="8. Media Announcements (必选)"></a>8. Media Announcements (必选)</h5><p><img src="/2020/04/08/RTSP-SDP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/7.png" alt="7"><br><img src="/2020/04/08/RTSP-SDP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/8.png" alt="8"></p><h5 id="9-rtpmap（可选）"><a href="#9-rtpmap（可选）" class="headerlink" title="9. rtpmap（可选）"></a>9. rtpmap（可选）</h5><p><img src="/2020/04/08/RTSP-SDP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/9.png" alt="9"><br>对于音频流，&lt;编码参数&gt;说明了音频的通道数。通道数默认缺省值为1。对于视频流，现阶段没有&lt;编码参数&gt;。<br><img src="/2020/04/08/RTSP-SDP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/10.png" alt="10"><br>在 rtpmap 中，实验性的编码方案也可以用。其格式名前一定为”X－”例：一种新的实验性的被称为 GSMLPC 的音频流，使用的动态负载类型为 99。<br><img src="/2020/04/08/RTSP-SDP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/11.png" alt="11"></p><h5 id="10-SuggestedAttributes（可选）"><a href="#10-SuggestedAttributes（可选）" class="headerlink" title="10. SuggestedAttributes（可选）"></a>10. SuggestedAttributes（可选）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=&lt;TYPE&gt;或 a=&lt;TYPE&gt;:&lt;VALUES&gt;</span><br><span class="line">a=framerate:&lt;帧速率(fps)&gt;</span><br><span class="line">例子：音频：a=framerate:50</span><br><span class="line"></span><br><span class="line">按照 8K、8Bit 来算，(1/8000)*1000*1Byte*20ms=12.5B a=lang:&lt;语言标记&gt;//会话描述的缺省语言或媒体描述的语言</span><br></pre></td></tr></table></figure><p>注:如果 SDP 语法分析器不能识别某一类型(Type),则整个描述丢失。如果”a=”的某属性值不理解,则予以丢失此属性。会话级的描述就是媒体级描述的缺省值（就是说媒体级描述其实也是一个会话级描述，只不过没写出来的会话级描述参数都用的缺省值）。</p><h4 id="四、举例"><a href="#四、举例" class="headerlink" title="四、举例"></a>四、举例</h4><h5 id="1-媒体级会话-VLC-播放-264-视频的-sdp-文件"><a href="#1-媒体级会话-VLC-播放-264-视频的-sdp-文件" class="headerlink" title="1. 媒体级会话 VLC 播放 264 视频的 sdp 文件"></a>1. 媒体级会话 VLC 播放 264 视频的 sdp 文件</h5><p><img src="/2020/04/08/RTSP-SDP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/12.png" alt="12"></p><h5 id="2-媒体级会话-VLC-播放-g711-音频的-sdp-文件"><a href="#2-媒体级会话-VLC-播放-g711-音频的-sdp-文件" class="headerlink" title="2. 媒体级会话 VLC 播放 g711 音频的 sdp 文件"></a>2. 媒体级会话 VLC 播放 g711 音频的 sdp 文件</h5><p><img src="/2020/04/08/RTSP-SDP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/13.png" alt="13"><br>如果是同时播放音频和视频流只要把这两个媒体级会话合在一个 sdp 文件中就好了</p><h5 id="3-点播-mp4-文件，MS-H-返回给终端的-sdp-信息"><a href="#3-点播-mp4-文件，MS-H-返回给终端的-sdp-信息" class="headerlink" title="3. 点播 mp4 文件，MS_H 返回给终端的 sdp 信息"></a>3. 点播 mp4 文件，MS_H 返回给终端的 sdp 信息</h5><p><img src="/2020/04/08/RTSP-SDP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/14.png" alt="14"></p><h5 id="4-直播"><a href="#4-直播" class="headerlink" title="4. 直播"></a>4. 直播</h5><p>编码器生成的 sdp 文件<br><img src="/2020/04/08/RTSP-SDP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/15.png" alt="15"><br><img src="/2020/04/08/RTSP-SDP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/16.png" alt="16"><br><img src="/2020/04/08/RTSP-SDP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/17.png" alt="17"><br><img src="/2020/04/08/RTSP-SDP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/18.png" alt="18"></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h4&gt;&lt;p&gt;SDP 传递着媒体流信息，接收者可以解析传入的 sdp 数据，从而知道发送者的基本信&lt;br&gt;息。SDP 基本上在 internet 上工作。定义了会话描述的统一格式，但并不定义多播地址的分配和 SDP 消息的传输方式，也不支持媒体编码方案的协商，这些功能均由下层传送协议完成。典型的会话传送协议包括:SAP(Session Announcement Protocol 会话公告协议),SIP(Session Initiation Protocol，会话初始协议),RTSP,HTTP,和使用&lt;br&gt;MIME 的 E-Mail。&lt;/p&gt;
    
    </summary>
    
    
      <category term="RTSP" scheme="http://www.faihung.net/categories/RTSP/"/>
    
    
      <category term="SDP" scheme="http://www.faihung.net/tags/SDP/"/>
    
  </entry>
  
  <entry>
    <title>RTSP-RTSP简单介绍</title>
    <link href="http://www.faihung.net/2020/04/03/RTSP-RTSP%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <id>http://www.faihung.net/2020/04/03/RTSP-RTSP简单介绍/</id>
    <published>2020-04-03T06:26:38.000Z</published>
    <updated>2020-04-03T06:49:08.843Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、概要"><a href="#一、概要" class="headerlink" title="一、概要"></a>一、概要</h4><p>RTSP（Real Time Streaming Protocol）实时流协议：一种流媒体控制协议，可对流媒体进行暂停、快进、快倒等操作。</p><p>流媒体就是实时在线点播。而流媒体与普通媒体的差别在于：对于普通媒体，在访问它之前要得到全部的内容；对于流媒体，则在完全接收到全部内容之前就开始访问。</p><p>本文主要介绍RTSP的基本消息信令及手机与HMS的RTSP的消息交互过程。</p><a id="more"></a><h4 id="二、流媒体基本业务组网图"><a href="#二、流媒体基本业务组网图" class="headerlink" title="二、流媒体基本业务组网图"></a>二、流媒体基本业务组网图</h4><p><img src="/2020/04/03/RTSP-RTSP%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/1.png" alt="1"></p><h4 id="三、RTSP-介绍"><a href="#三、RTSP-介绍" class="headerlink" title="三、RTSP 介绍"></a>三、RTSP 介绍</h4><h5 id="3-1-RTSP是什么？"><a href="#3-1-RTSP是什么？" class="headerlink" title="3.1    RTSP是什么？"></a>3.1    RTSP是什么？</h5><p>RTSP（Real Time Streaming Protocol），实时流协议，是一种应用层的协议，用于实时的控制数据的传输。RTSP提供一个可扩展的架构来实现控制实时媒体的在线点播，如音频或是视频内容。数据源可以是直播信号也可以是制作好的媒体文件。RTSP能够同时控制多个数据传输会话过程。</p><h5 id="3-2-RTSP-URL的语法结构"><a href="#3-2-RTSP-URL的语法结构" class="headerlink" title="3.2    RTSP URL的语法结构"></a>3.2    RTSP URL的语法结构</h5><p>一个终端用户是通过在播放器中输入URL地址开始进行观看流媒体业务的第一步，而对于使用RTSP协议的移动流媒体点播而言，URL的一般写法如下：</p><p>一个以“rtsp”或是“rtspu”开始的URL链接用于指定当前使用的是RTSP 协议。RTSP URL的语法结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtsp_URL=(“rtsp:”| “rtspu:”) “//” host [“:”port”] /[abs_path]/content_name</span><br></pre></td></tr></table></figure><p>host：可以是一个有效的域名或是IP地址。</p><p>port：端口号，对于RTSP协议来说，缺省的端口号为554，即如HTTP的缺省端口号是80一样。当我们在确认流媒体服务器提供的端口号为554时，此项可以省略</p><p>说明：当HMS服务器使用的端口号为554时，我们在写点播链接时，可以不用写明端口号，但当使用非554端口时，在RTSP URL中一定要指定相应的端口。</p><p>注：我们在点播时使用的都是rtsp，而没有使用到rtspu。</p><h5 id="3-3-RTSP-消息"><a href="#3-3-RTSP-消息" class="headerlink" title="3.3    RTSP 消息"></a>3.3    RTSP 消息</h5><h6 id="3-3-1-消息"><a href="#3-3-1-消息" class="headerlink" title="3.3.1    消息"></a>3.3.1    消息</h6><p>RTSP是一种基于文本的协议，用CRLF作为一行的结束符。使用基于文本协议的好处在于我们可以随时在使用过程中的增加自定义的参数，也可以随便将协议包抓住很直观的进行分析。</p><p>RTSP从传输方向上有两种消息，即“请求消息”及“回应消息”。一个消息一般由头和内容组成，不过也有很多的消息是只有消息头（message head or header）而没有消息体（message body）的。</p><h6 id="3-3-2-请求消息"><a href="#3-3-2-请求消息" class="headerlink" title="3.3.2    请求消息"></a>3.3.2    请求消息</h6><p>一个请求消息（a request message）即可以由客户端向服务端发起也可以由服务端向客户端发起。请求消息的语法结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Request=Request-Line</span><br><span class="line">*(general-header | request-header | entity-header)</span><br><span class="line">CRLF</span><br><span class="line">[message-body]</span><br></pre></td></tr></table></figure><p><strong>1. Request Line</strong></p><p>请求消息的第一行的语法结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Request-Line=Method 空格 Request-URI 空格 RTSP-Version CRLF</span><br><span class="line">其中在消息行中出现的第一个单词即是所使用的信令标志。</span><br></pre></td></tr></table></figure><p>目前已经有的信息标志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Method =“DESCRIBE” </span><br><span class="line">|“ANNOUNCE”</span><br><span class="line">|“GET_PARAMETER”</span><br><span class="line">|“OPTIONS”</span><br><span class="line">|“PAUSE”</span><br><span class="line">|“PLAY”</span><br><span class="line">|“RECORD”</span><br><span class="line">|“REDIRECT”</span><br><span class="line">|“SETUP”</span><br><span class="line">|“SET_PARAMETER”</span><br><span class="line">|“TEARDOWN”</span><br><span class="line">|extension-method</span><br></pre></td></tr></table></figure><p>extension-method    = 标志<br>我们可以使用自己定义的信令标示符</p><p>Request-URI = “*” | absolute_URI<br>    请使用请求媒体存放的绝对路径</p><p>RTSP-Version = “RTSP” “/” 1<em>DIGIT “.” 1</em>DIGIT<br>    RTSP的版本号</p><p>例子：DESCRIBE rtsp://211.94.164.227/3.3gp RTSP/1.0</p><p><strong>2.    Request Header Fields</strong></p><p>在消息头中除了第一行的内容外，还有一些需求提供附加信息。其中有些是一定要的，后续我们会详细介绍经常用到的几个域的含义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Request-header=Accept</span><br><span class="line">|Accept-Encoding</span><br><span class="line">|Accept-Language</span><br><span class="line">|Authorization</span><br><span class="line">|From</span><br><span class="line">|If-Modified-Since</span><br><span class="line">|Range</span><br><span class="line">|Referer</span><br><span class="line">|User-Agent</span><br></pre></td></tr></table></figure><h6 id="3-3-3-响应消息"><a href="#3-3-3-响应消息" class="headerlink" title="3.3.3    响应消息"></a>3.3.3    响应消息</h6><p>客户端或是服务端在接收并解释一个请求消息后，会回复一个消息（response message）给请求方。响应消息的语法结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Response=Status-Line</span><br><span class="line">*(general-header</span><br><span class="line">|response-header</span><br><span class="line">|entity-header)</span><br><span class="line">CRLF</span><br><span class="line">[message-body]</span><br></pre></td></tr></table></figure><p><strong>1. Status-Line</strong></p><p>响应消息的第一行是状态行（status-line），每个元素之间用空格分开。除了最后的CRLF之外，在此行的中间不得有CR或是LF的出现。它的语法格式如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Status-Line = RTSP-Version 空格 Status-Code 空格 Reason-Phrase CRLF</span><br></pre></td></tr></table></figure><p>Status-Code 是一个三位数的整数，用于描述接收方对所收到请求消息的执行结果，而Reason-Phrase是对Status-Code给出一个简短的文字描述，便于我们在收到一个消息后，不用每次都去查看code的解释，而只需要看Reason-Phrase就可以大概了解当前请求的执行状态。</p><p>Status-Code的第一位数字指定了这个回复消息的种类，一共有5类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1XX: Informational – 请求被接收到，继续处理</span><br><span class="line">2XX: Success – 请求被成功的接收，解析并接受</span><br><span class="line">3XX: Redirection – 为完成请求需要更多的操作</span><br><span class="line">4XX: Client Error – 请求消息中包含语法错误或是不能够被有效执行</span><br><span class="line">5XX: Server Error – 服务器响应失败，无法处理正确的有效的请求消息</span><br></pre></td></tr></table></figure><p>我们在处理问题时经常会遇到的状态码有如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Status-Code =“200”:OK</span><br><span class="line">|“400”:Bad Request</span><br><span class="line">|“404”:Not Found</span><br><span class="line">|“500”Internal Server Error</span><br></pre></td></tr></table></figure><p>RTSP的状态码也是可以扩展的。服务器可以根据实际情况定义相应的状态码及描述信息。</p><p><strong>2. Response Header Fields</strong></p><p>在响应消息的域中存放的是无法放在Status-Line中,而又需要传送给请求者的一些附加信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Response-header =Location</span><br><span class="line">|Proxy-Authenticate</span><br><span class="line">|Public</span><br><span class="line">|Retry-After</span><br><span class="line">|Server</span><br><span class="line">|Vary</span><br><span class="line">|WWW-Authenticate</span><br></pre></td></tr></table></figure><h5 id="3-4-信令"><a href="#3-4-信令" class="headerlink" title="3.4    信令"></a>3.4    信令</h5><p>信令指的是在Request-URI中指定的需要被接收者完成的操作。信令（The method）大小写敏感，不能以字符”$”开始，并且一定要是一个标记符。<br>概要描述如下：<br><img src="/2020/04/03/RTSP-RTSP%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/2.png" alt="2"></p><p>C：客户端<br>S：服务端<br>下面介绍几个常用的信令</p><h6 id="3-4-1-OPTIONS"><a href="#3-4-1-OPTIONS" class="headerlink" title="3.4.1    OPTIONS"></a>3.4.1    OPTIONS</h6><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C-&gt;S: </span><br><span class="line">OPTIONS * RTSP/1.0 </span><br><span class="line">CSeq: 1 </span><br><span class="line">Require: implicit-play </span><br><span class="line">Proxy-Require: gzipped-messages </span><br><span class="line"></span><br><span class="line">S-&gt;C: </span><br><span class="line">RTSP/1.0 200 OK </span><br><span class="line">CSeq: 1 </span><br><span class="line">Public: DESCRIBE, SETUP, TEARDOWN, PLAY, PAUSE</span><br></pre></td></tr></table></figure><p>OPTIONS消息可以在任何时间被发起，如MOTO835手机就会每隔60秒左右向服务器端发送一个OPTIONS的消息，而HMS服务器在检查MOTO835是否仍在线时，也是通过来检查服务器端是否定时收到OPTIONS的消息来实现的。但需注意的是，并不是所有的手机和播放器会定时发送OPTIONS消息到服务器端，即使有发送，发送OPTIONS的消息的时间间隔也是不尽相同的。</p><h6 id="3-4-2-DESCRIBE"><a href="#3-4-2-DESCRIBE" class="headerlink" title="3.4.2    DESCRIBE"></a>3.4.2    DESCRIBE</h6><p>DESCRIBE消息是由客户端发送到服务器端，用于客户端得到请求链接（request URL）中指定的媒体文件的相关描述。DESCRIBE的这一对交互消息完成了RTSP的媒体初始化。<br>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">C-&gt;S: </span><br><span class="line">DESCRIBE rtsp://server.example.com/fizzle/foo RTSP/1.0 </span><br><span class="line">CSeq: 312 </span><br><span class="line">Accept: application/sdp, application/rtsl, application/mheg </span><br><span class="line"></span><br><span class="line">S-&gt;C: </span><br><span class="line">RTSP/1.0 200 OK </span><br><span class="line">CSeq: 312 </span><br><span class="line">Date: 23 Jan 1997 15:35:06 GMT </span><br><span class="line">Content-Type: application/sdp </span><br><span class="line">Content-Length: 376 </span><br><span class="line"></span><br><span class="line">v=0 （这里就是MESSAGE BODY，它的长度由Content_Length来指定）</span><br><span class="line">o=mhandley 2890844526 2890842807 IN IP4 126.16.64.4 </span><br><span class="line">s=SDP Seminar </span><br><span class="line">i=A Seminar on the session description protocol </span><br><span class="line">u=http://www.cs.ucl.ac.uk/staff/M.Handley/sdp.03.ps e=mjh@isi.edu (Mark Handley) </span><br><span class="line">c=IN IP4 224.2.17.12/127 </span><br><span class="line">t=2873397496 2873404696 </span><br><span class="line">a=recvonly </span><br><span class="line">m=audio 3456 RTP/AVP 0 </span><br><span class="line">m=video 2232 RTP/AVP 31 </span><br><span class="line">m=whiteboard 32416 UDP WB </span><br><span class="line">a=orient:portrait</span><br></pre></td></tr></table></figure><p>DESCRIBE的响应消息必须包含所有的媒体初始化信息。对于基于RTSP的系统，媒体初始化是必须的，但是并不一定要通过DESCRIBE消息来得到，这里是一个RTSP的客户端得到初始化信息的三种方式：</p><ul><li>通过RTSP的DESCRIBE</li><li>一些其它的协议，如HTTP，email attachment等</li><li>命令行方式</li></ul><h6 id="3-4-3-SETUP"><a href="#3-4-3-SETUP" class="headerlink" title="3.4.3    SETUP"></a>3.4.3    SETUP</h6><p>SETUP请求用于指定流媒体使用的传输机置。在请求消息中会指定客户端在数据传输时相关的传送参数，而在响应消息中将包含由服务器端所指定的传输参数。服务器端在回复SETUP消息时将会生成一个session ID.<br>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">C-&gt;S: </span><br><span class="line">SETUP rtsp://example.com/foo/bar/baz.3gp RTSP/1.0 </span><br><span class="line">CSeq: 302 </span><br><span class="line">Transport: RTP/AVP;unicast;client_port=4588-4589 </span><br><span class="line"></span><br><span class="line">S-&gt;C: </span><br><span class="line">RTSP/1.0 200 OK </span><br><span class="line">CSeq: 302 </span><br><span class="line">Date: 23 Jan 1997 15:35:06 GMT </span><br><span class="line">Session: 47112344 </span><br><span class="line">Transport: RTP/AVP;unicast; </span><br><span class="line">client_port=4588-4589;server_port=6256-6257</span><br></pre></td></tr></table></figure><p>服务器端在回复SETUP消息时将会生成一个session ID. </p><h6 id="3-4-4-PLAY"><a href="#3-4-4-PLAY" class="headerlink" title="3.4.4    PLAY"></a>3.4.4    PLAY</h6><p>PLAY消息是告诉服务器端可以使用在SETUP消息中所指定的传输机置开始传送数据。需要指出的是，客户端不应该发送任何PLAY请求直到所有的SETUP消息被成功解析。PLAY消息会在range中指定媒体的播放时间，服务器在接到PLAY消息后会由range中指定的开始点开始发送媒体数据直到range中指定的结束点。</p><p>所有的PLAY消息都是必须按顺序被处理的，即当一个PLAY的请求到达时，而上一个PLAY请求还未完成，后面的PLAY请求将被延时，直到第一个PLAY处理完成时才会被处理。例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C-&gt;S: </span><br><span class="line">PLAY rtsp://audio.example.com/audio RTSP/1.0 </span><br><span class="line">CSeq: 835 </span><br><span class="line">Session: 12345678 </span><br><span class="line">Range: npt=10-15</span><br></pre></td></tr></table></figure><h6 id="3-4-5-PAUSE"><a href="#3-4-5-PAUSE" class="headerlink" title="3.4.5    PAUSE"></a>3.4.5    PAUSE</h6><p>PAUSE消息是用于暂时中断流媒体的传送。当暂停的时间过长（这个值应在SETUP消息中由timeout参数指定），服务器可以自动断开这个会话，释放所占用的资源。例子: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C-&gt;S: </span><br><span class="line">PAUSE rtsp://example.com/fizzle/foo RTSP/1.0 </span><br><span class="line">CSeq: 834 </span><br><span class="line">Session: 12345678 </span><br><span class="line"></span><br><span class="line">S-&gt;C: </span><br><span class="line">RTSP/1.0 200 OK </span><br><span class="line">CSeq: 834 </span><br><span class="line">Date: 23 Jan 1997 15:35:06 GMT</span><br></pre></td></tr></table></figure><p>服务器不是必须要支持PAUSE信令的，例如，对于直播的节目，就可以不支持暂停。当一个服务器不支持某一个信令时，必须要返回给客户端以“501 Not Implemented”的响应消息，并且客户端应该不再尝试向服务器端发送这个请求。</p><h6 id="3-4-6-TEARDOWN"><a href="#3-4-6-TEARDOWN" class="headerlink" title="3.4.6    TEARDOWN"></a>3.4.6    TEARDOWN</h6><p>TEARDOWN消息是用于停止媒体数据的传送，并释放所占用的资源。<br>例子： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C-&gt;S: </span><br><span class="line">TEARDOWN rtsp://example.com/fizzle/foo RTSP/1.0 </span><br><span class="line">CSeq: 892 </span><br><span class="line">Session: 12345678 </span><br><span class="line"></span><br><span class="line">S-&gt;C: </span><br><span class="line">RTSP/1.0 200 OK </span><br><span class="line">CSeq: 892</span><br></pre></td></tr></table></figure><h5 id="3-5-Header-Field-解析"><a href="#3-5-Header-Field-解析" class="headerlink" title="3.5    Header Field 解析"></a>3.5    Header Field 解析</h5><p>在每个消息中都会包含一定的字段用于描述一些信息。</p><ul><li>Type ”g” 指通用，在请求消息和响应消息中都可能出现</li><li>Type “R” 指请求消息</li><li>Type “r” 指响应消息</li><li>Type “e” 指实体头字段</li></ul><p><strong>RTSP头字段简述：</strong></p><p><img src="/2020/04/03/RTSP-RTSP%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/3.png" alt="3"><br><img src="/2020/04/03/RTSP-RTSP%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/4.png" alt="4"></p><p>下面简要介绍一些在RTSP中常用到的头字段，详细的信息请查看RFC 2326。</p><h6 id="3-5-1-Accept"><a href="#3-5-1-Accept" class="headerlink" title="3.5.1    Accept"></a>3.5.1    Accept</h6><p>Accept字段可用于指定可被接受的描述类型<br>例子: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: application/rtsl, application/sdp;level=2</span><br></pre></td></tr></table></figure><h6 id="3-5-2-Cseq"><a href="#3-5-2-Cseq" class="headerlink" title="3.5.2    Cseq"></a>3.5.2    Cseq</h6><p>Cseq域指定一对RTSP请求-响应消息的序列号。在请求消息及响应消息中一定要指定这个域。对于请求消息，会有一个具有相同Cseq域内容的响应消息与之对应。<br>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">C-&gt;S: </span><br><span class="line">SETUP rtsp://example.com/foo/bar/baz.3gp RTSP/1.0 </span><br><span class="line">CSeq: 302 </span><br><span class="line">Transport: RTP/AVP;unicast;client_port=4588-4589 </span><br><span class="line"></span><br><span class="line">S-&gt;C: </span><br><span class="line">RTSP/1.0 200 OK </span><br><span class="line">CSeq: 302 </span><br><span class="line">Date: 23 Jan 1997 15:35:06 GMT </span><br><span class="line">Session: 47112344 </span><br><span class="line">Transport: RTP/AVP;unicast; </span><br><span class="line">client_port=4588-4589;server_port=6256-6257</span><br></pre></td></tr></table></figure><h6 id="3-5-3-Range"><a href="#3-5-3-Range" class="headerlink" title="3.5.3    Range"></a>3.5.3    Range</h6><p>Range用于在请求消息和响应消息中指定播放的时间段。<br>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range: clock=19960213T143205Z-;time=19970123T143720Z</span><br></pre></td></tr></table></figure><h6 id="3-5-4-RTP-Info"><a href="#3-5-4-RTP-Info" class="headerlink" title="3.5.4    RTP-Info"></a>3.5.4    RTP-Info</h6><p>这个域用于在回复PLAY消息中指定RTP特殊的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">url:与设置的RTP参数对应的流媒体链接</span><br><span class="line">seq:    流媒体第一个包的序列号</span><br><span class="line">rtptime:用于回复range域对应的RTP时间戳</span><br><span class="line">RTP-Info语法结构： </span><br><span class="line">   RTP-Info         = &quot;RTP-Info&quot; &quot;:&quot; 1#stream-url 1*parameter</span><br><span class="line">   stream-url       = &quot;url&quot; &quot;=&quot; url</span><br><span class="line">   parameter        = &quot;;&quot; &quot;seq&quot; &quot;=&quot; 1*DIGIT</span><br><span class="line">                    | &quot;;&quot; &quot;rtptime&quot; &quot;=&quot; 1*DIGIT</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTP-Info:url=rtsp://foo.com/bar.avi/streamid=0;seq=45102,url=rtsp://foo.com/bar.avi/streamid=1;seq=30211</span><br></pre></td></tr></table></figure><h6 id="3-5-5-Session"><a href="#3-5-5-Session" class="headerlink" title="3.5.5    Session"></a>3.5.5    Session</h6><p>Session域在请求与响应消息中用于识别一个RTSP会话（RTSP session即一个完整的RTSP交互过程。例如：在点播流媒体时，一个典型的会话过程包括一个客户建立一个传输通道（SETUP），用PLAY开始传输流，最后用TEARDOWN来断开这个连接）。一旦客户端接收到Session标识，在这个会话中的任何请求都需要附加这个域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Session语法结构：</span><br><span class="line">Session  = &quot;Session&quot; &quot;:&quot; session-id [ &quot;;&quot; &quot;timeout&quot; &quot;=&quot; delta-seconds ]</span><br><span class="line">例子：</span><br><span class="line">Session: 12345678</span><br></pre></td></tr></table></figure><h6 id="3-5-6-Transport"><a href="#3-5-6-Transport" class="headerlink" title="3.5.6    Transport"></a>3.5.6    Transport</h6><p>这个域在请求消息中是标识哪一种传输协议将被使用，并指定一些在描述说明中没有指定的参数的值。使用的传输协议之间用逗号分隔，参数之间用分号分隔</p><p>常用参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unicast | multicast:单播还是组播（缺省值为multicast）.</span><br><span class="line">destination:        指定流将被传送到到哪个地址</span><br><span class="line">port:           (RTP协议):指定RTP/RTCP端口号（multicast）。一般为一个范围。e.g., port=3456-3457.</span><br><span class="line">Client_port:         客户端选择的用于接收媒体数据及控制信息的单播 RTP/RTCP端口号。e.g., port=3456-3457</span><br><span class="line">Server_port:         服务器端用于接收媒体数据和控制信息的单播 RTP/RTCP端口号。e.g., port=3456-3457</span><br></pre></td></tr></table></figure><p>例子: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transport:RTP/AVP;multicast;ttl=127;mode=&quot;PLAY&quot;, RTP/AVP;unicast;client_port=3456-3457;mode=&quot;PLAY&quot;</span><br></pre></td></tr></table></figure><h6 id="3-5-7-User-Agent"><a href="#3-5-7-User-Agent" class="headerlink" title="3.5.7 User-Agent"></a>3.5.7 User-Agent</h6><p>这个域用于用户标识，不同公司或是型号的手机发出的消息中的这个域的内容都不大相同。有时会指出手机的版本号，播放器的型号等等。在HMS中的terminal.xml文件就是根据这个域中的内容来完成简单的终端适配的功能。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent:01056SS68001117616022101802836055;14;41;4578;327;13824;0;1;0x0202;0x00000B;0x028010</span><br></pre></td></tr></table></figure><h4 id="四、移动流媒体与RTSP"><a href="#四、移动流媒体与RTSP" class="headerlink" title="四、移动流媒体与RTSP"></a>四、移动流媒体与RTSP</h4><p>移动流媒体技术就是把连续的影像和声音信息经过压缩处理后放到网络服务器上，让移动终端用户能够一边下载一边观看、收听，而不需要等到整个多媒体文件下载完成就可以即时观看的技术。实际上移动流媒体技术是网络音视频技术和移动通讯技术发展到一定阶段的产物，它是融合很多网络技术之后所产生的技术，它会涉及到流媒体数据的采集、压缩、存输以及网络通信等多项技术。它大致分为下面两大类业务类型：</p><ol><li><p>流媒体点播(VOD)</p><blockquote><p>内容提供商将预先录制好的多媒体内容编码压缩成相应格式，存放在内容服务器上并把内容的描述信息以及链接放置在流媒体的portal上。最终用户就可以通过访问portal，发现感兴趣的内容，有选择的进行播放。</p></blockquote></li><li><p>流媒体直播</p><blockquote><p>流媒体编码服务器将实时信号编码压缩成相应的格式，并经由流媒体服务器分发到用户的终端播放器。根据实时内容信号源的不同，又可以分为电视直播、远程监控等。对于点播和直播，都是使用的RTSP协议。下面我们介绍在实际应用中RTSP消息是如何交互来完成点播或是直播功能。</p></blockquote></li></ol><h5 id="4-1-点播流程"><a href="#4-1-点播流程" class="headerlink" title="4.1    点播流程"></a>4.1    点播流程</h5><p>一个移动用户使用手机通过访问网页得到URI，在URI中指定了流媒体服务器的地址及想要访问的媒体内容。通过RTSP SETUP消息来建立客户端与流媒体服务器之间的连接，然后客户端通过发送一个RTSP PLAY的消息来通知服务器开始传送一个或多个媒体流。</p><p>具体消息交互过程如下：<br><img src="/2020/04/03/RTSP-RTSP%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/5.png" alt="5"></p><p>每次客户端发送一个请求消息，服务器端都会回一个相应的响应消息。</p><ol><li>手机通过上网得到带有流媒体地址的网页，并点播一个节目</li><li>手机上发RTSP：DESCRIBE的消息给服务器，服务器处理其中的URL链接，得到相应文件的SDP信息，附加在响应消息中返回给手机。如果此时服务器找不到手机想要点播的文件，就会回应400的错误给手机，显示文件不存在。</li><li>手机根据收到的SDP的信息向服务器发送RTSP:SETUP消息，与服务器建立连接。如果媒体文件包含音频和视频，就会有两次SETUP的交互消息。一个是音频的信息，一个是视频的信息。如果交互成功，服务器会发送200的OK消息给手机</li><li>手机在SETUP消息执行成功后，会向服务器发送RTSP：PLAY的消息，要求服务器开始发送数据。服务器在收到PLAY消息后，即会开始传送UDP/RTP包。</li><li>如果在播放过程中需要暂停，手机会发送RTSP：PAUSE的消息给服务器，服务器在收到暂停消息后，即会停止发数据包，手机停止播放。如果需要继续播放，手机只需要再发送RTSP：PLAY的消息给服务器，服务器根据暂停的位置继续开始播放。</li><li>当播放完成后，手机会自动向服务器发送RTSP：TEARDOWN消息，当服务器收到下线消息后，就会断开与手机的连接，释放所占用的资源。</li><li>点播过程结束。</li></ol><h5 id="4-2-SDP"><a href="#4-2-SDP" class="headerlink" title="4.2    SDP"></a>4.2    SDP</h5><p>在播放过程中，手机得到内容的相关信息是很重要的，如果这些内容不正确，也会影响播放的正确性，下面简要介绍一下SDP。</p><p>SDP文件（Session Description Protocol）包含了会话的描述，媒体类型，媒体的码率。客户端通过RTSP DESCRIBE来得到SDP文件。</p><p>RTSP需要一个内容的描述。而SDP就被用于客户端与服务端的一种内容描述的格式。在传送给客户的SDP内容应该声明了这个对话所要访问的媒体内容的媒体编码类型。对于流媒体服务而言，以下几个域是在SDP中一定要包含的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">“a=control:”</span><br><span class="line">“a=range:”</span><br><span class="line">“a=rtpmap:”</span><br><span class="line">“a=fmtp:”</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">v=0</span><br><span class="line">o=ghost 2890844526 2890842807 IN IP4 192.168.10.10</span><br><span class="line">s=3GPP Unicast SDP Example</span><br><span class="line">i=Example of Unicast SDP file</span><br><span class="line">u=http://www.infoserver.com/ae600</span><br><span class="line">e=ghost@mailserver.com</span><br><span class="line">c=IN IP4 0.0.0.0</span><br><span class="line">b=AS:128</span><br><span class="line">t=0 0</span><br><span class="line">a=range:npt=0-45.678</span><br><span class="line">m=video 1024 RTP/AVP 96</span><br><span class="line">b=AS:128</span><br><span class="line">a=rtpmap:96 H263-2000/90000</span><br><span class="line">a=fmtp:96 profile=3;level=10</span><br><span class="line">a=control:rtsp;//mediaserver.com/movie</span><br><span class="line">a=recvonly</span><br></pre></td></tr></table></figure><p>就如我们以前所了解的，对于直播，我们在建立了直播源后，就会将生成的SDP文件broadcast.sdp放在服务器上，而用户使用rtsp://ip:port/broadcast.sdp就可以进行直播节目的播放，这里的sdp文件里的内容就是上面所提到的这些。它将我们在建立直播源时所设置的音、视频编码，及相应的码率记录下来存在broadcast.sdp文件中，这样手机在进行进播时，得到了相关的SDP信息，然后根据这些信息与服务器建立连接。</p><h5 id="4-3-数据传送"><a href="#4-3-数据传送" class="headerlink" title="4.3    数据传送"></a>4.3    数据传送</h5><p>控制及媒体数据的传送是通过TCP/IP和UPD/IP上完成的，下图是一个协议栈的简单描述。媒体数据被打包成RTP包进行传送。</p><p><img src="/2020/04/03/RTSP-RTSP%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/6.png" alt="6"></p><h5 id="4-4-消息流程"><a href="#4-4-消息流程" class="headerlink" title="4.4    消息流程"></a>4.4    消息流程</h5><p>下面让我们来看一个具体的消息交互过程。我们可以通过ETHEREAL或是TCPDUMP这些抓包工具来获得这些信息。</p><p><strong>c-&gt;s【向服务器请求SDP信息】</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">【DESCRIBE】DESCRIBE rtsp://211.94.164.227/3.3gp RTSP/1.0</span><br><span class="line">【交互标识】CSeq: 1</span><br><span class="line">【请求内容】Accept: application/sdp</span><br><span class="line">【用户标识】User-Agent:01056SS68001117616022101802836055;</span><br><span class="line">14;41;4578;327;13824;0;1;0x0202;0x00000B;0x028010</span><br></pre></td></tr></table></figure><p><strong>s-&gt;c 【服务端返回SDP信息】</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【成功响应】RTSP/1.0 200 OK</span><br><span class="line">【服务器版本号】Server: HMS Mobile V100R001B08D023</span><br><span class="line">【交互标识】CSeq: 1</span><br><span class="line">【SDP长度】Content-Length: 625</span><br><span class="line">【包含内容类型】Content-Type: application/sdp</span><br><span class="line">【包含内容信息】Content-Base: rtsp://211.94.164.227/3.3gp/</span><br></pre></td></tr></table></figure><p><strong>【以下为SDP内容】</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">【SDP版本号】v=0</span><br><span class="line">【服务器信息】o=StreamingServer 3276474929 1067418948000 IN </span><br><span class="line">IP4 10.70.139.108</span><br><span class="line">【文件名】s=3.3gp</span><br><span class="line">【URL】u=rtsp://211.94.164.227/3.3gp</span><br><span class="line">【e-mail】e=admin@</span><br><span class="line">【IPv4】c=IN IP4 0.0.0.0</span><br><span class="line">t=0 0</span><br><span class="line">【控制属性】a=control:rtsp://211.94.164.227/3.3gp</span><br><span class="line">【视频信息】m=video 0 RTP/AVP 96【媒体类型】</span><br><span class="line">【视频带宽】b=AS:16</span><br><span class="line">【视频格式】a=rtpmap:96 MP4V-ES【格式】/90000【采样率】</span><br><span class="line">【视频格式】a=fmtp:96 profile-level-id=8; </span><br><span class="line">config=000001B008000001B50EA020202F000001000000012000C788BA9850584121463F</span><br><span class="line">a=mpeg4-esid:201</span><br><span class="line">【厂家信息】a=x-envivio-verid:00011118</span><br><span class="line">【视频轨道】a=control:trackID=65737</span><br><span class="line"></span><br><span class="line">【音频信息】m=audio 0 RTP/AVP 97【媒体类型】</span><br><span class="line">【音频带宽】b=AS:19</span><br><span class="line">【音频格式】a=rtpmap:97 MP4A-LATM【格式】/11025【采样率】/1</span><br><span class="line">a=fmtp:97 profile-level-id=15; object=2; </span><br><span class="line">cpresent=0; config=40002A103FC0</span><br><span class="line">a=mpeg4-esid:101</span><br><span class="line">【厂家信息】a=x-envivio-verid:00011118</span><br><span class="line">【音频轨道】a=control:trackID=65637</span><br></pre></td></tr></table></figure><p><strong>c-&gt;s 【向服务器发起建立视频连接的呼叫】</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【SETUP信令】SETUP rtsp://211.94.164.227/3.3gp/trackID=65737 RTSP/1.0</span><br><span class="line">CSeq: 2</span><br><span class="line">【传输信息】Transport: RTP/AVP;unicast【单播 区别组播】;</span><br><span class="line">client_port=5004-5005【客户端端口号】</span><br></pre></td></tr></table></figure><p><strong>s-&gt;c【服务器返回视频连接建立成功信息】</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RTSP/1.0 200 OK</span><br><span class="line">Server: HMS Mobile V100R001B08D023</span><br><span class="line">CSeq: 2</span><br><span class="line">【会话标识】Session: 4</span><br><span class="line">【传输信息】Transport: RTP/AVP;unicast;client_port=5004-5005;</span><br><span class="line">source=211.94.164.227;【服务器IP】</span><br><span class="line">server_port=8090-8091【服务器端口号】;</span><br><span class="line">ssrc=3e06【同步源描述符】</span><br></pre></td></tr></table></figure><p><strong>c-&gt;s【向服务器发起建立音频连接的呼叫】</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SETUP rtsp://211.94.164.227/3.3gp/trackID=65637 RTSP/1.0</span><br><span class="line">CSeq: 3</span><br><span class="line">Transport: RTP/AVP;unicast;client_port=5006-5007</span><br><span class="line">Session: 4</span><br></pre></td></tr></table></figure><p><strong>s-&gt;c【服务器返回音频连接建立成功信息】</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RTSP/1.0 200 OK</span><br><span class="line">Server: HMS Mobile V100R001B08D023</span><br><span class="line">CSeq: 3</span><br><span class="line">Session: 4</span><br><span class="line">Transport: RTP/AVP;unicast;client_port=5006-5007;</span><br><span class="line">source=211.94.164.227;server_port=8092-8093;ssrc=3e06</span><br></pre></td></tr></table></figure><p><strong>c-&gt;s【向服务器发出播放请求】</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PLAY rtsp://211.94.164.227/3.3gp RTSP/1.0</span><br><span class="line">CSeq: 4</span><br><span class="line">Session: 4</span><br><span class="line">【播放位置】Range: npt=now- 【从当前位置开始播放】</span><br></pre></td></tr></table></figure><p><strong>s-&gt;c【服务器返回发出播放成功响应请求】</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RTSP/1.0 200 OK</span><br><span class="line">Server: HMS Mobile V100R001B08D023</span><br><span class="line">CSeq: 4</span><br><span class="line">Session: 4</span><br><span class="line">【RTP信息】RTP-Info: url=trackID=65737;【轨道信息】seq=1;【RTP包序列号】</span><br><span class="line">rtptime=0【RTP包时间戳】,url=trackID=65637;seq=1;rtptime=0</span><br><span class="line">【播放范围】Range: npt=0.000000-60.193000</span><br></pre></td></tr></table></figure><p><strong>s-&gt;c【服务器发送视音频数据给终端】</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【RTP包 略】xxxx</span><br></pre></td></tr></table></figure><p><strong>c-&gt;s【向服务器发送终止请求】</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【TEARDOWN信令】TEARDOWN rtsp://211.94.164.227/3.3gp RTSP/1.0</span><br><span class="line">CSeq: 5</span><br><span class="line">Session: 4</span><br></pre></td></tr></table></figure><p><strong>s-&gt;c【服务器返回终止成功信息】</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RTSP/1.0 200 OK</span><br><span class="line">Server: HMS Mobile V100R001B08D023</span><br><span class="line">CSeq: 5</span><br><span class="line">Session: 4</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、概要&quot;&gt;&lt;a href=&quot;#一、概要&quot; class=&quot;headerlink&quot; title=&quot;一、概要&quot;&gt;&lt;/a&gt;一、概要&lt;/h4&gt;&lt;p&gt;RTSP（Real Time Streaming Protocol）实时流协议：一种流媒体控制协议，可对流媒体进行暂停、快进、快倒等操作。&lt;/p&gt;
&lt;p&gt;流媒体就是实时在线点播。而流媒体与普通媒体的差别在于：对于普通媒体，在访问它之前要得到全部的内容；对于流媒体，则在完全接收到全部内容之前就开始访问。&lt;/p&gt;
&lt;p&gt;本文主要介绍RTSP的基本消息信令及手机与HMS的RTSP的消息交互过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="RTSP" scheme="http://www.faihung.net/categories/RTSP/"/>
    
    
      <category term="RTSP" scheme="http://www.faihung.net/tags/RTSP/"/>
    
      <category term="SDP" scheme="http://www.faihung.net/tags/SDP/"/>
    
      <category term="C/S" scheme="http://www.faihung.net/tags/C-S/"/>
    
      <category term="URL" scheme="http://www.faihung.net/tags/URL/"/>
    
      <category term="DESCRIBE" scheme="http://www.faihung.net/tags/DESCRIBE/"/>
    
      <category term="SETUP" scheme="http://www.faihung.net/tags/SETUP/"/>
    
      <category term="PLAY" scheme="http://www.faihung.net/tags/PLAY/"/>
    
      <category term="PAUSE" scheme="http://www.faihung.net/tags/PAUSE/"/>
    
      <category term="TEARDOWN" scheme="http://www.faihung.net/tags/TEARDOWN/"/>
    
  </entry>
  
  <entry>
    <title>海思-VENC模块学习</title>
    <link href="http://www.faihung.net/2020/04/02/%E6%B5%B7%E6%80%9D-VENC%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.faihung.net/2020/04/02/海思-VENC模块学习/</id>
    <published>2020-04-02T15:39:33.000Z</published>
    <updated>2020-04-02T15:52:05.776Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、VENC是什么？"><a href="#一、VENC是什么？" class="headerlink" title="一、VENC是什么？"></a>一、VENC是什么？</h4><p>VENC 模块，即视频编码模块。本模块支持多路实时编码，且每路编码彼此独立，++编码协议和编码 profile 可以不同++ 。本模块支持视频编码同时，调度 Region 模块对编码图像内容进行叠加和遮挡。<br><img src="/2020/04/02/%E6%B5%B7%E6%80%9D-VENC%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/1.jpg" alt="1"></p><a id="more"></a><ol><li><p>VENC 模块由编码通道组子模块（GROUP）和编码协议子模块（H.264/JPEG/MJPEG/MPEG-4）组成。</p></li><li><p>通道组支持接收 YUV 格式图像输入，支持格式为 Semi-planar YUV 4:2:0 或 Semi-planar YUV 4:2:2，其中 H264E/MPEG-4 只支持 Semi-planar YUV 4:2:0，JPEG/MJPEG支持 Semi-planar YUV 4:2:0 或 Semi-planar YUV 4:2:2。通道组模块接收外部原始图像数据，而不关心图像数据是来自哪个外部模块。</p></li><li><p>完成视频区域管理之后，图像被送入具体协议类型编码通道，完成视频编码，输出码流。</p></li></ol><h5 id="1-1编码通道与通道组"><a href="#1-1编码通道与通道组" class="headerlink" title="1.1编码通道与通道组"></a>1.1编码通道与通道组</h5><p><img src="/2020/04/02/%E6%B5%B7%E6%80%9D-VENC%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/2.jpg" alt="2"></p><ol><li>编码通道做为基本容器，保存不同编码通道的用户设置，管理不同编码通道的内部资源。编码通道完成图像转化为码流的功能，具体由码率控制器和编码器协同完成。这里的编码器指的是狭义上的编码器，只完成编码功能。码率控制器提供了对编码参数的控制和调整，从而对输出码率进行控制。</li><li>编码通道可分为主编码通道和次编码通道。对于一帧输入图像，VENC 仅支持一路主编码通道，不支持次编码通道。</li><li>编码通道组是指芯片启动一次，能够同时处理的编码通道的集合。VENC 编码通道组支持启动一次，仅编码一路主码流通道（H.264/JPEG/MJPEG/MPEG-4） 。所以在创建编码通道时，只允许注册一个主码流通道。</li><li>码率控制器分别提供了对 H.264\MPEG-4\MJPEG 协议编码通道 CBR、VBR、FIXQP 等三种码率控制模式；</li><li>对图像质量和码率进行调节。Hi3521/Hi3520A/Hi3518/Hi3516C/Hi3520D/Hi3515A/Hi3515C 不支持 MPEG-4 编码，所以，也不支持 MPEG-4 类型的码率控制。</li></ol><h5 id="1-2码率"><a href="#1-2码率" class="headerlink" title="1.2码率"></a>1.2码率</h5><p><strong>CBR（Constant Bit Rate）固定比特率。</strong><br>即在码率统计时间内保证编码码率平稳。码率稳定主要由两个量来评估，这两个量都可以由用户在创建编码通道时指定。</p><ol><li><p>码率统计时间</p><blockquote><p>单位为秒(s)，码率统计时间越长，每帧图像的码率波动对于码率调节的影响越弱，码率的调节会更缓慢，图像质量的波动会更轻微；码率统计时间越短，每帧图像的码率波动对于码率调节的影响越强，图像码率的调节会更灵敏，图像质量的波动会更剧烈。</p></blockquote></li><li><p>码率的波动等级</p><blockquote><p>系统提供了 6 阶的图像质量波动等级，波动等级越大，系统允许码率的波动范围更大。如果波动等级设置高，对于一些图像复杂，变化剧烈的场景，图像质量可能会更平稳，适用于网络带宽富裕的场景；如果波动等级设置低，编码的码率会比较平稳，对于一些图像复杂，变化剧烈的场景，图像质量可能不如高波动等级，适用于带宽不富裕的场景。</p></blockquote></li></ol><p><strong>VBR（Variable Bit Rate）可变比特率。</strong><br>即在码率统计时间内编码码率波动，从而保证编码图像质量平稳。以 H.264 编码为例，VENC 模块提供用户可设置 MaxQp，MinQp，MaxBitrate。MaxQp，MinQp 用于控制图像的质量范围， MaxBitrate 用于钳位码率统计时间内的最大编码码率。</p><p><strong>Fix Qp</strong><br>固定 Qp 值。在码率统计时间内，编码图像所有宏块 Qp 值相同，采用用户设定的图像 Qp 值，I 帧和 P 帧的 QP 值可以分别设置。</p><h5 id="1-3跳帧"><a href="#1-3跳帧" class="headerlink" title="1.3跳帧"></a>1.3跳帧</h5><p>H.264 编码提供 3 种跳帧参考模式：<br><img src="/2020/04/02/%E6%B5%B7%E6%80%9D-VENC%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/3.jpg" alt="3"></p><p><strong>1 倍跳帧参考；</strong></p><blockquote><p>I1 是 I 帧，p1,p2…p12 都是 P 帧。图中有箭头指入的帧，如 I1,p2,p4 等为参考帧，没有箭头指入的帧，如 p1,p3，是非参考帧。<br>用户在保存码流时，可以只保存 4 倍跳帧参考的参考帧，如 I1,p4,p8；也可以保存所有参考帧，甚至所有的帧。     </p></blockquote><p><strong>2 倍跳帧参考；</strong></p><blockquote><p>图中有箭头指入的帧，如 I1,p2,p4 等为参考帧，没有箭头指入的帧，如p1,p3，是非参考帧。用户在保存码流的时候可以保存所有参考帧，也可以保存所有的帧。    </p></blockquote><p><strong>4 倍跳帧参考；</strong></p><blockquote><p>所有的帧都是参考帧，用户在保存码流的时候需要保存所有参考帧。    </p></blockquote><h5 id="1-4其他"><a href="#1-4其他" class="headerlink" title="1.4其他"></a>1.4其他</h5><p><img src="/2020/04/02/%E6%B5%B7%E6%80%9D-VENC%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/4.jpg" alt="4"><br><img src="/2020/04/02/%E6%B5%B7%E6%80%9D-VENC%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/5.jpg" alt="5"><br><img src="/2020/04/02/%E6%B5%B7%E6%80%9D-VENC%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/6.jpg" alt="6"><br><img src="/2020/04/02/%E6%B5%B7%E6%80%9D-VENC%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/7.jpg" alt="7"></p><h4 id="二、数据类型分类学习"><a href="#二、数据类型分类学习" class="headerlink" title="二、数据类型分类学习"></a>二、数据类型分类学习</h4><h5 id="2-1-三种码流（H264、JPEG、MPEG-4的包PACK类型）"><a href="#2-1-三种码流（H264、JPEG、MPEG-4的包PACK类型）" class="headerlink" title="2.1 三种码流（H264、JPEG、MPEG-4的包PACK类型）"></a>2.1 三种码流（H264、JPEG、MPEG-4的包PACK类型）</h5><h6 id="2-1-1-H264E-NALU-TYPE-E"><a href="#2-1-1-H264E-NALU-TYPE-E" class="headerlink" title="2.1.1 H264E_NALU_TYPE_E"></a>2.1.1 H264E_NALU_TYPE_E</h6><p><img src="/2020/04/02/%E6%B5%B7%E6%80%9D-VENC%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/8.jpg" alt="8"></p><h6 id="2-1-2-H264E-REFSLICE-TYPE-E"><a href="#2-1-2-H264E-REFSLICE-TYPE-E" class="headerlink" title="2.1.2 H264E_REFSLICE_TYPE_E"></a>2.1.2 H264E_REFSLICE_TYPE_E</h6><p>定义获取的 H.264 码流属于何种跳帧参考模式下的参考帧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    H264E_REFSLICE_FOR_1X = 1,</span><br><span class="line">    H264E_REFSLICE_FOR_2X = 2,</span><br><span class="line">    H264E_REFSLICE_FOR_4X = 5,</span><br><span class="line">    H264E_REFSLICE_FOR_BUTT</span><br><span class="line">&#125; H264E_REFSLICE_TYPE_E;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/02/%E6%B5%B7%E6%80%9D-VENC%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/9.jpg" alt="9"></p><h6 id="2-1-3-JPEGE-PACK-TYPE-E"><a href="#2-1-3-JPEGE-PACK-TYPE-E" class="headerlink" title="2.1.3 JPEGE_PACK_TYPE_E"></a>2.1.3 JPEGE_PACK_TYPE_E</h6><p><img src="/2020/04/02/%E6%B5%B7%E6%80%9D-VENC%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/10.jpg" alt="10"><br><img src="/2020/04/02/%E6%B5%B7%E6%80%9D-VENC%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/11.jpg" alt="11"></p><h6 id="2-1-4-MPEG4E-PACK-TYPE-E"><a href="#2-1-4-MPEG4E-PACK-TYPE-E" class="headerlink" title="2.1.4 MPEG4E_PACK_TYPE_E"></a>2.1.4 MPEG4E_PACK_TYPE_E</h6><p><img src="/2020/04/02/%E6%B5%B7%E6%80%9D-VENC%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/12.jpg" alt="12"></p><h5 id="2-2-VENC-DATA-TYPE-U"><a href="#2-2-VENC-DATA-TYPE-U" class="headerlink" title="2.2 VENC_DATA_TYPE_U"></a>2.2 VENC_DATA_TYPE_U</h5><p><img src="/2020/04/02/%E6%B5%B7%E6%80%9D-VENC%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/13.jpg" alt="13"></p><h5 id="2-3-VENC-PACK-S-帧码流包结构体"><a href="#2-3-VENC-PACK-S-帧码流包结构体" class="headerlink" title="2.3 VENC_PACK_S(帧码流包结构体)"></a>2.3 VENC_PACK_S(帧码流包结构体)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct hiVENC_PACK_S</span><br><span class="line">&#123;</span><br><span class="line">    HI_U32 u32PhyAddr[2];//码流包物理地址</span><br><span class="line">    HI_U8  *pu8Addr[2];//码流包首地址</span><br><span class="line">    HI_U32 u32Len[2];//码流包长度</span><br><span class="line">    VENC_DATA_TYPE_U  DataType;// 码流类型，支持 H.264/JPEG/MPEG-4 协议类型的数据包</span><br><span class="line">    HI_U64 u64PTS;//时间戳</span><br><span class="line">    HI_BOOL bFieldEnd;//场结束标识？？场是个什么概念？？</span><br><span class="line">    HI_BOOL bFrameEnd;//帧结束标识</span><br><span class="line">&#125;VENC_PACK_S;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/02/%E6%B5%B7%E6%80%9D-VENC%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/14.jpg" alt="14"></p><h5 id="2-4-协议码流特征-H264、JPEG、MPEG-4"><a href="#2-4-协议码流特征-H264、JPEG、MPEG-4" class="headerlink" title="2.4 协议码流特征(H264、JPEG、MPEG-4)"></a>2.4 协议码流特征(H264、JPEG、MPEG-4)</h5><p>暂略</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、VENC是什么？&quot;&gt;&lt;a href=&quot;#一、VENC是什么？&quot; class=&quot;headerlink&quot; title=&quot;一、VENC是什么？&quot;&gt;&lt;/a&gt;一、VENC是什么？&lt;/h4&gt;&lt;p&gt;VENC 模块，即视频编码模块。本模块支持多路实时编码，且每路编码彼此独立，++编码协议和编码 profile 可以不同++ 。本模块支持视频编码同时，调度 Region 模块对编码图像内容进行叠加和遮挡。&lt;br&gt;&lt;img src=&quot;/2020/04/02/%E6%B5%B7%E6%80%9D-VENC%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/1.jpg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="海思" scheme="http://www.faihung.net/categories/%E6%B5%B7%E6%80%9D/"/>
    
    
      <category term="VENC" scheme="http://www.faihung.net/tags/VENC/"/>
    
      <category term="编码通道" scheme="http://www.faihung.net/tags/%E7%BC%96%E7%A0%81%E9%80%9A%E9%81%93/"/>
    
      <category term="码率" scheme="http://www.faihung.net/tags/%E7%A0%81%E7%8E%87/"/>
    
      <category term="跳帧" scheme="http://www.faihung.net/tags/%E8%B7%B3%E5%B8%A7/"/>
    
      <category term="数据帧类型" scheme="http://www.faihung.net/tags/%E6%95%B0%E6%8D%AE%E5%B8%A7%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>makefile-1.1-Makefile基本概念</title>
    <link href="http://www.faihung.net/2020/02/15/makefile-1-1-Makefile%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://www.faihung.net/2020/02/15/makefile-1-1-Makefile基本概念/</id>
    <published>2020-02-15T10:38:28.000Z</published>
    <updated>2020-04-12T13:00:36.574Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一、一个示例"><a href="#一、一个示例" class="headerlink" title="一、一个示例"></a>一、一个示例</h5><p>先看一个代码演示：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;hello world!\n&quot;);</span><br><span class="line">printf(&quot;hello maekfile\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>makefile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hello:helloworld.o</span><br><span class="line">gcc -o hello helloworld.o</span><br><span class="line">helloworld.o:helloworld.c</span><br><span class="line">gcc -o helloworld.o -c helloworld.c</span><br><span class="line">clean:</span><br><span class="line">rm hello helloworld.o</span><br></pre></td></tr></table></figure><p>执行: make</p><p><img src="/2020/02/15/makefile-1-1-Makefile%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/1.jpg" alt="1"></p><p>执行: ./hello</p><p><img src="/2020/02/15/makefile-1-1-Makefile%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2.jpg" alt="2"></p><h5 id="二、什么是Makefile"><a href="#二、什么是Makefile" class="headerlink" title="二、什么是Makefile?"></a>二、什么是Makefile?</h5><p>make命令执行时，需要一个makefile文件，以告诉make命令需要怎么样的去编译和链接程序。</p><p>makefile文件保存了编译器和连接器的参数选项,还表述了所有源文件之间的关系(源代码文件需要的特定的包含文件,可执行文件要求包含的目标文件模块及库等)。</p><p>创建程序(make程序)首先读取makefile文件,然后再激活编译器,汇编器,资源编译器和连接器以便产生最后的输出,最后输出并生成的通常是可执行文件。</p><p>创建程序利用内置的推理规则来激活编译器,以便通过对特定CPP文件的编译来产生特定的OBJ文件。</p><p><img src="/2020/02/15/makefile-1-1-Makefile%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/3.jpg" alt="3"></p><h5 id="三、Make是如何工作的？"><a href="#三、Make是如何工作的？" class="headerlink" title="三、Make是如何工作的？"></a>三、Make是如何工作的？</h5><p>在默认的方式下，也就是我们只输入make命令。那么，</p><p>1、make会在当前目录下找名字叫“Makefile”或“makefile”的文件。</p><p>2、如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“hello”这个文件，并把这个文件作为最终的目标文件。</p><p>3、如果hello文件不存在，或是hello所依赖的后面的 .o 文件的文件修改时间要比hello这个文件新，那么，他就会执行后面所定义的命令来生成hello这个文件。</p><p>4、如果hello所依赖的.o文件也不存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程）</p><p>5、当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件生成make的终极任务，也就是执行文件hello了。</p><p>这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。</p><h5 id="四、学习Makefile的必要性"><a href="#四、学习Makefile的必要性" class="headerlink" title="四、学习Makefile的必要性"></a>四、学习Makefile的必要性</h5><p>会不会写Makefile从侧面可以看出一个人是否具有完成大型项目工程的能力。</p><ul><li>Linux/Unix环境下开发必备技能</li><li>系统架构师、项目经理核心技能</li><li>研究开源项目、Linux内核的地图</li><li>加深对底层软件构造系统及过程的理解</li></ul><h5 id="五、如何学习Makefile？"><a href="#五、如何学习Makefile？" class="headerlink" title="五、如何学习Makefile？"></a>五、如何学习Makefile？</h5><h6 id="5-1-理论基础"><a href="#5-1-理论基础" class="headerlink" title="5.1 理论基础"></a>5.1 理论基础</h6><blockquote><p>面向依赖的思维</p></blockquote><ul><li><p><a href="https://pan.baidu.com/s/1qLoethrcmuhqnqNfu8P9lg" target="_blank" rel="noopener">程序员的自我修养(装载&amp;库)(高清带完整书签版)</a></p><blockquote><p>提取码：6ukr</p></blockquote></li><li><p><a href="https://pan.baidu.com/s/1VQ07fDdRuLOrT6rK2ZKmBQ" target="_blank" rel="noopener">GNU+makefile中文手册</a></p><blockquote><p>提取码：le6g </p></blockquote></li><li><p><a href="https://pan.baidu.com/s/1zJr2rC6UoFzDDdXnB9EwEg" target="_blank" rel="noopener">深入理解软件构造系统 原理与最佳实践</a></p><blockquote><p>提取码：pwpa</p></blockquote></li></ul><h6 id="5-2-学习环境"><a href="#5-2-学习环境" class="headerlink" title="5.2 学习环境"></a>5.2 学习环境</h6><ul><li>Linux、Unix环境</li><li>Windows下的cygwin等模拟环境</li></ul><h6 id="5-3-项目编程基础"><a href="#5-3-项目编程基础" class="headerlink" title="5.3 项目编程基础"></a>5.3 项目编程基础</h6><ul><li><p>C语言基础</p></li><li><p>C语言项目基础</p><ul><li><p>C语言实战之学生成绩管理系统</p></li><li><p>多文件源码管理、头文件包含、函数的声明与定义</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;一、一个示例&quot;&gt;&lt;a href=&quot;#一、一个示例&quot; class=&quot;headerlink&quot; title=&quot;一、一个示例&quot;&gt;&lt;/a&gt;一、一个示例&lt;/h5&gt;&lt;p&gt;先看一个代码演示：&lt;/p&gt;
    
    </summary>
    
    
      <category term="makefile" scheme="http://www.faihung.net/categories/makefile/"/>
    
    
      <category term="make" scheme="http://www.faihung.net/tags/make/"/>
    
      <category term="makefile" scheme="http://www.faihung.net/tags/makefile/"/>
    
      <category term="资料" scheme="http://www.faihung.net/tags/%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>shell-shell命令监测程序运行状态</title>
    <link href="http://www.faihung.net/2020/01/14/shell-shell%E5%91%BD%E4%BB%A4%E7%9B%91%E6%B5%8B%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81/"/>
    <id>http://www.faihung.net/2020/01/14/shell-shell命令监测程序运行状态/</id>
    <published>2020-01-14T01:30:53.000Z</published>
    <updated>2020-01-14T01:32:53.214Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在系统没有断电的前提下，监控脚本一直处于运行中</p></blockquote><p>1.将av_streamer -i input_stream.so -o output_app.so 后台重定向到无底洞中去或者是运行在后台中</p><a id="more"></a><p>2.检测程序运行的命令</p><pre><code>ps |grep -w av_streamer  |grep -v grep|wc -l</code></pre><p>监测到运行程序返回1</p><p>没有监测到则返回0​​​</p><p>3.根据检测到的状态决定是否启动程序<br>返回0启动程序 av_streamer -i input_stream.so -o output_app.so<br>返回1打印：程序正在运行。</p><p>具体表现在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">count=0</span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">ProcNumber=`ps |grep -w av_streamer  |grep -v grep|wc -l`</span><br><span class="line">if [ 1 -eq $ProcNumber ];then</span><br><span class="line">#echo &quot;task running...&quot; </span><br><span class="line">count=$((count + 1))</span><br><span class="line">echo &quot;task running is&quot; $count</span><br><span class="line">sleep 30s</span><br><span class="line">else                                                   </span><br><span class="line">echo &quot;task not run...&quot;   </span><br><span class="line">sleep 30s</span><br><span class="line">av_streamer -i input_stream.so -o output_app.so &amp;</span><br><span class="line">echo &quot;task start run...&quot;</span><br><span class="line">fi       </span><br><span class="line">done</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在系统没有断电的前提下，监控脚本一直处于运行中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.将av_streamer -i input_stream.so -o output_app.so 后台重定向到无底洞中去或者是运行在后台中&lt;/p&gt;
    
    </summary>
    
    
      <category term="shell" scheme="http://www.faihung.net/categories/shell/"/>
    
    
      <category term="shell" scheme="http://www.faihung.net/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Git-03_gitlab的应用场景</title>
    <link href="http://www.faihung.net/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://www.faihung.net/2020/01/12/Git-03-gitlab的应用场景/</id>
    <published>2020-01-12T04:50:39.000Z</published>
    <updated>2020-01-12T05:00:48.943Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前面简单介绍了Web端gitlab的配置与准备工作，这里主要介绍gitlab的一些应用场景。</p></blockquote><p>以Linux为例，Windows平台和linux一样。<br>前面(2.2.1点击按钮“New project”建立项目)在建立一个新的project的时候出现Command line instructions,下面几乎所有的操作都是围绕着这几条命令。</p><a id="more"></a><h5 id="Command-line-instructions"><a href="#Command-line-instructions" class="headerlink" title="Command line instructions"></a>Command line instructions</h5><h6 id="Git-global-setup"><a href="#Git-global-setup" class="headerlink" title="Git global setup"></a>Git global setup</h6><p>在第一次使用时需要对Git进行设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yhh&quot;</span><br><span class="line">git config --global user.email &quot;yihuihong@example.cn&quot;</span><br></pre></td></tr></table></figure><h6 id="Create-a-new-repository"><a href="#Create-a-new-repository" class="headerlink" title="Create a new repository"></a>Create a new repository</h6><p>从远程库中克隆一个空的project下来，然后创建新的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone git@example.wicp.vip:example_firmware/test.git</span><br><span class="line">cd test</span><br><span class="line">touch README.md</span><br><span class="line">git add README.md        //1.将代码从工作区中添加到版本库暂存区中去</span><br><span class="line">git commit -m &quot;add README&quot;  //2.把暂存区的所有修改提交到master分支上去</span><br><span class="line">git push -u origin master   //3.把分master支上代码push到远程仓库中去</span><br></pre></td></tr></table></figure><h6 id="Existing-folder"><a href="#Existing-folder" class="headerlink" title="Existing folder"></a>Existing folder</h6><p>我们一般用的是这个命令，将现有工程代码push到远程库中去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd existing_folder</span><br><span class="line">git init //创建版本库，后面会有详细介绍（只有第一次操作即可，后面不用操作）</span><br><span class="line"></span><br><span class="line">关联仓库（两种push代码方式）</span><br><span class="line">git remote add origin http://example.wicp.vip/example_firmware/test.git /*走http协议（只有第一次操作即可，后面不用操作）*/</span><br><span class="line">git remote add origin git@192.168.0.xx:example_firmware/plug-in_framework.git /*走SSH协议 （只有第一次操作即可，后面不用操作）*/</span><br><span class="line"></span><br><span class="line">git add .                      //1.将代码从工作区中添加到版本库暂存区中去</span><br><span class="line">git commit -m &quot;Initial commit&quot; //2.把暂存区的所有修改提交到master分支上去</span><br><span class="line">git push -u origin master      //3.把分master支上代码push到远程仓库中去</span><br></pre></td></tr></table></figure><h6 id="Existing-Git-repository"><a href="#Existing-Git-repository" class="headerlink" title="Existing Git repository"></a>Existing Git repository</h6><p>没做研究（略）</p><h5 id="1-创建版本库"><a href="#1-创建版本库" class="headerlink" title="1.    创建版本库"></a>1.    创建版本库</h5><p>在linux平台相应项目工作目录中执行：git init 之后对应的工作目录中就会生成一个.git文件。这个是用来跟踪库管理版本库的，以后千万不要把这个删除了，不然之前的所有git记录都会被破坏掉。<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/1.png" alt="1"><br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/2.png" alt="2"></p><h5 id="2-关联仓库"><a href="#2-关联仓库" class="headerlink" title="2.  关联仓库"></a>2.  关联仓库</h5><p>将本地仓库和远程仓库进行关联，之后才能把内容添加到远程仓库中去。</p><h6 id="SSH方式"><a href="#SSH方式" class="headerlink" title="SSH方式"></a>SSH方式</h6><pre><code>git remote add origin git@192.168.0.xx:example_firmware/plug-in_framework.git  </code></pre><h6 id="HTTP方式"><a href="#HTTP方式" class="headerlink" title="HTTP方式"></a>HTTP方式</h6><pre><code>git remote add origin http://example.wicp.vip/example_firmware/test.git</code></pre><h5 id="3-代码管理"><a href="#3-代码管理" class="headerlink" title="3.    代码管理"></a>3.    代码管理</h5><p>代码管理，常用的几个命令，其实就是三板斧。</p><h6 id="3-1查看代码状态"><a href="#3-1查看代码状态" class="headerlink" title="3.1查看代码状态"></a>3.1查看代码状态</h6><p>执行命令：</p><pre><code>git status</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/3.png" alt="3"></p><h6 id="3-2-添加代码到版本库"><a href="#3-2-添加代码到版本库" class="headerlink" title="3.2    添加代码到版本库"></a>3.2    添加代码到版本库</h6><p>执行命令：</p><pre><code>git add .</code></pre><h6 id="3-3-将代码添加分支"><a href="#3-3-将代码添加分支" class="headerlink" title="3.3    将代码添加分支"></a>3.3    将代码添加分支</h6><p>执行命令：</p><pre><code>git commit -m “初次提交”</code></pre><p>（太多了就不上图了）</p><h6 id="3-4-将分支代码提交到远程库"><a href="#3-4-将分支代码提交到远程库" class="headerlink" title="3.4    将分支代码提交到远程库"></a>3.4    将分支代码提交到远程库</h6><p>执行命令：</p><pre><code>git push -u origin master(第一次执行命令需要加上-u，后面就不需要)</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/4.png" alt="4"></p><h5 id="4-版本回退"><a href="#4-版本回退" class="headerlink" title="4.    版本回退"></a>4.    版本回退</h5><p>我们这工作中，经常想知道我们在版本库中提交了多少版本，执行命令：</p><pre><code>git log</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/5.png" alt="5"></p><p>或者命令：</p><pre><code>git log --pretty=onelin</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/6.png" alt="6"><br>其中commit 4b10e619d0b82c574a34b2266ca40ad13b7d5622，是每一个版本的id 通过SHA1计算出来的。</p><p>或者命令：</p><pre><code>git reflog</code></pre><h6 id="4-1-代码回退到上一个版本"><a href="#4-1-代码回退到上一个版本" class="headerlink" title="4.1 代码回退到上一个版本"></a>4.1 代码回退到上一个版本</h6><p>执行命令：</p><pre><code>git reset --hard HEAD^</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/7.png" alt="7"><br>其中HEAD是当前版本的指针，^ 表示上一个版本，^^表示上上一个版本。</p><h6 id="4-2-代码回退指定版本"><a href="#4-2-代码回退指定版本" class="headerlink" title="4.2 代码回退指定版本"></a>4.2 代码回退指定版本</h6><p>指令命令：</p><pre><code>git reset --hard 57d3f9aa669dc646697064a97810b842a50fe1bc</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/8.png" alt="8"></p><h6 id="4-3-代码回退最新版本"><a href="#4-3-代码回退最新版本" class="headerlink" title="4.3 代码回退最新版本"></a>4.3 代码回退最新版本</h6><p>第一步，执行命令：</p><pre><code>git reflog //找到所有版本的 commit id</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/9.png" alt="9"></p><p>第二步，执行命令：</p><pre><code>git reset --hard 4b10e61</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/10.png" alt="10"></p><h5 id="5-多个分支"><a href="#5-多个分支" class="headerlink" title="5.    多个分支"></a>5.    多个分支</h5><p>平时开发，我们一般是master分支留作发布版本，dev分支做测试开发。</p><h6 id="5-1-建立新分支"><a href="#5-1-建立新分支" class="headerlink" title="5.1 建立新分支"></a>5.1 建立新分支</h6><p>执行一个命令：</p><pre><code>git checkout -b dev</code></pre><p>这个命令可分解为两步：git branch dev和git checkout dev</p><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/11.png" alt="11"></p><blockquote><p>注意：切换dev分支时，需要将master分支中的代码 commit 到版本库中去，否则切换不成功，或者原有的代码将不保存。</p></blockquote><h6 id="5-2-查看分支"><a href="#5-2-查看分支" class="headerlink" title="5.2 查看分支"></a>5.2 查看分支</h6><p>执行命令：</p><pre><code>git branch</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/12.png" alt="12"><br>表示现在可以在dev分支上进行开发了，图中绿色字体。    </p><h6 id="5-3-合并分支"><a href="#5-3-合并分支" class="headerlink" title="5.3 合并分支"></a>5.3 合并分支</h6><p>在dev分支上修改代码并提交到版本库中去，然后进入master分支上去执行命令：</p><pre><code>git merge dev</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/13.png" alt="13"></p><h6 id="5-4-删除分支"><a href="#5-4-删除分支" class="headerlink" title="5.4 删除分支"></a>5.4 删除分支</h6><p>执行命令：</p><pre><code>git branch -d dev</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/14.png" alt="14"></p><h6 id="5-5-合并分支的冲突"><a href="#5-5-合并分支的冲突" class="headerlink" title="5.5 合并分支的冲突"></a>5.5 合并分支的冲突</h6><p>所谓的冲突，就是多个分支之间不同步，一般我们在修改master分支代码之前，先pull一下代码，不然就会出现下面这种冲突的情况，出现这种情况，我们就需要把git合并失败的文件手动编辑为我们希望的内容，再提交。</p><p>第一步：创建并修改一个分支，然后提交。如下：<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/15.png" alt="15"></p><p>第二步：切换到master分支，并修改master分支，之后合并dev1分支。<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/16.png" alt="16"><br>可以看到有合并冲突，同时查看readme.txt<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/17.png" alt="17"><br>这种情况就是冲突，必须需要手动解决冲突后再提交。删除readme.txt不需要的部分然后再commit上去即可。<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/18.png" alt="18"><br>执行命令：</p><pre><code>git log --graph --pretty=oneline --abbrev-commit</code></pre><p>可以查看分子合并的情况，如图。</p><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/19.png" alt="19"></p><h6 id="5-6-多人协作"><a href="#5-6-多人协作" class="headerlink" title="5.6 多人协作"></a>5.6 多人协作</h6><p>多人协作时，大家都会往master和dev分支上推送各自的修改。假设你是A，同时有一个人B在另一台电脑（注意要把SSH Key添加到GitLab）或者同一台电脑的另一个目录下克隆。</p><p>执行命令：</p><pre><code>git clone git@192.168.0.xx:xxx_firmware/test.git</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/20.png" alt="20"></p><p>默认情况下就是master分支，如下：git branch<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/21.png" alt="21"></p><p>此时B会在dev分支上开发并push代码<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/22.png" alt="22"></p><p>然后A也做了修改，同时将代码push到dev分支上去，如下<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/23.png" alt="23"></p><p>上面显示推送失败，因为B在最新的提交和A的提交有冲突，解决方法就是先将远程库的代码拉取下来，看下图。</p><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/24.png" alt="24"><br>注意：在拉取代码失败的时候，需要指定本地的dev分支和远程库的origin/dev分支的关联。同时查看本地readme.txt分支修改情况，可以发现<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/25.png" alt="25"></p><p>这个时候和5.6合并分支的冲突一样。解决之后再提交，最后在push。<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/26.png" alt="26"></p><h5 id="6-标签设定与版本号"><a href="#6-标签设定与版本号" class="headerlink" title="6.    标签设定与版本号"></a>6.    标签设定与版本号</h5><p>Gitlab没push一个版本代码都有一个commit id，我们根据这些commit id 可以给他们打上一个标签，这写标签可以是一个版本号。</p><h6 id="6-1-默认标签"><a href="#6-1-默认标签" class="headerlink" title="6.1 默认标签"></a>6.1 默认标签</h6><p>默认标签是打在最新提交的commit上的如下：<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/27.png" alt="27"></p><h6 id="6-2-指定commit-id-上打标签"><a href="#6-2-指定commit-id-上打标签" class="headerlink" title="6.2    指定commit id 上打标签"></a>6.2    指定commit id 上打标签</h6><p>第一步：</p><pre><code>git log --pretty=oneline --abbrev-commit</code></pre><p>找到所有master分支上提交版本commit id</p><p>第二步：</p><pre><code>git tag v0.9 8c1b181 </code></pre><p>指定commit 打标签</p><h6 id="6-3-查看具体标签具体信息"><a href="#6-3-查看具体标签具体信息" class="headerlink" title="6.3    查看具体标签具体信息"></a>6.3    查看具体标签具体信息</h6><p>执行命令：</p><pre><code>git show v0.9</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/28.png" alt="28"></p><h6 id="6-4-推送标签"><a href="#6-4-推送标签" class="headerlink" title="6.4    推送标签"></a>6.4    推送标签</h6><p>推送某一个标签：</p><pre><code>git push origin v1.0</code></pre><p>推送所有标签：</p><pre><code>git push origin –tags</code></pre><p><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/29.png" alt="29"></p><p>此时观察Web端：<br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/30.png" alt="30"><br><img src="/2020/01/12/Git-03-gitlab%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/31.png" alt="31"><br>这个就是标签。</p><h6 id="6-5-删除标签"><a href="#6-5-删除标签" class="headerlink" title="6.5    删除标签"></a>6.5    删除标签</h6><p>若标签只存在本地，直接执行命令：</p><pre><code>git tag -d v1.0</code></pre><p>若标签已经推送到远程，要删除远程标签需要<br>第一步，先删除本地标签：</p><pre><code>git tag -d v1.0</code></pre><p>第二步，再删除远程的标签：</p><pre><code>git push origin :refs/tags/v1.0</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前面简单介绍了Web端gitlab的配置与准备工作，这里主要介绍gitlab的一些应用场景。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以Linux为例，Windows平台和linux一样。&lt;br&gt;前面(2.2.1点击按钮“New project”建立项目)在建立一个新的project的时候出现Command line instructions,下面几乎所有的操作都是围绕着这几条命令。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://www.faihung.net/categories/Git/"/>
    
    
      <category term="gitlab" scheme="http://www.faihung.net/tags/gitlab/"/>
    
      <category term="github" scheme="http://www.faihung.net/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>C语言-shell命令方式&amp;函数方式执行汇总</title>
    <link href="http://www.faihung.net/2020/01/10/C%E8%AF%AD%E8%A8%80-shell%E5%91%BD%E4%BB%A4%E6%96%B9%E5%BC%8F-%E5%87%BD%E6%95%B0%E6%96%B9%E5%BC%8F%E6%89%A7%E8%A1%8C%E6%B1%87%E6%80%BB/"/>
    <id>http://www.faihung.net/2020/01/10/C语言-shell命令方式-函数方式执行汇总/</id>
    <published>2020-01-10T03:10:41.000Z</published>
    <updated>2020-01-10T03:30:52.874Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一、调用system执行shell命令"><a href="#一、调用system执行shell命令" class="headerlink" title="一、调用system执行shell命令"></a>一、调用system执行shell命令</h5><p><strong>编译验证过的源码码</strong>：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">#define FILE_PATH_HISI_TAR &quot;/mnt/hgfs/VMWARE/curl/app/temp/&quot;</span><br><span class="line">#define FILE_PATH_HISI_TAR_AFTER &quot;/mnt/hgfs/VMWARE/curl/app/temp/root/&quot;</span><br><span class="line">#define FILE_PATH_MD5 &quot;/mnt/hgfs/VMWARE/test/12-shell_cmd_func/&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int shell_system(char *pcmd)</span><br><span class="line">&#123;</span><br><span class="line">pid_t status;</span><br><span class="line"></span><br><span class="line">printf(&quot;execute cmd:%s\n&quot;,pcmd);</span><br><span class="line">status = system(pcmd);</span><br><span class="line">if (-1 == status)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;system error!&quot;);</span><br><span class="line">return -1;</span><br><span class="line">    &#125;</span><br><span class="line">if(WIFEXITED(status) != 0)//正常退出</span><br><span class="line">&#123;</span><br><span class="line">if(WEXITSTATUS(status) == 0)//操作正确</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;run command success\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;run error\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else//异常退出</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;exit error is %d\n&quot;, WEXITSTATUS(status));</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">char shell_cmd_ls[128];</span><br><span class="line">char shell_cmd_tar[128];</span><br><span class="line">char shell_cmd_md5[128];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sprintf(shell_cmd_ls,&quot;ls -al&quot;);</span><br><span class="line">if(0 != shell_system(shell_cmd_ls))</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;System call failed!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">/* </span><br><span class="line">//解压文件</span><br><span class="line">sprintf(shell_cmd_tar,&quot;tar zxvf %s%s -C %s&quot;,FILE_PATH_HISI_TAR,&quot;hisi_app.tar.gz&quot;,FILE_PATH_HISI_TAR_AFTER);</span><br><span class="line">if(0 != shell_system(shell_cmd_tar))</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;System call failed!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//拷贝文件</span><br><span class="line">//删除文件</span><br><span class="line">//统计文件</span><br><span class="line">//改变文件权限</span><br><span class="line">//计算md5值</span><br><span class="line">sprintf(shell_cmd_md5,&quot;md5sum %s%s&quot;,FILE_PATH_MD5,&quot;chmod.c&quot;);</span><br><span class="line">if(0 != shell_system(shell_cmd_md5))</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;System call failed!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="二、调用popen执行shell命令"><a href="#二、调用popen执行shell命令" class="headerlink" title="二、调用popen执行shell命令"></a>二、调用popen执行shell命令</h5><p><strong>编译验证过的源码码</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">#define FILE_PATH_HISI_TAR &quot;/mnt/hgfs/VMWARE/curl/app/temp/&quot;</span><br><span class="line">#define FILE_PATH_HISI_TAR_AFTER &quot;/mnt/hgfs/VMWARE/curl/app/temp/root/&quot;</span><br><span class="line">#define FILE_PATH_MD5 &quot;/mnt/hgfs/VMWARE/test/12-shell_cmd_func/&quot;</span><br><span class="line"></span><br><span class="line">int shell_popen(char *pbuf,char *pfile_path)</span><br><span class="line">&#123;</span><br><span class="line">char cmd_buf[64];</span><br><span class="line">FILE* fp = NULL;</span><br><span class="line">sprintf(cmd_buf,&quot;md5sum %s&quot;,pfile_path);</span><br><span class="line">fp = popen(cmd_buf, &quot;r&quot;);</span><br><span class="line">if(NULL == fp)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;popen&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">while(fgets(pbuf, 1024, fp) != NULL);</span><br><span class="line"></span><br><span class="line">pclose(fp);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void) </span><br><span class="line">&#123;</span><br><span class="line">char buf[128] = &#123;0&#125;;</span><br><span class="line">char file_path[128];</span><br><span class="line"></span><br><span class="line">//ls -al</span><br><span class="line">//拷贝文件</span><br><span class="line">//删除文件</span><br><span class="line">//统计文件</span><br><span class="line">//改变文件权限</span><br><span class="line">//解压文件</span><br><span class="line">//计算md5值</span><br><span class="line">sprintf(file_path,&quot;%s/%s&quot;,FILE_PATH_MD5,&quot;chmod.c&quot;);</span><br><span class="line">if(0 == shell_popen(buf,file_path))</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;MD5:%s\n&quot;, buf);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">printf(&quot;get MD5&apos;s value is failed!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">memset(buf, 0x0, sizeof(buf));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以前用shell命令通过管道或者系统方式执行一条命令，这样会在线程里面开启新的进程，从而会造成代码出现不可控的状态。<br>管道或者system会返回出各种状态值，这些状态值是不可控。</p><h5 id="三、函数方式删除文件"><a href="#三、函数方式删除文件" class="headerlink" title="三、函数方式删除文件"></a>三、函数方式删除文件</h5><p><strong>编译验证过的源码码</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#ifndef _DELETE_FILE</span><br><span class="line">#define _DELETE_FILE</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;limits.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line"></span><br><span class="line">//判断是否为目录</span><br><span class="line">bool is_dir(const char *path)</span><br><span class="line">&#123;</span><br><span class="line">    struct stat statbuf;</span><br><span class="line">    if(lstat(path, &amp;statbuf) ==0)//lstat返回文件的信息，文件信息存放在stat结构中</span><br><span class="line">    &#123;</span><br><span class="line">        return S_ISDIR(statbuf.st_mode) != 0;//S_ISDIR宏，判断文件类型是否为目录</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//判断是否为常规文件</span><br><span class="line">bool is_file(const char *path)</span><br><span class="line">&#123;</span><br><span class="line">    struct stat statbuf;</span><br><span class="line">    if(lstat(path, &amp;statbuf) ==0)</span><br><span class="line">        return S_ISREG(statbuf.st_mode) != 0;//判断文件是否为常规文件</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//判断是否是特殊目录</span><br><span class="line">bool is_special_dir(const char *path)</span><br><span class="line">&#123;</span><br><span class="line">    return strcmp(path, &quot;.&quot;) == 0 || strcmp(path, &quot;..&quot;) == 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//生成完整的文件路径</span><br><span class="line">void get_file_path(const char *path, const char *file_name,  char *file_path)</span><br><span class="line">&#123;</span><br><span class="line">    strcpy(file_path, path);</span><br><span class="line">    if(file_path[strlen(path) - 1] != &apos;/&apos;)</span><br><span class="line">        strcat(file_path, &quot;/&quot;);</span><br><span class="line">    strcat(file_path, file_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void delete_file(const char *path)</span><br><span class="line">&#123;</span><br><span class="line">    DIR *dir;</span><br><span class="line">    struct dirent *dir_info;</span><br><span class="line">    char file_path[PATH_MAX];</span><br><span class="line">    if(is_file(path))</span><br><span class="line">    &#123;</span><br><span class="line">        remove(path);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(is_dir(path))</span><br><span class="line">    &#123;</span><br><span class="line">        if((dir = opendir(path)) == NULL)</span><br><span class="line">            return;</span><br><span class="line">        while((dir_info = readdir(dir)) != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            get_file_path(path, dir_info-&gt;d_name, file_path);</span><br><span class="line">            if(is_special_dir(dir_info-&gt;d_name))</span><br><span class="line">                continue;</span><br><span class="line">            delete_file(file_path);</span><br><span class="line">            rmdir(file_path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;argv[1]=%s\n&quot;,argv[1]);</span><br><span class="line">    delete_file(argv[1]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h5 id="四、函数方式统计某个目录下的文件个数"><a href="#四、函数方式统计某个目录下的文件个数" class="headerlink" title="四、函数方式统计某个目录下的文件个数"></a>四、函数方式统计某个目录下的文件个数</h5><p><strong>编译验证过的源码码</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define MAX 1024</span><br><span class="line">/*</span><br><span class="line">返回值,返回该文件夹中的文件个数</span><br><span class="line">参数ppathfile,所求文件夹目录的路径</span><br><span class="line">*/</span><br><span class="line">int get_file_count(char *ppathfile)</span><br><span class="line">&#123;</span><br><span class="line">DIR *dir;</span><br><span class="line">struct dirent * ptr;</span><br><span class="line">int total = 0;</span><br><span class="line">char path[MAX];</span><br><span class="line">dir = opendir(ppathfile); /* 打开目录*/</span><br><span class="line">if(dir == NULL)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;fail to open dir&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line">errno = 0;</span><br><span class="line">while((ptr = readdir(dir)) != NULL)</span><br><span class="line">&#123;</span><br><span class="line">//顺序读取每一个目录项；</span><br><span class="line">//跳过“..”和“.”两个目录</span><br><span class="line">if(strcmp(ptr-&gt;d_name,&quot;.&quot;) == 0 || strcmp(ptr-&gt;d_name,&quot;..&quot;) == 0)</span><br><span class="line">&#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">//printf(&quot;%s%s\n&quot;,ppathfile,ptr-&gt;d_name);</span><br><span class="line">//如果是目录，则递归调用 get_file_count函数</span><br><span class="line">if(ptr-&gt;d_type == DT_DIR)</span><br><span class="line">&#123;</span><br><span class="line">sprintf(path,&quot;%s%s/&quot;,ppathfile,ptr-&gt;d_name);</span><br><span class="line">//printf(&quot;%s\n&quot;,path);</span><br><span class="line"></span><br><span class="line">total += get_file_count(path);</span><br><span class="line">&#125;</span><br><span class="line">if(ptr-&gt;d_type == DT_REG)</span><br><span class="line">&#123;</span><br><span class="line">total++;</span><br><span class="line">printf(&quot;%s%s\n&quot;,ppathfile,ptr-&gt;d_name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(errno != 0)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;fail to read dir&quot;); //失败则输出提示信息</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line">closedir(dir);</span><br><span class="line">return total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">int total;</span><br><span class="line">if(argc != 2)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;wrong usage\n&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line">total = get_file_count(argv[1]);</span><br><span class="line">printf(&quot;%s have %d files\n&quot;,argv[1],total);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="五、函数方式改变文件权限"><a href="#五、函数方式改变文件权限" class="headerlink" title="五、函数方式改变文件权限"></a>五、函数方式改变文件权限</h5><p><strong>编译验证过的源码码</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    chmod(&quot;/home/yhh/123&quot;, S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IWGRP|S_IXGRP|S_IROTH|S_IWOTH|S_IXOTH);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#if 0</span><br><span class="line">函数说明：</span><br><span class="line">chmod()会依参数mode 权限来更改参数path 指定文件的权限</span><br><span class="line"></span><br><span class="line">参数 mode 有下列数种组合：</span><br><span class="line">S_ISUID 04000 文件的 (set user-id on execution)位</span><br><span class="line">S_ISGID 02000 文件的 (set group-id on execution)位</span><br><span class="line">S_ISVTX 01000 文件的sticky 位</span><br><span class="line">S_IRUSR (S_IREAD) 00400 文件所有者具可读取权限</span><br><span class="line">S_IWUSR (S_IWRITE)00200 文件所有者具可写入权限</span><br><span class="line">S_IXUSR (S_IEXEC) 00100 文件所有者具可执行权限</span><br><span class="line">S_IRGRP 00040 用户组具可读取权限</span><br><span class="line">S_IWGRP 00020 用户组具可写入权限</span><br><span class="line">S_IXGRP 00010 用户组具可执行权限</span><br><span class="line">S_IROTH 00004 其他用户具可读取权限</span><br><span class="line">S_IWOTH 00002 其他用户具可写入权限</span><br><span class="line">S_IXOTH 00001 其他用户具可执行权限</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h5 id="六、函数方式计算文件的md5值"><a href="#六、函数方式计算文件的md5值" class="headerlink" title="六、函数方式计算文件的md5值"></a>六、函数方式计算文件的md5值</h5><p><strong>编译验证过的源码码</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned int count[2];  </span><br><span class="line">    unsigned int state[4];  </span><br><span class="line">    unsigned char buffer[64];     </span><br><span class="line">&#125;MD5_CTX;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define F(x,y,z) ((x &amp; y) | (~x &amp; z))  </span><br><span class="line">#define G(x,y,z) ((x &amp; z) | (y &amp; ~z))  </span><br><span class="line">#define H(x,y,z) (x^y^z)  </span><br><span class="line">#define I(x,y,z) (y ^ (x | ~z))  </span><br><span class="line">#define ROTATE_LEFT(x,n) ((x &lt;&lt; n) | (x &gt;&gt; (32-n)))  </span><br><span class="line">#define FF(a,b,c,d,x,s,ac) \</span><br><span class="line">&#123; \</span><br><span class="line">    a += F(b,c,d) + x + ac; \</span><br><span class="line">    a = ROTATE_LEFT(a,s); \</span><br><span class="line">    a += b; \</span><br><span class="line">&#125;  </span><br><span class="line">#define GG(a,b,c,d,x,s,ac) \</span><br><span class="line">&#123; \</span><br><span class="line">    a += G(b,c,d) + x + ac; \</span><br><span class="line">    a = ROTATE_LEFT(a,s); \</span><br><span class="line">    a += b; \</span><br><span class="line">&#125;  </span><br><span class="line">#define HH(a,b,c,d,x,s,ac) \</span><br><span class="line">&#123; \</span><br><span class="line">    a += H(b,c,d) + x + ac; \</span><br><span class="line">    a = ROTATE_LEFT(a,s); \</span><br><span class="line">    a += b; \</span><br><span class="line">&#125;  </span><br><span class="line">#define II(a,b,c,d,x,s,ac) \</span><br><span class="line">&#123; \</span><br><span class="line">    a += I(b,c,d) + x + ac; \</span><br><span class="line">    a = ROTATE_LEFT(a,s); \</span><br><span class="line">    a += b; \</span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line">unsigned char PADDING[]=&#123;</span><br><span class="line">0x80,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  </span><br><span class="line">0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  </span><br><span class="line">0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  </span><br><span class="line">0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">void MD5Encode(unsigned char *output,unsigned int *input,unsigned int len)  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned int i = 0,j = 0;  </span><br><span class="line">    while(j &lt; len)  </span><br><span class="line">    &#123;  </span><br><span class="line">        output[j] = input[i] &amp; 0xFF;    </span><br><span class="line">        output[j+1] = (input[i] &gt;&gt; 8) &amp; 0xFF;  </span><br><span class="line">        output[j+2] = (input[i] &gt;&gt; 16) &amp; 0xFF;  </span><br><span class="line">        output[j+3] = (input[i] &gt;&gt; 24) &amp; 0xFF;  </span><br><span class="line">        i++;  </span><br><span class="line">        j+=4;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">void MD5Decode(unsigned int *output,unsigned char *input,unsigned int len)  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned int i = 0,j = 0;  </span><br><span class="line">    while(j &lt; len)  </span><br><span class="line">    &#123;  </span><br><span class="line">        output[i] = (input[j]) |  </span><br><span class="line">            (input[j+1] &lt;&lt; 8) |  </span><br><span class="line">            (input[j+2] &lt;&lt; 16) |  </span><br><span class="line">            (input[j+3] &lt;&lt; 24);  </span><br><span class="line">        i++;  </span><br><span class="line">        j+=4;   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">void MD5Transform(unsigned int state[4],unsigned char block[64])  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned int a = state[0];  </span><br><span class="line">    unsigned int b = state[1];  </span><br><span class="line">    unsigned int c = state[2];  </span><br><span class="line">    unsigned int d = state[3];  </span><br><span class="line">    unsigned int x[64];  </span><br><span class="line">    MD5Decode(x,block,64);  </span><br><span class="line">    FF(a, b, c, d, x[ 0], 7, 0xd76aa478);   </span><br><span class="line">    FF(d, a, b, c, x[ 1], 12, 0xe8c7b756);   </span><br><span class="line">    FF(c, d, a, b, x[ 2], 17, 0x242070db);   </span><br><span class="line">    FF(b, c, d, a, x[ 3], 22, 0xc1bdceee);   </span><br><span class="line">    FF(a, b, c, d, x[ 4], 7, 0xf57c0faf);   </span><br><span class="line">    FF(d, a, b, c, x[ 5], 12, 0x4787c62a);   </span><br><span class="line">    FF(c, d, a, b, x[ 6], 17, 0xa8304613);   </span><br><span class="line">    FF(b, c, d, a, x[ 7], 22, 0xfd469501);   </span><br><span class="line">    FF(a, b, c, d, x[ 8], 7, 0x698098d8);   </span><br><span class="line">    FF(d, a, b, c, x[ 9], 12, 0x8b44f7af);   </span><br><span class="line">    FF(c, d, a, b, x[10], 17, 0xffff5bb1);   </span><br><span class="line">    FF(b, c, d, a, x[11], 22, 0x895cd7be);   </span><br><span class="line">    FF(a, b, c, d, x[12], 7, 0x6b901122);   </span><br><span class="line">    FF(d, a, b, c, x[13], 12, 0xfd987193);   </span><br><span class="line">    FF(c, d, a, b, x[14], 17, 0xa679438e);   </span><br><span class="line">    FF(b, c, d, a, x[15], 22, 0x49b40821);   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    GG(a, b, c, d, x[ 1], 5, 0xf61e2562);   </span><br><span class="line">    GG(d, a, b, c, x[ 6], 9, 0xc040b340);   </span><br><span class="line">    GG(c, d, a, b, x[11], 14, 0x265e5a51);   </span><br><span class="line">    GG(b, c, d, a, x[ 0], 20, 0xe9b6c7aa);   </span><br><span class="line">    GG(a, b, c, d, x[ 5], 5, 0xd62f105d);   </span><br><span class="line">    GG(d, a, b, c, x[10], 9,  0x2441453);   </span><br><span class="line">    GG(c, d, a, b, x[15], 14, 0xd8a1e681);   </span><br><span class="line">    GG(b, c, d, a, x[ 4], 20, 0xe7d3fbc8);   </span><br><span class="line">    GG(a, b, c, d, x[ 9], 5, 0x21e1cde6);   </span><br><span class="line">    GG(d, a, b, c, x[14], 9, 0xc33707d6);   </span><br><span class="line">    GG(c, d, a, b, x[ 3], 14, 0xf4d50d87);   </span><br><span class="line">    GG(b, c, d, a, x[ 8], 20, 0x455a14ed);   </span><br><span class="line">    GG(a, b, c, d, x[13], 5, 0xa9e3e905);   </span><br><span class="line">    GG(d, a, b, c, x[ 2], 9, 0xfcefa3f8);   </span><br><span class="line">    GG(c, d, a, b, x[ 7], 14, 0x676f02d9);   </span><br><span class="line">    GG(b, c, d, a, x[12], 20, 0x8d2a4c8a);   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    HH(a, b, c, d, x[ 5], 4, 0xfffa3942);   </span><br><span class="line">    HH(d, a, b, c, x[ 8], 11, 0x8771f681);   </span><br><span class="line">    HH(c, d, a, b, x[11], 16, 0x6d9d6122);   </span><br><span class="line">    HH(b, c, d, a, x[14], 23, 0xfde5380c);   </span><br><span class="line">    HH(a, b, c, d, x[ 1], 4, 0xa4beea44);   </span><br><span class="line">    HH(d, a, b, c, x[ 4], 11, 0x4bdecfa9);   </span><br><span class="line">    HH(c, d, a, b, x[ 7], 16, 0xf6bb4b60);   </span><br><span class="line">    HH(b, c, d, a, x[10], 23, 0xbebfbc70);   </span><br><span class="line">    HH(a, b, c, d, x[13], 4, 0x289b7ec6);   </span><br><span class="line">    HH(d, a, b, c, x[ 0], 11, 0xeaa127fa);   </span><br><span class="line">    HH(c, d, a, b, x[ 3], 16, 0xd4ef3085);   </span><br><span class="line">    HH(b, c, d, a, x[ 6], 23,  0x4881d05);   </span><br><span class="line">    HH(a, b, c, d, x[ 9], 4, 0xd9d4d039);   </span><br><span class="line">    HH(d, a, b, c, x[12], 11, 0xe6db99e5);   </span><br><span class="line">    HH(c, d, a, b, x[15], 16, 0x1fa27cf8);   </span><br><span class="line">    HH(b, c, d, a, x[ 2], 23, 0xc4ac5665);   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    II(a, b, c, d, x[ 0], 6, 0xf4292244);   </span><br><span class="line">    II(d, a, b, c, x[ 7], 10, 0x432aff97);   </span><br><span class="line">    II(c, d, a, b, x[14], 15, 0xab9423a7);   </span><br><span class="line">    II(b, c, d, a, x[ 5], 21, 0xfc93a039);   </span><br><span class="line">    II(a, b, c, d, x[12], 6, 0x655b59c3);   </span><br><span class="line">    II(d, a, b, c, x[ 3], 10, 0x8f0ccc92);   </span><br><span class="line">    II(c, d, a, b, x[10], 15, 0xffeff47d);   </span><br><span class="line">    II(b, c, d, a, x[ 1], 21, 0x85845dd1);   </span><br><span class="line">    II(a, b, c, d, x[ 8], 6, 0x6fa87e4f);   </span><br><span class="line">    II(d, a, b, c, x[15], 10, 0xfe2ce6e0);   </span><br><span class="line">    II(c, d, a, b, x[ 6], 15, 0xa3014314);   </span><br><span class="line">    II(b, c, d, a, x[13], 21, 0x4e0811a1);   </span><br><span class="line">    II(a, b, c, d, x[ 4], 6, 0xf7537e82);   </span><br><span class="line">    II(d, a, b, c, x[11], 10, 0xbd3af235);   </span><br><span class="line">    II(c, d, a, b, x[ 2], 15, 0x2ad7d2bb);   </span><br><span class="line">    II(b, c, d, a, x[ 9], 21, 0xeb86d391);   </span><br><span class="line">    state[0] += a;  </span><br><span class="line">    state[1] += b;  </span><br><span class="line">    state[2] += c;  </span><br><span class="line">    state[3] += d;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">void MD5Init(MD5_CTX *context)  </span><br><span class="line">&#123;  </span><br><span class="line">    context-&gt;count[0] = 0;  </span><br><span class="line">    context-&gt;count[1] = 0;  </span><br><span class="line">    context-&gt;state[0] = 0x67452301;  </span><br><span class="line">    context-&gt;state[1] = 0xEFCDAB89;  </span><br><span class="line">    context-&gt;state[2] = 0x98BADCFE;  </span><br><span class="line">    context-&gt;state[3] = 0x10325476;  </span><br><span class="line">&#125;  </span><br><span class="line">void MD5Update(MD5_CTX *context,unsigned char *input,unsigned int inputlen)  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned int i = 0,index = 0,partlen = 0;  </span><br><span class="line">    index = (context-&gt;count[0] &gt;&gt; 3) &amp; 0x3F;  </span><br><span class="line">    partlen = 64 - index;  </span><br><span class="line">    context-&gt;count[0] += inputlen &lt;&lt; 3;  </span><br><span class="line">    if(context-&gt;count[0] &lt; (inputlen &lt;&lt; 3))  </span><br><span class="line">        context-&gt;count[1]++;  </span><br><span class="line">    context-&gt;count[1] += inputlen &gt;&gt; 29;  </span><br><span class="line"></span><br><span class="line">    if(inputlen &gt;= partlen)  </span><br><span class="line">    &#123;  </span><br><span class="line">        memcpy(&amp;context-&gt;buffer[index],input,partlen);  </span><br><span class="line">        MD5Transform(context-&gt;state,context-&gt;buffer);  </span><br><span class="line">        for(i = partlen;i+64 &lt;= inputlen;i+=64)  </span><br><span class="line">            MD5Transform(context-&gt;state,&amp;input[i]);  </span><br><span class="line">        index = 0;          </span><br><span class="line">    &#125;    </span><br><span class="line">    else  </span><br><span class="line">    &#123;  </span><br><span class="line">        i = 0;  </span><br><span class="line">    &#125;  </span><br><span class="line">    memcpy(&amp;context-&gt;buffer[index],&amp;input[i],inputlen-i);  </span><br><span class="line">&#125;  </span><br><span class="line">void MD5Final(MD5_CTX *context,unsigned char digest[16])  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned int index = 0,padlen = 0;  </span><br><span class="line">    unsigned char bits[8];  </span><br><span class="line">    index = (context-&gt;count[0] &gt;&gt; 3) &amp; 0x3F;  </span><br><span class="line">    padlen = (index &lt; 56)?(56-index):(120-index);  </span><br><span class="line">    MD5Encode(bits,context-&gt;count,8);  </span><br><span class="line">    MD5Update(context,PADDING,padlen);  </span><br><span class="line">    MD5Update(context,bits,8);  </span><br><span class="line">    MD5Encode(digest,context-&gt;state,16);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* md5函数测试 */</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">FILE *fp = fopen(&quot;chmod.c&quot;, &quot;r&quot;);</span><br><span class="line">    struct stat st;</span><br><span class="line">    unsigned char digest[16] = &#123;0&#125;;</span><br><span class="line">    MD5_CTX context;</span><br><span class="line">    int i = 0;</span><br><span class="line"></span><br><span class="line">    MD5Init(&amp;context);</span><br><span class="line">if(0 == stat(&quot;chmod.c&quot;, &amp;st))//获取文件信息</span><br><span class="line">    &#123;</span><br><span class="line">/* 计算文件MD5 */</span><br><span class="line">char *data = NULL;</span><br><span class="line">int ret = 0;</span><br><span class="line"></span><br><span class="line">if(!fp)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;fopen&quot;);</span><br><span class="line">exit(-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data = malloc(st.st_size);</span><br><span class="line">if(!data)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;malloc&quot;);</span><br><span class="line">exit(-1);</span><br><span class="line">&#125;</span><br><span class="line">ret = fread(data, 1, st.st_size, fp);</span><br><span class="line">if(ret != st.st_size)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;fread&quot;);</span><br><span class="line">exit(-1);</span><br><span class="line">&#125; </span><br><span class="line">MD5Update(&amp;context, data, st.st_size);</span><br><span class="line">fclose(fp);</span><br><span class="line">free(data);</span><br><span class="line">    &#125;</span><br><span class="line">    MD5Final(&amp;context, digest);</span><br><span class="line"></span><br><span class="line">    /* 打印MD5值 */</span><br><span class="line">    printf(&quot;md5: &quot;);</span><br><span class="line">    for(i = 0; i &lt; 16; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%02x&quot;, digest[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="七、函数方式查看磁盘空间"><a href="#七、函数方式查看磁盘空间" class="headerlink" title="七、函数方式查看磁盘空间"></a>七、函数方式查看磁盘空间</h5><p><strong>编译验证过的源码码</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/statfs.h&gt;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">void get_system_available(unsigned long long *pavailable)</span><br><span class="line">&#123;</span><br><span class="line">struct statfs diskInfo;</span><br><span class="line"></span><br><span class="line">statfs(&quot;/&quot;, &amp;diskInfo);</span><br><span class="line">unsigned long long blocksize = diskInfo.f_bsize;//每个block里包含的字节数</span><br><span class="line">unsigned long long totalsize = blocksize * diskInfo.f_blocks; //总的字节数，f_blocks为block的数目</span><br><span class="line">printf(&quot;Total_size = %llu B = %llu KB = %llu MB = %llu GB\n&quot;, totalsize, totalsize&gt;&gt;10, totalsize&gt;&gt;20, totalsize&gt;&gt;30);</span><br><span class="line"></span><br><span class="line">unsigned long long freeDisk = diskInfo.f_bfree * blocksize;//剩余空间的大小</span><br><span class="line">*pavailable = diskInfo.f_bavail * blocksize; //可用空间大小</span><br><span class="line">printf(&quot;Disk_free = %llu MB = %llu GB\n&quot;, freeDisk&gt;&gt;20, freeDisk&gt;&gt;30);</span><br><span class="line">//printf(&quot;Disk_available = %llu MB = %llu GB\n&quot;, availableDisk&gt;&gt;20, availableDisk&gt;&gt;30);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">unsigned long long available;</span><br><span class="line">get_system_available(&amp;available);</span><br><span class="line">printf(&quot;Disk_available = %llu MB = %llu GB\n&quot;, available&gt;&gt;20, available&gt;&gt;30);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;一、调用system执行shell命令&quot;&gt;&lt;a href=&quot;#一、调用system执行shell命令&quot; class=&quot;headerlink&quot; title=&quot;一、调用system执行shell命令&quot;&gt;&lt;/a&gt;一、调用system执行shell命令&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;编译验证过的源码码&lt;/strong&gt;：&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://www.faihung.net/categories/C/"/>
    
    
      <category term="system" scheme="http://www.faihung.net/tags/system/"/>
    
      <category term="popen" scheme="http://www.faihung.net/tags/popen/"/>
    
      <category term="remove" scheme="http://www.faihung.net/tags/remove/"/>
    
      <category term="dirent" scheme="http://www.faihung.net/tags/dirent/"/>
    
      <category term="chmod" scheme="http://www.faihung.net/tags/chmod/"/>
    
      <category term="MD5" scheme="http://www.faihung.net/tags/MD5/"/>
    
      <category term="statfs" scheme="http://www.faihung.net/tags/statfs/"/>
    
  </entry>
  
  <entry>
    <title>Git-02_gitlab的配置与准备工作</title>
    <link href="http://www.faihung.net/2020/01/01/Git-02-gitlab%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"/>
    <id>http://www.faihung.net/2020/01/01/Git-02-gitlab的配置与准备工作/</id>
    <published>2020-01-01T15:44:57.000Z</published>
    <updated>2020-01-01T16:01:02.388Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前面简单介绍了Web端gitlab的一些基本信息，这里主要介绍gitlab 一些配置和准备工作。</p></blockquote><h5 id="1-修改密码和邮箱"><a href="#1-修改密码和邮箱" class="headerlink" title="1.修改密码和邮箱"></a>1.修改密码和邮箱</h5><p>略</p><h5 id="2-配置SSH-Keys"><a href="#2-配置SSH-Keys" class="headerlink" title="2.配置SSH Keys"></a>2.配置SSH Keys</h5><p>前面Web端介绍时提到了SSH Keys的设置（见web端界面2.12账户设置）。<br>在往前我们建立一个新项目的时候也看到了一个SSH协议（见Web界面2.2.1点击按钮“New project”建立一个新项目，那里还有一个http协议，http协议不需要配置，但是push代码比较慢）。<br>都有提到关于SSH，这是因为我们git仓库和Gitlab仓库之间是通过SSH加密的，所以需要进行相应的配置。</p><a id="more"></a><h6 id="第1步：创建SSH-Key"><a href="#第1步：创建SSH-Key" class="headerlink" title="第1步：创建SSH Key"></a>第1步：创建SSH Key</h6><p>在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：<br>ssh-keygen -t rsa -C <a href="mailto:email@example.com" target="_blank" rel="noopener">email@example.com</a><br>之后一路回车，使用默认值，就可以获得一个Key值。一切顺利可以在用户主目录下面找到.ssh文件夹，可以看到里面有两个文件id_rsa和id_rsa.pub。其中id_rsa是私钥，id_rsa.pub是公钥。</p><p>如图：<br><img src="/2020/01/01/Git-02-gitlab%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/1.png" alt="1"></p><h6 id="第2步：登陆GitLab，打开账户设置，“SSH-Keys”页面："><a href="#第2步：登陆GitLab，打开账户设置，“SSH-Keys”页面：" class="headerlink" title="第2步：登陆GitLab，打开账户设置，“SSH Keys”页面："></a>第2步：登陆GitLab，打开账户设置，“SSH Keys”页面：</h6><p><img src="/2020/01/01/Git-02-gitlab%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/2.png" alt="2"></p><p><img src="/2020/01/01/Git-02-gitlab%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/3.png" alt="3"><br>这样就成功添加了。<br>其实在前面创建项目的时候提示这个，就表示要添加SSH Keys了。<br><img src="/2020/01/01/Git-02-gitlab%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/4.png" alt="4"></p><h5 id="3-安装Git"><a href="#3-安装Git" class="headerlink" title="3.安装Git"></a>3.安装Git</h5><p>Windows端需要下载一个git 客户端工具GitHubDesktopSetup.exe，这里主要是以Linux为主。<br>执行命令：</p><pre><code>sudo apt install git</code></pre><p>然后直接安装即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前面简单介绍了Web端gitlab的一些基本信息，这里主要介绍gitlab 一些配置和准备工作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;1-修改密码和邮箱&quot;&gt;&lt;a href=&quot;#1-修改密码和邮箱&quot; class=&quot;headerlink&quot; title=&quot;1.修改密码和邮箱&quot;&gt;&lt;/a&gt;1.修改密码和邮箱&lt;/h5&gt;&lt;p&gt;略&lt;/p&gt;
&lt;h5 id=&quot;2-配置SSH-Keys&quot;&gt;&lt;a href=&quot;#2-配置SSH-Keys&quot; class=&quot;headerlink&quot; title=&quot;2.配置SSH Keys&quot;&gt;&lt;/a&gt;2.配置SSH Keys&lt;/h5&gt;&lt;p&gt;前面Web端介绍时提到了SSH Keys的设置（见web端界面2.12账户设置）。&lt;br&gt;在往前我们建立一个新项目的时候也看到了一个SSH协议（见Web界面2.2.1点击按钮“New project”建立一个新项目，那里还有一个http协议，http协议不需要配置，但是push代码比较慢）。&lt;br&gt;都有提到关于SSH，这是因为我们git仓库和Gitlab仓库之间是通过SSH加密的，所以需要进行相应的配置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://www.faihung.net/categories/Git/"/>
    
    
      <category term="gitlab" scheme="http://www.faihung.net/tags/gitlab/"/>
    
      <category term="github" scheme="http://www.faihung.net/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Git-01_gitlab的Web端界面</title>
    <link href="http://www.faihung.net/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/"/>
    <id>http://www.faihung.net/2019/12/30/Git-01-gitlab的Web端界面/</id>
    <published>2019-12-30T15:42:15.000Z</published>
    <updated>2020-01-01T16:00:07.174Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、gitlab的登录"><a href="#一、gitlab的登录" class="headerlink" title="一、gitlab的登录"></a>一、gitlab的登录</h4><p>Web网页输入：<a href="http://xxx.wicp.vip/" target="_blank" rel="noopener">http://xxx.wicp.vip/</a> 进入gitlab登录界面，输入账号密码之后，选择 standard登录，进入Web页面。不同权限的人进入的界面是不一样的。<br>如下：<br><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/1.png" alt="1"></p><a id="more"></a><h4 id="二、gitlab-Web端的介绍"><a href="#二、gitlab-Web端的介绍" class="headerlink" title="二、gitlab Web端的介绍"></a>二、gitlab Web端的介绍</h4><p>点击Web端菜单栏上标签按钮，可以进入不同的功能任务主窗口。</p><h5 id="2-1-gitlab-一个logo标志-，进入或者恢复初始界面。"><a href="#2-1-gitlab-一个logo标志-，进入或者恢复初始界面。" class="headerlink" title="2.1 gitlab(一个logo标志)，进入或者恢复初始界面。"></a>2.1 gitlab(一个logo标志)，进入或者恢复初始界面。</h5><h5 id="2-2-Project，根据下拉列表或者Project标签页中的Tab列表选择同类型的项目。如下图"><a href="#2-2-Project，根据下拉列表或者Project标签页中的Tab列表选择同类型的项目。如下图" class="headerlink" title="2.2 Project，根据下拉列表或者Project标签页中的Tab列表选择同类型的项目。如下图"></a>2.2 Project，根据下拉列表或者Project标签页中的Tab列表选择同类型的项目。如下图</h5><p><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/2.png" alt="2"><br><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/3.png" alt="3"></p><h6 id="2-2-1点击按钮“New-project”建立项目"><a href="#2-2-1点击按钮“New-project”建立项目" class="headerlink" title="2.2.1点击按钮“New project”建立项目"></a>2.2.1点击按钮“New project”建立项目</h6><p><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/4.png" alt="4"><br>可以看到主窗口中有三个待选标签页：Blank project、Create from template、 Import project分别表示不同project的创建方式，一般我们用第一种。</p><p>根据项目Group的下拉菜单，选择beacom_firmware开发小组，输入项目名名称test，添加项目描述信息。</p><p>最后选择Visibility Level 的权限(可以选上README文件，最后会生成一个README文件)，点击按钮“Create project”就在这个开发小组中可以建立一个项目了。<br>如下图：<br><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/5.png" alt="5"></p><p>注意: </p><ol><li>点击按钮“clone”弹出一个对话框，上面有关于SSH和HTTP方式的链接，后续会有介绍。</li><li>每建立一个project 都会有这样一个命令：Command line instructions，这个是让我我们上传代码的命令，后面所有的操作基本上都是围绕这几步来，一般我们用这个命令：Create a new repository，后续会有介绍。</li></ol><h6 id="2-2-2回到刚才的Project-gt-Your-project-页面中可以看到新建的子项目xxx-firmware-test，以后开发就可以从这里进入"><a href="#2-2-2回到刚才的Project-gt-Your-project-页面中可以看到新建的子项目xxx-firmware-test，以后开发就可以从这里进入" class="headerlink" title="2.2.2回到刚才的Project-&gt;Your project 页面中可以看到新建的子项目xxx_firmware/test，以后开发就可以从这里进入"></a>2.2.2回到刚才的Project-&gt;Your project 页面中可以看到新建的子项目xxx_firmware/test，以后开发就可以从这里进入</h6><h5 id="2-3-Group-根据顶级菜单的下拉列表或者是子菜单的Tab列表都可以进如到不同的开发小组中去。"><a href="#2-3-Group-根据顶级菜单的下拉列表或者是子菜单的Tab列表都可以进如到不同的开发小组中去。" class="headerlink" title="2.3 Group,根据顶级菜单的下拉列表或者是子菜单的Tab列表都可以进如到不同的开发小组中去。"></a>2.3 Group,根据顶级菜单的下拉列表或者是子菜单的Tab列表都可以进如到不同的开发小组中去。</h5><p>以XXX_firmware开发小组为例，可以看到左边的的功能菜单上有：<br><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/6.png" alt="6"></p><h6 id="2-3-1-Owerview"><a href="#2-3-1-Owerview" class="headerlink" title="2.3.1 Owerview"></a>2.3.1 Owerview</h6><p>是一些项目细节或者是开发人员的活跃记录，如上图和下图所示。<br><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/7.png" alt="7"></p><h6 id="2-3-2-Issues"><a href="#2-3-2-Issues" class="headerlink" title="2.3.2 Issues"></a>2.3.2 Issues</h6><p>在这里这个项目组成员可以提交一些问题，大家相互交流，项目开发进度等等，代码发布版本都可以在这里做记录，这里没做研究。</p><h6 id="2-3-3-Merge-Requests"><a href="#2-3-3-Merge-Requests" class="headerlink" title="2.3.3 Merge Requests"></a>2.3.3 Merge Requests</h6><p>主要是别人提交代码请求合并的记录</p><h6 id="2-3-4-Kubernetes"><a href="#2-3-4-Kubernetes" class="headerlink" title="2.3.4 Kubernetes"></a>2.3.4 Kubernetes</h6><p>略</p><h6 id="2-3-5-Members"><a href="#2-3-5-Members" class="headerlink" title="2.3.5 Members"></a>2.3.5 Members</h6><p>这里有开发人员的相关信息，包括各级权限。</p><h5 id="2-4-Activity"><a href="#2-4-Activity" class="headerlink" title="2.4 Activity"></a>2.4 Activity</h5><p>不同人员各种代码提交、活跃记录都在上面。</p><h5 id="2-5-Milestones"><a href="#2-5-Milestones" class="headerlink" title="2.5 Milestones"></a>2.5 Milestones</h5><p>同2.3.2Issues中的milestones,就是项目开发达到某一个程度，比如可以发布的一个版本。（后面给代码打标签设置版本号还会提到如：git tag v1.0）</p><h5 id="2-6-Snippet"><a href="#2-6-Snippet" class="headerlink" title="2.6 Snippet"></a>2.6 Snippet</h5><p>个人的一些工作中的Idea启发,都可以记录在这里，有权限设置，相当于个人blog。</p><h5 id="2-7-“-”"><a href="#2-7-“-”" class="headerlink" title="2.7 “+”"></a>2.7 “+”</h5><p>根据下拉列表看到New Project、New group、New snippet，这个前面都有相关介绍。</p><h5 id="2-8-Issues"><a href="#2-8-Issues" class="headerlink" title="2.8 Issues"></a>2.8 Issues</h5><p>同2.3.2 Issues</p><h5 id="2-9-Merge-Requests"><a href="#2-9-Merge-Requests" class="headerlink" title="2.9 Merge Requests"></a>2.9 Merge Requests</h5><p>同2.3.3 Merge Requests</p><h5 id="2-9-Todos"><a href="#2-9-Todos" class="headerlink" title="2.9 Todos"></a>2.9 Todos</h5><p>接下来要做的事情，同2.3.2 Issues</p><h5 id="2-10？"><a href="#2-10？" class="headerlink" title="2.10？"></a>2.10？</h5><p>一款工具不能少的，常见帮助信息。</p><h5 id="2-11-账户设置"><a href="#2-11-账户设置" class="headerlink" title="2.11 账户设置"></a>2.11 账户设置</h5><p>选择账户中下拉列表Setings进入账户设置。如下图</p><p><img src="/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/8.png" alt="8"></p><p>这里主要是一些个人信息的设置，比如修改账户密码、邮箱等。还有一个重要的操作修改添加SSH Keys后面会有介绍。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、gitlab的登录&quot;&gt;&lt;a href=&quot;#一、gitlab的登录&quot; class=&quot;headerlink&quot; title=&quot;一、gitlab的登录&quot;&gt;&lt;/a&gt;一、gitlab的登录&lt;/h4&gt;&lt;p&gt;Web网页输入：&lt;a href=&quot;http://xxx.wicp.vip/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://xxx.wicp.vip/&lt;/a&gt; 进入gitlab登录界面，输入账号密码之后，选择 standard登录，进入Web页面。不同权限的人进入的界面是不一样的。&lt;br&gt;如下：&lt;br&gt;&lt;img src=&quot;/2019/12/30/Git-01-gitlab%E7%9A%84Web%E7%AB%AF%E7%95%8C%E9%9D%A2/1.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://www.faihung.net/categories/Git/"/>
    
    
      <category term="gitlab" scheme="http://www.faihung.net/tags/gitlab/"/>
    
      <category term="github" scheme="http://www.faihung.net/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>系统函数&amp;库函数-Linux中的popen函数和system函数(转)</title>
    <link href="http://www.faihung.net/2019/12/22/%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0-%E5%BA%93%E5%87%BD%E6%95%B0-Linux%E4%B8%AD%E7%9A%84popen%E5%87%BD%E6%95%B0%E5%92%8Csystem%E5%87%BD%E6%95%B0-%E8%BD%AC/"/>
    <id>http://www.faihung.net/2019/12/22/系统函数-库函数-Linux中的popen函数和system函数-转/</id>
    <published>2019-12-22T15:57:19.000Z</published>
    <updated>2019-12-22T16:05:12.314Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>说在前面，在实际编程中尽量减少使用system函数。</p></blockquote><h5 id="int-system-const-char-command"><a href="#int-system-const-char-command" class="headerlink" title="int system(const char *command);"></a>int system(const char *command);</h5><h6 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h6><p>system()通过调用/bin/sh -c命令执行命令中指定的命令，并在命令完成后返回。在执行该命令期间，SIGCHLD将被阻塞，并且SIGINT和SIGQUIT将被忽略。</p><a id="more"></a><h6 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h6><p>实际上system调用了三个函数：fork()、exec()、waitpid()。因此有三种返回值：</p><ol><li>fork()失败或者waitpid()返回除了EINTR之外的出错，则system返回-1.而且errno中设置了错误类型值。</li><li>如果exec失败（表示不能执行shell），则其返回值如同shell执行了exit（127）一样</li><li>如果三个函数都执行成功，并且system的返回值是shell的终止状态，其格式已在已在waitpid中说明。</li></ol><h6 id="system的实现："><a href="#system的实现：" class="headerlink" title="system的实现："></a>system的实现：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int system(const char * cmdstring)  </span><br><span class="line">&#123;   </span><br><span class="line">  pid_t pid;   </span><br><span class="line">  int status;   </span><br><span class="line">  if(cmdstring == NULL)  </span><br><span class="line">    &#123;   </span><br><span class="line">      return (1);   </span><br><span class="line">    &#125;   </span><br><span class="line">  if((pid = fork())&lt;0)  </span><br><span class="line">    &#123;   </span><br><span class="line">      status = -1;   </span><br><span class="line">    &#125;   </span><br><span class="line">  else if(pid = 0)  </span><br><span class="line">    &#123;  </span><br><span class="line">       execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-c&quot;, cmdstring, (char *)0); -exit(127); //子进程正常执行则不会执行此语句 &#125;   </span><br><span class="line">  else  </span><br><span class="line">    &#123;   </span><br><span class="line">       while(waitpid(pid, &amp;status, 0) &lt; 0)  </span><br><span class="line">    &#123;  </span><br><span class="line">  if(errno != EINTER)&#123; status = -1; break;   </span><br><span class="line">    &#125;   </span><br><span class="line">   &#125;  </span><br><span class="line">  &#125;   </span><br><span class="line">  return status;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="简单的使用："><a href="#简单的使用：" class="headerlink" title="简单的使用："></a>简单的使用：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int status = 0;</span><br><span class="line">  status = system(&quot;ls -a&quot;);</span><br><span class="line">  if(-1 == status)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(&quot;system&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  if(WIFEXITED(status) != 0)  //正常退出</span><br><span class="line">  &#123;</span><br><span class="line">    if(WEXITSTATUS(status) == 0)  //操作正确</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;run command success\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;run error\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else      //异常退出</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;exit error is %d\n&quot;, WEXITSTATUS(status));</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以看到，system在使用时的一个弊端，由于返回值太多，要安全的使用它就要进行许多步的出错处理。</p><p>所以，不太建议使用system。</p><h6 id="使用system需要注意："><a href="#使用system需要注意：" class="headerlink" title="使用system需要注意："></a>使用system需要注意：</h6><p>1.建议system()函数只用来执行shell命令，因为一般来讲，system()返回值不是0就说明出错了； </p><p>2.监控一下system()函数的执行完毕后的errno值，争取出错时给出更多有用信息； </p><h5 id="建议使用popen函数取代system"><a href="#建议使用popen函数取代system" class="headerlink" title="建议使用popen函数取代system();"></a>建议使用popen函数取代system();</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *popen(const char *command, const char *type);</span><br><span class="line">int pclose(FILE *stream);返回值： command的终止状态， 出错返回-1</span><br></pre></td></tr></table></figure><h6 id="popen-函数较于system-函数的优势在于使用简单，popen-函数只返回两个值："><a href="#popen-函数较于system-函数的优势在于使用简单，popen-函数只返回两个值：" class="headerlink" title="popen()函数较于system()函数的优势在于使用简单，popen()函数只返回两个值："></a>popen()函数较于system()函数的优势在于使用简单，popen()函数只返回两个值：</h6><p>成功返回子进程的status，使用WIFEXITED相关宏就可以取得command的返回结果；</p><p>失败返回-1，我们可以使用perro()函数或strerror()函数得到有用的错误信息。</p><p>popen先执行fork，然后调用exec以执行command并返回一个标准I/O文件指针。如果type是“r”，则文件指针链接到command的标准输出。如果type是“w”,则文件指针链接到command的标准输入。将popen和fopen进行类比，方便记忆其最后一个参数及其作用，如果type是“r”，则返回文件指针是刻度的，如果type是是“w”，则是可写的。</p><p><img src="/2019/12/22/%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0-%E5%BA%93%E5%87%BD%E6%95%B0-Linux%E4%B8%AD%E7%9A%84popen%E5%87%BD%E6%95%B0%E5%92%8Csystem%E5%87%BD%E6%95%B0-%E8%BD%AC/1.png" alt="1"></p><p>简单使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  FILE* fp = NULL;</span><br><span class="line">  char buf[1024] = &#123;0&#125;;</span><br><span class="line">  fp = popen(&quot;ls -a&quot;, &quot;r&quot;);</span><br><span class="line">  if(NULL == fp)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(&quot;popen&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  while(fgets(buf, 1024, fp) != NULL)</span><br><span class="line">  &#123;</span><br><span class="line">   fprintf(stdout, &quot;%s&quot;, buf); </span><br><span class="line">  &#125;</span><br><span class="line">  pclose(fp);</span><br><span class="line"> </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，popen绝不应该由设置用户ID或设置组ID程序调用。当它执行命令</p><p>popen等同于execl(“/bin/sh”, “sh”, “-c”, command ,NULL);</p><p>它在从调用者继承的环境中执行shell，并由shell解释执行command。一个心怀不轨的用户可以操纵这种环境，使得shell能以设置ID文件模式所授予的提升了的权限以及非预期的方式执行命令。</p><p>popen特别适用于构造简单的过滤程序，它变换运行命令的输入或输出。</p><p>当命令希望构建自己的管道线时就是这种情形。</p><blockquote><p>借楼发个问题：在多次调用system和popen（中间没有做delay处理）后，再次调用是直接fp返回空或system返回无此目录或文件。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;说在前面，在实际编程中尽量减少使用system函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;int-system-const-char-command&quot;&gt;&lt;a href=&quot;#int-system-const-char-command&quot; class=&quot;headerlink&quot; title=&quot;int system(const char *command);&quot;&gt;&lt;/a&gt;int system(const char *command);&lt;/h5&gt;&lt;h6 id=&quot;说明：&quot;&gt;&lt;a href=&quot;#说明：&quot; class=&quot;headerlink&quot; title=&quot;说明：&quot;&gt;&lt;/a&gt;说明：&lt;/h6&gt;&lt;p&gt;system()通过调用/bin/sh -c命令执行命令中指定的命令，并在命令完成后返回。在执行该命令期间，SIGCHLD将被阻塞，并且SIGINT和SIGQUIT将被忽略。&lt;/p&gt;
    
    </summary>
    
    
      <category term="系统函数&amp;库函数" scheme="http://www.faihung.net/categories/%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0-%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="system" scheme="http://www.faihung.net/tags/system/"/>
    
      <category term="popen" scheme="http://www.faihung.net/tags/popen/"/>
    
  </entry>
  
  <entry>
    <title>系统函数&amp;库函数-popen 的使用方法及场景(转)</title>
    <link href="http://www.faihung.net/2019/12/22/%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0-%E5%BA%93%E5%87%BD%E6%95%B0-popen-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%8F%8A%E5%9C%BA%E6%99%AF-%E8%BD%AC/"/>
    <id>http://www.faihung.net/2019/12/22/系统函数-库函数-popen-的使用方法及场景-转/</id>
    <published>2019-12-22T15:56:46.000Z</published>
    <updated>2019-12-22T16:02:47.363Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-Popen的应用场景"><a href="#1-Popen的应用场景" class="headerlink" title="1.Popen的应用场景"></a>1.Popen的应用场景</h5><p>popen应用于执行shell命令，并读取此命令的返值，或者与执行的命令进行交互。</p><a id="more"></a><h5 id="2-Popen的实现"><a href="#2-Popen的实现" class="headerlink" title="2.Popen的实现"></a>2.Popen的实现</h5><p>popen()函数通过创建一个管道，调用fork()产生一个子进程，执行一个shell以运行命令来开启一个进程。可以通过这个管道执行标准输入输出操作。这个管道必须由pclose()函数关闭，必须由pclose()函数关闭，必须由pclose()函数关闭，而不是fclose()函数（若使用fclose则会产生僵尸进程）。pclose()函数关闭标准I/O流，等待命令执行结束，然后返回shell的终止状态。如果shell不能被执行，则pclose()返回的终止状态与shell已执行exit一样。</p><p>type参数只能是读或者写中的一种，得到的返回值（标准I/O流）也具有和type相应的只读或只写类型。如果type是”r”则文件指针连接到command的标准输出；如果type是”w”则文件指针连接到command的标准输入。</p><p>command参数是一个指向以NULL结束的shell命令字符串的指针。这行命令将被传到bin/sh并使用-c标志，shell将执行这个命令。</p><p>popen()的返回值是个标准I/O流，必须由pclose来终止。前面提到这个流是单向的（只能用于读或写）。向这个流写内容相当于写入该命令的标准输入，命令的标准输出和调用popen()的进程相同；与之相反的，从流中读数据相当于读取命令的标准输出，命令的标准输入和调用popen()的进程相同。</p><p><strong>返回值</strong></p><p>如果调用fork()或pipe()失败，或者不能分配内存将返回NULL，否则返回标准I/O流。popen()没有为内存分配失败设置errno值。如果调用fork()或pipe()时出现错误，errno被设为相应的错误类型。如果type参数不合法，errno将返回EINVAL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *popen(const char *command, const char *type);</span><br><span class="line">int pclose(FILE *stream);</span><br></pre></td></tr></table></figure><h5 id="3-Pclose操作"><a href="#3-Pclose操作" class="headerlink" title="3.Pclose操作"></a>3.Pclose操作</h5><p>Pclose()函数会闭标准i/0流，等待子进程结束，然后返回shell终止状态。如果不执行，则pclose()返回终止状态就是shell的exit状态。</p><p><strong>源码附上：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line">/* Copyright (C) 2004       Manuel Novoa III    &lt;mjn3@codepoet.org&gt;</span><br><span class="line"> * Copyright (C) 2000-2006 Erik Andersen &lt;andersen@uclibc.org&gt;</span><br><span class="line"> *</span><br><span class="line"> * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.</span><br><span class="line"> *</span><br><span class="line"> * Dedicated to Toni.  See uClibc/DEDICATION.mjn3 for details.</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/* Jan 1, 2004</span><br><span class="line"> *</span><br><span class="line"> * Rewrite popen for SUSv3 compliance.</span><br><span class="line"> *   Added a list of popen()&apos;d to store pids and use waitpid() in pclose().</span><br><span class="line"> *   Loop on waitpid() failure due to EINTR as required.</span><br><span class="line"> *   Close parent&apos;s popen()&apos;d FILEs in the &#123;v&#125;fork()&apos;d child.</span><br><span class="line"> *   Fix failure exit code for failed execve().</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;bits/uClibc_mutex.h&gt;</span><br><span class="line"> </span><br><span class="line">#ifdef __UCLIBC_MJN3_ONLY__</span><br><span class="line">#warning &quot;hmm... susv3 says Pipe streams are byte-oriented.&quot;</span><br><span class="line">#endif /* __UCLIBC_MJN3_ONLY__ */</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/* uClinux-2.0 has vfork, but Linux 2.0 doesn&apos;t */</span><br><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line">#if ! defined __NR_vfork</span><br><span class="line"># define vfork fork</span><br><span class="line"># define VFORK_LOCK((void) 0)</span><br><span class="line"># define VFORK_UNLOCK((void) 0)</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">#ifndef VFORK_LOCK</span><br><span class="line">__UCLIBC_MUTEX_STATIC(mylock, PTHREAD_MUTEX_INITIALIZER);</span><br><span class="line"># define VFORK_LOCK__UCLIBC_MUTEX_LOCK(mylock)</span><br><span class="line"># define VFORK_UNLOCK__UCLIBC_MUTEX_UNLOCK(mylock)</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">struct popen_list_item &#123;</span><br><span class="line">struct popen_list_item *next;</span><br><span class="line">FILE *f;</span><br><span class="line">pid_t pid;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">static struct popen_list_item *popen_list /* = NULL (bss initialized) */;</span><br><span class="line"> </span><br><span class="line">FILE *popen(const char *command, const char *modes)</span><br><span class="line">&#123;</span><br><span class="line">FILE *fp;</span><br><span class="line">struct popen_list_item *pi;</span><br><span class="line">struct popen_list_item *po;</span><br><span class="line">int pipe_fd[2];</span><br><span class="line">int parent_fd;</span><br><span class="line">int child_fd;</span><br><span class="line">int child_writing;/* Doubles as the desired child fildes. */</span><br><span class="line">pid_t pid;</span><br><span class="line"> </span><br><span class="line">child_writing = 0;/* Assume child is writing. */</span><br><span class="line">if (modes[0] != &apos;w&apos;) &#123;/* Parent not writing... */</span><br><span class="line">++child_writing;/* so child must be writing. */</span><br><span class="line">if (modes[0] != &apos;r&apos;) &#123;/* Oops!  Parent not reading either! */</span><br><span class="line">__set_errno(EINVAL);</span><br><span class="line">goto RET_NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">if (!(pi = malloc(sizeof(struct popen_list_item)))) &#123;</span><br><span class="line">goto RET_NULL;</span><br><span class="line">&#125;</span><br><span class="line">// 打开一个pipe，管道是单向。故数据流只能单向流动。</span><br><span class="line">if (pipe(pipe_fd)) &#123;</span><br><span class="line">goto FREE_PI;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//下面两个描述符就是管道的两端的描述，一个为读一个为写。</span><br><span class="line">child_fd = pipe_fd[child_writing]; </span><br><span class="line">parent_fd = pipe_fd[1-child_writing]; </span><br><span class="line">//fdopen就是打开一个描述，fd相同模式或者字集的方式打开。意思就是把一个已找打开的流与一个文件描述符相关联，且</span><br><span class="line">//这个文件描述是唯一的，这样也就可以保证这个函数接口的可重入性。如果设计的不可重入性，也就没必要再做一次fdopen了。</span><br><span class="line">if (!(fp = fdopen(parent_fd, modes))) &#123;</span><br><span class="line">close(parent_fd);</span><br><span class="line">close(child_fd);</span><br><span class="line">goto FREE_PI;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">VFORK_LOCK;</span><br><span class="line">//再这里创建一个子进程，然后执行 shell命令。这里最重的两步就是用pipe的两个描述替换标准输入或者输出。</span><br><span class="line">if ((pid = vfork()) == 0) &#123;/* Child of vfork... */</span><br><span class="line">close(parent_fd);</span><br><span class="line">if (child_fd != child_writing) &#123;</span><br><span class="line">dup2(child_fd, child_writing); //用child_fd来代替标准输入或输出。</span><br><span class="line">close(child_fd);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* SUSv3 requires that any previously popen()&apos;d streams in the</span><br><span class="line"> * parent shall be closed in the child. */</span><br><span class="line">//关闭不必要的资源。</span><br><span class="line">for (po = popen_list ; po ; po = po-&gt;next) &#123;</span><br><span class="line">close(po-&gt;f-&gt;__filedes);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//执行exec shell,这个时候标准输入/输出就变为pipe管道的一端了。</span><br><span class="line">//这里只能实现单向的功能。要么读要么写。</span><br><span class="line">execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-c&quot;, command, (char *)0);</span><br><span class="line"> </span><br><span class="line">/* SUSv3 mandates an exit code of 127 for the child if the</span><br><span class="line"> * command interpreter can not be invoked. */</span><br><span class="line">_exit(127);</span><br><span class="line">&#125;</span><br><span class="line">VFORK_UNLOCK;</span><br><span class="line"> </span><br><span class="line">/* We need to close the child filedes whether vfork failed or</span><br><span class="line"> * it succeeded and we&apos;re in the parent. */</span><br><span class="line">close(child_fd);</span><br><span class="line">//将当前的信息保存到全局链表。为了是pclose可以找到对的子进程与通信文件描述。</span><br><span class="line">if (pid &gt; 0) &#123;/* Parent of vfork... */</span><br><span class="line">pi-&gt;pid = pid;</span><br><span class="line">pi-&gt;f = fp;</span><br><span class="line">VFORK_LOCK;</span><br><span class="line">pi-&gt;next = popen_list;</span><br><span class="line">popen_list = pi;</span><br><span class="line">VFORK_UNLOCK;</span><br><span class="line"> </span><br><span class="line">return fp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* If we get here, vfork failed. */</span><br><span class="line">fclose(fp);/* Will close parent_fd. */</span><br><span class="line"> </span><br><span class="line"> FREE_PI:</span><br><span class="line">free(pi);</span><br><span class="line"> </span><br><span class="line"> RET_NULL:</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#warning is pclose correct wrt the new mutex semantics?</span><br><span class="line"> </span><br><span class="line">int pclose(FILE *stream)</span><br><span class="line">&#123;</span><br><span class="line">struct popen_list_item *p;</span><br><span class="line">int stat;</span><br><span class="line">pid_t pid;</span><br><span class="line"> </span><br><span class="line">/* First, find the list entry corresponding to stream and remove it</span><br><span class="line"> * from the list.  Set p to the list item (NULL if not found). */</span><br><span class="line">VFORK_LOCK;</span><br><span class="line">if ((p = popen_list) != NULL) &#123;</span><br><span class="line">if (p-&gt;f == stream) &#123;// 找到stream对应的popen结点。</span><br><span class="line">popen_list = p-&gt;next;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">struct popen_list_item *t;</span><br><span class="line">do &#123;</span><br><span class="line">t = p;</span><br><span class="line">if (!(p = t-&gt;next)) &#123;</span><br><span class="line">__set_errno(EINVAL); /* Not required by SUSv3. */</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if (p-&gt;f == stream) &#123;</span><br><span class="line">t-&gt;next = p-&gt;next;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125; while (1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">VFORK_UNLOCK;</span><br><span class="line"> </span><br><span class="line">if (p) &#123;</span><br><span class="line">pid = p-&gt;pid;/* Save the pid we need */</span><br><span class="line">free(p);/* and free the list item. */</span><br><span class="line"> </span><br><span class="line">fclose(stream);/* The SUSv3 example code ignores the return. */</span><br><span class="line"> </span><br><span class="line">/* SUSv3 specificly requires that pclose not return before the child</span><br><span class="line"> * terminates, in order to disallow pclose from returning on EINTR. */</span><br><span class="line">do &#123;</span><br><span class="line">if (waitpid(pid, &amp;stat, 0) &gt;= 0) &#123; //等待子进程返回。获取返回值。</span><br><span class="line">return stat;</span><br><span class="line">&#125;</span><br><span class="line">if (errno != EINTR) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125; while (1);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>举例附上：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">FILE *fp = NULL;</span><br><span class="line">char buf[1024] = &quot;&quot;;</span><br><span class="line"> </span><br><span class="line">fp = popen(&quot;ls -al&quot;, &quot;r&quot;);</span><br><span class="line">if(fp == NULL)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;popen error\n&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">while(fgets(buf, sizeof(buf), fp) != 0)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%s\n&quot;, buf);</span><br><span class="line">memset(buf, 0x0, sizeof(buf));</span><br><span class="line">&#125;</span><br><span class="line">pclose(fp);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;1-Popen的应用场景&quot;&gt;&lt;a href=&quot;#1-Popen的应用场景&quot; class=&quot;headerlink&quot; title=&quot;1.Popen的应用场景&quot;&gt;&lt;/a&gt;1.Popen的应用场景&lt;/h5&gt;&lt;p&gt;popen应用于执行shell命令，并读取此命令的返值，或者与执行的命令进行交互。&lt;/p&gt;
    
    </summary>
    
    
      <category term="系统函数&amp;库函数" scheme="http://www.faihung.net/categories/%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0-%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="popen" scheme="http://www.faihung.net/tags/popen/"/>
    
  </entry>
  
  <entry>
    <title>C语言-函数返回局部变量的几种方式</title>
    <link href="http://www.faihung.net/2019/12/15/C%E8%AF%AD%E8%A8%80-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.faihung.net/2019/12/15/C语言-函数返回局部变量的几种方式/</id>
    <published>2019-12-15T04:46:13.000Z</published>
    <updated>2019-12-18T10:53:21.032Z</updated>
    
    <content type="html"><![CDATA[<p>一般的来说，函数是可以返回局部变量的。</p><p>局部变量的作用域只在函数内部，在函数返回后，局部变量的内存已经释放了。</p><p>因此，如果函数返回的是局部变量的值，不涉及地址，程序不会出错。</p><p>但是如果返回的是局部变量的地址(指针)的话，程序运行后会出错。</p><p>因为函数只是把指针复制后返回了，但是指针指向的内容已经被释放了，这样指针指向的内容就是不可预料的内容，调用就会出错。</p><p>准确的来说，函数不能通过返回指向栈内存的指针(注意这里指的是栈，返回指向堆内存的指针是可以的)。</p><a id="more"></a><p>下面以函数返回局部变量的指针举几个典型的例子来说明：</p><h5 id="1-字符串常量’hello-world’，存放在只读数据段"><a href="#1-字符串常量’hello-world’，存放在只读数据段" class="headerlink" title="1. 字符串常量’hello world’，存放在只读数据段"></a>1. 字符串常量’hello world’，存放在只读数据段</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;   </span><br><span class="line">char *returnStr()   </span><br><span class="line">&#123;   </span><br><span class="line">    char *p=&quot;hello world!&quot;;   </span><br><span class="line">    return p;   </span><br><span class="line">&#125;   </span><br><span class="line">int main()   </span><br><span class="line">&#123;   </span><br><span class="line">    char *str;   </span><br><span class="line">    str=returnStr();   </span><br><span class="line">    printf(&quot;%s\n&quot;, str);   </span><br><span class="line">    return 0;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个没有任何问题，因为”hello world!”是一个字符串常量，存放在只读数据段，把该字符串常量存放的只读数据段的首地址赋值给了指针，所以returnStr函数退出时，该该字符串常量所在内存不会被回收，故能够通过指针顺利无误的访问。</p><h5 id="2-局部变量’hello-world’存放在栈中"><a href="#2-局部变量’hello-world’存放在栈中" class="headerlink" title="2. 局部变量’hello world’存放在栈中"></a>2. 局部变量’hello world’存放在栈中</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;   </span><br><span class="line"></span><br><span class="line">char *returnStr()   </span><br><span class="line">&#123;   </span><br><span class="line">    char p[]=&quot;hello world!&quot;;   </span><br><span class="line">    return p;   </span><br><span class="line">&#125;   </span><br><span class="line">int main()   </span><br><span class="line">&#123;   </span><br><span class="line">    char *str;   </span><br><span class="line">    str=returnStr();   </span><br><span class="line">    printf(&quot;%s\n&quot;, str);   </span><br><span class="line">    return 0;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“hello world!”是局部变量存放在栈中。当returnStr函数退出时，栈要清空，局部变量的内存也被清空了，所以这时的函数返回的是一个已被释放的内存地址，所以有可能打印出来的是乱码。 </p><h5 id="3-局部变量（实参与型参）、地址（指针）栈（指向内存的释放）、静态变量地址（指针）的生存周期"><a href="#3-局部变量（实参与型参）、地址（指针）栈（指向内存的释放）、静态变量地址（指针）的生存周期" class="headerlink" title="3. 局部变量（实参与型参）、地址（指针）栈（指向内存的释放）、静态变量地址（指针）的生存周期"></a>3. 局部变量（实参与型参）、地址（指针）栈（指向内存的释放）、静态变量地址（指针）的生存周期</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int func()  </span><br><span class="line">&#123;  </span><br><span class="line">      int a;  </span><br><span class="line">      ....  </span><br><span class="line">      return a;    //允许  </span><br><span class="line">&#125;                     </span><br><span class="line">  </span><br><span class="line">int * func()  </span><br><span class="line">&#123;  </span><br><span class="line">      int a;  </span><br><span class="line">      ....  </span><br><span class="line">      return &amp;a;    //无意义，不应该这样做  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部变量也分局部自动变量和局部静态变量，由于a返回的是值，因此返回一个局部变量是可以的，无论自动还是静态，因为这时候返回的是这个局部变量的值。</p><p>但不应该返回指向局部自动变量的指针，因为函数调用结束后该局部自动变量<br>被抛弃，这个指针指向一个不再存在的对象，是无意义的。</p><p>但可以返回指向局部静态变量的指针，因为静态变量的生存期从定义起到程序结束。</p><h5 id="4-如果函数的返回值非要是一个局部变量的地址，那么该局部变量一定要申明为static类型。"><a href="#4-如果函数的返回值非要是一个局部变量的地址，那么该局部变量一定要申明为static类型。" class="headerlink" title="4. 如果函数的返回值非要是一个局部变量的地址，那么该局部变量一定要申明为static类型。"></a>4. 如果函数的返回值非要是一个局部变量的地址，那么该局部变量一定要申明为static类型。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;   </span><br><span class="line">char *returnStr()   </span><br><span class="line">&#123;   </span><br><span class="line">    static char p[]=&quot;hello world!&quot;;   </span><br><span class="line">    return p;   </span><br><span class="line">&#125;   </span><br><span class="line">int main()   </span><br><span class="line">&#123;   </span><br><span class="line">    char *str;   </span><br><span class="line">    str=returnStr();   </span><br><span class="line">    printf(&quot;%s\n&quot;, str);   </span><br><span class="line">  </span><br><span class="line">    return 0;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-数组是不能作为函数的返回值的，原因是编译器把数组名认为是局部变量（数组）的地址。返回一个数组一般用返回指向这个数组的指针代替，而且这个指针不能指向一个自动数组，因为函数结束后自动数组被抛弃，但可以返回一个指向静态局部数组的指针，因为静态存储期是从对象定义到程序结束的。"><a href="#5-数组是不能作为函数的返回值的，原因是编译器把数组名认为是局部变量（数组）的地址。返回一个数组一般用返回指向这个数组的指针代替，而且这个指针不能指向一个自动数组，因为函数结束后自动数组被抛弃，但可以返回一个指向静态局部数组的指针，因为静态存储期是从对象定义到程序结束的。" class="headerlink" title="5. 数组是不能作为函数的返回值的，原因是编译器把数组名认为是局部变量（数组）的地址。返回一个数组一般用返回指向这个数组的指针代替，而且这个指针不能指向一个自动数组，因为函数结束后自动数组被抛弃，但可以返回一个指向静态局部数组的指针，因为静态存储期是从对象定义到程序结束的。"></a>5. 数组是不能作为函数的返回值的，原因是编译器把数组名认为是局部变量（数组）的地址。返回一个数组一般用返回指向这个数组的指针代替，而且这个指针不能指向一个自动数组，因为函数结束后自动数组被抛弃，但可以返回一个指向静态局部数组的指针，因为静态存储期是从对象定义到程序结束的。</h5><p>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int* func( void )  </span><br><span class="line">&#123;  </span><br><span class="line">    static int a[10];  </span><br><span class="line">    ........  </span><br><span class="line">    return a;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-返回指向堆内存的指针是可以的"><a href="#6-返回指向堆内存的指针是可以的" class="headerlink" title="6. 返回指向堆内存的指针是可以的"></a>6. 返回指向堆内存的指针是可以的</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">char *GetMemory3(int num)  </span><br><span class="line">&#123;  </span><br><span class="line">    char *p = (char *)malloc(sizeof(char) * num);  </span><br><span class="line">    return p;  </span><br><span class="line">&#125;  </span><br><span class="line">void Test3(void)  </span><br><span class="line">&#123;  </span><br><span class="line">    char *str = NULL;  </span><br><span class="line">    str = GetMemory3(100);  </span><br><span class="line">    strcpy(str, &quot;hello&quot;);  </span><br><span class="line">    cout&lt;&lt; str &lt;&lt; endl;  </span><br><span class="line">    free(str);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序在运行的时候用 malloc 申请任意多少的内存,程序员自己负责在何时用 free释放内存。动态内存的生存期由程序员自己决定,使用非常灵活。</p><h5 id="7-通过局部变量在另一个函数去取值-传一个地址，用指针变量来接收，用指针来指向一个值"><a href="#7-通过局部变量在另一个函数去取值-传一个地址，用指针变量来接收，用指针来指向一个值" class="headerlink" title="7. 通过局部变量在另一个函数去取值(传一个地址，用指针变量来接收，用指针来指向一个值)"></a>7. 通过局部变量在另一个函数去取值(传一个地址，用指针变量来接收，用指针来指向一个值)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void get_value(int* Temp)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;2:0x%x\n&quot;,Temp);</span><br><span class="line">    *Temp = 6;</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    int temp;</span><br><span class="line">    printf(&quot;1:0x%x\n&quot;,&amp;temp);</span><br><span class="line">    </span><br><span class="line">    get_value(&amp;temp);</span><br><span class="line">    printf(&quot;3:%d\n&quot;,temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-通过局部变量数组在另一个函数去取值-传一个地址，用指针变量来接收，用指针来指向一个值"><a href="#8-通过局部变量数组在另一个函数去取值-传一个地址，用指针变量来接收，用指针来指向一个值" class="headerlink" title="8. 通过局部变量数组在另一个函数去取值(传一个地址，用指针变量来接收，用指针来指向一个值)"></a>8. 通过局部变量数组在另一个函数去取值(传一个地址，用指针变量来接收，用指针来指向一个值)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void get_value(char * ptemp)</span><br><span class="line">&#123;</span><br><span class="line">char i;</span><br><span class="line">    printf(&quot;2:0x%x\n&quot;,ptemp);</span><br><span class="line">    ptemp = &quot;hello world!&quot;;//这样不行，字符串常量放在只读数据段，和主函数中的temp局部数据区域有冲突</span><br><span class="line"></span><br><span class="line">printf(&quot;3:%s\n&quot;,ptemp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char temp[13]=&#123;0&#125;;</span><br><span class="line">    printf(&quot;1:0x%x\n&quot;,temp);</span><br><span class="line">    </span><br><span class="line">    get_value(temp);</span><br><span class="line"></span><br><span class="line">    printf(&quot;4:%s\n&quot;,temp);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2019/12/15/C%E8%AF%AD%E8%A8%80-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/1.png" alt="1"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void get_value(char * ptemp)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;2:0x%x\n&quot;,ptemp);</span><br><span class="line">    for(char i=0;i&lt;13;i++)//这样可以，temp和ptemp都在栈函数数据区域中，main函数调用get_value，get_value会先释放，但是temp申请的内存空间，此时并没有释放，所以可以拿到值。</span><br><span class="line">&#123;</span><br><span class="line">ptemp[i] = &apos;h&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;3:%s\n&quot;,ptemp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char temp[13]=&#123;0&#125;;</span><br><span class="line">    printf(&quot;1:0x%x\n&quot;,temp);</span><br><span class="line">    </span><br><span class="line">    get_value(temp);</span><br><span class="line"></span><br><span class="line">    printf(&quot;4:%s\n&quot;,temp);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2019/12/15/C%E8%AF%AD%E8%A8%80-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/2.png" alt="2"></p><h5 id="9-通过结构体类型的局部变量数组在另一个函数去取值-传一个结构体变量的地址，用指针变量来接收，用指针来指向一个值"><a href="#9-通过结构体类型的局部变量数组在另一个函数去取值-传一个结构体变量的地址，用指针变量来接收，用指针来指向一个值" class="headerlink" title="9. 通过结构体类型的局部变量数组在另一个函数去取值(传一个结构体变量的地址，用指针变量来接收，用指针来指向一个值)"></a>9. 通过结构体类型的局部变量数组在另一个函数去取值(传一个结构体变量的地址，用指针变量来接收，用指针来指向一个值)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">char hisi_app[9];</span><br><span class="line">char sys_lib[9];</span><br><span class="line">char mb_mcu[9];</span><br><span class="line">char mcu_4g[9];</span><br><span class="line">char mcu_1256[9];</span><br><span class="line">char device[7];</span><br><span class="line">&#125;file_ver_t;</span><br><span class="line"></span><br><span class="line">void read_file_version(file_ver_t *pfile_ver)</span><br><span class="line">&#123;</span><br><span class="line">memset(pfile_ver-&gt;hisi_app,0,9);</span><br><span class="line">memcpy(pfile_ver-&gt;hisi_app,&quot;3.01.0001&quot;,9);</span><br><span class="line">printf(&quot;%s\n&quot;, pfile_ver-&gt;hisi_app);</span><br><span class="line">memcpy(pfile_ver-&gt;sys_lib,&quot;3.01.0001&quot;,9);</span><br><span class="line">printf(&quot;%s\n&quot;, pfile_ver-&gt;sys_lib);</span><br><span class="line">memcpy(pfile_ver-&gt;mb_mcu,&quot;3.01.0001&quot;,9);</span><br><span class="line">printf(&quot;%s\n&quot;, pfile_ver-&gt;mb_mcu);</span><br><span class="line">memcpy(pfile_ver-&gt;mcu_4g,&quot;3.01.0001&quot;,9);</span><br><span class="line">printf(&quot;%s\n&quot;, pfile_ver-&gt;mcu_4g);</span><br><span class="line">memcpy(pfile_ver-&gt;mcu_1256,&quot;3.01.0001&quot;,9);</span><br><span class="line">printf(&quot;%s\n&quot;, pfile_ver-&gt;mcu_1256);</span><br><span class="line">memcpy(pfile_ver-&gt;device,&quot;1.00.00&quot;,7);</span><br><span class="line">printf(&quot;%s\n&quot;, pfile_ver-&gt;device);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">file_ver_t file_ver;</span><br><span class="line">read_file_version(&amp;file_ver);</span><br><span class="line"></span><br><span class="line">printf(&quot;%s\n&quot;, file_ver.hisi_app);</span><br><span class="line">printf(&quot;%s\n&quot;, file_ver.sys_lib);</span><br><span class="line">printf(&quot;%s\n&quot;, file_ver.mb_mcu);</span><br><span class="line">printf(&quot;%s\n&quot;, file_ver.mcu_4g);</span><br><span class="line">printf(&quot;%s\n&quot;, file_ver.mcu_1256);</span><br><span class="line">printf(&quot;%s\n&quot;, file_ver.device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2019/12/15/C%E8%AF%AD%E8%A8%80-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/3.png" alt="3"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般的来说，函数是可以返回局部变量的。&lt;/p&gt;
&lt;p&gt;局部变量的作用域只在函数内部，在函数返回后，局部变量的内存已经释放了。&lt;/p&gt;
&lt;p&gt;因此，如果函数返回的是局部变量的值，不涉及地址，程序不会出错。&lt;/p&gt;
&lt;p&gt;但是如果返回的是局部变量的地址(指针)的话，程序运行后会出错。&lt;/p&gt;
&lt;p&gt;因为函数只是把指针复制后返回了，但是指针指向的内容已经被释放了，这样指针指向的内容就是不可预料的内容，调用就会出错。&lt;/p&gt;
&lt;p&gt;准确的来说，函数不能通过返回指向栈内存的指针(注意这里指的是栈，返回指向堆内存的指针是可以的)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="http://www.faihung.net/categories/C/"/>
    
    
      <category term="指针" scheme="http://www.faihung.net/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="生存周期" scheme="http://www.faihung.net/tags/%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F/"/>
    
      <category term="内存分配" scheme="http://www.faihung.net/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
      <category term="局部变量" scheme="http://www.faihung.net/tags/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"/>
    
      <category term="数组取值" scheme="http://www.faihung.net/tags/%E6%95%B0%E7%BB%84%E5%8F%96%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>问题-notepadd++  ANSI编码与UTF-8编码</title>
    <link href="http://www.faihung.net/2019/12/15/%E9%97%AE%E9%A2%98-notepadd-ANSI%E7%BC%96%E7%A0%81%E4%B8%8EUTF-8%E7%BC%96%E7%A0%81/"/>
    <id>http://www.faihung.net/2019/12/15/问题-notepadd-ANSI编码与UTF-8编码/</id>
    <published>2019-12-14T16:33:10.000Z</published>
    <updated>2019-12-14T16:36:13.899Z</updated>
    
    <content type="html"><![CDATA[<p>之前有一种见鬼的感觉，主要表现在写脚本上（写脚本主要是因为空格的原因），写程序倒是不会出现。结果导致脚本执行不成功。</p><a id="more"></a><p>使用UTF-8编码</p><p><img src="/2019/12/15/%E9%97%AE%E9%A2%98-notepadd-ANSI%E7%BC%96%E7%A0%81%E4%B8%8EUTF-8%E7%BC%96%E7%A0%81/1.png" alt="1"></p><p>使用ANSI编码</p><p><img src="/2019/12/15/%E9%97%AE%E9%A2%98-notepadd-ANSI%E7%BC%96%E7%A0%81%E4%B8%8EUTF-8%E7%BC%96%E7%A0%81/2.png" alt="2"></p><p>这种情况要记住，以后不要在这上面浪费时间了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前有一种见鬼的感觉，主要表现在写脚本上（写脚本主要是因为空格的原因），写程序倒是不会出现。结果导致脚本执行不成功。&lt;/p&gt;
    
    </summary>
    
    
      <category term="问题" scheme="http://www.faihung.net/categories/%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="notepadd" scheme="http://www.faihung.net/tags/notepadd/"/>
    
      <category term="UTF-8" scheme="http://www.faihung.net/tags/UTF-8/"/>
    
      <category term="ANSI" scheme="http://www.faihung.net/tags/ANSI/"/>
    
  </entry>
  
  <entry>
    <title>cURL-09_使用curl库进行http通信(转)</title>
    <link href="http://www.faihung.net/2019/12/12/cURL-09-%E4%BD%BF%E7%94%A8curl%E5%BA%93%E8%BF%9B%E8%A1%8Chttp%E9%80%9A%E4%BF%A1-%E8%BD%AC/"/>
    <id>http://www.faihung.net/2019/12/12/cURL-09-使用curl库进行http通信-转/</id>
    <published>2019-12-12T07:37:14.000Z</published>
    <updated>2019-12-12T07:38:23.583Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一、LibCurl基本编程框架"><a href="#一、LibCurl基本编程框架" class="headerlink" title="一、LibCurl基本编程框架"></a>一、LibCurl基本编程框架</h5><p>关于libcurl，<a href="https://www.faihung.net/2019/11/03/cURL-01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BA%86%E8%A7%A3/">前面已经有了很多介绍</a>，这里就不详西描述了。</p><p>在基于LibCurl的程序里，主要采用callback function （回调函数）的形式完成传输任务，用户在启动传输前设置好各类参数和回调函数，当满足条件时libcurl将调用用户的回调函数实现特定功能。</p><a id="more"></a><p>下面是利用libcurl完成传输任务的流程：</p><ol><li>调用curl_global_init()初始化libcurl</li><li>调用curl_easy_init()函数得到 easy interface 型指针</li><li>调用curl_easy_setopt()设置传输选项</li><li>根据curl_easy_setopt()设置的传输选项，实现回调函数以完成用户特定任务</li><li>调用curl_easy_perform()函数完成传输任务</li><li>调用curl_easy_cleanup()释放内存</li></ol><p>在整过过程中设置curl_easy_setopt()参数是最关键的，几乎所有的libcurl程序都要使用它。</p><h5 id="二、一些基本的函数"><a href="#二、一些基本的函数" class="headerlink" title="二、一些基本的函数"></a>二、一些基本的函数</h5><h6 id="1-CURLcode-curl-global-init-long-flags"><a href="#1-CURLcode-curl-global-init-long-flags" class="headerlink" title="1.CURLcode curl_global_init(long flags);"></a>1.CURLcode curl_global_init(long flags);</h6><p>描述：<br>这个函数只能用一次。(其实在调用curl_global_cleanup 函数后仍然可再用)<br>如果这个函数在curl_easy_init函数调用时还没调用，它将由libcurl库自动调用，所以多线程下最好主动调用该函数以防止在线程中curl_easy_init时多次调用。</p><p>注意：虽然libcurl是线程安全的，但curl_global_init是不能保证线程安全的，所以不要在每个线程中都调用curl_global_init，应该将该函数的调用放在主线程中。</p><p>参数：flags</p><pre><code>CURL_GLOBAL_ALL             //初始化所有的可能的调用。CURL_GLOBAL_SSL             //初始化支持安全套接字层。CURL_GLOBAL_WIN32           //初始化win32套接字库。CURL_GLOBAL_NOTHING         //没有额外的初始化。</code></pre><h6 id="2-void-curl-global-cleanup-void"><a href="#2-void-curl-global-cleanup-void" class="headerlink" title="2 void curl_global_cleanup(void);"></a>2 void curl_global_cleanup(void);</h6><p>描述：在结束libcurl使用的时候，用来对curl_global_cleanup做的工作清理。类似于close的函数。</p><p>注意：虽然libcurl是线程安全的，但curl_global_cleanup是不能保证线程安全的，所以不要在每个线程中都调用curl_global_init，应该将该函数的调用放在主线程中。</p><h6 id="3-char-curl-version"><a href="#3-char-curl-version" class="headerlink" title="3 char *curl_version( );"></a>3 char *curl_version( );</h6><p>描述: 打印当前libcurl库的版本。</p><h6 id="4-CURL-curl-easy-init"><a href="#4-CURL-curl-easy-init" class="headerlink" title="4 CURL *curl_easy_init( );"></a>4 CURL *curl_easy_init( );</h6><p>描述:<br>curl_easy_init用来初始化一个CURL的指针(有些像返回FILE类型的指针一样). 相应的在调用结束时要用curl_easy_cleanup函数清理.<br>一般curl_easy_init意味着一个会话的开始. 它会返回一个easy_handle(CURL*对象), 一般都用在easy系列的函数中.</p><h6 id="5-void-curl-easy-cleanup-CURL-handle"><a href="#5-void-curl-easy-cleanup-CURL-handle" class="headerlink" title="5 void curl_easy_cleanup(CURL *handle);"></a>5 void curl_easy_cleanup(CURL *handle);</h6><p>描述:<br>这个调用用来结束一个会话，curl_easy_init配合着用。</p><p>参数:<br>CURL类型的指针.</p><h6 id="6-CURLcode-curl-easy-setopt-CURL-handle-CURLoption-option-parameter"><a href="#6-CURLcode-curl-easy-setopt-CURL-handle-CURLoption-option-parameter" class="headerlink" title="6 CURLcode curl_easy_setopt(CURL *handle, CURLoption option, parameter);"></a>6 CURLcode curl_easy_setopt(CURL *handle, CURLoption option, parameter);</h6><p>描述: 这个函数最重要了.几乎所有的curl程序都要频繁的使用它.它告诉curl库.程序将有如何的行为. 比如要查看一个网页的html代码等.(这个函数有些像ioctl函数)参数:</p><ol><li>CURL类型的指针。</li><li>各种CURLoption类型的选项.(都在curl.h库里有定义,man也可以查看到)</li><li>parameter 这个参数既可以是个函数的指针,也可以是某个对象的指针,也可以是个long型的变量.它用什么这取决于第二个参数。<br>CURLoption 这个参数的取值很多.具体的可以查看man手册。</li></ol><h6 id="7-CURLcode-curl-easy-perform-CURL-handle"><a href="#7-CURLcode-curl-easy-perform-CURL-handle" class="headerlink" title="7 CURLcode curl_easy_perform(CURL *handle);"></a>7 CURLcode curl_easy_perform(CURL *handle);</h6><p>描述:这个函数在初始化CURL类型的指针 以及curl_easy_setopt完成后调用.就像字面的意思所说perform就像是个舞台，让我们设置的<br>option 运作起来.</p><p>参数:<br>CURL类型的指针。</p><h5 id="三、curl-easy-setopt函数部分选项介绍"><a href="#三、curl-easy-setopt函数部分选项介绍" class="headerlink" title="三、curl_easy_setopt函数部分选项介绍"></a>三、curl_easy_setopt函数部分选项介绍</h5><p>本节主要介绍curl_easy_setopt中跟http相关的参数。该函数是curl中非常重要的函数，curl所有设置都是在该函数中完成的，该函数的设置选项众多，注意本节的阐述的只是部分常见选项。</p><h6 id="1-CURLOPT-URL"><a href="#1-CURLOPT-URL" class="headerlink" title="1.CURLOPT_URL"></a>1.CURLOPT_URL</h6><p>设置访问URL</p><h6 id="2-CURLOPT-WRITEFUNCTION，CURLOPT-WRITEDATA"><a href="#2-CURLOPT-WRITEFUNCTION，CURLOPT-WRITEDATA" class="headerlink" title="2.CURLOPT_WRITEFUNCTION，CURLOPT_WRITEDATA"></a>2.CURLOPT_WRITEFUNCTION，CURLOPT_WRITEDATA</h6><p>回调函数原型为：</p><pre><code>size_t function( void *ptr, size_t size, size_t nmemb, void *stream);</code></pre><p>函数将在libcurl接收到数据后被调用，因此函数多做数据保存的功能，如处理下载文件。</p><p>CURLOPT_WRITEDATA 用于表明CURLOPT_WRITEFUNCTION函数中的stream指针的来源。<br>如果你没有通过CURLOPT_WRITEFUNCTION属性给easy handle设置回调函数，libcurl会提供一个默认的回调函数，它只是简单的将接收到的数据打印到标准输出。你也可以通过 CURLOPT_WRITEDATA属性给默认回调函数传递一个已经打开的文件指针，用于将数据输出到文件里。</p><h6 id="3-CURLOPT-HEADERFUNCTION，CURLOPT-HEADERDATA"><a href="#3-CURLOPT-HEADERFUNCTION，CURLOPT-HEADERDATA" class="headerlink" title="3.CURLOPT_HEADERFUNCTION，CURLOPT_HEADERDATA"></a>3.CURLOPT_HEADERFUNCTION，CURLOPT_HEADERDATA</h6><p>回调函数原型为 </p><pre><code>size_t function( void *ptr, size_t size,size_t nmemb, void *stream);</code></pre><p>libcurl一旦接收到http 头部数据后将调用该函数。CURLOPT_WRITEDATA 传递指针给libcurl，该指针表明CURLOPT_HEADERFUNCTION函数的stream指针的来源。</p><h6 id="4-CURLOPT-READFUNCTION-CURLOPT-READDATA"><a href="#4-CURLOPT-READFUNCTION-CURLOPT-READDATA" class="headerlink" title="4.CURLOPT_READFUNCTION CURLOPT_READDATA"></a>4.CURLOPT_READFUNCTION CURLOPT_READDATA</h6><p>libCurl需要读取数据传递给远程主机时将调用CURLOPT_READFUNCTION指定的函数，函数原型是：</p><pre><code>size_t function(void *ptr, size_t size, size_t nmemb,void *stream)；</code></pre><p>CURLOPT_READDATA 表明CURLOPT_READFUNCTION函数原型中的stream指针来源。</p><h6 id="5-CURLOPT-NOPROGRESS，CURLOPT-PROGRESSFUNCTION，CURLOPT-PROGRESSDATA"><a href="#5-CURLOPT-NOPROGRESS，CURLOPT-PROGRESSFUNCTION，CURLOPT-PROGRESSDATA" class="headerlink" title="5.CURLOPT_NOPROGRESS，CURLOPT_PROGRESSFUNCTION，CURLOPT_PROGRESSDATA"></a>5.CURLOPT_NOPROGRESS，CURLOPT_PROGRESSFUNCTION，CURLOPT_PROGRESSDATA</h6><p>跟数据传输进度相关的参数。CURLOPT_PROGRESSFUNCTION指定的函数正常情况下每秒被libcurl调用一次，为了使CURLOPT_PROGRESSFUNCTION被调用，CURLOPT_NOPROGRESS必须被设置为false，CURLOPT_PROGRESSDATA指定的参数将作为CURLOPT_PROGRESSFUNCTION指定函数的第一个参数</p><h6 id="6-CURLOPT-TIMEOUT，CURLOPT-CONNECTIONTIMEOUT"><a href="#6-CURLOPT-TIMEOUT，CURLOPT-CONNECTIONTIMEOUT" class="headerlink" title="6.CURLOPT_TIMEOUT，CURLOPT_CONNECTIONTIMEOUT"></a>6.CURLOPT_TIMEOUT，CURLOPT_CONNECTIONTIMEOUT</h6><p>CURLOPT_TIMEOUT 由于设置传输时间，CURLOPT_CONNECTIONTIMEOUT 设置连接等待时间</p><h6 id="7-CURLOPT-FOLLOWLOCATION"><a href="#7-CURLOPT-FOLLOWLOCATION" class="headerlink" title="7.CURLOPT_FOLLOWLOCATION"></a>7.CURLOPT_FOLLOWLOCATION</h6><p>设置重定位URL</p><h6 id="8-CURLOPT-RANGE-CURLOPT-RESUME-FROM"><a href="#8-CURLOPT-RANGE-CURLOPT-RESUME-FROM" class="headerlink" title="8.CURLOPT_RANGE: CURLOPT_RESUME_FROM:"></a>8.CURLOPT_RANGE: CURLOPT_RESUME_FROM:</h6><p>断点续传相关设置。CURLOPT_RANGE 指定char *参数传递给libcurl，用于指明http域的RANGE头域，</p><p>例如：</p><pre><code>表示头500个字节：bytes=0-499表示第二个500字节：bytes=500-999表示最后500个字节：bytes=-500表示500字节以后的范围：bytes=500-第一个和最后一个字节：bytes=0-0,-1同时指定几个范围：bytes=500-600,601-999</code></pre><p>CURLOPT_RESUME_FROM 传递一个long参数给libcurl，指定你希望开始传递的偏移量。</p><h5 id="四、curl-easy-perform-函数说明（error-状态码）"><a href="#四、curl-easy-perform-函数说明（error-状态码）" class="headerlink" title="四、curl_easy_perform 函数说明（error 状态码）"></a>四、curl_easy_perform 函数说明（error 状态码）</h5><p>该函数是完成curl_easy_setopt指定的所有选项，本节重点介绍curl_easy_perform的返回值。返回0意味一切ok，非0代表错误发生。主要错误码说明：</p><pre><code>1.CURLE_OK任务完成一切都好2.CURLE_UNSUPPORTED_PROTOCOL不支持的协议，由URL的头部指定3.CURLE_COULDNT_CONNECT不能连接到remote 主机或者代理4.CURLE_REMOTE_ACCESS_DENIED访问被拒绝5.CURLE_HTTP_RETURNED_ERRORHttp返回错误6.CURLE_READ_ERROR读本地文件错误</code></pre><p>要获取详细的错误描述字符串，可以通过</p><pre><code>const char *curl_easy_strerror(CURLcode errornum ) </code></pre><p>这个函数取得。    </p><h5 id="五、libcurl使用的HTTP消息头"><a href="#五、libcurl使用的HTTP消息头" class="headerlink" title="五、libcurl使用的HTTP消息头"></a>五、libcurl使用的HTTP消息头</h5><p>当使用libcurl发送http请求时，它会自动添加一些http头。我们可以通过CURLOPT_HTTPHEADER属性手动替换、添加或删除相应 的HTTP消息头。</p><pre><code>Hosthttp1.1（大部分http1.0)版本都要求客户端请求提供这个信息头。Pragma&quot;no-cache&quot;。表示不要缓冲数据。Accept&quot;*/*&quot;。表示允许接收任何类型的数据。Expect以POST的方式向HTTP服务器提交请求时，libcurl会设置该消息头为&quot;100-continue&quot;，它要求服务器在正式处理该请求之前，返回一 个&quot;OK&quot;消息。如果POST的数据很小，libcurl可能不会设置该消息头。</code></pre><p><strong>自定义选项</strong></p><p>当前越来越多的协议都构建在HTTP协议之上（如：soap），这主要归功于HTTP的可靠性，以及被广泛使用的代理支持（可以穿透大部分防火墙）。 这些协议的使用方式与传统HTTP可能有很大的不同。对此，libcurl作了很好的支持。</p><p>自定义请求方式(CustomRequest)，<br>HTTP支持GET, HEAD或者POST提交请求。可以设置CURLOPT_CUSTOMREQUEST来设置自定义的请求方式，libcurl默认以GET方式提交请求：</p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_CUSTOMREQUEST, &quot;MYOWNREQUEST&quot;);</code></pre><p><strong>修改消息头</strong></p><p>HTTP协议提供了消息头，请求消息头用于告诉服务器如何处理请求；响应消息头则告诉浏览器如何处理接收到的数据。在libcurl中，你可以自由的添加这些消息头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct curl_slist *headers=NULL; /* init to NULL is important */</span><br><span class="line">headers = curl_slist_append(headers, &quot;Hey-server-hey: how are you?&quot;);</span><br><span class="line">headers = curl_slist_append(headers, &quot;X-silly-content: yes&quot;);</span><br><span class="line">/* pass our list of custom made headers */</span><br><span class="line">curl_easy_setopt(easyhandle, CURLOPT_HTTPHEADER, headers);</span><br><span class="line">curl_easy_perform(easyhandle); /* transfer http */</span><br><span class="line">curl_slist_free_all(headers); /* free the header list */</span><br></pre></td></tr></table></figure><p>对于已经存在的消息头，可以重新设置它的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">headers = curl_slist_append(headers, &quot;Accept: Agent-007&quot;); </span><br><span class="line">headers = curl_slist_append(headers, &quot;Host: munged.host.line&quot;);</span><br></pre></td></tr></table></figure><p><strong>删除消息头</strong></p><p>对于一个已经存在的消息头，设置它的内容为空，libcurl在发送请求时就不会同时提交该消息头：</p><pre><code>headers = curl_slist_append(headers, &quot;Accept:&quot;);</code></pre><h5 id="六、获取http应答头信息"><a href="#六、获取http应答头信息" class="headerlink" title="六、获取http应答头信息"></a>六、获取http应答头信息</h5><p>发出http请求后，服务器会返回应答头信息和应答数据，如果仅仅是打印应答头的所有内容，则直接可以通过curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, 打印函数)的方式来完成，这里需要获取的是应答头中特定的信息，比如应答码、cookies列表等，则需要通过下面这个函数：</p><pre><code>CURLcode curl_easy_getinfo(CURL *curl, CURLINFO info, ... );</code></pre><p>info参数就是我们需要获取的内容，下面是一些参数值:</p><pre><code>1.CURLINFO_RESPONSE_CODE 获取应答码2.CURLINFO_HEADER_SIZE 头大小3.CURLINFO_COOKIELIST cookies列表</code></pre><p>除了获取应答信息外，这个函数还能获取curl的一些内部信息，如请求时间、连接时间等等。</p><p>更多的参数可以参考API文档。</p><h5 id="七、多线程问题"><a href="#七、多线程问题" class="headerlink" title="七、多线程问题"></a>七、多线程问题</h5><p>首先一个基本原则就是：绝对不应该在线程之间共享同一个libcurl handle(CURL *对象)，不管是easy handle还是multi handle（本文只介绍easy_handle）。一个线程每次只能使用一个handle。</p><p>libcurl是线程安全的，但有两点例外：信号(signals)和SSL/TLS handler。 信号用于超时失效名字解析(timing out name resolves)。libcurl依赖其他的库来支持SSL/STL，所以用多线程的方式访问HTTPS或FTPS的URL时，应该满足这些库对多线程 操作的一些要求。</p><p>NSS: 宣称是多线程安全的。</p><h5 id="八、什么时候libcurl无法正常工作"><a href="#八、什么时候libcurl无法正常工作" class="headerlink" title="八、什么时候libcurl无法正常工作"></a>八、什么时候libcurl无法正常工作</h5><p>传输失败总是有原因的。你可能错误的设置了一些libcurl的属性或者没有正确的理解某些属性的含义，或者是远程主机返回一些无法被正确解析的内容。</p><p>这里有一个<strong>黄金法则</strong>来处理这些问题：</p><p>将CURLOPT_VERBOSE属性设置为1，libcurl会输出通信过程中的一些细节。如果使用的是http协议，请求头/响应头也会被输出。将CURLOPT_HEADER设为1，这些头信息将出现在消息的内容中。</p><p>当然不可否认的是，libcurl还存在bug。</p><p>如果你对相关的协议了解越多，在使用libcurl时，就越不容易犯错。</p><h5 id="九、关于密码"><a href="#九、关于密码" class="headerlink" title="九、关于密码"></a>九、关于密码</h5><p>客户端向服务器发送请求时，许多协议都要求提供用户名与密码。libcurl提供了多种方式来设置它们。</p><p>一些协议支持在URL中直接指定用户名和密码，类似于：<br>protocol://user:<a href="mailto:password@example.com" target="_blank" rel="noopener">password@example.com</a>/path/。libcurl能正确的识别这种URL中的用户名与密码并执行相应的操作。如果你提供的用户名和密码中有特殊字符，首先应该对其进行URL编码。</p><p>也可以通过CURLOPT_USERPWD属性来设置用户名与密码。参数是格式如<br>“user:password ”的字符串：</p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_USERPWD, &quot;user_name:password&quot;);</code></pre><p>有时候在访问代理服务器的时候，可能时时要求提供用户名和密码进行用户身份验证。这种情况下，libcurl提供了另一个属性CURLOPT_PROXYUSERPWD：</p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_PROXYUSERPWD, &quot;user_name:password&quot;);</code></pre><p>在UNIX平台下，访问FTP的用户名和密码可能会被保存在$HOME/.netrc文件中。libcurl支持直接从这个文件中获取用户名与密码：  </p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_NETRC, 1L);    </code></pre><p>在使用SSL时，可能需要提供一个私钥用于数据安全传输，通过CURLOPT_KEYPASSWD来设置私钥：</p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_KEYPASSWD, &quot;keypassword&quot;);</code></pre><h5 id="十、HTTP验证"><a href="#十、HTTP验证" class="headerlink" title="十、HTTP验证"></a>十、HTTP验证</h5><p>在使用HTTP协议时，客户端有很多种方式向服务器提供验证信息。默认的HTTP验证方法是”Basic”，它将用户名与密码以明文的方式、经Base64编码后保存在HTTP请求头中，发往服务器。当然这不太安全。</p><p>当前版本的libcurl支持的验证方法有：basic, Digest, NTLM, Negotiate, GSS-Negotiate and SPNEGO。（译者感叹：搞Web这么多年，尽然不知道这些Http的验证方式，实在惭愧。）可以通过CURLOPT_HTTPAUTH属性来设置具体 的验证方式：</p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_HTTPAUTH, CURLAUTH_DIGEST);</code></pre><p>向代理服务器发送验证信息时，可以通过CURLOPT_PROXYAUTH设置验证方式：</p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_PROXYAUTH, CURLAUTH_NTLM);</code></pre><p>也可以同时设置多种验证方式（通过按位与）， 使用’CURLAUTH_ANY’将允许libcurl可以选择任何它所支持的验证方式。通过CURLOPT_HTTPAUTH或 CURLOPT_PROXYAUTH属性设置的多种验证方式，libcurl会在运行时选择一种它认为是最好的方式与服务器通信：</p><pre><code>curl_easy_setopt(easy_handle, CURLOPT_HTTPAUTH,  CURLAUTH_DIGEST|CURLAUTH_BASIC);// curl_easy_setopt(easy_handle, CURLOPT_HTTPAUTH,  CURLAUTH_ANY);</code></pre><h5 id="十一、代码示例"><a href="#十一、代码示例" class="headerlink" title="十一、代码示例"></a>十一、代码示例</h5><h6 id="1-基本的http-GET-POST操作"><a href="#1-基本的http-GET-POST操作" class="headerlink" title="1.基本的http GET/POST操作"></a>1.基本的http GET/POST操作</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line"></span><br><span class="line">bool getUrl(char *filename)</span><br><span class="line">&#123;</span><br><span class="line">    CURL *curl;</span><br><span class="line">    CURLcode res;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    if ((fp = fopen(filename, &quot;w&quot;)) == NULL)  //返回结果用文件存储</span><br><span class="line">        return false;</span><br><span class="line">    struct curl_slist *headers = NULL;</span><br><span class="line">    headers = curl_slist_append(headers, &quot;Accept: Agent-007&quot;);</span><br><span class="line">    curl = curl_easy_init();    //初始化</span><br><span class="line">    if (curl)</span><br><span class="line">    &#123;</span><br><span class="line">        //curl_easy_setopt(curl, CURLOPT_PROXY, &quot;10.99.60.201:8080&quot;);//代理</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);//改协议头</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_URL,&quot;http://www.baidu.com&quot;);</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp); //将返回的http头输出到fp指向的文件</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_HEADERDATA, fp); //将返回的html主体数据输出到fp指向的文件</span><br><span class="line">        res = curl_easy_perform(curl);   // 执行</span><br><span class="line">        if (res != 0) &#123;</span><br><span class="line"></span><br><span class="line">            curl_slist_free_all(headers);</span><br><span class="line">            curl_easy_cleanup(curl);</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fp);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool postUrl(char *filename)</span><br><span class="line">&#123;</span><br><span class="line">    CURL *curl;</span><br><span class="line">    CURLcode res;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    if ((fp = fopen(filename, &quot;w&quot;)) == NULL)</span><br><span class="line">        return false;</span><br><span class="line">    curl = curl_easy_init();</span><br><span class="line">    if (curl)</span><br><span class="line">    &#123;</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_COOKIEFILE, &quot;/mnt/hgfs/VMWARE/test/10-http/temp/cookie.txt&quot;); // 指定cookie文件</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, &quot;&amp;logintype=uid&amp;u=xieyan&amp;psw=xxx86&quot;);    // 指定post内容</span><br><span class="line">        //curl_easy_setopt(curl, CURLOPT_PROXY, &quot;10.99.60.201:8080&quot;);</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_URL, &quot; http://mail.sina.com.cn/cgi-bin/login.cgi &quot;);   // 指定url</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);</span><br><span class="line">        res = curl_easy_perform(curl);</span><br><span class="line">        curl_easy_cleanup(curl);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    getUrl(&quot;/mnt/hgfs/VMWARE/test/10-http/temp/get.html&quot;);</span><br><span class="line">    postUrl(&quot;/mnt/hgfs/VMWARE/test/10-http/temp/post.html&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令：</p><pre><code>gcc  get_post.c  -o get_post –lcurl./ get_post</code></pre><p>得到结果：<br>略</p><h6 id="2-获取html网页"><a href="#2-获取html网页" class="headerlink" title="2. 获取html网页"></a>2. 获取html网页</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    CURL *curl;             //定义CURL类型的指针</span><br><span class="line">    CURLcode res;           //定义CURLcode类型的变量，保存返回状态码</span><br><span class="line">    if(argc!=2)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Usage : file &lt;url&gt;;\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    curl = curl_easy_init();        //初始化一个CURL类型的指针</span><br><span class="line">    if(curl!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        //设置curl选项. 其中CURLOPT_URL是让用户指 定url. argv[1]中存放的命令行传进来的网址</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_URL, argv[1]);        </span><br><span class="line">        //调用curl_easy_perform 执行我们的设置.并进行相关的操作. 在这 里只在屏幕上显示出来.</span><br><span class="line">        res = curl_easy_perform(curl);</span><br><span class="line">        //清除curl操作.</span><br><span class="line">        curl_easy_cleanup(curl);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令：</p><pre><code>gcc  get_http.c  -o get_http –lcurl./get_http www.baidu.com</code></pre><h6 id="3-网页下载保存实例"><a href="#3-网页下载保存实例" class="headerlink" title="3. 网页下载保存实例"></a>3. 网页下载保存实例</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 采用CURLOPT_WRITEFUNCTION 实现网页下载保存功能</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;;</span><br><span class="line"> </span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line">#include &lt;curl/types.h&gt;</span><br><span class="line">#include &lt;curl/easy.h&gt;</span><br><span class="line"> </span><br><span class="line">FILE *fp;  //定义FILE类型指针</span><br><span class="line">//这个函数是为了符合CURLOPT_WRITEFUNCTION而构造的</span><br><span class="line">//完成数据保存功能</span><br><span class="line">size_t write_data(void *ptr, size_t size, size_t nmemb, void *stream)  </span><br><span class="line">&#123;</span><br><span class="line">    int written = fwrite(ptr, size, nmemb, (FILE *)fp);</span><br><span class="line">    return written;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    CURL *curl;</span><br><span class="line"> </span><br><span class="line">    curl_global_init(CURL_GLOBAL_ALL);  </span><br><span class="line">    curl=curl_easy_init();</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL, argv[1]);  </span><br><span class="line"> </span><br><span class="line">    if((fp=fopen(argv[2],&quot;w&quot;))==NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        curl_easy_cleanup(curl);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    ////CURLOPT_WRITEFUNCTION 将后继的动作交给write_data函数处理</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);  </span><br><span class="line">    curl_easy_perform(curl);</span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令：</p><pre><code>gcc  save_http.c  -o save_http –lcurl./ save_http www.baidu.com/tmp/baidu</code></pre><h6 id="4-进度条实例显示文件下载进度"><a href="#4-进度条实例显示文件下载进度" class="headerlink" title="4.进度条实例显示文件下载进度"></a>4.进度条实例显示文件下载进度</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">// 采用CURLOPT_NOPROGRESS， CURLOPT_PROGRESSFUNCTION    CURLOPT_PROGRESSDATA 实现文件传输进度提示功能</span><br><span class="line">//函数采用了gtk库，故编译时需指定gtk库</span><br><span class="line">//函数启动专门的线程用于显示gtk 进度条bar</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;gtk/gtk.h&gt;</span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line">#include &lt;curl/types.h&gt; /* new for v7 */</span><br><span class="line">#include &lt;curl/easy.h&gt; /* new for v7 */</span><br><span class="line"> </span><br><span class="line">GtkWidget *Bar;</span><br><span class="line">////这个函数是为了符合CURLOPT_WRITEFUNCTION而构造的</span><br><span class="line">//完成数据保存功能</span><br><span class="line">size_t my_write_func(void *ptr, size_t size, size_t nmemb, FILE *stream)</span><br><span class="line">&#123;</span><br><span class="line">  return fwrite(ptr, size, nmemb, stream);</span><br><span class="line">&#125;</span><br><span class="line">//这个函数是为了符合CURLOPT_READFUNCTION而构造的</span><br><span class="line">//数据上传时使用</span><br><span class="line">size_t my_read_func(void *ptr, size_t size, size_t nmemb, FILE *stream)</span><br><span class="line">&#123;</span><br><span class="line">  return fread(ptr, size, nmemb, stream);</span><br><span class="line">&#125;</span><br><span class="line">//这个函数是为了符合CURLOPT_PROGRESSFUNCTION而构造的</span><br><span class="line">//显示文件传输进度，t代表文件大小，d代表传 输已经完成部分</span><br><span class="line">int my_progress_func(GtkWidget *bar,</span><br><span class="line">                     double t, /* dltotal */</span><br><span class="line">                     double d, /* dlnow */</span><br><span class="line">                     double ultotal,</span><br><span class="line">                     double ulnow)</span><br><span class="line">&#123;</span><br><span class="line">/*  printf(&quot;%d / %d (%g %%)\n&quot;, d, t, d*100.0/t);*/</span><br><span class="line">  gdk_threads_enter();</span><br><span class="line">  gtk_progress_set_value(GTK_PROGRESS(bar), d*100.0/t);</span><br><span class="line">  gdk_threads_leave();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void *my_thread(void *ptr)</span><br><span class="line">&#123;</span><br><span class="line">  CURL *curl;</span><br><span class="line">  CURLcode res;</span><br><span class="line">  FILE *outfile;</span><br><span class="line">  gchar *url = ptr;</span><br><span class="line"> </span><br><span class="line">  curl = curl_easy_init();</span><br><span class="line">  if(curl)</span><br><span class="line">  &#123;</span><br><span class="line">    outfile = fopen(&quot;test.curl&quot;, &quot;w&quot;);</span><br><span class="line"> </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL, url);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEDATA, outfile);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, my_write_func);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_READFUNCTION, my_read_func);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 0L);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_PROGRESSFUNCTION, my_progress_func);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_PROGRESSDATA, Bar);</span><br><span class="line"> </span><br><span class="line">    res = curl_easy_perform(curl);</span><br><span class="line"> </span><br><span class="line">    fclose(outfile);</span><br><span class="line">    /* always cleanup */</span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">  GtkWidget *Window, *Frame, *Frame2;</span><br><span class="line">  GtkAdjustment *adj;</span><br><span class="line"> </span><br><span class="line">  /* Must initialize libcurl before any threads are started */</span><br><span class="line">  curl_global_init(CURL_GLOBAL_ALL);</span><br><span class="line"> </span><br><span class="line">  /* Init thread */</span><br><span class="line">  g_thread_init(NULL);</span><br><span class="line"> </span><br><span class="line">  gtk_init(&amp;argc, &amp;argv);</span><br><span class="line">  Window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</span><br><span class="line">  Frame = gtk_frame_new(NULL);</span><br><span class="line">  gtk_frame_set_shadow_type(GTK_FRAME(Frame), GTK_SHADOW_OUT);</span><br><span class="line">  gtk_container_add(GTK_CONTAINER(Window), Frame);</span><br><span class="line">  Frame2 = gtk_frame_new(NULL);</span><br><span class="line">  gtk_frame_set_shadow_type(GTK_FRAME(Frame2), GTK_SHADOW_IN);</span><br><span class="line">  gtk_container_add(GTK_CONTAINER(Frame), Frame2);</span><br><span class="line">  gtk_container_set_border_width(GTK_CONTAINER(Frame2), 5);</span><br><span class="line">  adj = (GtkAdjustment*)gtk_adjustment_new(0, 0, 100, 0, 0, 0);</span><br><span class="line">  Bar = gtk_progress_bar_new_with_adjustment(adj);</span><br><span class="line">  gtk_container_add(GTK_CONTAINER(Frame2), Bar);</span><br><span class="line">  gtk_widget_show_all(Window);</span><br><span class="line"> </span><br><span class="line">  if (!g_thread_create(&amp;my_thread, argv[1], FALSE, NULL) != 0)</span><br><span class="line">    g_warning(&quot;can&apos;t create the thread&quot;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  gdk_threads_enter();</span><br><span class="line">  gtk_main();</span><br><span class="line">  gdk_threads_leave();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令：</p><pre><code>export PKG_CONFIG_PATH=/usr/lib/pkgconfig/gcc progress.c –o progress ` pkg-config --libs –cflags gtk+-2..0` -lcurl –lgthread-2.0./ progress  http://software.sky-union.cn/index.asp</code></pre><h6 id="5-断点续传实例"><a href="#5-断点续传实例" class="headerlink" title="5.断点续传实例"></a>5.断点续传实例</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">//采用CURLOPT_RESUME_FROM_LARGE 实现文件断点续传功能</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line"> </span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line">//这个函数为CURLOPT_HEADERFUNCTION参数构造</span><br><span class="line">/* 从http头部获取文件size*/</span><br><span class="line">size_t getcontentlengthfunc(void *ptr, size_t size, size_t nmemb, void *stream) &#123;</span><br><span class="line">       int r;</span><br><span class="line">       long len = 0;</span><br><span class="line"> </span><br><span class="line">       /* _snscanf() is Win32 specific */</span><br><span class="line">       // r = _snscanf(ptr, size * nmemb, &quot;Content-Length: %ld\n&quot;, &amp;len);</span><br><span class="line"> r = sscanf(ptr, &quot;Content-Length: %ld\n&quot;, &amp;len);</span><br><span class="line">       if (r) /* Microsoft: we don&apos;t read the specs */</span><br><span class="line">              *((long *) stream) = len;</span><br><span class="line"> </span><br><span class="line">       return size * nmemb;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* 保存下载文件 */</span><br><span class="line">size_t wirtefunc(void *ptr, size_t size, size_t nmemb, void *stream)</span><br><span class="line">&#123;</span><br><span class="line">        return fwrite(ptr, size, nmemb, stream);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/*读取上传文件 */</span><br><span class="line">size_t readfunc(void *ptr, size_t size, size_t nmemb, void *stream)</span><br><span class="line">&#123;</span><br><span class="line">       FILE *f = stream;</span><br><span class="line">       size_t n;</span><br><span class="line"> </span><br><span class="line">       if (ferror(f))</span><br><span class="line">              return CURL_READFUNC_ABORT;</span><br><span class="line"> </span><br><span class="line">       n = fread(ptr, size, nmemb, f) * size;</span><br><span class="line"> </span><br><span class="line">       return n;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 下载 或者上传文件函数</span><br><span class="line">int download(CURL *curlhandle, const char * remotepath, const char * localpath,</span><br><span class="line">           long timeout, long tries)</span><br><span class="line">&#123;</span><br><span class="line">       FILE *f;</span><br><span class="line">       curl_off_t local_file_len = -1 ;</span><br><span class="line">       long filesize =0 ;</span><br><span class="line">       </span><br><span class="line">       CURLcode r = CURLE_GOT_NOTHING;</span><br><span class="line">       int c;</span><br><span class="line">  struct stat file_info;</span><br><span class="line">  int use_resume = 0;</span><br><span class="line">  /* 得到本地文件大小 */</span><br><span class="line">  //if(access(localpath,F_OK) ==0)</span><br><span class="line">  </span><br><span class="line">    if(stat(localpath, &amp;file_info) == 0) </span><br><span class="line">     &#123;</span><br><span class="line">        local_file_len =  file_info.st_size;</span><br><span class="line">        use_resume  = 1;</span><br><span class="line">      &#125;</span><br><span class="line">  //采用追加方式打开文件，便于实现文件断点续传工作</span><br><span class="line">       f = fopen(localpath, &quot;ab+&quot;); </span><br><span class="line">       if (f == NULL) &#123;</span><br><span class="line">              perror(NULL);</span><br><span class="line">              return 0;</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">       //curl_easy_setopt(curlhandle, CURLOPT_UPLOAD, 1L);</span><br><span class="line"> </span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_URL, remotepath);</span><br><span class="line"> </span><br><span class="line">              curl_easy_setopt(curlhandle, CURLOPT_CONNECTTIMEOUT, timeout);  // 设置连接超时，单位秒</span><br><span class="line">       //设置http 头部处理函数</span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_HEADERFUNCTION, getcontentlengthfunc);</span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_HEADERDATA, &amp;filesize);</span><br><span class="line"> // 设置文件续传的位置给libcurl</span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_RESUME_FROM_LARGE, use_resume?local_file_len:0);</span><br><span class="line"> </span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_WRITEDATA, f);</span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_WRITEFUNCTION, wirtefunc);</span><br><span class="line"> </span><br><span class="line">       //curl_easy_setopt(curlhandle, CURLOPT_READFUNCTION, readfunc);</span><br><span class="line">       //curl_easy_setopt(curlhandle, CURLOPT_READDATA, f);</span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_NOPROGRESS, 1L);</span><br><span class="line">       curl_easy_setopt(curlhandle, CURLOPT_VERBOSE, 1L);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  r = curl_easy_perform(curlhandle);</span><br><span class="line">       </span><br><span class="line"> </span><br><span class="line">       fclose(f);</span><br><span class="line"> </span><br><span class="line">       if (r == CURLE_OK)</span><br><span class="line"></span><br><span class="line">              return 1;</span><br><span class="line">       else &#123;</span><br><span class="line">              fprintf(stderr, &quot;%s\n&quot;, curl_easy_strerror(r));</span><br><span class="line">              return 0;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int c, char **argv) &#123;</span><br><span class="line">       CURL *curlhandle = NULL;</span><br><span class="line"> </span><br><span class="line">       curl_global_init(CURL_GLOBAL_ALL);</span><br><span class="line">       curlhandle = curl_easy_init();</span><br><span class="line"> </span><br><span class="line">       //download(curlhandle, &quot;ftp://user:pass@host/path/file&quot;, &quot;C:\\file&quot;, 0, 3);</span><br><span class="line">  download(curlhandle , &quot;http://software.sky-union.cn/index.asp&quot;,&quot;/mnt/hgfs/VMWARE/test/10-http/temp/index.asp&quot;,1,3);</span><br><span class="line">       curl_easy_cleanup(curlhandle);</span><br><span class="line">       curl_global_cleanup();</span><br><span class="line"> </span><br><span class="line">       return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令：</p><pre><code>gcc  resume.c  -o resume –lcurl./ resume  </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;一、LibCurl基本编程框架&quot;&gt;&lt;a href=&quot;#一、LibCurl基本编程框架&quot; class=&quot;headerlink&quot; title=&quot;一、LibCurl基本编程框架&quot;&gt;&lt;/a&gt;一、LibCurl基本编程框架&lt;/h5&gt;&lt;p&gt;关于libcurl，&lt;a href=&quot;https://www.faihung.net/2019/11/03/cURL-01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BA%86%E8%A7%A3/&quot;&gt;前面已经有了很多介绍&lt;/a&gt;，这里就不详西描述了。&lt;/p&gt;
&lt;p&gt;在基于LibCurl的程序里，主要采用callback function （回调函数）的形式完成传输任务，用户在启动传输前设置好各类参数和回调函数，当满足条件时libcurl将调用用户的回调函数实现特定功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="cURL" scheme="http://www.faihung.net/categories/cURL/"/>
    
    
      <category term="cURL" scheme="http://www.faihung.net/tags/cURL/"/>
    
  </entry>
  
  <entry>
    <title>cURL-08_ARM交叉编译</title>
    <link href="http://www.faihung.net/2019/12/12/cURL-08-ARM%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"/>
    <id>http://www.faihung.net/2019/12/12/cURL-08-ARM交叉编译/</id>
    <published>2019-12-12T06:24:59.000Z</published>
    <updated>2019-12-12T06:25:53.992Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.faihung.net/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/">前面</a>提到过libcurl在Ubuntu环境下的编译安装，本章主要是嵌入式环境下的ARM交叉编译</p><p>执行<a href="https://www.faihung.net/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/">前面</a>的操作之后，进行arm的交叉编译</p><pre><code>./configure --host=arm-himix200-linux CC=arm-himix200-linux-gcc CXX=arm-himix200-linux-g++ </code></pre><a id="more"></a><p>交叉编译，说实话整了好几个小时没怎么明白，不知道为什么不行。</p><p>但是，我把原有工程的的cURL模块拆分出来，修改了Makefile之后，可以交叉编译可以在设备中运行。</p><p>目前关于cURL的交叉编译就告一段落，之后有时间在研究编译。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.faihung.net/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/&quot;&gt;前面&lt;/a&gt;提到过libcurl在Ubuntu环境下的编译安装，本章主要是嵌入式环境下的ARM交叉编译&lt;/p&gt;
&lt;p&gt;执行&lt;a href=&quot;https://www.faihung.net/2019/12/08/cURL-06-cURL%E5%92%8Clibcuel%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%AE%89%E8%A3%85%E9%80%94%E5%BE%84/&quot;&gt;前面&lt;/a&gt;的操作之后，进行arm的交叉编译&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./configure --host=arm-himix200-linux CC=arm-himix200-linux-gcc CXX=arm-himix200-linux-g++ &lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="cURL" scheme="http://www.faihung.net/categories/cURL/"/>
    
    
      <category term="cURL" scheme="http://www.faihung.net/tags/cURL/"/>
    
  </entry>
  
  <entry>
    <title>cURL-07_Linux下使用libcurl实现FTP文件上传下载功能</title>
    <link href="http://www.faihung.net/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/"/>
    <id>http://www.faihung.net/2019/12/08/cURL-07-Linux下使用libcurl实现FTP文件上传下载功能/</id>
    <published>2019-12-08T10:24:54.000Z</published>
    <updated>2019-12-31T07:43:50.080Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Linux下使用libcurl实现FTP单个文件或者压缩包上传下载功能</p></blockquote><a id="more"></a><h5 id="一、关于FTP"><a href="#一、关于FTP" class="headerlink" title="一、关于FTP"></a>一、关于FTP</h5><p>参考：<br><a href="https://www.faihung.net/2019/12/07/%E5%B7%A5%E5%85%B7-%E5%9C%A8WIN10%E4%B8%8A%E6%90%AD%E5%BB%BAFtp%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E8%BD%AC%EF%BC%89/">在WIN10上搭建Ftp服务器</a></p><h5 id="二、FTP上传"><a href="#二、FTP上传" class="headerlink" title="二、FTP上传"></a>二、FTP上传</h5><p>该FTP上传代码为官网上的<a href="https://curl.haxx.se/libcurl/c/example.html" target="_blank" rel="noopener">demo</a>例程代码，若要为己所用，只需将宏定义修改并准备一个要上传的文件即可。当然，该函数只能上传一个文件或者压缩包至FTP服务器，若要上传多个文件，可以在此例程上进行修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#ifdef WIN32</span><br><span class="line">#include &lt;io.h&gt;</span><br><span class="line">#else</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define LOCAL_FILE      &quot;/mnt/hgfs/VMWARE/test/8-curl/1206.rar&quot; //要上传的文件</span><br><span class="line">#define UPLOAD_FILE_AS  &quot;while-uploading.txt&quot;</span><br><span class="line">#define REMOTE_URL      &quot;ftp://192.168.31.175/&quot;  UPLOAD_FILE_AS //FTP服务器地址</span><br><span class="line">#define RENAME_FILE_TO  &quot;1206.rar&quot;//最终写入到这个文件名中</span><br><span class="line"></span><br><span class="line">static size_t read_callback(void *ptr, size_t size, size_t nmemb, void *stream)</span><br><span class="line">&#123;</span><br><span class="line">  curl_off_t nread;</span><br><span class="line"></span><br><span class="line">  size_t retcode = fread(ptr, size, nmemb, stream);</span><br><span class="line"></span><br><span class="line">  nread = (curl_off_t)retcode;</span><br><span class="line"></span><br><span class="line">  fprintf(stderr, &quot; We read %&quot; CURL_FORMAT_CURL_OFF_T</span><br><span class="line">          &quot; bytes from file\n&quot;, nread);</span><br><span class="line">  return retcode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">  CURL *curl;</span><br><span class="line">  CURLcode res;</span><br><span class="line">  FILE *hd_src;</span><br><span class="line">  struct stat file_info;</span><br><span class="line">  curl_off_t fsize;</span><br><span class="line"></span><br><span class="line">  struct curl_slist *headerlist = NULL;</span><br><span class="line">  static const char buf_1 [] = &quot;RNFR &quot; UPLOAD_FILE_AS;</span><br><span class="line">  static const char buf_2 [] = &quot;RNTO &quot; RENAME_FILE_TO;</span><br><span class="line"></span><br><span class="line">  /* 获得上传文件的大小 */ </span><br><span class="line">  if(stat(LOCAL_FILE, &amp;file_info)) &#123;</span><br><span class="line">    printf(&quot;Couldn&apos;t open &apos;%s&apos;: %s\n&quot;, LOCAL_FILE, strerror(errno));</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  fsize = (curl_off_t)file_info.st_size;</span><br><span class="line"></span><br><span class="line">  printf(&quot;Local file size: %&quot; CURL_FORMAT_CURL_OFF_T &quot; bytes.\n&quot;, fsize);</span><br><span class="line"></span><br><span class="line">  /* 获得FILE类型变量 */ </span><br><span class="line">  hd_src = fopen(LOCAL_FILE, &quot;rb&quot;);</span><br><span class="line"></span><br><span class="line">  /* 初始化 */ </span><br><span class="line">  curl_global_init(CURL_GLOBAL_ALL);</span><br><span class="line"></span><br><span class="line">  /* 获得curl操作符 */ </span><br><span class="line">  curl = curl_easy_init();</span><br><span class="line">  if(curl) &#123;</span><br><span class="line">    /*建立一个传递给libcurl的命令列表 */ </span><br><span class="line">    headerlist = curl_slist_append(headerlist, buf_1);</span><br><span class="line">    headerlist = curl_slist_append(headerlist, buf_2);</span><br><span class="line"></span><br><span class="line">    /* 使用curl提供的Read功能 */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_READFUNCTION, read_callback);</span><br><span class="line"></span><br><span class="line">    /* 上传使能 */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_UPLOAD, 1L);</span><br><span class="line"></span><br><span class="line">    /* 设置特定目标 */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL, REMOTE_URL);</span><br><span class="line"></span><br><span class="line">    /* 传递最后一个FTP命令以在传输后运行 */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_POSTQUOTE, headerlist);</span><br><span class="line"></span><br><span class="line">    /*指定上传文件 */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_READDATA, hd_src);</span><br><span class="line"></span><br><span class="line">    /*设置要上传的文件的大小（可选） */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_INFILESIZE_LARGE,</span><br><span class="line">                     (curl_off_t)fsize);</span><br><span class="line"></span><br><span class="line">    /* 运行 */ </span><br><span class="line">    res = curl_easy_perform(curl);</span><br><span class="line">    /* 容错处理 */ </span><br><span class="line">    if(res != CURLE_OK)</span><br><span class="line">      fprintf(stderr, &quot;curl_easy_perform() failed: %s\n&quot;,</span><br><span class="line">              curl_easy_strerror(res));</span><br><span class="line"></span><br><span class="line">    /* 清除FTP命令列表 */ </span><br><span class="line">    curl_slist_free_all(headerlist);</span><br><span class="line"></span><br><span class="line">    /*释放所有curl资源 */ </span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(hd_src); /*关闭本地文件 */ </span><br><span class="line"></span><br><span class="line">  /*释放所有curl资源 */ </span><br><span class="line">  curl_global_cleanup();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存代码，文件名命名为“ftpupload.c”，并在/mnt/hgfs/VMWARE/test/8-curl文件夹中准备“1206.rar”文件（即代码中指定的要上传的文件名），使用gcc编译，编译指令：</p><pre><code>gcc -o ftpupload ftpupload.c -lcurl</code></pre><p>执行结果：</p><p><img src="/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/1.png" alt="1"></p><p>上传前的代码：</p><p><img src="/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/2.png" alt="2"></p><p>上传到FTP服务器之后：</p><p><img src="/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/3.png" alt="3"></p><p>至此，上传功能完成。</p><h5 id="三、FTP下载"><a href="#三、FTP下载" class="headerlink" title="三、FTP下载"></a>三、FTP下载</h5><p>同样，该FTP下载代码为官网上的<a href="https://curl.haxx.se/libcurl/c/example.html" target="_blank" rel="noopener">demo</a>例程代码，若要为己所用，只需将宏定义修改并指定一个要下载的文件即可。当然，该函数只能下载一个文件或者压缩包至FTP客户端，若要下载多个文件，可以在此例程上进行修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;curl/curl.h&gt;</span><br><span class="line"></span><br><span class="line">struct FtpFile &#123;</span><br><span class="line">  const char *filename;</span><br><span class="line">  FILE *stream;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static size_t my_fwrite(void *buffer, size_t size, size_t nmemb, void *stream)</span><br><span class="line">&#123;</span><br><span class="line">  struct FtpFile *out = (struct FtpFile *)stream;</span><br><span class="line">  if(out &amp;&amp; !out-&gt;stream) &#123;</span><br><span class="line">    /* 打开文件以进行写操作 */ </span><br><span class="line">    out-&gt;stream = fopen(out-&gt;filename, &quot;wb&quot;);</span><br><span class="line">    if(!out-&gt;stream)</span><br><span class="line">      return -1; /* failure, can&apos;t open file to write */ </span><br><span class="line">  &#125;</span><br><span class="line">  return fwrite(buffer, size, nmemb, out-&gt;stream);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">  CURL *curl;</span><br><span class="line">  CURLcode res;</span><br><span class="line">  struct FtpFile ftpfile = &#123;</span><br><span class="line">    &quot;/mnt/hgfs/VMWARE/test/8-curl/1208.rar&quot;, /* 若FTP下载成功，名命下载后的文件为&quot;curl.txt&quot; */ </span><br><span class="line">    NULL</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  curl_global_init(CURL_GLOBAL_DEFAULT);</span><br><span class="line"></span><br><span class="line">  curl = curl_easy_init();</span><br><span class="line">  if(curl) &#123;</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL,</span><br><span class="line">                     &quot;ftp://192.168.31.175/1208.rar&quot;);//下载指定的文件</span><br><span class="line">    /* 定义回调函数，以便在需要写入数据时进行调用 */ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, my_fwrite);</span><br><span class="line">    /*设置一个指向我们的结构的指针传递给回调函数*/ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;ftpfile);</span><br><span class="line"></span><br><span class="line">    /* 打开完整的协议/调试输出*/ </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);</span><br><span class="line"></span><br><span class="line">    res = curl_easy_perform(curl);</span><br><span class="line"></span><br><span class="line">    /* 释放所有curl资源*/ </span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line"></span><br><span class="line">    if(CURLE_OK != res) &#123;</span><br><span class="line">      /*容错处理 */ </span><br><span class="line">      fprintf(stderr, &quot;curl told us %d\n&quot;, res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(ftpfile.stream)</span><br><span class="line">    fclose(ftpfile.stream); /* 关闭本地文件 */ </span><br><span class="line"> /*释放所有curl资源*/</span><br><span class="line">  curl_global_cleanup();</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用gcc编译，编译指令：</p><pre><code>gcc -o ftpDown ftpDown.c -lcurl</code></pre><p>执行结果：</p><p><img src="/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/4.png" alt="4"></p><p>下载之前，放在FTP服务器中时：</p><p><img src="/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/5.png" alt="5"></p><p>下载之后，放在本地文件中中时：</p><p><img src="/2019/12/08/cURL-07-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8libcurl%E5%AE%9E%E7%8E%B0FTP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/6.png" alt="6"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Linux下使用libcurl实现FTP单个文件或者压缩包上传下载功能&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="cURL" scheme="http://www.faihung.net/categories/cURL/"/>
    
    
      <category term="cURL" scheme="http://www.faihung.net/tags/cURL/"/>
    
  </entry>
  
</feed>
