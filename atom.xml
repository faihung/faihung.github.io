<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Faihung&#39;s blog</title>
  
  <subtitle>作者：faihung</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.faihung.net/"/>
  <updated>2019-11-03T15:40:24.521Z</updated>
  <id>http://www.faihung.net/</id>
  
  <author>
    <name>faihung</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cURL-02_在命令行中使用cURL</title>
    <link href="http://www.faihung.net/2019/11/03/cURL-02-%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E4%BD%BF%E7%94%A8cURL/"/>
    <id>http://www.faihung.net/2019/11/03/cURL-02-在命令行中使用cURL/</id>
    <published>2019-11-03T15:38:29.000Z</published>
    <updated>2019-11-03T15:40:24.521Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、获取和安装-cURL-libcurl"><a href="#一、获取和安装-cURL-libcurl" class="headerlink" title="一、获取和安装 cURL/libcurl"></a>一、获取和安装 cURL/libcurl</h4><p>获取和安装 libcurl 非常简单，取决于您所运行的 Linux 发行版。如果运行的是 Ubuntu，您可以使用 apt-get轻松安装这些包。以下行演示了如何为 libcurl 安装 libcurl 和 Python 绑定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libcurl3</span><br><span class="line">$ sudo apt-get install python-pycurl</span><br></pre></td></tr></table></figure><blockquote><p>apt-get实用工具确保该过程满足所有的依赖关系。</p></blockquote><a id="more"></a><h4 id="二、相对简单的用法"><a href="#二、相对简单的用法" class="headerlink" title="二、相对简单的用法"></a>二、相对简单的用法</h4><h5 id="1-从百度的网页服务器上获得该网站的主页："><a href="#1-从百度的网页服务器上获得该网站的主页：" class="headerlink" title="1. 从百度的网页服务器上获得该网站的主页："></a>1. 从百度的网页服务器上获得该网站的主页：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://www.baidu.com/</span><br></pre></td></tr></table></figure><p>如果要把这个网页保存下来，可以使用<code>-o</code>参数，这就相当于使用wget命令了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -o [文件名] www.baidu.com</span><br></pre></td></tr></table></figure><h5 id="2-自动跳转"><a href="#2-自动跳转" class="headerlink" title="2. 自动跳转"></a>2. 自动跳转</h5><p>有的网址是自动跳转的。使用<code>-L</code>参数，curl就会跳转到新的网址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L www.baidu.com</span><br></pre></td></tr></table></figure><p>输入上面的命令，结果就自动跳转为<a href="http://www.baidu.com。" target="_blank" rel="noopener">www.baidu.com。</a></p><h5 id="3-显示头信息"><a href="#3-显示头信息" class="headerlink" title="3. 显示头信息"></a>3. 显示头信息</h5><p><code>-i</code>参数可以显示http response的头信息，连同网页代码一起。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i www.baidu.com</span><br></pre></td></tr></table></figure><p><code>-I</code>参数则是只显示http response的头信息。</p><h5 id="4-显示通信过程"><a href="#4-显示通信过程" class="headerlink" title="4. 显示通信过程"></a>4. 显示通信过程</h5><p><code>-v</code>参数可以显示一次http通信的整个过程，包括端口连接和http request头信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -v www.baidu.com</span><br></pre></td></tr></table></figure><p>如果你觉得上面的信息还不够，那么下面的命令可以查看更详细的通信过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --trace output.txt www.baidu.com</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --trace-ascii output.txt www.baidu.com</span><br></pre></td></tr></table></figure><p>运行后，请打开output.txt文件查看。</p><h5 id="5-发送表单信息"><a href="#5-发送表单信息" class="headerlink" title="5. 发送表单信息"></a>5. 发送表单信息</h5><p>发送表单信息有GET和POST两种方法。GET方法相对简单，只要把数据附在网址后面就行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl example.com/form.cgi?data=xxx</span><br></pre></td></tr></table></figure><p>POST方法必须把数据和网址分开，curl就要用到–data参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X POST --data &quot;data=xxx&quot; example.com/form.cgi</span><br></pre></td></tr></table></figure><p>如果你的数据没有经过表单编码，还可以让curl为你编码，参数是<code>--data-urlencode</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X POST--data-urlencode &quot;date=April 1&quot; example.com/form.cgi</span><br></pre></td></tr></table></figure><h5 id="6-HTTP动词"><a href="#6-HTTP动词" class="headerlink" title="6. HTTP动词"></a>6. HTTP动词</h5><p>curl默认的HTTP动词是GET，使用<code>-X</code>参数可以支持其他动词。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X POST www.example.com</span><br><span class="line">$ curl -X DELETE www.example.com</span><br></pre></td></tr></table></figure><h5 id="7-文件上传"><a href="#7-文件上传" class="headerlink" title="7. 文件上传"></a>7. 文件上传</h5><p>假定文件上传的表单是下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=&quot;POST&quot; enctype=&apos;multipart/form-data&apos; action=&quot;upload.cgi&quot;&gt;</span><br><span class="line">&lt;input type=file name=upload&gt;</span><br><span class="line">&lt;input type=submit name=press value=&quot;OK&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>你可以用curl这样上传文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --form upload=@localfilename --form press=OK [URL]</span><br></pre></td></tr></table></figure><h5 id="8-Referer字段"><a href="#8-Referer字段" class="headerlink" title="8. Referer字段"></a>8. Referer字段</h5><p>有时你需要在http request头信息中，提供一个referer字段，表示你是从哪里跳转过来的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --referer http://www.example.com http://www.example.com</span><br></pre></td></tr></table></figure><h5 id="9-User-Agent字段"><a href="#9-User-Agent字段" class="headerlink" title="9. User Agent字段"></a>9. User Agent字段</h5><p>这个字段是用来表示客户端的设备信息。服务器有时会根据这个字段，针对不同设备，返回不同格式的网页，比如手机版和桌面版。</p><p>iPhone4的User Agent是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_0 like Mac OS X; en-us) AppleWebKit/532.9 (KHTML, like Gecko) Version/4.0.5 Mobile/8A293 Safari/6531.22.7</span><br></pre></td></tr></table></figure><p>curl可以这样模拟：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --user-agent &quot;[User Agent]&quot; [URL]</span><br></pre></td></tr></table></figure><h5 id="10-cookie"><a href="#10-cookie" class="headerlink" title="10. cookie"></a>10. cookie</h5><p>使用<code>--cookie</code>参数，可以让curl发送cookie。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --cookie &quot;name=xxx&quot; www.example.com</span><br></pre></td></tr></table></figure><p>至于具体的cookie的值，可以从http response头信息的<code>Set-Cookie</code>字段中得到。</p><p><code>-c cookie-file</code>可以保存服务器返回的cookie到文件，<code>-b cookie-file</code>可以使用这个文件作为cookie信息，进行后续的请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -c cookies http://example.com</span><br><span class="line">$ curl -b cookies http://example.com</span><br></pre></td></tr></table></figure><h5 id="11-增加头信息"><a href="#11-增加头信息" class="headerlink" title="11. 增加头信息"></a>11. 增加头信息</h5><p>有时需要在http request之中，自行增加一个头信息。<code>--header</code>参数就可以起到这个作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --header &quot;Content-Type:application/json&quot; http://example.com</span><br></pre></td></tr></table></figure><h5 id="12-HTTP认证"><a href="#12-HTTP认证" class="headerlink" title="12. HTTP认证"></a>12. HTTP认证</h5><p>有些网域需要HTTP认证，这时curl需要用到<code>--user</code>参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --user name:password example.com</span><br></pre></td></tr></table></figure><h5 id="13-cURL还有很多命令行操作，这里就不作陈诉了。"><a href="#13-cURL还有很多命令行操作，这里就不作陈诉了。" class="headerlink" title="13. cURL还有很多命令行操作，这里就不作陈诉了。"></a>13. cURL还有很多命令行操作，这里就不作陈诉了。</h5>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、获取和安装-cURL-libcurl&quot;&gt;&lt;a href=&quot;#一、获取和安装-cURL-libcurl&quot; class=&quot;headerlink&quot; title=&quot;一、获取和安装 cURL/libcurl&quot;&gt;&lt;/a&gt;一、获取和安装 cURL/libcurl&lt;/h4&gt;&lt;p&gt;获取和安装 libcurl 非常简单，取决于您所运行的 Linux 发行版。如果运行的是 Ubuntu，您可以使用 apt-get轻松安装这些包。以下行演示了如何为 libcurl 安装 libcurl 和 Python 绑定：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo apt-get install libcurl3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo apt-get install python-pycurl&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;apt-get实用工具确保该过程满足所有的依赖关系。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="cURL" scheme="http://www.faihung.net/categories/cURL/"/>
    
    
      <category term="cURL" scheme="http://www.faihung.net/tags/cURL/"/>
    
  </entry>
  
  <entry>
    <title>sscanf()函数使用详解</title>
    <link href="http://www.faihung.net/2019/11/03/sscanf-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.faihung.net/2019/11/03/sscanf-函数使用详解/</id>
    <published>2019-11-03T10:47:58.000Z</published>
    <updated>2019-11-03T10:50:24.994Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、描述："><a href="#一、描述：" class="headerlink" title="一、描述："></a>一、描述：</h4><p>sscanf通常被用来解析并转换字符串，其格式定义灵活多变，可以实现很强大的字符串解析功能。</p><p>sscanf的原型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int sscanf(const char *str, const char *format, ...);</span><br></pre></td></tr></table></figure><a id="more"></a><p>str:待解析的字符串;</p><p>format:字符串格式描述;</p><p>其后是一序列数目不定的指针参数，存储解析后的数据.</p><h4 id="二、示例用法："><a href="#二、示例用法：" class="headerlink" title="二、示例用法："></a>二、示例用法：</h4><h5 id="sscanf的基本用法"><a href="#sscanf的基本用法" class="headerlink" title="sscanf的基本用法"></a>sscanf的基本用法</h5><h6 id="整形数转换"><a href="#整形数转换" class="headerlink" title="整形数转换"></a>整形数转换</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int year, month, day;</span><br><span class="line"></span><br><span class="line">int converted = sscanf(&quot;20191103&quot;, &quot;%04d%02d%02d&quot;, &amp;year, &amp;month, &amp;day);</span><br><span class="line">printf(&quot;converted=%d, year=%d, month=%d, day=%d/n&quot;, converted, year, month, day);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">converted=3, year=2019, month=11, day=03</span><br></pre></td></tr></table></figure><p>“%04d%02d%02d”是用来解析字符串的格式，%表示格式转换的开始，d表示转换为一个整数，04作为d的修饰，表示这是一个长度为4位的整数，不足4位时以0补齐。</p><p>例子返回结果等于3，表示有3个数据成功转换，转换成功数目同时取决于被解析的字符串以及其转换格式，如果我们把例子中的格式改为”%04d%02d”，那么sscanf将只返回2，day的数值不会被sscanf更改。</p><h6 id="浮点数转换"><a href="#浮点数转换" class="headerlink" title="浮点数转换"></a>浮点数转换</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double longitude, latitude;</span><br><span class="line">int converted = sscanf(&quot;113.123456789 31.123456789&quot;, &quot;%lf %lf&quot;, &amp;longitude, &amp;latitude);</span><br><span class="line">printf(&quot;converted=%d, longitude=%.9lf, latitude=%lf/n&quot;, converted, longitude, latitude);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">converted=2, longitude=113.123456789, latitude=31.123457</span><br></pre></td></tr></table></figure><p>sscanf的格式字符串中，f表示这是一个浮点数，其修饰词l表示这是一个double的浮点数。</p><h5 id="sscanf的高级用法"><a href="#sscanf的高级用法" class="headerlink" title="sscanf的高级用法"></a>sscanf的高级用法</h5><h6 id="数字-字符串"><a href="#数字-字符串" class="headerlink" title="数字+字符串"></a>数字+字符串</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char str[32] = &quot;&quot;;</span><br><span class="line">sscanf(&quot;123456abcdedf&quot;, &quot;%31[0-9]&quot;, str);</span><br><span class="line">printf(&quot;str=%s/n&quot;, str);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str=123456</span><br></pre></td></tr></table></figure><p>上面的格式中，[0-9]表示这是一个仅包含0-9这几个字符的字符串，==前面使用数字31修饰词表示这个字符串缓冲区的最大长度(这也是sscanf最为人诟病的地方，很容易出现缓冲区溢出错误，实际上sscanf是可以避免出现缓冲区溢出的，只要在书写任何字符串解析的格式时，注意加上其缓冲区尺寸的限制)。==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char str[32] = &quot;&quot;;</span><br><span class="line">sscanf(&quot;123456abcdedf&quot;, &quot;%31[0-9a-z]&quot;, str);</span><br><span class="line">printf(&quot;str=%s/n&quot;, str);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str=123456abcdedf</span><br></pre></td></tr></table></figure><p>在格式[]中增加了a-z的描述。</p><h6 id="使用-示例："><a href="#使用-示例：" class="headerlink" title="使用^示例："></a>使用^示例：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char str[32] = &quot;&quot;;</span><br><span class="line">sscanf(&quot;123456abcdedf&quot;, &quot;%31[^a-z]&quot;, str);</span><br><span class="line">printf(&quot;str=%s/n&quot;, str);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str=123456</span><br></pre></td></tr></table></figure><p>在[]中增加^表示相反的意思，上面的[^a-z]表示一个不包含任何a-z之间的字符串。</p><h6 id="使用-的例子："><a href="#使用-的例子：" class="headerlink" title="使用*的例子："></a>使用*的例子：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char str[32] = &quot;&quot;;</span><br><span class="line">int ret = sscanf(&quot;123456abcdedf&quot;, &quot;%*[0-9]%31[a-z]&quot;, str);</span><br><span class="line">printf(&quot;ret=%d, str=%s/n&quot;,ret, str);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret=1, str=abcdedf</span><br></pre></td></tr></table></figure><p>加上*修饰表示一个被忽略的数据，同时也不需要为它准备空间存放解析结果。如上面的例子中，我们就只使用了str一个参数存放%31[a-z]的解析结果，而sscanf也只返回1，表示只解析了一个数据。</p><p>掌握了[], ^, *如何使用后，我们会发现sscanf原来是一个如此强大的工具，很多我们原先认为必须使用正则表达式的地方，很可能使用sscanf就可以实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、描述：&quot;&gt;&lt;a href=&quot;#一、描述：&quot; class=&quot;headerlink&quot; title=&quot;一、描述：&quot;&gt;&lt;/a&gt;一、描述：&lt;/h4&gt;&lt;p&gt;sscanf通常被用来解析并转换字符串，其格式定义灵活多变，可以实现很强大的字符串解析功能。&lt;/p&gt;
&lt;p&gt;sscanf的原型&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int sscanf(const char *str, const char *format, ...);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="系统函数&amp;库函数" scheme="http://www.faihung.net/categories/%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0-%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="字符串操作" scheme="http://www.faihung.net/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>linux 通过系统函数设置系统时间</title>
    <link href="http://www.faihung.net/2019/11/03/linux-%E9%80%9A%E8%BF%87%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/"/>
    <id>http://www.faihung.net/2019/11/03/linux-通过系统函数设置系统时间/</id>
    <published>2019-11-03T09:06:09.000Z</published>
    <updated>2019-11-03T09:09:54.432Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一、描述："><a href="#一、描述：" class="headerlink" title="一、描述："></a>一、描述：</h5><p>通过settimeofday()函数来设置系统时间，这个函数设置的精度可以精确到微秒。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">int settimeofday(const struct timeval *tv , const struct timezone *tz);</span><br><span class="line"></span><br><span class="line">struct timeval &#123;</span><br><span class="line">    time_t      tv_sec;     /* seconds */</span><br><span class="line">    suseconds_t tv_usec;    /* microseconds */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct timezone &#123;</span><br><span class="line">    int tz_minuteswest;     /* minutes west of Greenwich */</span><br><span class="line">    int tz_dsttime;         /* type of DST correction */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>tz参数为时区，时区结构中tz_dsttime在linux中不支持，应该置为0，通常将参数tz设置为NULL，表示使用当前系统的时区。该函数是glib中的，但在mingw中没有实现。</p></blockquote><a id="more"></a><h5 id="二、代码演示："><a href="#二、代码演示：" class="headerlink" title="二、代码演示："></a>二、代码演示：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/time.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int SetSystemTime(char *dt)</span><br><span class="line">&#123;</span><br><span class="line">    struct tm rtc_time;</span><br><span class="line">    struct tm _tm;</span><br><span class="line">    struct timeval tv;</span><br><span class="line">    time_t timep;</span><br><span class="line">    sscanf(dt, &quot;%d-%d-%d %d:%d:%d&quot;, &amp;rtc_time.tm_year,</span><br><span class="line">&amp;rtc_time.tm_mon, &amp;rtc_time.tm_mday,&amp;rtc_time.tm_hour,</span><br><span class="line">        &amp;rtc_time.tm_min, &amp;rtc_time.tm_sec);</span><br><span class="line">    _tm.tm_sec = rtc_time.tm_sec;</span><br><span class="line">    _tm.tm_min = rtc_time.tm_min;</span><br><span class="line">    _tm.tm_hour = rtc_time.tm_hour;</span><br><span class="line">    _tm.tm_mday = rtc_time.tm_mday;</span><br><span class="line">    _tm.tm_mon = rtc_time.tm_mon - 1;</span><br><span class="line">    _tm.tm_year = rtc_time.tm_year - 1900;</span><br><span class="line"> </span><br><span class="line">    timep = mktime(&amp;_tm);</span><br><span class="line">    tv.tv_sec = timep;</span><br><span class="line">    tv.tv_usec = 0;</span><br><span class="line">    // if(settimeofday (&amp;tv, (struct timezone *) 0) &lt; 0)</span><br><span class="line">if(settimeofday (&amp;tv, NULL) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">printf(&quot;Set system datatime error!\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;现在的时间是:&quot;);</span><br><span class="line">fflush(stdout);</span><br><span class="line">system(&quot;date&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  SetSystemTime(&quot;2019-11-03 16:30:30&quot;);//2019-11-01 21:19:05  </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="三、效果如下："><a href="#三、效果如下：" class="headerlink" title="三、效果如下："></a>三、效果如下：</h5><p><img src="/2019/11/03/linux-%E9%80%9A%E8%BF%87%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/1.jpg" alt="1"><br>注意：</p><ol><li>调用settimeofday函数时必须要在root权限下执行。</li><li>设置时间之前最好把虚拟机网络断开。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;一、描述：&quot;&gt;&lt;a href=&quot;#一、描述：&quot; class=&quot;headerlink&quot; title=&quot;一、描述：&quot;&gt;&lt;/a&gt;一、描述：&lt;/h5&gt;&lt;p&gt;通过settimeofday()函数来设置系统时间，这个函数设置的精度可以精确到微秒。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;time.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int settimeofday(const struct timeval *tv , const struct timezone *tz);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct timeval &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    time_t      tv_sec;     /* seconds */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    suseconds_t tv_usec;    /* microseconds */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct timezone &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int tz_minuteswest;     /* minutes west of Greenwich */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int tz_dsttime;         /* type of DST correction */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;tz参数为时区，时区结构中tz_dsttime在linux中不支持，应该置为0，通常将参数tz设置为NULL，表示使用当前系统的时区。该函数是glib中的，但在mingw中没有实现。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="系统函数&amp;库函数" scheme="http://www.faihung.net/categories/%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0-%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="系统时间" scheme="http://www.faihung.net/tags/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>cURL-01_基本概念与了解</title>
    <link href="http://www.faihung.net/2019/11/03/cURL-01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BA%86%E8%A7%A3/"/>
    <id>http://www.faihung.net/2019/11/03/cURL-01-基本概念与了解/</id>
    <published>2019-11-03T03:59:28.000Z</published>
    <updated>2019-11-03T14:58:32.291Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h5><p>cURL（Client URL Library Functions）is a command line tool for transfering data with URL syntax（使用 URL 语法传输数据的命令行工具），即客户端向服务器请求资源的工具。</p><p><img src="/2019/11/03/cURL-01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BA%86%E8%A7%A3/1.png" alt="1"></p><a id="more"></a><p>curl库是C语言封装的一个强大的库，使用curl比封装socket更加方便。</p><p>cURL 最初的设计初衷是使用不同的协议（比如 FTP、HTTP、SCP 等）在端点之间移动文件。它最初是一个命令行实用工具，但现在也是一个绑定了 30 多种语言的库。因此，现在不仅可以通过 shell 使用 cURL，您还可以构建合并了这个重要功能的应用程序。libcurl 库也是可以移植的，支持 Linux®、IBM®AIX®操作系统、BSD、Solaris 以及许多其他 UNIX®变体。</p><p>cURL是一个命令行工具和库，实现了各种客户端协议。它支持 12 种以上的协议，包括 FTP、HTTP、Telnet 以及其他安全变体。许多平台上都能找到 cURL，包括 Linux、AIX、BSD 和 Solaris，它支持 30 多种语言。</p><p>PycURL是 libcurl API 之上的一个薄层，PycURL 速度非常快。使用 PycURL，您可以使用 libcurl 库开发 Python 应用程序。</p><p>关于cURL,<a href="https://curl.haxx.se/" target="_blank" rel="noopener">这里</a>有更详细的介绍。</p><h5 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h5><p>1.网页资源（例如编写网页爬虫）</p><p>2.WebService 数据接口资源（比如动态获取接口数据，比如天气、号码归属地等）</p><p>3.FTP 服务器里的文件资源（下载 FTP 服务器里面的文件）</p><p>4.其他资源（所有网络上的资源都可以使用 cURL 访问和下载到）</p><h5 id="三、延伸-为什么要用cURL"><a href="#三、延伸-为什么要用cURL" class="headerlink" title="三、延伸(为什么要用cURL)"></a>三、延伸(为什么要用cURL)</h5><p>开发 HTTP 和 FTP 之类依赖于应用层协议的应用程序并不复杂，但也不简单。进一步讲，这不是应用程序的重点，因为大部分情况下，协议之上的内容才是真正重要的内容。因此，libcurl 引起了许多人的兴趣，因为它的重点是应用程序而不是开发的各个方面。注意，很少有应用程序开发自己的 TCP/IP 堆栈，所以老话重提：尽可能重用以最小化开发安排并提高应用程序的可靠性。</p><h6 id="关于Web-协议"><a href="#关于Web-协议" class="headerlink" title="关于Web 协议"></a>关于Web 协议</h6><p>如今构建应用程序已与过去大不相同。现在的应用程序需要能够通过网络或 Internet 进行通讯（提供人类可用的网络 API 或接口），还要能支持用户脚本化以提高灵活性。现代应用程序通常使用 HTTP 公开 Web 接口，并通过 Simple Mail Transport Protocol (SMTP) 提供警告通知。这些协议允许您将 Web 浏览器指向设备以获得配置或状态信息，并从设备或常用的电子邮件客户端接收标准电子邮件（分别通过 HTTP 和 SMTP）。</p><p>这些 Web 服务通常构建在网络堆栈的套接字层上（见图 1）。套接字层实现一个最先出现在 Berkeley Software Distribution (BSD) 操作系统上的 API，并提取底层传输和网络层协议的详细信息。</p><p>图 1. 网络堆栈和 libcurl</p><p><img src="/2019/11/03/cURL-01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BA%86%E8%A7%A3/2.gif" alt="2"></p><p>Web 服务发生在客户端和服务器之间的协议对话中。在 HTTP 上下文中，服务器是终端设备，客户端是位于端点上的浏览器。对于 SMTP，服务器是邮件网关或端点用户，客户端是终端设备。在某些情况下，协议对话发生在两个步骤（请求和响应）中，但另一些情况下，需要协商和通讯的通信量更多。这种协商可能增加了大量复杂性，这可以通过 API 进行抽象，比如 libcurl。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;一、基本概念&quot;&gt;&lt;a href=&quot;#一、基本概念&quot; class=&quot;headerlink&quot; title=&quot;一、基本概念&quot;&gt;&lt;/a&gt;一、基本概念&lt;/h5&gt;&lt;p&gt;cURL（Client URL Library Functions）is a command line tool for transfering data with URL syntax（使用 URL 语法传输数据的命令行工具），即客户端向服务器请求资源的工具。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/11/03/cURL-01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BA%86%E8%A7%A3/1.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="cURL" scheme="http://www.faihung.net/categories/cURL/"/>
    
    
      <category term="cURL" scheme="http://www.faihung.net/tags/cURL/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机VMware与Windows主机共享文件介绍</title>
    <link href="http://www.faihung.net/2019/11/03/%E8%99%9A%E6%8B%9F%E6%9C%BAVMware%E4%B8%8EWindows%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/"/>
    <id>http://www.faihung.net/2019/11/03/虚拟机VMware与Windows主机共享文件介绍/</id>
    <published>2019-11-03T03:07:48.000Z</published>
    <updated>2019-11-03T03:12:10.814Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一、设置共享文件夹功能"><a href="#一、设置共享文件夹功能" class="headerlink" title="一、设置共享文件夹功能"></a>一、设置共享文件夹功能</h5><p>虚拟机VMware提供了在宿主机与虚拟机系统之间交换文件的共享文件夹（Shared Folder）功能。不管虚拟机操作系统是Linux还是Windows都可用。你可以通过设置（ Settings）&gt;共享文件夹（Shared Folder）来设置。但是此功能选项必须要安装虚拟机工具（VMware Tools），否则如下所示，否则该功能选项不可用。</p><p><img src="/2019/11/03/%E8%99%9A%E6%8B%9F%E6%9C%BAVMware%E4%B8%8EWindows%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/1.jpg" alt="1"></p><a id="more"></a><h5 id="二、安装虚拟机工具步骤如下所示："><a href="#二、安装虚拟机工具步骤如下所示：" class="headerlink" title="二、安装虚拟机工具步骤如下所示："></a>二、安装虚拟机工具步骤如下所示：</h5><h6 id="1-在对应虚拟机的设置选项（Settings-下，为虚拟机光驱指定虚拟机系统的镜像文件。"><a href="#1-在对应虚拟机的设置选项（Settings-下，为虚拟机光驱指定虚拟机系统的镜像文件。" class="headerlink" title="1. 在对应虚拟机的设置选项（Settings)下，为虚拟机光驱指定虚拟机系统的镜像文件。"></a>1. 在对应虚拟机的设置选项（Settings)下，为虚拟机光驱指定虚拟机系统的镜像文件。</h6><p>注意：在执行下面步骤前，必须确保虚拟机的电源开启、虚拟机系统正在运行。</p><p><img src="/2019/11/03/%E8%99%9A%E6%8B%9F%E6%9C%BAVMware%E4%B8%8EWindows%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/2.png" alt="2"></p><h6 id="2-在VM下选择”Install-VMware-Tools”"><a href="#2-在VM下选择”Install-VMware-Tools”" class="headerlink" title="2. 在VM下选择”Install VMware Tools”."></a>2. 在VM下选择”Install VMware Tools”.</h6><p><img src="/2019/11/03/%E8%99%9A%E6%8B%9F%E6%9C%BAVMware%E4%B8%8EWindows%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/3.png" alt="3"></p><ol start="3"><li>然后安装虚拟机组件工具，详细步骤如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@DB-Server ~]# cd /mnt</span><br><span class="line">[root@DB-Server mnt]# mkdir cdrom</span><br><span class="line">[root@DB-Server mnt]# mount /dev/cdrom  /mnt/cdrom</span><br><span class="line">[root@DB-Server mnt]# cd /mnt/cdrom</span><br><span class="line">[root@DB-Server cdrom]# cp  VMwareTools-8.8.2-590212.tar.gz /tmp</span><br><span class="line">[root@DB-Server cdrom]#tar xz</span><br><span class="line">[root@DB-Server tmp]# ls</span><br><span class="line">gconfd-root     orbit-root           VMwareTools-8.8.2-590212.tar.gz</span><br><span class="line">keyring-qO15Cg  ssh-EWUeHQ4064       vmware-tools-distrib</span><br><span class="line">mapping-root    virtual-root.9mZzaq</span><br><span class="line">[root@DB-Server tmp]# cd vmware-tools-distrib/</span><br><span class="line">[root@DB-Server vmware-tools-distrib]# ls</span><br><span class="line">bin  doc  etc  FILES  INSTALL  installer  lib  vmware-install.pl</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[root@DB-Server vmware-tools-distrib]# ./vmware-install.pl </span><br><span class="line">A previous installation of VMware Tools has been detected.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">之后直接安装即可。</span><br></pre></td></tr></table></figure>安装完成后重启虚拟机</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;一、设置共享文件夹功能&quot;&gt;&lt;a href=&quot;#一、设置共享文件夹功能&quot; class=&quot;headerlink&quot; title=&quot;一、设置共享文件夹功能&quot;&gt;&lt;/a&gt;一、设置共享文件夹功能&lt;/h5&gt;&lt;p&gt;虚拟机VMware提供了在宿主机与虚拟机系统之间交换文件的共享文件夹（Shared Folder）功能。不管虚拟机操作系统是Linux还是Windows都可用。你可以通过设置（ Settings）&amp;gt;共享文件夹（Shared Folder）来设置。但是此功能选项必须要安装虚拟机工具（VMware Tools），否则如下所示，否则该功能选项不可用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/11/03/%E8%99%9A%E6%8B%9F%E6%9C%BAVMware%E4%B8%8EWindows%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/1.jpg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://www.faihung.net/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="ubuntu" scheme="http://www.faihung.net/tags/ubuntu/"/>
    
      <category term="VMware" scheme="http://www.faihung.net/tags/VMware/"/>
    
  </entry>
  
  <entry>
    <title>Source Insight 使用技巧整理</title>
    <link href="http://www.faihung.net/2019/11/03/Source-Insight-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    <id>http://www.faihung.net/2019/11/03/Source-Insight-使用技巧整理/</id>
    <published>2019-11-02T16:17:01.000Z</published>
    <updated>2019-11-03T02:50:35.710Z</updated>
    
    <content type="html"><![CDATA[<h4 id="通用设置"><a href="#通用设置" class="headerlink" title="通用设置"></a>通用设置</h4><p>Options - File Type Options:</p><ul><li>显示行号：勾选Show line mumbers</li><li>选中自动高亮：勾选Hightlight references to selected sysmbol</li><li>转换tab成空格：勾选Expand tabs to spaces，设置Tab width：4<br><img src="/2019/11/03/Source-Insight-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/1.png" alt="1"></li></ul><a id="more"></a><p><strong>高亮选中符号：</strong><br>F8</p><p><strong>代码折叠：</strong><br>View –&gt; Show Outlining </p><p><strong>代码默认字体大小：</strong><br>Ctrl + 滑动鼠标滑轮，可以增大缩小代码字体大小</p><blockquote><p>对所有代码文件字体都生效，步骤如：<br>Preferences –&gt; File Type Options -&gt; Screen Font<br>Preferences –&gt; Languages –&gt; File Types –&gt; Screen Font</p></blockquote><p><strong>只为主界面导入配色方案（不是全局，全局在Options-&gt;Load Configuration..）</strong></p><ol><li>Options –&gt; Style properties -&gt; Load</li><li>背景色修改： Options –&gt; Preferences –&gt;  Colors –&gt; Window Background </li><li>字体修改：在需要修改的词处点击，选择style Properties 会自动对应到需要修改的词语类型，然后直接修改颜色即可。</li></ol><p><strong>替换：</strong><br>Ctrl + h<br><strong>查找：</strong><br>Ctrl + f<br><strong>全局查找：</strong><br>Ctrl + /<br><strong>向上搜索</strong><br>Ctrl + F3<br><strong>向下搜索</strong><br>Ctrl + F4<br><strong>跳转到行：</strong><br>F5<br><strong>跳转到定义：</strong><br>Ctrl + 鼠标左键</p><h4 id="显示中文乱码"><a href="#显示中文乱码" class="headerlink" title="显示中文乱码"></a>显示中文乱码</h4><p>File - Reload As Encoding - GB2312</p><p><img src="/2019/11/03/Source-Insight-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/2.png" alt="2"></p><h4 id="添加注释快捷键"><a href="#添加注释快捷键" class="headerlink" title="添加注释快捷键"></a>添加注释快捷键</h4><blockquote><p>添加一些配置文件宏，比如：注释掉代码：单行注释、多行注释，将选中内容注释掉；在一行代码的前、后添加注释性文字等。</p></blockquote><h5 id="操作步骤："><a href="#操作步骤：" class="headerlink" title="操作步骤："></a>操作步骤：</h5><p>打开Projcet-&gt;Open project，选择base，可以看到utils.em文件，将下列宏添加到该文件中，并在其他工程里加入该文件，在上面介绍的快捷键添加方式里找到该宏并自定义快捷键。</p><h5 id="单行、多行注释："><a href="#单行、多行注释：" class="headerlink" title="单行、多行注释："></a>单行、多行注释：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">macro MultiLineComment()  </span><br><span class="line">&#123;  </span><br><span class="line">    hwnd = GetCurrentWnd()  </span><br><span class="line">    selection = GetWndSel(hwnd)  </span><br><span class="line">    LnFirst = GetWndSelLnFirst(hwnd)      //取首行行号  </span><br><span class="line">    LnLast = GetWndSelLnLast(hwnd)      //取末行行号  </span><br><span class="line">    hbuf = GetCurrentBuf()  </span><br><span class="line">   </span><br><span class="line">    if(GetBufLine(hbuf, 0) == &quot;//magic-number:tph85666031&quot;)&#123;  </span><br><span class="line">        stop  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    Ln = Lnfirst  </span><br><span class="line">    buf = GetBufLine(hbuf, Ln)  </span><br><span class="line">    len = strlen(buf)  </span><br><span class="line">   </span><br><span class="line">    while(Ln &lt;= Lnlast) &#123;  </span><br><span class="line">        buf = GetBufLine(hbuf, Ln)  //取Ln对应的行  </span><br><span class="line">        if(buf == &quot;&quot;)&#123;                    //跳过空行  </span><br><span class="line">            Ln = Ln + 1  </span><br><span class="line">            continue  </span><br><span class="line">        &#125;  </span><br><span class="line">   </span><br><span class="line">        if(StrMid(buf, 0, 1) == &quot;/&quot;) &#123;       //需要取消注释,防止只有单字符的行  </span><br><span class="line">            if(StrMid(buf, 1, 2) == &quot;/&quot;)&#123;  </span><br><span class="line">                PutBufLine(hbuf, Ln, StrMid(buf, 2, Strlen(buf)))  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">   </span><br><span class="line">        if(StrMid(buf,0,1) != &quot;/&quot;)&#123;          //需要添加注释  </span><br><span class="line">            PutBufLine(hbuf, Ln, Cat(&quot;//&quot;, buf))  </span><br><span class="line">        &#125;  </span><br><span class="line">        Ln = Ln + 1  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    SetWndSel(hwnd, selection)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码保存到utils.em文件，打开source insight，将该文件添加到工程中，然后在Options-&gt;Key Assignments中你就可以看到这个宏了，宏的名字是MultiLineComments，然后我们为它分配快捷键“Ctrl + /”，然后就可以了。</p><p>添加“#ifdef 0”和“#endif”的宏代码，定义快捷键为Ctrl+/+Shift：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">macro AddMacroComment()  </span><br><span class="line">&#123;  </span><br><span class="line">    hwnd=GetCurrentWnd()  </span><br><span class="line">    sel=GetWndSel(hwnd)  </span><br><span class="line">    lnFirst=GetWndSelLnFirst(hwnd)  </span><br><span class="line">    lnLast=GetWndSelLnLast(hwnd)  </span><br><span class="line">    hbuf=GetCurrentBuf()  </span><br><span class="line">   </span><br><span class="line">    if(LnFirst == 0) &#123;  </span><br><span class="line">            szIfStart = &quot;&quot;  </span><br><span class="line">    &#125;else&#123;  </span><br><span class="line">            szIfStart = GetBufLine(hbuf, LnFirst-1)  </span><br><span class="line">    &#125;  </span><br><span class="line">    szIfEnd = GetBufLine(hbuf, lnLast+1)  </span><br><span class="line">    if(szIfStart == &quot;#if 0&quot; &amp;&amp; szIfEnd == &quot;#endif&quot;) &#123;  </span><br><span class="line">            DelBufLine(hbuf, lnLast+1)  </span><br><span class="line">            DelBufLine(hbuf, lnFirst-1)  </span><br><span class="line">            sel.lnFirst = sel.lnFirst – 1  </span><br><span class="line">            sel.lnLast = sel.lnLast – 1  </span><br><span class="line">    &#125;else&#123;  </span><br><span class="line">            InsBufLine(hbuf, lnFirst, &quot;#if 0&quot;)  </span><br><span class="line">            InsBufLine(hbuf, lnLast+2, &quot;#endif&quot;)  </span><br><span class="line">            sel.lnFirst = sel.lnFirst + 1  </span><br><span class="line">            sel.lnLast = sel.lnLast + 1  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    SetWndSel( hwnd, sel )  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作和上面类似</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;通用设置&quot;&gt;&lt;a href=&quot;#通用设置&quot; class=&quot;headerlink&quot; title=&quot;通用设置&quot;&gt;&lt;/a&gt;通用设置&lt;/h4&gt;&lt;p&gt;Options - File Type Options:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;显示行号：勾选Show line mumbers&lt;/li&gt;
&lt;li&gt;选中自动高亮：勾选Hightlight references to selected sysmbol&lt;/li&gt;
&lt;li&gt;转换tab成空格：勾选Expand tabs to spaces，设置Tab width：4&lt;br&gt;&lt;img src=&quot;/2019/11/03/Source-Insight-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/1.png&quot; alt=&quot;1&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://www.faihung.net/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Source Insight" scheme="http://www.faihung.net/tags/Source-Insight/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu配置NFS及其挂载设备</title>
    <link href="http://www.faihung.net/2019/11/02/Ubuntu%E9%85%8D%E7%BD%AENFS%E5%8F%8A%E5%85%B6%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87/"/>
    <id>http://www.faihung.net/2019/11/02/Ubuntu配置NFS及其挂载设备/</id>
    <published>2019-11-01T16:00:00.000Z</published>
    <updated>2019-11-03T02:31:52.620Z</updated>
    
    <content type="html"><![CDATA[<h5 id="在Ubuntu系统中安装NFS"><a href="#在Ubuntu系统中安装NFS" class="headerlink" title="在Ubuntu系统中安装NFS"></a>在Ubuntu系统中安装NFS</h5><p>执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nfs-kernel-server</span><br></pre></td></tr></table></figure><blockquote><p>同时会有两个软件包nfs-common和portmap被安装上，如果没有安装成功多安装几次。</p></blockquote><a id="more"></a><h5 id="在Ubuntu系统中的-mnt下建立共享项目nfs-shared"><a href="#在Ubuntu系统中的-mnt下建立共享项目nfs-shared" class="headerlink" title="在Ubuntu系统中的/mnt下建立共享项目nfs_shared"></a>在Ubuntu系统中的/mnt下建立共享项目nfs_shared</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mkdir nfs_shared </span><br><span class="line"># chmod 777 -R nfs_shared/</span><br></pre></td></tr></table></figure><p>保证使用者都能够读、写、执行。如图</p><p><img src="/2019/11/02/Ubuntu%E9%85%8D%E7%BD%AENFS%E5%8F%8A%E5%85%B6%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87/1.png" alt="1"></p><h5 id="在Ubuntu系统中修改NFS配置文件"><a href="#在Ubuntu系统中修改NFS配置文件" class="headerlink" title="在Ubuntu系统中修改NFS配置文件"></a>在Ubuntu系统中修改NFS配置文件</h5><p>执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/exports</span><br></pre></td></tr></table></figure><p>在exports最后一行添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/mnt/nfs_shared 192.168.0.*(rw,sync,no_root_squash,no_subtree_check)</span><br><span class="line">其中，</span><br><span class="line">/mnt/nfs_shared  ---要共享的目录</span><br><span class="line">192.168.0.*---允许访问的网段，也可以是ip地址、主机名（能够被服务器解析）、</span><br><span class="line">     *（所有人都能访问）</span><br><span class="line">(rw,sync,no_root_squash,no_subtree_check)---</span><br><span class="line">rw:读/写权限</span><br><span class="line">sync:数据同步写入内存和硬盘</span><br><span class="line">no_root_squash:服务器允许远程系统以root特权存取该目录</span><br><span class="line">no_subtree_check:关闭子树检查</span><br></pre></td></tr></table></figure><p><img src="/2019/11/02/Ubuntu%E9%85%8D%E7%BD%AENFS%E5%8F%8A%E5%85%B6%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87/2.png" alt="2"></p><h5 id="在Ubuntu系统中启动服务"><a href="#在Ubuntu系统中启动服务" class="headerlink" title="在Ubuntu系统中启动服务"></a>在Ubuntu系统中启动服务</h5><p>依次执行下列命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo service rpcbind restart</span><br><span class="line">sudo service rpcbind restart</span><br></pre></td></tr></table></figure><p><img src="/2019/11/02/Ubuntu%E9%85%8D%E7%BD%AENFS%E5%8F%8A%E5%85%B6%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87/3.png" alt="3"></p><h5 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h5><h6 id="测试Ubuntu-nfs"><a href="#测试Ubuntu-nfs" class="headerlink" title="测试Ubuntu nfs"></a>测试Ubuntu nfs</h6><p>执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$showmount -e</span><br></pre></td></tr></table></figure><p><img src="/2019/11/02/Ubuntu%E9%85%8D%E7%BD%AENFS%E5%8F%8A%E5%85%B6%E6%8C%82%E8%BD%BD%E8%AE%BE%E5%A4%87/4.png" alt="4"></p><h6 id="设备挂载"><a href="#设备挂载" class="headerlink" title="设备挂载"></a>设备挂载</h6><p>在《Hi3519AV100 SDK 安装及升级使用说明.pdf》中4.2 使用 NFS 文件系统进行开发可以看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t nfs -o nolock -o tcp -o rsize=32768,wsize=32768 xx.xx.xx.xx:/your-nfs-path /mnt</span><br></pre></td></tr></table></figure><p>改为：（在设备中挂载）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t nfs -o nolock -o tcp -o rsize=32768,wsize=32768 192.168.0.180:/mnt/</span><br></pre></td></tr></table></figure><p>之后就可以在设备的/mnt下面查看Ubuntu/mnt/nfs_shared的文件了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;在Ubuntu系统中安装NFS&quot;&gt;&lt;a href=&quot;#在Ubuntu系统中安装NFS&quot; class=&quot;headerlink&quot; title=&quot;在Ubuntu系统中安装NFS&quot;&gt;&lt;/a&gt;在Ubuntu系统中安装NFS&lt;/h5&gt;&lt;p&gt;执行命令：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install nfs-kernel-server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;同时会有两个软件包nfs-common和portmap被安装上，如果没有安装成功多安装几次。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://www.faihung.net/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="nfs" scheme="http://www.faihung.net/tags/nfs/"/>
    
      <category term="ubuntu" scheme="http://www.faihung.net/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.faihung.net/2019/11/02/%E7%AE%80%E5%8D%95%E7%9A%84rtsp%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/"/>
    <id>http://www.faihung.net/2019/11/02/简单的rtsp交互过程/</id>
    <published>2019-11-01T16:00:00.000Z</published>
    <updated>2019-11-02T11:06:44.334Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里C表示rtsp客户端,S表示rtsp服务端。 </p></blockquote><h6 id="C-gt-发送流媒体数据前的准备"><a href="#C-gt-发送流媒体数据前的准备" class="headerlink" title="C-&gt;:发送流媒体数据前的准备"></a>C-&gt;:发送流媒体数据前的准备</h6><ul><li>C-&gt;S:OPTION request  //询问S有哪些方法可用 </li><li>S-&gt;C:OPTION response //S回应信息中包括提供的所有可用方法 </li></ul><ul><li>C-&gt;S:DESCRIBE request //要求得到S提供的媒体初始化描述信息 </li><li>S-&gt;C:DESCRIBE response //S回应媒体初始化描述信息，主要是sdp </li></ul><ul><li>C-&gt;S:SETUP request //设置会话的属性，以及传输模式，提醒S建立会话 </li><li>S-&gt;C:SETUP response //S建立会话，返回会话标识符，以及会话相关信息 </li></ul><ul><li>C-&gt;S:PLAY request //C请求播放 </li><li>S-&gt;C:PLAY response //S回应该请求的信息 </li></ul><h6 id="S-gt-C-发送流媒体数据"><a href="#S-gt-C-发送流媒体数据" class="headerlink" title="S-&gt;C:发送流媒体数据"></a>S-&gt;C:发送流媒体数据</h6><ul><li>C-&gt;S:TEARDOWN request //C请求关闭会话 </li><li>S-&gt;C:TEARDOWN response //S回应该请求</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这里C表示rtsp客户端,S表示rtsp服务端。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&quot;C-gt-发送流媒体数据前的准备&quot;&gt;&lt;a href=&quot;#C-gt-发送流媒体数据前的准备&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
    
      <category term="流媒体" scheme="http://www.faihung.net/categories/%E6%B5%81%E5%AA%92%E4%BD%93/"/>
    
    
  </entry>
  
</feed>
